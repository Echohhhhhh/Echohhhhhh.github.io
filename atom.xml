<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Echo&#39;s blog</title>
  
  <subtitle>远方到底有多远</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2020-07-14T16:35:40.262Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Echo</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>面试之海量数据处理</title>
    <link href="http://yoursite.com/2020/07/15/%E9%9D%A2%E8%AF%95%E4%B9%8B%E6%B5%B7%E9%87%8F%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/"/>
    <id>http://yoursite.com/2020/07/15/面试之海量数据处理/</id>
    <published>2020-07-14T16:07:09.000Z</published>
    <updated>2020-07-14T16:35:40.262Z</updated>
    
    <content type="html"><![CDATA[<h1><span id="b树和b树">B树和B+树</span></h1><p>为了减少磁盘I/O，磁盘上的数据通常以树的形式存储。<strong>树中每个节点对应一次磁盘I/O</strong>，为了减少搜索时间，因此需要控制树的高度，像二叉树就不适合了，因为二叉树每个节点只有2个子树，导致树的层数很深。这里使用B树和B+树。<br>B树和B+树是多叉搜索树。</p><p>B树</p><ul><li>所有叶子节点位于同一层</li><li>多叉搜索树</li><li>B树的中间节点和叶子节点都表示实际的数据</li></ul><p><img src="/2020/07/15/面试之海量数据处理/B树.jpg" alt=""></p><p>B树的查找顺序为：</p><ol><li>从根节点开始，如果查找的数据比根节点小，就去左子树中找，否则去右子树找</li><li>和子树的多个关键字比较，找出目标所处的范围，然后去范围对应的子树中继续查找</li><li>以此循环，直到找到</li></ol><p>B+树</p><ul><li>叶子节点都在同一层</li><li>多叉搜索树</li><li>B+数的中间节点不保存数据，只用来索引，所有的数据保存在叶子节点上</li></ul><p><img src="/2020/07/15/面试之海量数据处理/B+树.jpg" alt=""></p><p>从图可以看出，B+树的中间节点和叶子节点有重复的数据，这是因为中间节点保存的只是子树数据中的指针，并不是真正的数据。<br>因为中间节点存储的是指针，而指针占用的空间比较少，所以一个节点可以保存很多个指针，使得B+数比B数矮胖，相对而言，读取I/O次数更少。</p><p><strong>磁盘存储的知识</strong></p><ol><li>磁盘I/O比在内存中操作慢非常非常非常多，因此需要尽量减少磁盘I/O操作，即不要过多的读取磁盘</li><li>磁盘I/O时间=寻道+磁盘旋转+数据传输时间<br>从磁盘中读取数据时，系统会将逻辑地址发给磁盘，磁盘将逻辑地址转换为物理地址（哪个磁道，哪个扇区），然后磁头转到相应的磁道，再找到该磁道对应的扇区。</li><li><p>扇区是磁盘的最小存储单元。一次磁盘I/O会读出一个扇<br>区的数据，因此读1个字节和读4k（一个扇区）需要的时间几乎一样</p><p><img src="/2020/07/15/面试之海量数据处理/磁道.jpg" alt=""></p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1&gt;&lt;span id=&quot;b树和b树&quot;&gt;B树和B+树&lt;/span&gt;&lt;/h1&gt;&lt;p&gt;为了减少磁盘I/O，磁盘上的数据通常以树的形式存储。&lt;strong&gt;树中每个节点对应一次磁盘I/O&lt;/strong&gt;，为了减少搜索时间，因此需要控制树的高度，像二叉树就不适合了，因为二叉树每个节点
      
    
    </summary>
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>百面机器学习概述二</title>
    <link href="http://yoursite.com/2020/07/05/%E7%99%BE%E9%9D%A2%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%A6%82%E8%BF%B0%E4%BA%8C/"/>
    <id>http://yoursite.com/2020/07/05/百面机器学习概述二/</id>
    <published>2020-07-05T14:34:41.000Z</published>
    <updated>2020-07-15T01:53:47.007Z</updated>
    
    <content type="html"><![CDATA[<p>总结《百面机器学习》有关知识点。</p><a id="more"></a><!-- TOC --><ul><li><a href="#1-损失函数">1. 损失函数</a><ul><li><a href="#11-分类损失函数">1.1. 分类损失函数</a><ul><li><a href="#111-二分类和多分类">1.1.1. 二分类和多分类</a></li></ul></li><li><a href="#12-回归损失函数">1.2. 回归损失函数</a></li></ul></li><li><a href="#2-梯度下降">2. 梯度下降</a></li><li><a href="#3-dropout">3. Dropout</a></li><li><a href="#4-集成学习">4. 集成学习</a><ul><li><a href="#41-boosting和bagging">4.1. Boosting和Bagging</a></li><li><a href="#42-集成学习步骤和例子">4.2. 集成学习步骤和例子</a></li><li><a href="#43-偏差和方差">4.3. 偏差和方差</a></li><li><a href="#44-常见集成学习模型">4.4. 常见集成学习模型</a><ul><li><a href="#441-随机森林">4.4.1. 随机森林</a></li><li><a href="#442-adaboost">4.4.2. AdaBoost</a></li><li><a href="#443-gbdt">4.4.3. GBDT</a></li><li><a href="#444-xgboost">4.4.4. XGBoost</a></li><li><a href="#445-gdbt和xgboost区别">4.4.5. GDBT和XGBoost区别</a></li></ul></li></ul></li><li><a href="#5-cnn">5. CNN</a></li><li><a href="#6-gnn">6. GNN</a><ul><li><a href="#61-deepwalk">6.1. DeepWalk</a></li><li><a href="#62-line">6.2. LINE</a></li><li><a href="#63-图卷积神经网络">6.3. 图卷积神经网络</a><ul><li><a href="#631-谱图卷积">6.3.1. 谱图卷积</a></li><li><a href="#632-空间图卷积">6.3.2. 空间图卷积</a></li></ul></li></ul></li></ul><!-- /TOC --><h1><span id="1-损失函数">1. 损失函数</span></h1><p>损失函数用来评估模型预测值和真实值的差异，损失越小，说明模型的性能越好。<br>损失函数分为经验风险损失、结构风险损失<br>经验风险损失指预测值和真实值的差异<br>结构风险损失=经验风险损失+正则化</p><h2><span id="11-分类损失函数">1.1. 分类损失函数</span></h2><p><strong>1. 0-1损失函数</strong></p><script type="math/tex; mode=display">L(Y, f(X))=\left\{\begin{array}{l}   1, Y \neq f(X) \\   0, Y=f(X)   \end{array}\right.</script><p>   特点：<br>   （1）0-1损失表示分类错误的个数，但是它是一个非凸函数，不太适用<br>   （2）这个损失函数的条件太严格，需要严格等于真实值</p><p><strong>2. 对数损失函数</strong><br>   也称为交叉熵损失函数</p><blockquote><p>熵的定义<br>   $H(X)=-\sum_{i=1}^{i=n}p(x_i)log(p(x_i))$</p></blockquote><script type="math/tex; mode=display">L(Y,\hat{Y})=-log(\hat{Y})</script><p>   其中$\hat{Y}$表示训练样本属于某类的概率</p><p>   特点：<br>   （1）逻辑回归和softmax回归都是采用log损失函数<br>   （2）健壮性不强</p><p><strong>3. Hinge Loss</strong><br>   Hinge Loss通常被用于最大间隔算法，例如SVM中，Hinge Loss的数学表达式为：<br>   $L(\hat{y},y)=max(0,1-\hat{y}y)$<br>   $\hat{y}$表示预测输出，值在[-1,1]之间，$y$表示label值，为-1或1.<br>   如果样本被正确分类，损失为0，否则为$1-\hat{y}y$。<br>   什么时候样本损失为0呢？即$\hat{y}y&gt;=1$，也就是当$y=1$时，此时的$\hat{y}&gt;=1$，当$y=-1$时，此时的$\hat{y}&lt;=-1$，这些样本正好是SVM中分割超平面两边的样本。即SVM中分割超平面两边的样本损失为0，分割超平面中间的样本损失为$1-\hat{y}y$，我们要让这个损失尽可能小，即要让$\hat{y}y$尽可能接近1，那就是让正例的输出尽可能为1，让负例的输出尽可能为-1，即最大化间隔。</p><h3><span id="111-二分类和多分类">1.1.1. 二分类和多分类</span></h3><p>逻辑回归用来解决二分类问题，对于逻辑回归，有</p><script type="math/tex; mode=display">h(x)=g(w^Tx)=\frac{1}{1+e^{-w^Tx}}</script><p>输出的$h(x)$表示样本$x$属于正例的概率</p><p>在求二分类的损失函数时，我们先看对数损失函数：</p><script type="math/tex; mode=display">L(Y,P(Y|X))=-log(P(Y|X))</script><p>逻辑回归的损失函数采用对数损失，则可以将逻辑回归的损失函数写成：</p><script type="math/tex; mode=display">\operatorname{L}\left(\hat{y}, y\right)=\left\{\begin{array}{ll}-\log \left(\hat{y}\right) & \text { if } y=1 \\-\log \left(1-\hat{y}\right) & \text { if } y=0\end{array}\right.</script><p>将上面式子合并成一个式子，下面表示一个样本的损失：</p><script type="math/tex; mode=display">L(\hat{y},y)=-ylog(\hat{y})-(1-y)log(1-\hat{y})</script><p>如果所有样本的损失函数</p><script type="math/tex; mode=display">L(\hat{y},y)=-\frac{1}{m}\sum_{i=1}^{i=m}ylog(\hat{y})+(1-y)log(1-\hat{y})</script><p>softmax层中的softmax函数是logistic函数在多分类任务上的推广，将因为是多任务，所以卒中最终输出的是一个N维的向量，N表示类别的个数，但是这N向量需要满足2个条件：</p><ol><li>N为维向量中的每个值在[0,1]之间</li><li>这N个数加起来等于</li></ol><p>而softmax正好可以满足这2个条件，softmax接收1个N维向量，将这个N为维向量变成1个N个[0,1]之间的数，且和为1的N向量输出。</p><script type="math/tex; mode=display">y^j=\frac{o^j}{\sum_{j=1}^{j=N}o^j}</script><p>经过softmax函数之后输出N个y值，表示样本属于N类的概率</p><p>单个样本的log损失函数为：</p><script type="math/tex; mode=display">L(\hat{y},y)=-\sum_{j=1}^{j=N}y_jlog(\hat{y_j})</script><p>$y_j$表示样本真实情况下是否属于第$j$类，属于的话$y_j=1$，否则为0<br>$\hat{y_j}$表示预测情况下样本属于第$j$类的概率。<br>一共有$N$项相加，其中只有1项不为0，其余的$N-1$项均为0</p><p>所有样本的损失函数为：</p><script type="math/tex; mode=display">L(\hat{y},y)=-\sum_{i=1}^{i=m}\sum_{j=1}^{j=N}y_j^ilog(\hat{y_j^i})</script><h2><span id="12-回归损失函数">1.2. 回归损失函数</span></h2><p><strong>1. 平方绝对值误差（L1损失）</strong></p><script type="math/tex; mode=display">M A E=\sum_{i=1}^{n}\left|y_{i}-\hat{y_i}\right|</script><p><strong>2. MSE误差（L2损失）</strong></p><script type="math/tex; mode=display">M S E=\sum_{i=1}^{n}\left(y_{i}-\hat{y_{i}}\right)^{2}</script><p>MAE对异常值有更好的鲁棒性。因为MSE取了平方，如果数据中存在异常点，就会放大误差，对异常点敏感。如果数据中有异常点，用MAE损失比较好。<br>直观理解：如果用MSE作为损失函数，对所有样本只预测出1个值，预测出来的值一定是所有label的均值。如果用MAE作为损失函数，对所有样本只预测1个值，预测出来的值一定是所有label的中位数。我们知道如果样本中有异常点，中位数比均值更鲁棒，因为用MAE比MSE更稳定。<br>但是MAE也存在问题，就是更新梯度始终相同，即使对于很小的损失值，梯度也很大，不利于模型的学习。解决方案是使用变化的学习率，在损失接近最小值时降低学习率。</p><p>但MSE就没有这个问题，因为MSE的梯度是变化的，随着loss减小，梯度也在变小。</p><p><img src="/2020/07/05/百面机器学习概述二/mse.png" alt=""></p><p>在实际情况中，选择MAE还是MSE视情况而定，如果异常值需要被检测出来，选择MSE，否则选择MAE</p><p>但是以上这2种损失都有个问题：当数据中90%的目标值为150，剩下10%为在<code>0~30</code>之间。如果选择MAE作为损失函数，输出的预测值倾向于150，因为MAE倾向于输出中位数。如果选择MSE作为损失函数，输出的预测值倾向于0~30，因为模型会向异常点偏移。这2种情况都不可取。<br>为了解决这个问题，提出了Huber损失函数</p><p><strong>3. Huber损失</strong><br>   Huber损失函数对异常点没有MSE那么敏感，在0也可微分。Huber结合了MAE和MSE，当误差很大时，变成MAE，当误差很小变成MSE。这里误差的大小分界线有1个阈值控制。</p><script type="math/tex; mode=display">L_{\delta}(y, f(x))=\left\{\begin{array}{ll}   \frac{1}{2}(y-f(x))^{2} & \text { for }|y-f(x)| \leq \delta \\   \delta|y-f(x)|- \frac{1}{2}\delta^{2} & \text { otherwise }   \end{array}\right.</script><p><img src="/2020/07/05/百面机器学习概述二/huber.png" alt=""></p><p>Huber有1个缺点是需要不断的调整超参数$\delta$</p><h1><span id="2-梯度下降">2. 梯度下降</span></h1><p>批量梯度下降：BGD<br>随机梯度下降：SGD<br>小批量梯度下降：MBGD</p><p>那逻辑回归损失函数举例：</p><script type="math/tex; mode=display">Loss(w)=-\frac{1}{m}\sum_{i=1}^{i=m}(y^ilog(h(x^i))+(1-y^i)log(1-h(x^i)))</script><ul><li>批量梯度下降：梯度下降公式中的$m$如果是样本总数，则每次更新参数时需要考虑所有的样本，这种方法容易求得全局最优解，但是由于样本个数太多，训练过程非常慢。</li><li>随机梯度下降：$m=1$，即每次更新参数时只考虑一个样本，这种方法训练速度快，但是准确率下降，并不是全局最优。</li><li>小批量梯度下降：m为所有样本的一小部分时，比如m=32，即每次更新参数时只考虑一小部分样本，它克服了上述两种方法的缺点又兼顾它们的优点，在实际中最常使用。</li></ul><h1><span id="3-dropout">3. Dropout</span></h1><p>Dropout用来应对过拟合。</p><p>当对隐藏层使用dropout时，该层的隐藏单元将有一定的概率被丢弃掉。假设丢弃概率为$p$，那么对于隐藏层的一个神经单元有$p$的概率被丢弃</p><h1><span id="4-集成学习">4. 集成学习</span></h1><p>通俗讲：三个臭皮匠，顶个诸葛亮。<br>将多个分类器的结果统一成最终的决策。<br>每个分类器称为：基分类器</p><h2><span id="41-boosting和bagging">4.1. Boosting和Bagging</span></h2><p>集成学习分为2种：Boosting和Bagging</p><p>Boosting是串行学习，各个基分类器之间有依赖。各个基分类器层层叠加，训练的时候，每个基分类器对前一个分类器分错的样本给予更高的权重。测试的时候将所有基分类器的分类结果加权得到最终结果。<br>概括为2点：（1）Boosting训练得到m个分类器，对哪些错误率小的模型赋予大的权重，对错误率大的模型赋予小的权重，在m个分类器结果整合时，乘上对应的权重。（2）在训练第二个模型时，对前一个模型预测错误的样本在第二个模型中提高权重，使其从错误中学习。<br>总结：从错误中学习</p><p><img src="/2020/07/05/百面机器学习概述二/boosting.jpg" alt=""></p><p>Bagging<br>并行训练，各个基分类器相互独立。将所有的训练样本划分成多个子集（可以相同，也可以不同，或部分相同），然后分配给每个分类器单独学习，由于个体之间存在差异，得到的决策也不会完全相同，在最终决策时，通过投票的方式做出最终的决策。<br>总结：集体投票</p><p><img src="/2020/07/05/百面机器学习概述二/bagging.jpg" alt=""></p><p>Boosting：GBDT<br>Bagging：随机森林，如下图</p><p><img src="/2020/07/05/百面机器学习概述二/随机森林.png" alt=""></p><h2><span id="42-集成学习步骤和例子">4.2. 集成学习步骤和例子</span></h2><p>集成学习分为3步：</p><ol><li>选择基分类器</li><li>训练基分类器</li><li>合并基分类器结果</li></ol><ul><li>选择基分类器</li></ul><p>任何的分类模型都可以作为基分类器，为什么集成学习中通常选择决策树作为基分类器？<br>主要有以下3个原因：</p><ol><li>决策树对输入数据分布敏感，数据的扰动对决策树的分类结果影响很大，这样“不稳定的分类器”更适合作为基分类器。</li><li>决策树的复杂程度和泛化能力，可以通过修改树的层数来折中</li><li>决策树可以方便地将样本的权重整合到训练过程中，而不需要通过过采样调整样本权重。</li></ol><p><strong>集成学习要求基分类器：好而不同（不稳定）</strong></p><ul><li>训练基分类器<br>有Bagging（并行）和Boosting（串行）2种方式</li><li>合并基分类器</li></ul><p>神经网络也可以作为基分类器，也可以通过调节层数和神经单元个数调整模型复杂度。</p><ul><li>是否可以选择SVM和KNN作为基分类器<br>不可以，因为SVM和KNN本身是稳定的分类器，方差不大，如果分别训练后再集成，可能和单独的分类器先比，结果不会更好，反而会使得因为将训练集拆分子集导致基分类器更难收敛。</li></ul><h2><span id="43-偏差和方差">4.3. 偏差和方差</span></h2><p>以前我们经常用过拟合、欠拟合来描述模型的好坏，这里使用偏差和方差来定量描述模型的性能。</p><ul><li><p>偏差(bias)：模型<strong>预测值的平均值和真实值之间</strong>的偏差，偏差通常是由于分类器的表达能力有限，导致系统性错误，在训练误差上就可以体现出来</p></li><li><p>方差(varicance)：<strong>模型预测值之间</strong>的方差。方差通常是由于模型太复杂，导致过拟合，点很分散（方差大容易导致过拟合），方差通常体现在测试误差相对训练误差的增量上</p></li></ul><p><img src="/2020/07/05/百面机器学习概述二/偏差和方差.png" alt=""></p><ul><li><p>如何从减小偏差和方差的角度解释Boosting和Bagging<br>Bagging并行，Boosting串行，这2种集成方法都可以提升基分类器的性能，是因为Bagging降低了方差，Boosting降低了偏差。</p><ul><li>因为Bagging是通过n个训练集，得到n个独立的基分类器，$X_1,X_2,…X_n$，每个模型的方差为$\sigma^2$，则n个模型的平均后的方差为<br>$Var(\frac{1}{n}\sum_{i=1}^{i=n}X_i)=\frac{1}{n^2}Var(\sum_{i=1}^{i=n}X_i)=\frac{\sigma^2}{n}$<br>即平均后的模型方差变成基分类器的$\frac{1}{n}$，但这要求n个基分类器相互独立，所以让方差变成原来的$\frac{1}{n}$，需要让这n个基分类器尽可能相互独立。例如在随机森林中，在对特征进行分裂时，随机选择一个特征，而不是选择最优特征。</li><li>Boosting将上一个基分类器的误差或参加，输入到下一个基分类器中，不断减少模型的损失，使输出更靠近靶心，可以减少偏差，但是这n个基分类器是强相关，并不相互独立，所以并不能显著降低方差。</li></ul></li></ul><p><img src="/2020/07/05/百面机器学习概述二/偏差和方差1.png" alt=""></p><h2><span id="44-常见集成学习模型">4.4. 常见集成学习模型</span></h2><p>Bagging：随机森林（基分类器是CART）</p><p>Boosting：AdaBoost，GBDT（基分类器是CART回归树），XGBoost</p><h3><span id="441-随机森林">4.4.1. 随机森林</span></h3><p>随机森林使用CART作为基分类器。</p><p>随机森林由多个决策树组成，不同决策树之间没有关联。当我们进行分类任务时，输入测试样本，就让森林中的每一棵决策树分别进行预测，每个决策树都会得到一个分类结果，然后采用投票机制，将测试样本分到票数多的那个类别。</p><p>构造随机森林的4个步骤：</p><ol><li>随机抽样，用来训练决策树<br>假设有N个样本，有放回地抽样得到N个样本，将这N个样本用来训练一个决策树</li><li>随机选择属性，作为节点分裂属性<br>假设一个样本有M个属性，在构建决策树时，从这这M个属性中随机选m个属性，然后在这m个属性中采用某种策略（信息增益，信息增益比）选择1个最优属性将节点进行划分</li><li>重复步骤2，直到节点不再分裂<br>当节点所有样本属于同一类，或没有属性可以选择停止划分</li><li>将大量决策树组成森林<br>将多个决策树组成森林</li></ol><p>随机森林的优点：</p><ol><li>不容易过拟合</li><li>可以并行，训练速度快</li><li>可以处理很高维的数据，不用做特征选择</li><li>实现简单</li></ol><p>随机森林缺点：</p><ol><li>在某些噪声大的数据集上容易过拟合</li><li>取值多的特征容易对随机森林的决策产生更大的影响</li></ol><p>随机森林的应用：</p><ol><li>分类</li><li>回归</li><li>无监督学习聚类</li><li>异常点检测</li></ol><h3><span id="442-adaboost">4.4.2. AdaBoost</span></h3><p>Boosting是集成技术，从很多个基分类器中创建一个强分类器。<br>AdaBoost是Adaptive Boosting（自适应增强）的缩写。自适应体现在前一个基分类器分错的样本在下一个分类器中权重会变大。</p><p>AdaBoost分为3个步骤：</p><ol><li>初始化训练集样本的权重，假设有N个样本，则每个样本初始化权重为$\frac{1}{N}$</li><li><p>训练基分类器，对所有的训练样本得到预测结果，计算预测结果的误差率，这里的误差率是所有被分错样本的权重之和。假设有3个样本被分错了，这3个样本的权重分别为0.1,0.2,0.2，则误差率是0.5。然后根据误差率计算这个分类器的融合权重。然后更新每个样本在下一个分类器中的权重。如果一个样本已经被正确分类，则在下一个分类器中，该样本的权重被降低或不变，那些没有被分错的样本在下一个分类器中，样本权重被增大。<br><strong>计算第$m$个基分类器的权重</strong><br>$\alpha_m=\frac{1}{2}ln\frac{1-e_m}{e_m}$<br>$e_m$表示第m个基分类器的误差率，可以看出误差率越大，基分类器的权重越小。</p><p><strong>更新每个样本的权重</strong></p><ul><li>对于上一个分类器分对的样本<br>$w_{m+1}(x)=\frac{w_m(x)}{Z_m}exp(-\alpha_m)$</li><li>对于上一个分类器分错的样本<br>$w_{m+1}(x)=\frac{w_m(x)}{Z_m}exp(\alpha_m)$</li></ul><p>$Z_m=\sum_{N}$是归一化因子，为了保证所有的$w$加起来等于1。<br>可以看到对于分对的样本，$exp(-\alpha_m)$小于1，所以该样本在下一个分类器中权重变小。<br>对于分错的样本，$exp(\alpha_m)$大于1，所以该样本在下一个分类器中权重变大</p></li><li><p>给定一个测试样本，将m个基分类器的预测结果加权融合起来，得到最终的预测结果</p></li></ol><p>AdaBoost优点：</p><ol><li>利用基分类器生成强分类器</li><li>具有很高的精度</li><li>充分考虑每个样本的权重</li></ol><p>AdaBoost的缺点：</p><ol><li>基分类器串行训练，耗时</li><li>基分类器数量不好确定</li><li>数据不平衡导致分类精度下降</li></ol><h3><span id="443-gbdt">4.4.3. GBDT</span></h3><p>梯度提升决策树（Gradient Boosting Decision Tree）属于Boosting，GDBT用来做回归。</p><p>GDBT的损失函数是平方损失</p><script type="math/tex; mode=display">L(y, f(x))=\frac{1}{2}(y-f(x))^{2}</script><p>GBDT基于决策树预测结果的残差进行迭代学习。GBDT属于Boosting，即在训练时 当前基分类器基于上一个基分类器的预测结果，重点关注那些分类错误的样本。<br>GDBT使用决策树作为基分类器，GBDT中的决策树通常被称为CART。每个决策树学的是之前所有树结论和的残差。<br>我们使用用户访问视频时长、时段、观看类型来预测用户的年龄。假设用户A的真实是25岁，第一棵决策树的预测年龄为22岁，残差为3，则第二课树就要去学习3，假设第二棵树预测结果为5，残差为-2，则第三棵树就要去学习-2。即每棵树都是学习残差，所以GBDT中的Gradient Boosting就是这个意思。<br>在预测阶段，给定一个测试样本，GBDT中的多个树可以并行预测，最终的结果为n个树预测结果之和。</p><p><strong>GBDT的优点和缺点</strong></p><p>优点：</p><ol><li>预测阶段快，多个树之间可以并行预测（注意GBDT不可以并行训练，但可以并行预测），最终的结果为$f(最终)=f(初)+f(残差1)+…+f(残差n)$</li><li>GBDT使用决策树作为基分类器，使得GBDT具有较好的解释性</li><li>效果好</li></ol><p>缺点：</p><ol><li>在高维系数的数据集上，表现不如SVM和神经网络</li><li>在处理文本分类时，优势不明显</li><li>训练需要串行，速度慢</li><li>以平方损失作为损失函数，对噪声数据敏感，如果有噪声会过度关注噪声，容易产生过拟合，解决方法是换一种损失函数，例如Huber或绝对值损失</li></ol><h3><span id="444-xgboost">4.4.4. XGBoost</span></h3><p>针对GBDT，陈天奇博士在论文中给出更优的解决方案：XGBoost（Extreme Gradient Boosting），基于GBDT的思想做出各种优化。主要包括以下几方面：</p><ul><li>在损失函数中添加正则项，避免过拟合</li><li>在损失函数上进行二阶泰勒展开，提升模型精度</li><li>在工程层面，并行处理，提高训练效率</li><li>对特征中缺失的特征值处理</li></ul><p>XGBoost和GBDT的预测方式一样，都是将所有树的预测结果加起来</p><script type="math/tex; mode=display">\hat{y}_{i}=\sum_{k=1}^{K} f_{k}\left(x_{i}\right), f_{k} \in \mathcal{F}</script><p>$K$表示基分类器的个数</p><p>但XGBoost的目标函数和GBDT不一样，XGBoost添加了正则化项</p><script type="math/tex; mode=display">\operatorname{obj}(\theta)=\sum_{i}^{n} l\left(y_{i}, \hat{y}_{i}\right)+\sum_{k=1}^{K} \Omega\left(f_{k}\right)</script><p>损失函数中我们需要训练的就是每一棵树$f_k$，一共有$K$棵树。<strong>XGBoost和GBDT采用的都是增量训练的方法</strong>，每一步都在是前一步的基础上增加一棵树，而新增的这棵树是为了修复前一棵树的不足。第$t$棵树的预测结果就是前一棵树的预测结果$\hat{y}^{t-1}$加上当前树的预测结果(残差)$f_t{x}$</p><script type="math/tex; mode=display">\begin{aligned}\hat{y}_{i}^{(0)} &=0 \\\hat{y}_{i}^{(1)} &=f_{1}\left(x_{i}\right)=\hat{y}_{i}^{(0)}+f_{1}\left(x_{i}\right) \\\hat{y}_{i}^{(2)} &=f_{1}\left(x_{i}\right)+f_{2}\left(x_{i}\right)=\hat{y}_{i}^{(1)}+f_{2}\left(x_{i}\right) \\& \ldots \\\hat{y}_{i}^{(t)} &=\sum_{k=1}^{t} f_{k}\left(x_{i}\right)=\hat{y}_{i}^{(t-1)}+f_{t}\left(x_{i}\right)\end{aligned}</script><p>在每一次添加一棵树时，怎么确定添加的这棵树就是我们想要的呢？怎么判断添加了这棵树让我们的模型变得更好呢？答案是：添加了这棵树有助于损失函数。在添加第$t$棵树时，损失函数为：</p><script type="math/tex; mode=display">\begin{aligned}\mathrm{obj}^{(t)} &=\sum_{i=1}^{n} l\left(y_{i}, \hat{y}_{i}^{(t)}\right)+\sum_{i=1}^{t} \Omega\left(f_{i}\right) \\&=\sum_{i=1}^{n} l\left(y_{i}, \hat{y}_{i}^{(t-1)}+f_{t}\left(x_{i}\right)\right)+\Omega\left(f_{t}\right)+\text {constant}\end{aligned}</script><p>假设这里使用均方差作为经验损失函数，则整体的损失函数变成：</p><script type="math/tex; mode=display">\begin{aligned}\mathrm{obj}^{(t)} &=\sum_{i=1}^{n}\left(y_{i}-\left(\hat{y}_{i}^{(t-1)}+f_{t}\left(x_{i}\right)\right)\right)^{2}+\sum_{i=1}^{t} \Omega\left(f_{i}\right) \\&=\sum_{i=1}^{n}\left[2\left(\hat{y}_{i}^{(t-1)}-y_{i}\right) f_{t}\left(x_{i}\right)+f_{t}\left(x_{i}\right)^{2}\right]+\Omega\left(f_{t}\right)+\text { constant }\end{aligned}</script><p>对于MSE求出来的损失函数式子比较友好，包含一个一阶项和一个二阶项。但是对于其他形式，就不会有这么好的损失函数了，但是我们可以用泰勒展开进行逼近</p><script type="math/tex; mode=display">\mathrm{obj}^{(t)}=\sum_{i=1}^{n}\left[l\left(y_{i}, \hat{y}_{i}^{(t-1)}\right)+g_{i} f_{t}\left(x_{i}\right)+\frac{1}{2} h_{i} f_{t}^{2}\left(x_{i}\right)\right]+\Omega\left(f_{t}\right)+\text {constant}</script><p>其中$g_i,h_i$分别是损失函数的一阶，二阶梯度。</p><script type="math/tex; mode=display">\begin{array}{l}g_{i}=\partial_{\hat{y}_{i}(t-1)} l\left(y_{i}, \hat{y}_{i}^{(t-1)}\right) \\h_{i}=\partial_{\hat{y}_{i}^{(t-1)}}^{2} l\left(y_{i}, \hat{y}_{i}^{(t-1)}\right)\end{array}</script><p>在计算过程中，我们还可以忽略常数项$l\left(y_{i}, \hat{y}_{i}^{(t-1)}\right)$（因为这个常数项表示目标值和第t-1棵决策树的预测值的差，第t棵决策树并不会优化这一项，因此是个定值），则第t棵树的损失函数可以简化为：</p><script type="math/tex; mode=display">\sum_{i=1}^{n}\left[g_{i} f_{t}\left(x_{i}\right)+\frac{1}{2} h_{i} f_{t}^{2}\left(x_{i}\right)\right]+\Omega\left(f_{t}\right)</script><p>因此在选择第t棵树的时候就按照上面的损失函数来选择。式子中只需要考虑$g_i,h_i$，这就是XGBoost为什么能支持自定义损失函数的原因。</p><p>下面介绍正则化$\Omega(f)$，在XGBoost中</p><script type="math/tex; mode=display">\Omega(f)=\gamma T+\frac{1}{2}\gamma\sum_{j=1}^Tw_j^2</script><p>$T$表示一个基分类器中叶子节点的个数，$w_j$表示第$j$个叶子节点上的分数</p><p>将正则化项带入损失函数中，变成：</p><p><img src="/2020/07/05/百面机器学习概述二/xgboost.jpg" alt=""></p><p>其中$f_t(X_i)=w_q(X_i)$，表示在第t个决策树$f_y$中，样本$X_i$落在某个叶子节点，这个叶子节点的权重。</p><ul><li><p><strong>XGBoost中的每个树怎么选择特征分类的</strong><br>XGBoost的基分类器是CART，误以为和CART的分分裂标准一样。先回顾下CART的分类标准：回归问题以平平方损失进行分类，分类树以基尼指数进行分裂。XGBoost和CART的分裂标准不一样，采用下面的公式来选择最优特征：</p><p><img src="/2020/07/05/百面机器学习概述二/xgboost3.jpg" alt=""></p></li><li><p><strong>XGboost使用的残差相加，怎么处理分类问题</strong><br>XGBoost使用残差相加的方式，这里的值都是连续值，最后每个叶子节点的数也是连续值。如果处理二分类问题，则将叶子叶子节点的值经过<code>sigmoid</code>函数，得到一个概率。如果是多分类，则经过<code>softmax</code>函数</p></li><li><p>XGBoost怎么处理缺失值</p><ol><li>在训练基分类器时，对于那些在特征A缺失的样本，分别把它分到左右子树上，然后计算增益大的方向进行分裂</li><li>如果在训练集上没有缺失值，在预测中出现了缺失，那会自动将缺失值的样本划分到右子树上</li></ol></li></ul><ul><li><p>XGBoost为什么这么快</p><ol><li><p>连续值的处理<br>决策树在训练时需要对特征进行划分，对于连续特征，如果枚举所有的划分点将会十分耗时。一种近似的方法是只枚举分位点，首先将这个特征的所有取值排序，然后只将那些对分类结果产生影响的特征值作为分位点，使用损失降低最大的那个分位点作为划分点。</p><ol><li>利用数据的稀疏性<br>产生稀疏性的3个原因：数据丢失；数据本身中就有大量的0；对离散值进行one-hot。通常利用稀疏性可以提高运算速度。XGBoost做法是：每个划分时，都指定一个默认分支，如果样本在划分特征上值为0，就被分到默认分支上。这样，在训练时不必考虑这些0，大大提高运算速度。将缺失样本划分到左节点和右节点，计算增益，分到增益大的一侧。</li></ol><p><img src="/2020/07/05/百面机器学习概述二/xgboost2.jpg" alt=""></p><ol><li>数据的预排序和分块存储<br>在分叉的时候需要找分位点，需要对每个特征进行排序，排序过程需要做很多遍，所以XGBoost在训练之前就将所有的特征按照特征值进行排序，并将排序后的特征值按列存储在内存中。在分布式环境中， 可以进行分块存储。</li><li>并行处理<br>XGBoost的并行不是树级别的并行，而是特征级别的并行。决策树学习中最耗时的部分是将数据按照特征值进行排序，为了降低排序成本，XGBoost通常在训练之前将特征已经排好序存储在内存单元(block)中，每个block数以压缩列的格式存储，每列按特征值排序。在进行节点分裂时，需要计算每个特征的增益，选择增益大的特征进行分裂，在计算各个特征的增益时可以并行计算。</li></ol></li></ol></li></ul><h3><span id="445-gdbt和xgboost区别">4.4.5. GDBT和XGBoost区别</span></h3><ol><li><p>GDBT使用CART作为基分类器，XGBoost还支持线性分类器，通过指定参数<code>booster:default=gbtree</code>，还可以是<code>gblinear,linear model</code></p></li><li><p>GBDT损失函数只用到一阶导数信息，XGBoost对损失函数进行二阶泰勒展开，同时用到一阶和二阶导数，并且指出自定义代价函数。</p></li><li>XGBoost相比GBDT在损失函数中加入正则化，用于控制模型复杂度</li></ol><h1><span id="5-cnn">5. CNN</span></h1><p>什么是平移不变性</p><p>不变性意味着即使目标的外观发生了某种变化，也依然可以识别出来。例如图像，无论是被平移，旋转，缩放，甚至不同的光照条件都可以被识别出来。所以不变性有各种方面：</p><ul><li>平移不变性</li><li>旋转不变性</li><li>光照不变性</li><li>等</li></ul><p>平移不变性：比如对于图像分类任务，图像中的目标不管被移到图片中的哪个位置，得到的label都是完全一样的。</p><p>卷积神经网络的平移不变性主要依赖于：卷积+池化</p><p><a href="https://www.cnblogs.com/Terrypython/p/11147490.html" target="_blank" rel="noopener">卷积神经网络为什么具有平移不变性？</a></p><h1><span id="6-gnn">6. GNN</span></h1><p>图数据是非欧式数据，不满足平移不变性</p><h2><span id="61-deepwalk">6.1. DeepWalk</span></h2><p>DeepWalk将随机游走和word2vec结合起来该算法能为图中每个节点学习一个节点嵌入。</p><p>DeepWalk利用随机游走算法从图中提取一些序列，借助NLP的思路，将这些序列看成一句话，输入到word2vec中的skip-gram模型（一对多），得到节点嵌入。</p><h2><span id="62-line">6.2. LINE</span></h2><p>LINE将大规模网络中的节点变成低维向量，训练的目标是使得联系紧密的节点学到的节点嵌入更相似。</p><p>LINE使用一阶相似性和二阶相似性来衡量图中2个节点的紧密性。例如下图中的6和7<br>一阶相似性：一阶邻居，直接相连。认定直接相连的节点一般更相似。<br>二阶相似性：这2个节点没有直接相连，但是它们有共同的邻居。例如下图中的5和6，一般也认为这2个节点更相似。</p><p><img src="/2020/07/05/百面机器学习概述二/line.jpg" alt=""></p><h2><span id="63-图卷积神经网络">6.3. 图卷积神经网络</span></h2><p>图卷积神经网络主要包括卷积算子和池化算法的构建。其中卷积算子的目的是刻画节点的局部结构。池化算子的目的是学到网络的层级化表示，降低参数。这里我们主要看如何构建卷积算子。</p><p>卷积算子的构建有2种方法：谱图卷积和空间卷积。</p><ul><li>谱图借助卷积定理在谱域上定义卷积</li><li>空间图卷积从节点域出发，通过定义聚合函数来聚合每个中心节点和邻近节点</li></ul><p>图卷积的本质是如何对邻居节点的特征做有效的聚合。</p><h3><span id="631-谱图卷积">6.3.1. 谱图卷积</span></h3><p>借助卷积定理在谱域上定义卷积</p><p>Spectral GNN(2013Bruna)—&gt;ChebNet—&gt;GCN</p><p>Sepctral GNN具有较高的时空复杂性<br>ChebNet和GCN对谱方法的卷积核进行参数化，降低时空复杂度。</p><p><strong>符号定义</strong><br>单位阵（对角阵）$I_{n} \in R^{n \times n}$<br>邻接矩阵$A \in R^{n \times n}$<br>度矩阵（对角阵）$D \in R^{n \times n}$<br>拉普拉斯矩阵$L \in R^{n \times n}$<br>特征向量矩阵$U \in R^{n \times n}$<br>特征值矩阵（对角阵）$\Lambda \in R^{n \times n}$<br>第$i$个特征向量$u_{i} \in R^{n}$</p><p>归一化后的拉普拉斯矩阵$L=I_{n}-D^{-\frac{1}{2}} A D^{-\frac{1}{2}}$<br>$L$是对称矩阵，对$L$做特征分解得到$L=U \Lambda U^{T}$</p><p><strong>卷积定理</strong></p><p>卷积定理：信息卷积的傅里叶变换等于信号傅里叶变换的乘积</p><script type="math/tex; mode=display">F\left(f^{*} g\right)=F(f) \cdot F(g)</script><p>对等式两边做傅里叶逆变换</p><script type="math/tex; mode=display">f^{*} g=F^{-1}(F(f) \cdot F(g))</script><p>利用卷积定理，可以对谱空间的信息$F(f),F(g)$做乘法，然后再做傅里叶逆变换，就可以得到原先空间的卷积运算。</p><p>上面定义的信号的傅里叶变换，而图上的傅里叶变换依赖于图上的拉普拉斯矩阵。下面定义<strong>图上的傅里叶变换</strong>。</p><script type="math/tex; mode=display">\hat{x}=U^{T} x</script><p>$x$表示节点域的图信号矩阵，$\hat{x}$表示$x$变换到谱域后的表示。<br><strong>图上的傅里叶逆变换</strong></p><script type="math/tex; mode=display">x=U \hat{x}</script><p>根据卷积定理，我们可以得到图卷积算子</p><script type="math/tex; mode=display">x_{G}^{*} y=U\left(\left(U^{T} x\right) \odot\left(U^{T} y\right)\right)</script><p>我们用一个对角阵来$g_{\theta}$来代替$U^Tx$，卷积算子变成:</p><script type="math/tex; mode=display">g_{\theta}{*}x=Ug_{\theta}U^{T} x</script><p>$g_{\theta}$就是我们需要学习的卷积核</p><ol><li><p>Spectral GNN<br>使用<strong>特征值组成的对角阵</strong>来代替卷积核$g_{\theta}$，有n个需要学习的参数，卷积运算变成</p><script type="math/tex; mode=display">g_{\theta} {*} x=U g_{\theta}(\Lambda) U^{T} x</script><p>缺点：</p><ol><li>时间复杂度高</li><li>不具有局部性，即产生信息聚合的节点不一定是邻近节点</li></ol></li><li><p>多项式卷积<br>为了降低时间复杂度，对卷积核进行简化，卷积核只考虑$K$阶，然后带入到卷积操作中，得到新的卷积操作：</p><p><img src="/2020/07/05/百面机器学习概述二/gnn1.jpg" alt=""></p><ol><li>不需要对$L$进行特征值分解</li><li>涉及到$L$的$K$次幂</li></ol></li><li><p>ChebNet<br>对上面$L$的$K$次幂使用切比雪夫多项式进行逼近，将矩阵连乘变成多项式，减少时间复杂度，K表示K阶邻居，这里就有了局部的概念</p><p><img src="/2020/07/05/百面机器学习概述二/gnn2.jpg" alt=""></p></li><li><p>GCN<br>GCN进一步通过指定最大的特征值$\lambda_{\max }=2$和$K=1$进一步简化ChebNet，最终得到一阶图卷积神经网络。</p><p><img src="/2020/07/05/百面机器学习概述二/gnn3.jpg" alt=""></p></li></ol><p>在谱图卷积中的ChebNet和GCN就引入了局部的概念，将拉普拉斯矩阵及其变体作为聚合函数。</p><h3><span id="632-空间图卷积">6.3.2. 空间图卷积</span></h3><p>空间图卷积从节点域出发，通过定义聚合函数来聚合每个中心节点和邻近节点。<br>空间图卷积受谱图卷积中局部聚合函数的启发，通过注意力机制或其他网络直接从节点域学习聚合函数，这些方法不再依赖拉普拉斯矩阵，而是设计神经网络来学习聚合函数。</p><ol><li><p>GAT</p><p><img src="/2020/07/05/百面机器学习概述二/gat.jpg" alt=""></p><p>这里的参数有$W,a$,$W$用来节点的特征维度变换，$a$用来计算注意力分数。<br>步骤：</p><ol><li>现将每个节点的特征从$F$维变成$F’$维</li><li>对每个节点计算它对所有邻居的注意力分数，即将$Wh_i$和$Wh_j$拼接起来，输入到一个FCN中，输出一个实数，表示这2个节点的注意力分数</li><li>计算出一个节点对所有邻居的注意力分数后，将这些分数加起来作为综合，对每个注意力分数使用softmax函数进行归一化到[0,1]之间，且和为1</li><li>对所有的邻居特征进行聚合<br>从GAT开始，节点之间的权重计算开始从依赖于网络的结构信息转移到依赖于节点的特征表达。</li></ol><p>缺点：GAT在处理时需要加载整个网络的节点特征，不适用于大规模网络</p></li><li><p>GraphSAGE<br>为了解决大规模图的问题，提出图采样聚合网络GraphSAGE，不同于以前模型考虑所有邻近节点，GraphSAGE对邻近节点做随机采样，利用采样得到的节点进行聚合。</p><p><img src="/2020/07/05/百面机器学习概述二/graphsage.jpg" alt=""></p></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;总结《百面机器学习》有关知识点。&lt;/p&gt;
    
    </summary>
    
      <category term="Machine Learning" scheme="http://yoursite.com/categories/Machine-Learning/"/>
    
    
      <category term="machine learning" scheme="http://yoursite.com/tags/machine-learning/"/>
    
  </entry>
  
  <entry>
    <title>python输入怎么写</title>
    <link href="http://yoursite.com/2020/06/21/python%E8%BE%93%E5%85%A5%E6%80%8E%E4%B9%88%E5%86%99/"/>
    <id>http://yoursite.com/2020/06/21/python输入怎么写/</id>
    <published>2020-06-21T09:35:43.000Z</published>
    <updated>2020-06-21T09:47:14.170Z</updated>
    
    <content type="html"><![CDATA[<p>Leetcode刷多了不太记得python的输入怎么写了。在实际笔试或面试时，需要自己写输入和输出函数，所以在此记录下怎么使用Python读取数据。<br><a id="more"></a></p><p>在面试的时候，面试官只给你一个白板，最多给你定义好的函数名，其余都要自己写。给定的题目一般先读取数据，然后使用<code>print</code>输出最终的结果。</p><ul><li><code>print</code>可以写在<code>test</code>函数中</li><li>也可以将要输出的内容保存下来，作为<code>test</code>的<code>return</code>，然后在<code>main</code>中输出<br>下面是写程序的模板：</li><li><code>main</code>只关注输入和输出</li><li>其余的功能单独封装成函数，在<code>main</code>中调用</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test</span><span class="params">(param1,param2)</span>:</span></span><br><span class="line">    <span class="comment">#do something</span></span><br><span class="line"></span><br><span class="line">    print(<span class="string">"xx"</span>)</span><br><span class="line">    <span class="comment">#或者return</span></span><br><span class="line">    <span class="keyword">return</span> xx</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    <span class="comment">#使用input读取数据</span></span><br><span class="line">    m = input()</span><br><span class="line">    n = list(map(int,input.split()))</span><br><span class="line"></span><br><span class="line">    test(m,n)</span><br><span class="line"></span><br><span class="line">    print(<span class="string">"xx"</span>)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Leetcode刷多了不太记得python的输入怎么写了。在实际笔试或面试时，需要自己写输入和输出函数，所以在此记录下怎么使用Python读取数据。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="Python" scheme="http://yoursite.com/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>百面机器学习概述一</title>
    <link href="http://yoursite.com/2020/06/19/%E7%99%BE%E9%9D%A2%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%A6%82%E8%BF%B0/"/>
    <id>http://yoursite.com/2020/06/19/百面机器学习概述/</id>
    <published>2020-06-19T15:12:34.000Z</published>
    <updated>2020-07-15T01:26:36.490Z</updated>
    
    <content type="html"><![CDATA[<p>总结《百面机器学习》有关知识点。</p><a id="more"></a><!-- TOC --><ul><li><a href="#1-特征工程">1. 特征工程</a><ul><li><a href="#11-特征归一化">1.1. 特征归一化</a></li><li><a href="#12-类别型特征">1.2. 类别型特征</a></li><li><a href="#13-文本表示模型">1.3. 文本表示模型</a></li><li><a href="#14-word2vec">1.4. Word2Vec</a></li><li><a href="#15-图像不足时处理方法">1.5. 图像不足时处理方法</a></li></ul></li><li><a href="#2-模型评估">2. 模型评估</a><ul><li><a href="#21-常见评估指标">2.1. 常见评估指标</a></li><li><a href="#22-p-r曲线和roc曲线">2.2. P-R曲线和ROC曲线</a></li><li><a href="#23-余弦距离">2.3. 余弦距离</a></li><li><a href="#24-ab测试">2.4. A/B测试</a></li><li><a href="#25-模型评估方法">2.5. 模型评估方法</a></li><li><a href="#26-过拟合和欠拟合">2.6. 过拟合和欠拟合</a></li><li><a href="#27-正则化">2.7. 正则化</a></li><li><a href="#梯度消失和梯度爆炸">梯度消失和梯度爆炸</a></li></ul></li><li><a href="#3-经典算法">3. 经典算法</a><ul><li><a href="#31-回归模型">3.1. 回归模型</a><ul><li><a href="#311-单变量线性回归">3.1.1. 单变量线性回归</a></li><li><a href="#312-多变量线性回归">3.1.2. 多变量线性回归</a></li><li><a href="#313-带有激活函数的反向传播">3.1.3. 带有激活函数的反向传播</a></li><li><a href="#314-l1正则和l2正则">3.1.4. L1正则和L2正则</a></li><li><a href="#315-面试问题">3.1.5. 面试问题</a></li></ul></li><li><a href="#32-逻辑回归">3.2. 逻辑回归</a><ul><li><a href="#321-逻辑回归推导">3.2.1. 逻辑回归推导</a></li><li><a href="#322-逻辑回归常见问题">3.2.2. 逻辑回归常见问题</a></li></ul></li><li><a href="#33-softmax回归">3.3. Softmax回归</a></li><li><a href="#34-回归和分类总结">3.4. 回归和分类总结</a></li><li><a href="#35-数据不平衡问题">3.5. 数据不平衡问题</a><ul><li><a href="#351-smote算法">3.5.1. SMOTE算法</a></li></ul></li><li><a href="#36-svm">3.6. SVM</a><ul><li><a href="#361-线性可分svm">3.6.1. 线性可分SVM</a></li><li><a href="#362-近似线性svm">3.6.2. 近似线性SVM</a></li><li><a href="#363-核函数">3.6.3. 核函数</a></li><li><a href="#364-面试问题">3.6.4. 面试问题</a></li></ul></li><li><a href="#37-决策树">3.7. 决策树</a><ul><li><a href="#371-基础树id3c45cart">3.7.1. 基础树(ID3/C4.5/CART)</a><ul><li><a href="#3711-id3">3.7.1.1. ID3</a></li><li><a href="#3712-c45">3.7.1.2. C4.5</a></li><li><a href="#3713-cart分类回归树">3.7.1.3. CART(分类回归树)</a></li><li><a href="#3714-总结">3.7.1.4. 总结</a></li></ul></li><li><a href="#372-树的剪枝">3.7.2. 树的剪枝</a></li></ul></li><li><a href="#38-k近邻knn">3.8. K近邻(KNN)</a><ul><li><a href="#381-knn原理">3.8.1. KNN原理</a></li><li><a href="#382-kd树">3.8.2. KD树</a></li></ul></li></ul></li><li><a href="#4-聚类">4. 聚类</a><ul><li><a href="#41-k-means聚类">4.1. K-Means聚类</a></li><li><a href="#42-k-means的优化">4.2. K-Means的优化</a><ul><li><a href="#421-k-means">4.2.1. K-Means++</a></li><li><a href="#422-isodata">4.2.2. ISODATA</a></li></ul></li><li><a href="#43-聚类评价指标">4.3. 聚类评价指标</a></li></ul></li><li><a href="#5-贝叶斯分类">5. 贝叶斯分类</a><ul><li><a href="#51-朴素贝叶斯分类器">5.1. 朴素贝叶斯分类器</a></li><li><a href="#52-半朴素贝叶斯分类器">5.2. 半朴素贝叶斯分类器</a></li></ul></li><li><a href="#6-生成模型和判别模型">6. 生成模型和判别模型</a></li></ul><!-- /TOC --><h1><span id="1-特征工程">1. 特征工程</span></h1><h2><span id="11-特征归一化">1.1. 特征归一化</span></h2><ul><li>目的：消除特征之间量纲的影响，防止学习到的结果向数值大的特征倾斜。</li><li>Max-Min归一化：将数据归一化到[0,1]之间，等比缩放。</li><li>Z-Score归一化（零均值归一化）：将数据归一化到均值为0，标准差为1的分布上。</li><li>需要归一化：线性回归、逻辑回归、SVM、深度神经网络。不需要归一化：基于决策树模型。</li></ul><h2><span id="12-类别型特征">1.2. 类别型特征</span></h2><p>将类别特征—&gt;数值特征，有以下方法</p><ul><li>序号编码：有大小关系的，比如低中高，可以编码成1,2,3</li><li>one-hot编码：没有大小关系，问题：高维稀疏，需要将其嵌入成低维稠密向量</li><li>二进制编码：先编码再转换成二进制</li></ul><h2><span id="13-文本表示模型">1.3. 文本表示模型</span></h2><ul><li>词袋模型：将文章按照词分割，使用每个词的权重来表示文章</li><li>TF-IDF：用来计算一个词的权重，TF=一个词w在文章d中出现的频率，IDF：特属词的特征，逆文档频率</li><li>N-gram模型：将连续的n个词作为一个特征放在向量中。</li><li>词嵌入模型：将词映射成低维稠密向量(50~300维度)，Word2Vec是最常用的词嵌入模型。</li></ul><h2><span id="14-word2vec">1.4. Word2Vec</span></h2><p>Word2Vec有2种网络结构：CBOW，skip-gram</p><ul><li>CBOW：多预测一</li><li>skip-gram：一预测多</li></ul><h2><span id="15-图像不足时处理方法">1.5. 图像不足时处理方法</span></h2><p>图像不足易出现过拟合问题。解决图像不足有2种方法：</p><ul><li>基于模型：采用一些措施降低过拟合。例如简化模型，L1L2正则化、Dropout，集成学习。</li><li>基于数据：通过一些方法增加数据。平移、旋转、裁剪、修改图片亮度，锐度、添加噪声等方法。</li></ul><h1><span id="2-模型评估">2. 模型评估</span></h1><h2><span id="21-常见评估指标">2.1. 常见评估指标</span></h2><ul><li>准确率(Accuracy)</li><li>精确率(Precision)</li><li>召回率(Recall)</li></ul><p>其中这些指标都有一定的局限性。对于一个排序模型，怎么评估排序模型的好坏：</p><ul><li>设置不同的N，计算P@N,R@N</li><li>设置更综合的评价指标，PR曲线，ROC曲线，F1值</li></ul><p>RMSE：回归问题的评价指标。如果在一个问题上，RMSE非常高，但是观察预测值和真实值，发现90%的预测值都很接近真实值，为什么RMSE还是这么高。分析由于剩下的10%存在非常大的异常值，即使90%预测很准，但是这10%导致最终的RMSE差别很大。解决方案：</p><ul><li>如果10%是噪声数据，提前去除噪声</li><li>如果10%不是噪声数据，需要对异常数据进行建模</li><li>换一个对异常值不敏感的指标，例如MAPE</li></ul><h2><span id="22-p-r曲线和roc曲线">2.2. P-R曲线和ROC曲线</span></h2><ul><li><p>P-R曲线<br>P-R曲线横坐标是召回率，纵坐标是准确率。<br>为什么要有P-R曲线？因为精确率precision和召回率recall指标都有一定的局限性，所以使用P-R曲线可以综合地评估一个模型的效果。<br>在P-R曲线中，通过改变正负样本间的阈值来改变precision和recall。当判定为正样本的阈值很大时，说明选出的正样本都是很有把握的，precision较大，recall较小。当判定为正样本的阈值很小时，即尽可能不漏掉正样本，导致precision降低，recall变大。</p></li><li><p>ROC曲线<br>横坐标是假阳率FPR，纵坐标是真阳率TPR。</p></li></ul><script type="math/tex; mode=display">假阳率=\frac{负例被判为正例}{真正的负例}\quad真阳率=\frac{正例被判为正例}{真正的正例}</script><p>可以看出真阳率也就是召回率。<br>同P-R曲线类似，ROC曲线也是通过不断改变正负样本的阈值生成的。</p><ul><li>P-R曲线和ROC曲线有什么不同</li></ul><p>当测试集中的负样本数量增加10倍时，P-R曲线发生了明显的变化，ROC曲线几乎不变。ROC曲线能够尽量降低测试集带来的干扰，适用于正负样本不均衡的数据集中。ROC适用的场景更多，被广泛应用在排序，推荐，广告等领域。</p><p><a href="https://blog.csdn.net/songyunli1111/article/details/82285266" target="_blank" rel="noopener">为什么ROC曲线不受样本不均衡问题的影响</a></p><p>AUC是概率值，表示正样本排在负样本前面的概率。AUC越大，说明中正样越有可能排在负样本前面，常用在推荐，排序领域。</p><p>ROC有真阳率和假阳率，所以ROC同时关注正负样本。而PR曲线更关注正样本。</p><ul><li>如果你更关注正例，使用P-R曲线，例如检测癌症，电信诈骗等。如果你同时关注正例和负例，则使用ROC曲线。</li><li>如果你不想让训练集的正负比例过度的影响模型效果，用ROC</li></ul><p><img src="/2020/06/19/百面机器学习概述/PR曲线和ROC曲线.png" alt=""></p><h2><span id="23-余弦距离">2.3. 余弦距离</span></h2><p>余弦相似度：</p><script type="math/tex; mode=display">\cos (A, B)=\frac{A \cdot B}{\|A\|_{2}\|B\|_{2}}</script><p>余弦距离体现方向上的相对差异，欧式距离体现数值上的绝对差异。</p><h2><span id="24-ab测试">2.4. A/B测试</span></h2><p>划分实验组和对照组<br>实验组和对照组：选取样本时要求独立性和无偏性。</p><h2><span id="25-模型评估方法">2.5. 模型评估方法</span></h2><p>通常将数据划分为训练集和测试集，但在<strong>样本划分</strong>和<strong>模型验证</strong>的过程中，存在着不同的方法。</p><ol><li>Holdout验证<br>随机将数据划分为训练集和测试集，在测试集上进行模型验证。<br>缺点：模型的效果取决于样本划分，具有随机性</li><li>k折交叉验证<br>将样本划分为k个大小相等的子集，一个子集作为测试集，k-1个子集作为训练集。将k次评估结果平均作为该模型最终的结果。<br>优点：（1）解决当数据量较小时，模型评估不准确的问题（2）消除数据对评估结果的随机性影响（3）可以用来选择超参数<br>缺点：耗时，需要训练多个模型求评估结果的平均值</li><li>自助法<br>如果数据比较小，holdout和k折交叉验证都需要划分数据集，导致训练集变小。自助发采用随机抽样，在全部样本中进行n次有放回的抽样，得到大小为n的训练集。这n个样本中有的样本是重复的，有的样本没有被抽到，这些没有抽到的样本作为测试集。</li></ol><h2><span id="26-过拟合和欠拟合">2.6. 过拟合和欠拟合</span></h2><ul><li>过拟合<br>模型在训练数据上loss很小，在测试集上loss大</li><li>欠拟合<br>模型在训练集和测试集上loss都很大，效果都不好</li><li><p>降低过拟合的方法</p><ol><li>增加数据集，减少噪声的影响。如果没有这么多数据，可以生成一些数据。例如图像可以通过平移，旋转等生成数据</li><li>正则化，在loss中添加L1或L2正则，防止参数过大</li><li>集成学习，将多个模型集成在一起，降低单一模型的过拟合风险</li><li>降低模型复杂度，例如减少网络参数，神经元个数等。</li><li>早停，当模型在验证机上的loss连续N次没有提升时，停止训练</li><li>Dropout，在训练过程中按照给定的概率随机删除隐藏层的一些神经单元。由于模型训练的随机性，减轻了不同特征之间的协同效应。<strong>Dropout只能在训练时使用，在测试集上不能使用</strong></li></ol></li><li><p>降低欠拟合的方法</p><ol><li>添加新的特征，当特征少时容易出现欠拟合，模型对训练数据的拟合程度不好。</li><li>增加模型复杂度</li><li>减少正则化系数</li></ol></li></ul><h2><span id="27-正则化">2.7. 正则化</span></h2><p>正则化为了避免过拟合，即在损失函数后加上一个正则项（惩罚项），模型越复杂，正则化值就越大。</p><script type="math/tex; mode=display">\min _{f \in \mathcal{F}} \frac{1}{N} \sum_{i=1}^{N} L\left(y_{i}, f\left(x_{i}\right)\right)+\lambda J(f)</script><p>第一项是损失值，第二项是正则化项，$\lambda$调整两者的权重。下面拿回归问题举例，损失值为平方损失。</p><ul><li>L1正则<br>惩罚项为权重绝对值的和</li></ul><script type="math/tex; mode=display">L(w)=\frac{1}{N} \sum_{i=1}^{N}\left(f\left(x_{i} ; w\right)-y_{i}\right)^{2}+\lambda\|w\|_{1}</script><ul><li>L2正则</li></ul><p>惩罚项为权重的平方和</p><script type="math/tex; mode=display">L(w)=\frac{1}{N} \sum_{i=1}^{N}\left(f\left(x_{i} ; w\right)-y_{i}\right)^{2}+\frac{\lambda}{2}\|w\|^{2}</script><h2><span id="梯度消失和梯度爆炸">梯度消失和梯度爆炸</span></h2><p>梯度消失和梯度爆炸经常出现在较深的网络中。反向传播用到链式法则，导数连乘。如果激活函数求导后与权重相乘的积大于1，层数增多时，求出的梯度将以指数增加，发生梯度爆炸。如果小于1，梯度将以指数衰减，发生梯度消失。<br>sigmoid的导数最大为0.25，易发生梯度消失问题</p><p>如何解决梯度消失和梯度爆炸：</p><ol><li>使用ReLU代替sigmoid解决梯度消失问题。Relu的正数部分导数为1，不存在梯度消失和梯度爆炸的问题</li><li>梯度裁剪解决梯度爆炸，设置一个梯度裁剪阈值，如果梯度大于这个阈值使，将其强制限制在这个范围内。</li><li>残差网络，解决梯度消失的问题</li><li>BN批归一化层，BN主要是对x进行归一化到均值为0，方差为1。在L对w反向求到时，结果中肯定有x的存在，所以x的大小也会影响梯度消失和梯度爆炸，BN通过将输出进行归一化来消除x带的放大缩小的影响。</li></ol><h1><span id="3-经典算法">3. 经典算法</span></h1><h2><span id="31-回归模型">3.1. 回归模型</span></h2><p>回归模型分为线性回归和非线性回归。</p><p>线性回归又分为单变量线性回归和多变量线性回归。</p><h3><span id="311-单变量线性回归">3.1.1. 单变量线性回归</span></h3><p>使用房子面积和房价举例。训练集中x表示房子面积，y表示房价。使用$(x,y)$表示一个训练样，其中$(x^{(i)},y^{(i)})$表示第$i$个训练样本。。</p><ul><li>$h(x)=w_0+w_1x$，通过训练集学习$w_0,w_1$，使得$x$可以得到对应的$y$。因为这里没有激活函数，$x和y$是线性关系，所以成为单变量线性回归模型，因为输入的特征$x$只有1个特征（房子面积）</li><li>损失函数：$Loss = \frac{1}{2m}\sum_{i=1}^{i=m}(h(x^{i})-y^{i})^2$<br>求得是平均损失，有m个样本，所以前面损失除以m，这里的1/2是为了求导简化添加的。</li></ul><p><img src="/2020/06/19/百面机器学习概述/百面机器学习/../百面机器学习概述/linear.jpg" alt=""></p><h3><span id="312-多变量线性回归">3.1.2. 多变量线性回归</span></h3><p>输入的x有多个特征，上面单变量回归问题中，x只表示房子面积，在多变量线性回归中，x1=房子面积，x2=卧室个数，x3=房子楼层，x4=房子年龄</p><ul><li>$h(x)=w_0+w_1x_1+w_2x_2+w_3x_3+w_4x_4$<br>令$x=[x_1,x_2,x_3,x_4]$为列向量，$w=[w_1,w_2,w_3,w_4]$为列向量，则$h(x)=w^Tx$</li></ul><p><img src="/2020/06/19/百面机器学习概述/百面机器学习/../百面机器学习概述/linear1.jpg" alt=""></p><h3><span id="313-带有激活函数的反向传播">3.1.3. 带有激活函数的反向传播</span></h3><p>上面介绍的单变量和多变量回归都是线性的，没有激活函数，这里介绍带有激活函数的回归问题。</p><p>首先定义损失函数</p><script type="math/tex; mode=display">L=\frac{1}{2m}\sum_{i=1}^{i=m}(h(x^i),y^i)^2\\h(x)=f(xW+b)</script><p>这里的$f$表示激活函数，可以是Sigmoid，Tanh，ReLU</p><p><img src="/2020/06/19/百面机器学习概述/BP1.jpg" alt=""></p><p><img src="/2020/06/19/百面机器学习概述/BP2.jpg" alt=""></p><p><strong>不同激活函数的导数</strong></p><p><img src="/2020/06/19/百面机器学习概述/BP3.jpg" alt=""></p><h3><span id="314-l1正则和l2正则">3.1.4. L1正则和L2正则</span></h3><p>正则就是给参数添加限制，缩小参数的解空间，降低结构风险。<br>L1正则和L2正则都是为了避免过拟合设计的。使用L1正则化的叫做Lasso回归，使用L2正则化的叫做岭回归。<br>这两种回归为了<strong>解决线性回归出现过拟合</strong>的问题。通过<strong>在损失函数中引入正则化项</strong>来解决</p><ul><li><p>Lasso回归损失函数<br> 添加L1正则项</p><script type="math/tex; mode=display">J(w)=\frac{1}{2m}\sum_{i=1}^{i=m}(h(x^i)-y^i)^2+\lambda\sum_{j=1}^{j=n}|w_j|</script></li><li><p>岭回归损失函数<br> 添加L2正则项</p><script type="math/tex; mode=display">J(w)=\frac{1}{2m}\sum_{i=1}^{i=m}(h(x^i)-y^i)^2+\lambda\sum_{j=1}^{j=n}w_j^2</script></li></ul><p>我们从梯度下降的角度分析下为什么加入正则化可以避免过拟合。下面以L2正则化为例。L2正则化的梯度下降公式为</p><script type="math/tex; mode=display">w_j = w_j - \alpha * \frac{1}{m}\sum_{i=1}^{i=m}(h(x^i)-y^i)x^i_j-2\lambda w_j</script><p>当惩罚项越大，即$\lambda$越大时，更新后得到的$w_j$也就越小，模型复杂度变小，模型更简单。</p><p>下面以线性回归为例，模型只包含2个参数。下面等高线图表示$w_1,w_2$和损失的关系。当$w_1,w_2$取值为图像中最里面紫色圆圈上的点时，损失最小。</p><p><img src="/2020/06/19/百面机器学习概述/L1_1.png" alt=""></p><p>当加上L1正则化后，目标函数图像为</p><p><img src="/2020/06/19/百面机器学习概述/L1_2.png" alt=""></p><p>原先损失函数的第一项就是等高线，L1正则化损失函数的第二项就是菱形上的点。图中的菱形函数为$\sum_{j=1}^{j=2}w_j=F$。我们现在求解的目标是不仅要让第一项小，即$w_1,w_2$的值靠近紫色的圆圈，还要让第二项小，即$|w_1|+|w_2|=F$小，即$F$比较小。如下图所示，如果让菱形靠近紫色的圆圈，虽然损失函数第一项小了，但是第二项会变大。因此我们要取到一个恰好的值，让第一项的值+第二项的值最小。<br>我们发现对于同一个等高线来说，即损失函数的第一项相同，当菱形和等高线相切（只有一个交点）时，菱形的边长最小，即$w_1+w_2$最小，也就是相加得到的损失最小。</p><p>由上面的说明可以看出，L1正则化后的解一定是某个菱形和某个等高线的切点。经过观察发现，对于图中的每条等高线，与这个等高线相切的菱形的切点一般出现在坐标轴上(x轴或y轴)，例如上面的解为$(0,y)$，这也是说L1正则化更容易得到稀疏解(解向量中0比较多)的原因。</p><p><img src="/2020/06/19/百面机器学习概述/L1_3.png" alt=""></p><p>当加入L2正则化后，目标函数图像为</p><p><img src="/2020/06/19/百面机器学习概述/L2.png" alt=""></p><p>菱形变成了圆，同样求等高线和圆的切点作为最终的解。与L1正则化相比，切点不容易出现在坐标轴上，然后仍然比较靠近坐标轴。因此L2正则化得到的解比较小（靠近0），但是比较平滑（不等于0）。所以通过添加L2正则化向，模型不会得到特别大的权重，偏向于学习比较小的权重。因此L2正则化又叫做权重衰减。</p><p><strong>总结</strong></p><p>L1正则化使权重稀疏，L2正则化使权重平滑。</p><ul><li>L1正则化趋向于使用更少的特征，没用的特征权重为0，</li><li>L2正则化趋向于使用更多的特征，但这些特征的权重都接近0。这样可以避免模型严重依赖与其中的少数特征，而是倾向于使用所有的特征。</li><li>如果不是进行特征选择，最常用L2正则化。</li></ul><p>问题：</p><ol><li>什么时候用L1正则化，什么时候用L2正则化？<br>如果想让参数变得稀疏，即很多参数都为0，意味着模型使用的特征没有那么多，就用L1正则。<br>如果想用所有的特征，同时特征的参数又不这么大，用L2正则。</li><li>L1正则中实现参数稀疏有什么好处？<br>参数稀疏，说明有些参数为0，这样就可以实现特征的选择，参数为0的那些特征不会参与到模型计算中。一般而言，大部分特征对模型是没有贡献的，有些无用的特征虽然可以减少训练集的误差，但是在测试集上，反而会产生干扰。通过引入稀疏参数，可以将无用特征的权重设置为0.</li><li>L2正则中为什么参数越小表示模型越简单<br>越是复杂的模型，越想要对训练集中所有的点都要拟合，包括异常点，这就会造成在较小的区间中产生较大的波动，这个较大的波动也会反映在这个区间的导数比较大。而只有较大的参数才会有较大的导数，因此参数越小，模型越简单。</li></ol><h3><span id="315-面试问题">3.1.5. 面试问题</span></h3><p><strong>1. 简单介绍以下线性回归</strong></p><ul><li>线性：输入x和输出y的关系是线性的，即图像是直线</li><li>非线性：输入x和输出y的关系不是一次函数，图像不是直线</li><li>线性回归就是利用已有的样本，通过监督学习，学习由x到y的映射，然后利用学到的映射函数对未知的x进行预测。由于预测的值是连续值，所以是回归问题。</li></ul><p><strong>2. 线性回归的损失函数</strong></p><script type="math/tex; mode=display">J(w)=\frac{1}{2m}\sum_{i=1}^{i=m}(h(x^i)-y^i)^2</script><ol><li><p>简述岭回归和Lasso回归<br>这两种回归为了<strong>解决线性回归出现过拟合</strong>的问题。通过<strong>在损失函数中引入正则化项</strong>来解决</p><ul><li>Lasso回归损失函数<br>添加L1正则项<script type="math/tex; mode=display">J(w)=\frac{1}{2m}\sum_{i=1}^{i=m}(h(x^i)-y^i)^2+\lambda\sum_{j=1}^{j=n}|w_j|</script></li><li>岭回归损失函数<br>添加L2正则项<script type="math/tex; mode=display">J(w)=\frac{1}{2m}\sum_{i=1}^{i=m}(h(x^i)-y^i)^2+\lambda\sum_{j=1}^{j=n}w_j^2</script></li></ul></li></ol><p><strong>4. 线性回归的假设</strong><br>   线性回归假设因变量y符合正态分布   </p><h2><span id="32-逻辑回归">3.2. 逻辑回归</span></h2><p>逻辑回归是分类模型，虽然名字中有回归二字，但却是分类模型，用来二分类任务。<br>二分类的y有正负样本，即$y\in{(0,1)}$，$y$只有2个取值，一般将我们想要找的样本作为正样本。例如垃圾邮件分类中，想要找垃圾邮件，所以将垃圾邮件划分为正样本，非垃圾邮件为负样本。肿瘤良性判断中将恶性肿瘤设置为正样本，良性肿瘤设置为负样本。</p><ul><li><p>如何用连续的数组预测离散的y</p><p>线性回归输出的是连续值，而分类问题的标签y是离散值，属于{0,1}。怎么用回归模型预测离散的标签呢？<br>一个直观的办法是设定一个阈值，比如0，如果预测的值&gt;0，则属于正样本，否则属于负样本。<br>另一种方法是不去直接预测标签，而是预测样本属于正样本的概率。概率是连续值，并且在[0,1]之间。但是回归问题的输出值并不是在[0,1]之间，为了限制回归问题的值域，使用sigmoid函数，又成为logistic函数。因为sigmoid函数可以将输入$x\in[-\infty,\infty]$映射到$[0,1]$之间，输出的$h(x)$正好可以作为样本属于正例的概率。这种方法成为<strong>逻辑回归模型=logistic函数+回归模型</strong></p></li></ul><h3><span id="321-逻辑回归推导">3.2.1. 逻辑回归推导</span></h3><p>sigmoid函数：</p><script type="math/tex; mode=display">g(x)=\frac{1}{1+e^{-x}}</script><p><img src="/2020/06/19/百面机器学习概述/sigmoid.png" alt=""></p><p>输出值在<code>0~1</code>之间。原先的回归问题的假设函数简化为$h(x)=w^Tx$，为了让$h(x)$的输出在0~1之间，在外面套上sigmoid函数。</p><script type="math/tex; mode=display">h(x)=\frac{1}{1+e^{-w^{T}x}}</script><p>求得的$h(x)$表示样本$x$被判为正样本的概率，例如$h(x)=0.7$表示邮件是垃圾邮件的概率是0.7。因为真实标签值$y$只能为0和1，所以需要将$h(x)$和$y$对应起来。<br>如果$h(x)&gt;=0.5$，也就是$w^Tx&gt;=0$，则预测$y=1$<br>如果$h(x)&lt;0.5$，也就是$w^Tx&lt;0$，则预测$y=0$</p><ul><li>逻辑回归损失函数</li></ul><p><img src="/2020/06/19/百面机器学习概述/logistic.png" alt=""></p><ol><li><p>求单个样本预测正确的概率<br>$h(x)$表示样本为正例$(y=1)$的概率$P(y=1|x,w)=h(x)$<br>则样本为负例的概率为$P(y=0|x,w)=1-h(x)$</p></li><li><p>将上述公式整合</p><script type="math/tex; mode=display">P(y \mid {x})=\left\{\begin{array}{r}h(x), y=1 \\1-h(x), y=0\end{array}\right.</script><p>将上述2种情况整合成一个公式为</p><script type="math/tex; mode=display">P(y^i|x^i)=h(x^i)^{y_i}*(1-h(x^i))^{1-y^i}</script><p>对于样本$(x^i,y^i)$，如果$y^i=1$，则概率为$h(x^i)$，如果$y^i=0$，则概率为$1-h(x^i)$</p></li><li><p>求$m$个样本的似然函数</p><blockquote><p>极大似然估计：利用已知的样本结果，反推最有可能（最大概率）导致这些样本结果出现的模型参数，即在模型已知的情况下，求参数。</p></blockquote><p>如果有$m$个样本，分别为$(x^1,y^1),(x^2,y^2),…,(x^m,y^m)$，这m个样本假设相互独立，组合概率为每个样本概率的乘积，即最大似然估计为：</p><script type="math/tex; mode=display">P_总=P(y^1|x^1)P(y^2|x^2)...P(y^m|x^m)=\prod_{i=1}^{i=m}h(x^i)^{y_i}*(1-h(x^i))^{1-y^i}</script><p>其中<script type="math/tex">h(x)=\frac{1}{1+e^{-w^Tx}}</script></p></li><li><p>求对数似然<br>模型需要做的就是该概率最大，即连乘的乘积最大，但是连乘很复杂，通过<strong>对两边取对数将连乘变成累加的形式</strong></p></li></ol><script type="math/tex; mode=display">\begin{array}{l}log(P_总)=log(\prod_{i=1}^{i=m}h(x^i)^{y_i}*(1-h(x^i))^{1-y^i})\\   =\sum_{i=1}^{i=m}log(h(x^i)^{y_i}*(1-h(x^i))^{1-y^i})\\=\sum_{i=1}^{i=m}(y^ilog(h(x^i))+(1-y^i)log(1-h(x^i)))\end{array}</script><ol><li><p>求逻辑回归损失函数<br>上面的最大化$P_总$其实是我们的目标函数，但是如果在最大化目标函数时，对参数$w$进行求导时，非常复杂，所以就先取对数，将连乘换成累加。然后为了迎合一般都是最小化损失函数，所以加上一个符号。<br>模型最好的效果是让$log(P_总)$越大越好，但是损失函数却是越小越好，所以我们将其取负数作为损失函数，应为损失函数求的是平均误差，所以需要除以样本个数$m$,即逻辑回归的损失函数为交叉熵损失函数</p><script type="math/tex; mode=display">Loss(w)=-\frac{1}{m}\sum_{i=1}^{i=m}(y^ilog(h(x^i))+(1-y^i)log(1-h(x^i)))</script><ul><li><p>为什么可以用似然函数<br>因为逻辑回归的目标是让预测为正的概率最大，且预测为负的概率最大，即每个样本都要保证得到最大的概率，将所有样本预测后的概率相乘就最大，即得到似然函数。</p></li><li><p>为什么损失函数要取对数</p><ul><li>线性回归模型的平方损失函数对sigmoid函数求导无法保证是凸函数，在优化求$w$的过程中，求得的解有可能是局部最优，而不是全局最优</li><li>取对数后，方便后续的求导</li></ul></li></ul></li></ol><ul><li><p>梯度下降</p><p>首先先看sigmoid的导数</p><script type="math/tex; mode=display">g(x)=\frac{1}{1+e^{-x}}</script><p><img src="/2020/06/19/百面机器学习概述/sigmoid.jpg" alt=""></p><p><img src="/2020/06/19/百面机器学习概述/sigmoid1.jpg" alt=""></p><p>得到导数之后，更新参数$w_j$<br><img src="/2020/06/19/百面机器学习概述/sigmoid2.jpg" alt=""></p><ol><li>梯度下降公式中的$m$如果是样本总数，则每次更新参数时需要考虑所有的样本，称为批量梯度下降(BGD)。这种方法容易求得全局最优解，但是由于样本个数太多，训练过程非常慢。</li><li>如果$m=1$，即每次更新参数时只考虑一个样本，称为随机梯度下降(SGD)。这种方法训练速度快，但是准确率下降，并不是全局最优。</li><li>综上所述，当m为所有样本的一小部分时，比如m=32，即每次更新参数时只考虑一小部分样本，称为小批量梯度下降(MBGD)。它克服了上述两种方法的缺点又兼顾它们的优点，在实际中最常使用。</li></ol></li></ul><h3><span id="322-逻辑回归常见问题">3.2.2. 逻辑回归常见问题</span></h3><p><strong>1. 用一句话概括逻辑回归</strong><br>   逻辑回归假设数据服从伯努利分布，通过极大化似然函数，使用梯度下降求解参数，达到二分类的目的。</p><p><strong>2. 逻辑回归的目的</strong><br>   进行二分类<br>   逻辑回归作为回归，输出值是连续的，怎么应用在分类上呢？这里的y确实是一个连续的值，但是它的输出值在[0,1]之间，可以选定一个阈值来进行划分，如果输出值大于0.5，则判定为正样本，否则判定为负样本。</p><p><strong>3. 逻辑回归的基本假设</strong></p><ul><li><p>逻辑回归假设数据服从伯努利分布。伯努利分布就是抛硬币，正面的概率为$p$，反面的概率为$1-p$<br>在逻辑回归中，样本被判定为正例的概率为$h(x)$，则被判为负例的概率为$1-h(x)$</p></li><li><p>第二个假设是样本为正的概率是</p><script type="math/tex; mode=display">p=\frac{1}{1+e^{-w^Tx}}</script></li></ul><p><strong>4. 逻辑回归的损失函数</strong><br>   逻辑回归的损失函数是它的极大对数似然函数的相反数</p><script type="math/tex; mode=display">Loss(w)=-\frac{1}{m}\sum_{i=1}^{i=m}(y^ilog(h(x^i))+(1-y^i)log(1-h(x^i)))</script><p><strong>5. 随机梯度下降、批量梯度下降、小批量梯度下降的优缺点</strong></p><ul><li>梯度下降公式中的$m$如果是样本总数，则每次更新参数时需要考虑所有的样本，称为批量梯度下降(BGD)。这种方法容易求得全局最优解，但是由于样本个数太多，训练过程非常慢。</li><li>如果$m=1$，即每次更新参数时只考虑一个样本，称为随机梯度下降(SGD)。这种方法训练速度快，但是准确率下降，并不是全局最优。</li><li>综上所述，当m为所有样本的一小部分时，比如m=32，即每次更新参数时只考虑一小部分样本，称为小批量梯度下降(MBGD)。它克服了上述两种方法的缺点又兼顾它们的优点，在实际中最常使用。</li></ul><p><strong>6. 逻辑回归的优缺点</strong><br>   优点：</p><ul><li>形式简单，模型可解释性好。模型的权重$w$表示不同特征对最终结果的影响，如果$w_j$大，说明第$j$个特征的权重比较高，对最终的结果影响较大</li><li>模型效果不错。在工程上可以接受，如果特征工作做的好，效果不会太差。</li><li>训练速度快。在分类时，计算两仅仅和特征的数目有关</li><li>资源占用小，尤其是内存。因为只需要存储各个维度的特征值</li><li><p>方便输出结果。逻辑回归可以很方便的得到最后的分类结果，因为输出的结果表示每个样本属于正例的概率，可以很容易的对概率进行划分阈值。<br>缺点</p></li><li><p>准确率不是很高，因为形式简单</p></li><li>很难处理不平衡的数据。距离：如果正负样本比例1:1000，则将所有的样本都预测为负样本，模型的损失值就很小，但是这样的模型对于正样本的召回率并不高</li><li>处理非线性数据较麻烦。逻辑回归一般只处理线性可分的数据，一般用于二分类</li><li>无法筛选特征，需要提前做特征工程。</li></ul><p><strong>7. 逻辑回归的输出是真实概率吗</strong><br>  如果数据满足以上的2个假设，则输出的数据表示样本属于正例的概率。但是这2个假设并不是那么容易满足，所以很多情况下，逻辑回归的输出值无法作为真实的概率，只能看做置信度。</p><p><strong>8. 使用逻辑回归怎么进行多分类</strong><br>  可以将多分类问题转换成二分类问题</p><p><strong>9. 逻辑回归和线性回归的区别</strong></p><ol><li>线性回归阈值$[-\infty,\infty]$,逻辑回归的阈值$[0,1]$</li><li>拟合函数不同，线性回归$h(x)=w^Tx$，逻辑回归$h(x)=\frac{1}{1+e^{-w^Tx}}$</li><li>损失函数形式不同。线性回归是最小二乘法（平方损失），逻辑回归是极大似然估计</li></ol><p><strong>10. 逻辑回归是分类问题，为什么叫回归？逻辑回归也叫做“对数几率回归”，这里的“对数几率”如何理解？</strong><br>  逻辑回归的前面部分和线性回归一样，都是$W^Tx+b$，只是最后输出层加了sigmoid函数，将输出转换到[0,1]之间，所以逻辑回归的可以写成</p><p>  $y=\frac{1}{1+e^{-z}}$<br>  $z=W^Tx+b$</p><p>  上式可以转换成</p><script type="math/tex; mode=display">ln\frac{y}{1-y}=W^Tx+b</script><p>  $y$表示样本属于正例的概率，$1-y$表示样本属于负例的概率，而两者的比$\frac{y}{1-y}$称为“几率”，取对数$ln\frac{y}{1-y}$叫做“对数几率”。<br>  由此可以式子$y=\frac{1}{1+e^{-W^Tx+b}}$是在用线性回归模型的预测结果$W^Tx+b$去逼近真实的对数几率，因此也叫做“对数几率回归”</p><p><strong>11.  分类为什么不用平方损失MSE</strong></p><ol><li><p>因为在逻辑回归中，输出层使用的sigmoid激活函数，如果使用MSE作为损失函数，权重和损失函数的的曲线是非凸的，有很多局部最优点。</p><p><img src="/2020/06/19/百面机器学习概述/逻辑回归.jpg" alt=""> </p></li><li><p>在分类问题中，例如样本的真实标签是第3类，我们预测出来的值不需要知道对于每类的预测概率，比如预测出属于第三类的概率为0.6，那另外2类的概率为多少我们并不在意，我们只需要让第三类的预测值大于另外2类就可以了。如果用MSE损失就太严格了</p></li></ol><h2><span id="33-softmax回归">3.3. Softmax回归</span></h2><p>逻辑回归用来解决二分类问题，softmax回归用来解决多分类问题。</p><p>假设对一个2*2的图像进行分类，判断图像是狗、猫、鸡的哪一种。即输入x有4个特征$x_1,x_2,x_3,x_4$，真实标签$y=1,2,3$。</p><p>softmax回归和线性回归一样，也是一个单层全连接层。输入有4个，输出有3个，所以参数有12个。</p><p><img src="/2020/06/19/百面机器学习概述/softmax.png" alt=""></p><p>像上面的线性回归，输出的y值是连续的，我们可以把输出的y值看做样本属于某一类值置信度。例如$o_1=o_3=10,o_2=1000$，则图片被预测为猫。但是由于输出的值不稳定，并且连续的预测值和真实的离散值误差难以衡量。<br>为了解决这个问题，这里用到softmax运算。softmax将原先输出的连续值$o$转换为概率。</p><p><img src="/2020/06/19/百面机器学习概述/softmax1.png" alt=""></p><p>最终softmax回归模型函数为</p><p>$o^i=W^Tx+b$<br>$y^i=softmax(o^i)$</p><p>逻辑回归和softmax回归的不同</p><ol><li>逻辑回归最后的输出层只有1个神经元，输出的结果表示样本属于正例的概率。softmax回归最后的输出层有n个神经元(n为类别数)，输出样本属于每个类别的概率。即sigmoid输出的是一个数，softmax输出的是一个向量。</li><li>逻辑回归最后输出用sigmoid将连续值转换为属于正例的概率。softmax回归最后输出用softmax将连续值转换为属于各类的概率。都是将连续值转换为概率。</li></ol><ul><li>softmax回归是逻辑回归在多分类的拓展</li></ul><p><img src="/2020/06/19/百面机器学习概述/softmax.jpg" alt=""></p><ul><li><p>逻辑回归怎么用来解决多分类问题<br>将多分类问题拆分成多个二分类问题。具体怎么拆分有3种方法：</p><ol><li>一对一。假设多分类中一共有k类，则将任意2类进行组合，一共形成k(k-1)/2个组合。将一个样本输入到这k(k-1)/2个分类器中，得到k(k-1)/2个分类结果，然后取个数最多的类别作为这个样本最终预测类别</li></ol><p><img src="/2020/06/19/百面机器学习概述/多分类1.png" alt=""> </p><ol><li>一对多。假设多分类中共有k类，一共形成k个分类器，第一个分类器将k1作为正例，其余类作为负例。第二个分类器将k2作为正例，其余类作为负例，以此类推。一个样本输入到这k个分类器中，输出k个分类结果，如果只有一个正例，则该样本属于这个类，如果输出多个正例，则看置信度。</li></ol><p><img src="/2020/06/19/百面机器学习概述/多分类2.png" alt=""></p><ol><li>多对多。每次将多个类作为正例，多个类作为负例。</li></ol></li></ul><p>  <img src="/2020/06/19/百面机器学习概述/多分类.png" alt=""></p><ul><li><p>如果一个样本有多个类别标签，怎么办？</p><p>这就不是一个多分类问题了，而是多标签学习。假设一共有k类，训练k个分类器。第$i$个分类器判断每个样本是否归为第$i$类。训练分类器时，需要将标签重新整理为属于第$i$类和不属于第$i$类。</p></li></ul><h2><span id="34-回归和分类总结">3.4. 回归和分类总结</span></h2><p><img src="/2020/06/19/百面机器学习概述/前向1.png" alt=""></p><p>回归问题和分类问题在前半部分都是一样的，输入$X$乘以权重$W$，然后再经过激活函数$f$，堆叠多层，得到输出$out$</p><p>回归问题和分类问题只是最后的输出层不一样。回归问题经过前面的堆叠得到最后的输出$y$</p><p>分类问题（多分类）还需要将$y$经过一个softmax层，将输出值归一化到[0,1]之间，且和为1。</p><p><img src="/2020/06/19/百面机器学习概述/前向2.png" alt=""></p><h2><span id="35-数据不平衡问题">3.5. 数据不平衡问题</span></h2><p>在分类问题中可能会遇到类别不平衡问题。例如1000个样本中，2个正例，998个负例。这样模型在预测值偏向于将样本预测为负例，但是在实际中却没有价值，因为它检测不到正例。</p><p>解决正负样本不均衡问题，有以下3个方法</p><ol><li><p>欠采样<br>对负样本进行负采样，使得正负样本均衡。欠采样需要丢弃一些负样本，但也不能随意丢弃，否则会丢失一些重要信息。代表算法为EasyEnsemble利用集成学习，将负样本划分为若干个集合进行训练，这样每个模型的数据都进行了欠采样。</p><p>欠采样方法有：<br>(1) Easy Ensemble算法：每次从样本多的那个类别中抽出一个子集E，子集E的样本个数等于少数类别的样本数，然后让E和少数样本训练得到一个分类器。多次抽取形成不同的子集E，就会训练得到不同的分类器，给定一个测试样本，测试样本的分类结果是多个分类器结果的融合。</p></li><li><p>过采样<br>生成一些正样本，使得正负样本均衡。但是过采样不能将原先的正样本复制n份，这样会造成严重的过拟合。过采样代表算法为SMOTE通过对训练集中的正样本进行插值生成一些正样本。<br>SMOTE算法对少数类别的样本点x，选择同类别的k个邻居，然后这K个邻居中随机选择1个邻居y，然后在x和y的连线上随机选择1个点作为新生成的样本。</p><p><img src="/2020/06/19/百面机器学习概述/smote.png" alt=""></p></li></ol><ol><li><p>调整阈值<br>在逻辑回归中，我们通常将$h(x)&gt;0.5$判定为正例，否则为负例。这说明正例和负例出现的可能性相同。但是如果正负样本不平衡，正样本出现非常小，可能阈值就需要变小。假设正样本:负样本=2:10，则将阈值变成0.2，例$h(x)&gt;0.2$我们就判定为正例，否则为负例。</p></li><li><p>转换问题角度<br>当样本数目极其不平衡时，可以将问题转化为单类学习，异常检测等问题。</p></li></ol><h3><span id="351-smote算法">3.5.1. SMOTE算法</span></h3><p>SMOTE是一种合成少数类过采样技术。SMOTE算法的基本思想是对少数样本进行分析和模拟，并将人工模拟的新样本添加到数据集中，该算法的模型过程采用KNN技术，步骤如下：</p><ol><li>对每个少数样本x，计算x到其他少数样本的欧式距离，为x找到K个最近邻居</li><li><p>从K个近邻中随机挑选1个样本，在x和这1个样本之间的连线上，线性差值生成新样本。</p><script type="math/tex; mode=display">x_{\text {new}}=x+\operatorname{rand}(0,1) \times(\tilde{x}-x)</script></li><li><p>重复步骤2进行N次，则少数样本数变成原来的N倍</p></li></ol><h2><span id="36-svm">3.6. SVM</span></h2><p>SVM用来做二分类，主要分为三部分</p><ol><li>数据线性可分：最优划分超平面/硬间隔SVM/线性可分SVM</li><li>数据近似线性可分：软间隔SVM/近似线性可分SVM</li><li>数据线性不可分：核方法</li></ol><h3><span id="361-线性可分svm">3.6.1. 线性可分SVM</span></h3><p>SVM就是解决二分类问题，分类学习最基本的想法就是找到一个划分超平面，将不同类别的数据集分开。目的就是找到一个最优的分割线将两类分开。</p><p>分类问题有线性可分和线性不可分。线性可分就是在二维空间中能找到一条直线将2类样本划分开。线性不可分就是不能找到一条直线。对于线性不可分的样本通常是通过高斯核函数将样本映射到高维空间，然后转换为高维空间线性可分的问题。<br>下图中的直线都可以将2类样本分开，但是哪个才是好的分割线呢？分类器的价值不在于它多么擅长分割训练样本，而是对于哪些未知的样本它的分类效果怎么样。下图中中间较粗的那条线，在正确划分训练样本的前提下，尽可能地同时远离两个聚类。而其他的线都是有些“倾斜”，一头远离一类，另一头靠近另一类。</p><p><img src="/2020/06/19/百面机器学习概述/SVM1.png" alt=""></p><p>假设划分超平面的公式为</p><script type="math/tex; mode=display">w^Tx+b=0</script><p>这就是我们初中学的直线公式$ax+b=0$</p><p>理想中超平面进行划分时，如果结果大于0就划分为正例，否则划分为负例。下面就是逻辑回归的划分方式：</p><script type="math/tex; mode=display">\left\{\begin{array}{ll}\omega^{T} x_{i}+b>0, & y_{i}=+1 \\\omega^{T} x_{i}+b<0, & y_{i}=-1\end{array}\right.</script><p>而SVM是逻辑回归的强化，SVM设置更严格的划分条件，变成：</p><script type="math/tex; mode=display">\left\{\begin{array}{l}w^{T} x+b \geq 1 \quad y=1 \\w^{T} x+b \leq-1 \quad y=-1\end{array}\right.</script><p>上面我们简单的介绍下SVM和逻辑回归的不同，下面我们将详细介绍SVM</p><p>假设SVM中的分割超平面为<script type="math/tex">w^Tx+b=0</script></p><p>$w=(w_1,w_2,…w_d)$是有个列向量，拆分开就是$w_1x_1+w_2x_2+…+w_dx_d+b=0$</p><p>超平面有以下几个性质</p><p><strong>性质1</strong>：等比例缩放$w,b$，超平面不变，仍然是同一条直线或超平面<br><strong>性质2</strong>：点$x=(x_1,x_2,…,x_d)$到超平面的距离为</p><script type="math/tex; mode=display">\frac{|w_1x_1+w_2x_2+...+w_dx_d+b|}{\sqrt{w_1^2+w_2^2+...+w_d^2}}=\frac{|w^Tx+b|}{||w||}</script><p>下面介绍2个概念：<strong>函数间隔、几何间隔</strong></p><blockquote><p>二维平面中点$(x,y)$到$AX+By+c=0$的距离为$\frac{|Ax+By+c|}{\sqrt{A^2+B^2}}$</p></blockquote><p>  <strong>超平面</strong>：$w^Tx+b=0$<br>  <strong>函数间隔</strong>：$\hat{\gamma}=y(w^Tx+b)=yf(x)=|f(x)|$<br>  函数间隔就是标签$y$乘上$f(x)$的值，函数间隔永远为正。但是由于SVM中$y$的取值只能为1和-1，所以函数间隔的值就是$|f(x)|$<br>  几何间隔表示点到超平面的距离，在SVM中点到超平面的距离为$\frac{|w^Tx+b|}{||w||}=\frac{|f(x)|}{||w||}=\frac{\hat{\gamma}}{||w||}$<br>  <strong>几何间隔</strong>：$\gamma=\frac{|w^Tx+b|}{||w||}=\frac{y(w^Tx+b)}{||w||}=\frac{\hat{\gamma}}{||w||}$</p><p>  函数间隔$y(w^Tx+b)$可以表示分类预测的准确性和置信度，值越大越好，说明模型将样本分正确的概率越大，但函数间隔并不表示点到超平面的距离，因为假如将$w,b$成比例变成$2w,2b$，超平面的位置没有变，但是$f(x)$却变成原来的2倍，即函数间隔变成原来的2倍。在实际中，定义点到直线的距离时，用的是几何间隔。$w,b$成倍数增加时，几何间隔不变。函数间隔是几何间隔没有除以$||w||$的表示，几何间隔是函数间隔归一化的结果。函数间隔是我们自己定义的，而几何间隔是客观存在的，无论$w,b$扩大几倍，对几何间隔没有影响。</p><p><strong>SVM的目标</strong></p><p>SVM的目标是找到一个最优的划分超平面。那怎么定义最优呢？在SVM中评价指标就是几何间隔。在下图中，我们直观的感觉图a的分类效果比b和c好，因为在图a中，与分割线最近的样本点相比b和c来说，这个样本点距离分割线最远。SVM正是遵循这一思想，在众多分割超平面中，找样本点（超平面附近的点）与分割超平面距离最大的那个超平面，即最小几何间隔中，最大的那个。</p><p><img src="/2020/06/19/百面机器学习概述/SVM3.png" alt=""></p><p>SVM的最佳划分超平面需要满足2个条件：（1）能够将所有的正负样本划分正确，即函数间隔大于0，（2）离超平面最近的样本点与超平面的几何距离最大</p><p>第一个条件公式为$\hat{\gamma}=y(w^Tx+b)&gt;0$<br>第二个条件为首先找到最近的样本点，即最小的函数间距，然后再最大化函数间距。</p><script type="math/tex; mode=display">\begin{array}{l}\min\tilde{\gamma}^{i}=\min \frac{y^{i}\left(w^{T} \mathbf{x}^{i}+b\right)}{\| w \mid}=\frac{1}{\|w\|} \min y^{i}\left(w^{T} \mathbf{x}^{i}+b\right), i=1,2, \ldots, m \\\max _{w, b} \frac{1}{\|w\|} \min y^{i}\left(w^{T} \mathbf{x}^{i}+b\right), i=1,2, \ldots, m\end{array}</script><p>结合上面的2个条件，求解最优划分超平面的公式为</p><script type="math/tex; mode=display">\begin{aligned}\max _{w, b} \frac{1}{\|w\|} \min y^{i}\left(w^{T} \mathbf{x}^{i}+b\right), i=1,2, \ldots, m \\\text { subject to } y^{i}\left(w^{T} \mathbf{x}^{i}+b\right)>0\end{aligned}</script><p>但是上面这个目标函数太复杂了，需要对其进行简化。这里就需要用到超平面的性质1：对$w,b$进行缩放，超平面不变。如果在求解的过程中，继续保持这个性质的话，就算上面的公式可以求得最优的划分超平面，但是$w,b$的取值却有无数个，即解不唯一。但是我们要求一个固定的超平面，对应的$w,b$是唯一的，就需要添加限制条件。限制条件可以有多种选择：</p><p>选择1：限制$||w||=1$，即超平面的法向量模长为1，这样就消除了等比缩放的影响。但是添加了这个限制对上面公式的简化没有什么帮助<br>选择2：$miny^i(w^Tx^i+b)=1$，限制最小的函数间隔等于1，这也是SVM所采取的方式。如果$\hat{\gamma}=1$，假设将$w,b$放大为$kw,kb$，理论上来说缩放后的函数间隔$\hat{\gamma}_{i+1}=k\hat{\gamma}$，但是我们限制了函数间隔只能为1，即$\hat{\gamma}_{i+1}=\hat{\gamma}=1$，那$k$也只能为1，即不存在等比缩放的问题。</p><blockquote><p>注意：SVM中将$miny^i(w^Tx^i+b)=1$，其实将值限制为2,3,4…，限制为多少都没关系，都可以消除等比缩放带来的影响，但是不可以不限制。</p></blockquote><p>有了这个限制条件，原先的目标就需要变了</p><p><strong>原先的目标函数</strong>：</p><script type="math/tex; mode=display">\begin{aligned}\max _{w, b} \frac{1}{\|w\|} \min y^{i}\left(w^{T} \mathbf{x}^{i}+b\right), i=1,2, \ldots, m \\\text { subject to } y^{i}\left(w^{T} \mathbf{x}^{i}+b\right)>0\end{aligned}</script><p>增加了$min y^i(w^Tx^i+b)=1$的限制，也就是说$y^i(w^Tx^i+b)&gt;=1$，第一个限制条件变成$\max _{w, b} \frac{1}{|w|}$，最大化$\frac{1}{||w||}$其实就是最小化$||w||$，也就是$min \frac{1}{2}||w||^2$，</p><p><strong>最终SVM的目标函数</strong></p><script type="math/tex; mode=display">\begin{aligned}\min _{w, b} \frac{1}{2}||w||^2 , i=1,2, \ldots, m \\\text { subject to } y^{i}\left(w^{T} \mathbf{x}^{i}+b\right)>=1\end{aligned}</script><p>于是我们得到了3个平面：最优划分超平面$w^Tx+b=0$，与划分超平面间隔平行的2个超平面$w^Tx+b=1$和$w^Tx+b=-1$</p><p><img src="/2020/06/19/百面机器学习概述/SVM2.png" alt=""></p><p>这是一个凸二次规划的问题，对于一个优化问题，通常可以从2个角度考虑：主问题和对偶问题。常常利用拉格朗日对偶性将主问题转换为对偶问题，通过求解对偶问题的解来得到原始问题的解，这是因为对偶问题的复杂度往往低于原始问题。</p><blockquote><p>拉格朗日乘子法知识点<br>拉格朗日乘子法将原问题转换为对偶问题进行求解，主问题有等式约束和不等式约束<br>主问题：</p><script type="math/tex; mode=display">\begin{array}{c}\min _{x} f(x)\\s . t . h_{i}(x)=0(i=1, \ldots, m)\\g_{j}(x) \leq 0(j=1, \ldots, n)\end{array}</script><p>拉格朗日函数为</p><script type="math/tex; mode=display">L(x, \lambda, \mu)=f(x)+\sum_{i=1}^{m} \lambda_{i} h_{i}(x)+\sum_{j=1}^{n} \mu_{j} g_{j}(x)</script><p>由不等式约束引入的KKT条件</p><script type="math/tex; mode=display">\left\{\begin{array}{l}g_{j}(x) \leq 0 \\\mu_{j} \geq 0 \\\mu_{j} g_{j}(x)=0\end{array}\right.</script><p>其中$\lambda=\left(\lambda_{1}, \lambda_{2}, \ldots, \lambda_{m}\right)^{T} \text { 和 } \mu=\left(\mu_{1}, \mu_{2}, \ldots, \mu_{n}\right)^{T}$是拉格朗日乘子</p></blockquote><p>根据上面的知识，我们得到<strong>SVM的拉格朗日函数</strong></p><p>[<br>L(\omega, b, \alpha)=\frac{1}{2}|\omega|^{2}+\sum_{i=1}^{m} \alpha_{i}\left(1-y_{i}\left(\omega^{T} x_{i}+b\right)\right)<br>]</p><script type="math/tex; mode=display">L(w, b, \alpha)=\frac{1}{2}\|w\|^{2}-\sum_{i=1}^{m} \alpha_{i} y_{i}\left(\omega^{T} x_{i}+b\right)+\sum_{i=1}^{N} \alpha_{i}</script><p>其中 $\alpha=\left(\alpha_{1} ; \alpha_{2} ; \ldots ; \alpha_{m}\right)$,拉格朗日乘子 $\alpha_{i} \geq 0$</p><p>一个优化问题可以从两个角度考虑：主问题和对偶问题。在约束最优化问题中，常常利用拉格朗日对偶性将原问题转化为对偶问题，通过对偶问题来得到原始问题的解。<br>根据拉格朗日对偶性，原始问题的对偶问题是极大极小问题：</p><script type="math/tex; mode=display">\max _{\alpha} \min _{w, b} L(w, b, \alpha)</script><p>所以为了求得对偶问题的解，需要先求$L(w,b,\alpha)$对$w,b$的极小，再求对$\alpha$的极大。</p><p>（1）求$\min _{w, b} L(w, b, \alpha)$<br>将拉格朗日函数$L(w,b,\alpha)$分别对$w,b$求偏导，并令其为0</p><script type="math/tex; mode=display">\begin{array}{l}\nabla_{w} L(w, b, \alpha)=w-\sum_{i=1}^{m} \alpha_{i} y_{i} x_{i}=0 \\\nabla_{b} L(w, b, \alpha)=-\sum_{i=1}^{m} \alpha_{i} y_{i}=0\end{array}</script><p>得到：</p><script type="math/tex; mode=display">\begin{array}{l}w=\sum_{j=1}^{m} \alpha_{i} y_{i} x_{i} \\\sum_{i=1}^{m} \alpha_{i} y_{i}=0\end{array}</script><p>将求得$w$带入到拉格朗日函数中</p><script type="math/tex; mode=display">\begin{aligned}L(w, b, \alpha) &=\frac{1}{2} \sum_{i=1}^{m} \sum_{j=1}^{m} \alpha_{i} \alpha_{j} y_{i} y_{j}x_{i}^T x_{j}-\sum_{i=1}^{m} \alpha_{i} y_{i}\left(\left(\sum_{j=1}^{m} \alpha_{j} y_{j} x_{j}^T\right) x_{i}+b\right)+\sum_{i=1}^{m} \alpha_{i} \\&=\frac{1}{2} \sum_{i=1}^{m} \sum_{j=1}^{m} \alpha_{i} \alpha_{j} y_{i} y_{j}x_{i}^T x_{j}-\sum_{i=1}^{m} \sum_{j=1}^{m} \alpha_{i} \alpha_{j} y_{i} y_{j}x_{i}^T x_{j}-\sum_{i=1}^{m} \alpha_{i} y_{i}b+\sum_{i=1}^{m} \alpha_{i} \\&=-\frac{1}{2} \sum_{i=1}^{m} \sum_{j=1}^{m} \alpha_{i} \alpha_{j} y_{i} y_{j}\left(x_{i} \cdot x_{j}\right)+\sum_{i=1}^{m} \alpha_{i}\end{aligned}</script><p>即</p><script type="math/tex; mode=display">\min _{w, b} L(w, b, \alpha)=-\frac{1}{2} \sum_{i=1}^{m} \sum_{j=1}^{m} \alpha_{i} \alpha_{j} y_{i} y_{j}x_{i}^T x_{j}+\sum_{i=1}^{m} \alpha_{i}</script><p>（2）求$\min _{w, b} L(w, b, \alpha)$关于$\alpha$的极大，即是对偶问题</p><script type="math/tex; mode=display">\begin{array}{ll}\max _{\alpha} & -\frac{1}{2} \sum_{i=1}^{m} \sum_{j=1}^{m} \alpha_{i} \alpha_{j} y_{i} y_{j}x_{i}^T x_{j}+\sum_{i=1}^{m} \alpha_{i} \\\text { s.t. } & \sum_{i=1}^{m} \alpha_{i} y_{i}=0 \\& \alpha_{i} \geqslant 0, \quad i=1,2, \cdots, m\end{array}</script><p>将上面的求极大变成下面的求极小问题</p><script type="math/tex; mode=display">\begin{array}{ll}\min _{\alpha} & \frac{1}{2} \sum_{i=1}^{m} \sum_{j=1}^{m} \alpha_{i} \alpha_{j} y_{i} y_{j}x_{i}^T x_{j}-\sum_{i=1}^{m} \alpha_{i} \\\text { s.t. } & \sum_{i=1}^{m} \alpha_{i} y_{i}=0 \\& \alpha_{i} \geqslant 0, \quad i=1,2, \cdots, m\end{array}</script><p>最终求得的$w,b$只和支持向量有关。因此SVM的一个重要性质是：SVM训练完之后，大部分的训练样本不需要保留，最终模型只和支持向量有关。</p><h3><span id="362-近似线性svm">3.6.2. 近似线性SVM</span></h3><p>在实际应用中，完全线性可分是很少的，例如下图中，没有一条直线可以将2类完全分开。</p><p><img src="/2020/06/19/百面机器学习概述/SVM4.png" alt=""></p><p>于是就有了软间隔，与线性可分的硬间隔相比，条件没有那么苛刻，我们允许个别样本点出现在隔离带里面，例如下</p><p><img src="/2020/06/19/百面机器学习概述/SVM5.png" alt=""></p><p>硬间隔要求所有样本点都满足</p><script type="math/tex; mode=display">y^i(w^Tx^i+b)>=1</script><p>软间隔引入松弛变量，允许部分样本点满足</p><script type="math/tex; mode=display">y^i(w^Tx^i+b)+\xi_{i}>=1</script><p>当$\xi_{i}=0$时，样本分类正确<br>当0&lt;$\xi_{i}<1$时，样本分类正确 当$\xi_{i}="">=1$时，样本分类正确</1$时，样本分类正确></p><p>增加松弛变量后，SVM的目标变成：</p><script type="math/tex; mode=display">\begin{aligned}&\min _{w} \frac{1}{2}\|w\|^{2}+C \sum_{i=1}^{m} \xi_{i}\\&\text {s.t.} \quad y_{i}\left(w^{T} x_{i}+b\right)\geq 1-\xi_{i}, \quad \xi_{i} \geq 0, \quad i=1,2, \ldots, n\end{aligned}</script><p>松弛变量通过学习得到，且要惩罚大的松弛变量。<br>$C$是一个大于0的数，表示错误样本的惩罚程度，当$C$无穷大时，表示对错误样本的惩罚无穷大，不允许分错样本，这样$\xi_i$就无穷小，就是线性可分SVM。当$C$为有限值时，才会允许部分样本分错。</p><p>注意：在间隔内的那部分样本点是不是支持向量？是</p><p>上述原问题的拉格朗日函数是</p><script type="math/tex; mode=display">L(w, b, \xi, \alpha, \mu)=\frac{1}{2}\|w\|^{2}+C \sum_{i=1}^{m} \xi_{i}-\sum_{i=1}^{m} \alpha_{i}\left(y_{i}\left(w^T x_{i}+b\right)-1+\xi_{i}\right)-\sum_{i=1}^{m} \mu_{i} \xi_{i}</script><script type="math/tex; mode=display">\alpha_{i} \geqslant 0, \mu_{i} \geqslant 0</script><p>对偶问题是拉格朗日的极大极小问题，所以对偶问题为</p><script type="math/tex; mode=display">\max _{\alpha,\mu} \min _{w, b,\xi} L(w, b, \xi, \alpha, \mu)</script><p>（1）极小化$\min _{w, b,\xi} L(w, b, \xi, \alpha, \mu)$，对$w, b,\xi$求导使其为0</p><script type="math/tex; mode=display">\begin{array}{l}\nabla_{w} L(w, b, \xi, \alpha, \mu)=w-\sum_{i=1}^{m} \alpha_{i} y_{i} x_{i}=0 \\\nabla_{b} L(w, b, \xi, \alpha, \mu)=-\sum_{i=1}^{m} \alpha_{i} y_{i}=0 \\\nabla_{\xi_{i}} L(w, b, \xi, \alpha, \mu)=C-\alpha_{i}-\mu_{i}=0\end{array}</script><p>得到</p><script type="math/tex; mode=display">\begin{array}{c}w=\sum_{i=1}^{m} \alpha_{i} y_{i} x_{i} \\\sum_{i=1}^{m} \alpha_{i} y_{i}=0 \\C-\alpha_{i}-\mu_{i}=0\end{array}</script><p>将上述公式带入到拉格朗日函数中，得到</p><script type="math/tex; mode=display">\min _{w, b, \xi} L(w, b, \xi, \alpha, \mu)=-\frac{1}{2} \sum_{i=1}^{m} \sum_{j=1}^{m} \alpha_{i} \alpha_{j} y_{i} y_{j}x_{i}^T x_{j}+\sum_{i=1}^{m} \alpha_{i}</script><p>（2）对$\min _{w, b, \xi} L(w, b, \xi, \alpha, \mu)$求$\alpha$的极大，得到对偶问题</p><script type="math/tex; mode=display">\max _{\alpha}-\frac{1}{2} \sum_{i=1}^{m} \sum_{j=1}^{m} \alpha_{i} \alpha_{j} y_{i} y_{j}x_{i}^T  x_{j}+\sum_{i=1}^{m} \alpha_{i}</script><script type="math/tex; mode=display">\begin{aligned}&\text { s.t. } \quad \sum_{i=1}^{m} \alpha_{i} y_{i}=0\\&\begin{array}{l}C-\alpha_{i}-\mu_{i}=0 \\\alpha_{i} \geqslant 0 \\\mu_{i} \geqslant 0, \quad i=1,2, \cdots, m\end{array}\end{aligned}</script><p>将上述极大变成极小为：</p><script type="math/tex; mode=display">\min _{\alpha}\frac{1}{2} \sum_{i=1}^{m} \sum_{j=1}^{m} \alpha_{i} \alpha_{j} y_{i} y_{j}x_{i}^T  x_{j}-\sum_{i=1}^{m} \alpha_{i}</script><p>SVM中的2个重要参数：惩罚系数$C$和$\gamma$<br>C和gamma都起到了正则化的作用<br>惩罚系数C表示对误差的惩罚程度，C越大，说明越不能容忍误差，容易出现过拟合；C越小，容易欠拟合<br>gamma是选择RBF函数（高斯核函数）作为核函数后，该函数自带的一个参数，隐含地决定了数据映射到新的特征空间后的分布，gamma越大，支持向量越少,容易过拟合；gamma越小，支持向量越多，容易欠拟合。支持向量的个数影响训练和预测的速度。</p><p><img src="/2020/06/19/百面机器学习概述/SVM4.jpg" alt=""></p><h3><span id="363-核函数">3.6.3. 核函数</span></h3><p>上面讨论的硬间隔和软间隔都是样本完全线性可分或者近似线性可分的，但是也会遇到样本不是线性可分的，例如下图：</p><p><img src="/2020/06/19/百面机器学习概述/SVM6.png" alt=""></p><p>解决方案：将样本使用核函数，向高维空间转化，使得在高维空间中线性可分。</p><p><img src="/2020/06/19/百面机器学习概述/SVM7.png" alt=""></p><p>核函数的好坏对SVM至关重要。若核函数选择不合适，将样本映射到一个不合适的特征空间，很有可能分类效果不佳。</p><p><img src="/2020/06/19/百面机器学习概述/SVM8.png" alt=""></p><h3><span id="364-面试问题">3.6.4. 面试问题</span></h3><ul><li><p><strong>介绍函数间隔和几何间隔</strong></p><blockquote><p>二维平面中点$(x,y)$到$AX+By+c=0$的距离为$\frac{|Ax+By+c|}{\sqrt{A^2+B^2}}$</p></blockquote><p><strong>超平面</strong>：$w^Tx+b=0$<br><strong>函数间隔</strong>：$\hat{\gamma}=y(w^Tx+b)=yf(x)=|f(x)|$<br>函数间隔就是标签$y$乘上$f(x)$的值，函数间隔永远为正。但是由于SVM中$y$的取值只能为1和-1，所以函数间隔的值就是$|f(x)|$<br>几何间隔表示点到超平面的距离，在SVM中点到超平面的距离为$\frac{|w^Tx+b|}{||w||}=\frac{|f(x)|}{||w||}=\frac{\hat{\gamma}}{||w||}$<br><strong>几何间隔</strong>：$\gamma=\frac{|w^Tx+b|}{||w||}=\frac{y(w^Tx+b)}{||w||}=\frac{\hat{\gamma}}{||w||}$</p><p>函数间隔$y(w^Tx+b)$可以表示分类预测的准确性和置信度，值越大越好，说明模型将样本分正确的概率越大，但函数间隔并不表示点到超平面的距离，因为假如将$w,b$成比例变成$2w,2b$，超平面的位置没有变，但是$f(x)$却变成原来的2倍，即函数间隔变成原来的2倍。在实际中，定义点到直线的距离时，用的是几何间隔。$w,b$成倍数增加时，几何间隔不变。函数间隔是几何间隔没有除以$||w||$的表示，几何间隔是函数间隔归一化的结果。函数间隔是我们自己定义的，而几何间隔是客观存在的，无论$w,b$扩大几倍，对几何间隔没有影响。</p></li><li><p><strong>SVM中$w^Tx+b&gt;1$，$w^Tx+b&lt;-1$设置为正负样本的阈值，为什么是正负1</strong><br>SVM最终学习到的是一个超平面，至于系数是$(w^T,b)$还是$(2w^T,2b)$都不重要，所以需要对$w,b$进行限制，这SVM对函数间隔进行限制为$y(w^Tx+b)=1$，这样在求得的解中$w,b$就是唯一的。当然$y(w^Tx+b)$也不一定为1，也可以为2，3或其他值</p></li><li><p><strong>SVM什么时候选择线性核函数，什么时候选择高斯核函数</strong><br>当样本量比较小，特征量比较大时使用线性核函数。因为此时特征空间已经很高维了，只是数据量不够，线性核函数足够了。如果用高斯核函数投影到高维容易出现过拟合。<br>当数据量比较大而特征量比较小时，使用高斯核函数，需要投影到高维特征空间。</p></li><li><p><strong>使用高斯核函数之前需要对数据进行处理吗</strong><br>需要对特征进行缩放，因为高斯核函数需要计算两个点之间的欧式距离，如果不特征缩放的话那些值特别大的特征将会对核函数的结果有决定性影响，而数据量小的特征将被忽略。</p></li><li><p><strong>SVM如何解决数据不均衡问题</strong><br>数据不均衡在SVM中导致的主要问题是数据量少的样本分布空间不如数据量多的样本。为了能够让分割超平面向数据量少的样本偏移，可以给样本少的分类更大的惩罚因为$C$,表示如果数据少的样本分错了将会有很大的惩罚，使模型更重视数量少的样本。</p></li><li><strong>SVM原始问题为什么要转化为对偶问题求解？</strong><ol><li>改变算法复杂度，对偶问题更容易求解。因为算法的复杂度与样本维度有关，在对偶问题下，算法复杂度和样本数量有关。如果是线性回归，样本维度小于样本数量，在原问题上求解就可以了。但如果是非线性回归，就涉及到升维，例如使用高斯核函数，将样本升到很高维，升维后的样本维度远远大于样本数量，这是显然在对偶问题下更好求解。</li><li>转化为对偶问题才能得到内积形式，引入核函数，进而推广到非线性分类问题中。</li></ol></li><li><strong>SVM为什么采用间隔最大化</strong><br>当数据线性可分时，有无穷多个超平面可以将样本划分开，利用间隔最大化可以求得最优的划分超平面。此时的划分超平面的分类结果是最鲁棒的，对未知数据的泛化能力最强。</li><li><strong>为什么SVM引入核函数</strong><br>当样本在原始空间中线性不可分时，通过核函数将样本映射到更高维的特征空间中，样本在这个特征空间中线性可分或近似线性可分。</li><li><strong>核函数也可以应用在别的分类模型中，为什么在逻辑回归中不用核函数呢？</strong><br>因为核函数将样本维度映射到很高维。在SVM中只有支持向量决定了划分超平面，只有少数样本参与核计算，在计算核函数时优势很大。但是逻辑回归是所有的样本都决定了划分超平面，如果采用核函数，那每个样本都参数核运算，则非常耗时。</li><li><p><strong>SVM为什么对缺失值敏感</strong><br>这里说的缺失数据是指缺失某些特征数据，向量数据不完整。SVM没有处理缺失值的策略（决策树有）。而SVM希望样本在特征空间中线性可分，所以特征空间的好坏对SVM的性能很重要。缺失特征数据将影响训练结果的好坏。</p></li><li><p><strong>SVM和逻辑回归的不同</strong></p><ol><li>SVM只有支持向量对模型有影响，即只有支持向量决定划分超平面。逻辑回归是所有点都影响划分超平面</li><li>损失函数不同。SVM采用hinge损失，逻辑回归采用对数损失<br>逻辑回归的目标函数 <script type="math/tex; mode=display">J(\theta)=-\frac{1}{m}\left[\sum_{i=1}^{m} y^{(i)} \log h_{\theta}\left(x^{(i)}\right)+\left(1-y^{(i)}\right) \log \left(1-h_{\theta}\left(x^{(i)}\right)\right)\right]</script>SVM的目标函数<script type="math/tex; mode=display">\mathcal{L}(w, b, \alpha)=\frac{1}{2}\|w\|^{2}-\sum_{i=1}^{n} \alpha_{i}\left(y_{i}\left(w^{T} x_{i}+b\right)-1\right)</script>逻辑回归是最大化似然，求得参数的值<br>SVM是最大化几何间隔，求得参数的值</li><li>输出不同。SVM输出0/1，逻辑回归输出样本属于正例的概率</li><li>处理非线性问题的能力不同。SVM通过核函数将非线性问题转化为线性问题。逻辑回归需要活动特征转换。</li><li>LR对异常值敏感；SVM相对不敏感，泛化能力好</li></ol></li><li><p>SVM的优缺点<br>优点：</p><ol><li>可以高效地解决高维特征的分类和回归</li><li>只依赖支持向量，无需全部样本</li><li>通过核函数可以处理线性不可分问题<br>缺点：</li><li>样本量巨大时，不适合用</li><li>SVM对缺失值敏感</li><li>对核函数没有选择的标准</li></ol></li></ul><h2><span id="37-决策树">3.7. 决策树</span></h2><p>决策树是一个非常见的机器学习算法，易于理解，可解释强，可以作为分类算法和回归算法。</p><p>决策树通常是递归的选择最优特征，并根据该特征对训练集进行划分，对训练即进行分类。</p><p>现将所有数据都放在根节点，然后选择一个最优特征，按照这一个特征将训练数据集分割成子集，分配到各个子节点上，如果子集中有些节点没有被正确分类，那在这个子集中再选择最优特征，继续分割，直到所有的训练数据集都被正确分类，或者没有合适的特征未知，最后每个子集都被分到叶子节点上，就变成了一棵决策树。</p><p>但如果决策树对训练数据集有非常好的分类能力，在测试数据集上可能会出现过拟合，就需要对已经生成的决策树进行由下而上的剪枝，使树变得简单。</p><p>决策树算法主要包括3个步骤：</p><ol><li>特征选择，选择哪个特征进行划分才能使数据能够很好的分类。</li><li>决策树的生成</li><li>决策树的剪枝</li></ol><p>决策树学习常用的算法有：ID3，C4.5，CART</p><p>在特征选择上，ID3使用信息增益，C4.5使用信息增益比，CART使用基尼指数</p><p>首先了解一个概念：<strong>信息熵</strong></p><p>一个事情发生的概率越大，这个事情所携带的信息熵越小，熵表示随机变量不确定的程度。假设$X$是一个随机变量，它的取值有$x_1,…x_n$，每个取值的概率为$p_i$，也就是$P(X=x_i)=p_i$<br>那么随机变量$X$的熵为：</p><script type="math/tex; mode=display">H(X)=-\sum_{i=1}^{i=n}p_ilogp_i</script><p>这里的$log$可以以2为底，也可以以$e$为底<br>熵越大，随机变量的不确定性越大。</p><p>例如一个人告诉你明天太阳从东方升起，那这个人相当于说了句废话，这个话的信息熵为0。</p><p><strong>条件熵</strong></p><p>有2个随机变量$X,Y$，条件熵就是在$X$给定的情况下随机变量$Y$的熵</p><script type="math/tex; mode=display">P(Y|X)=\sum_{i=1}^{i=n}p_iH(Y|X=x_i)</script><p>$p_i表示X为x_i$的概率</p><h3><span id="371-基础树id3c45cart">3.7.1. 基础树(ID3/C4.5/CART)</span></h3><h4><span id="3711-id3">3.7.1.1. ID3</span></h4><p>ID3根据信息增益进行划分，信息增益表示得知$X$时使得类$Y$的不确定性减少的程度。</p><p>信息增益是用来选择特征的一个指标，信息增益越大，说明这个特征带的信息越多，即已知这个特征的值让类$Y$的不确定性减少的越多，该特征越重要。</p><p>信息增益=信息熵-条件熵</p><p>特征$A$对训练数据集$D$的信息增益为$g(D,A)$<br>$g(D,A)=H(D)-H(D|A)$<br>原来数据集的信息熵为$H(D)$，知道特征$A$后数据集的信息熵为$H(D|A)$，信息熵减少了$H(D)-H(D|A)$就是信息增益</p><p>例如相亲问题中，女生根据男生会不会写代码这个条件下，来决定见或者不见。<br>如果男方会写代码，女方就见。不会写代码，女方就不见。说明这个特征对结果很重要，让分类结果变得确定，因此“会不会写代码”这个特征的信息增益很大。0&lt;=信息增益的取值&lt;=1</p><p>不同的特征有不同的信息增益<br>对数据集（整个数据集/子集）计算每个特征的信息增益，选择信息增益最大的特征进行划分数据集。</p><p>ID3算法步骤：</p><ol><li>从根节点开始，计算所有特征的信息增益，选择信息增益最大的特征作为划分特征，将根节点数据集划分成n类，n为特征的取值数</li><li>对n个子树再次计算所有特征的信息增益，再次划分子树</li><li>直到该节点上所有样本都为同一类时，或没有特征可以选，或信息增益都很小时结束划分。</li></ol><p>注意：当根节点选择特征1作为划分特征时，在子树中计算所有特征的信息增益不包括特征</p><p>缺点：</p><ul><li>信息增益对取值数据较多的特征有多偏好。例如编号，每个人的编号都不一样，编号的取值很多，则编号的信息增益接近1，形成只有2层的决策树。虽然信息增益很大，但是对于数据集的分割却没有意义。</li><li>信息增益只能处理离散的特征，不能处理连续特征</li><li>只能处理分类问题，不能处理回归问题</li><li>对缺失值敏感</li></ul><h4><span id="3712-c45">3.7.1.2. C4.5</span></h4><p>C4.5根据信息增益比进行划分</p><p>为了解决ID3对取值多的特征偏好这一缺点，引入信息增益比。</p><p>特征$A$对训练数据集$D$的信息增益比$g_R(D,A)$<br>为信息增益$g(D,A)$与特征$A$的熵$H_A(D)$之比</p><script type="math/tex; mode=display">g_R(D,A)=\frac{g(D,A)}{H_A(D)}</script><p>信息增益比就是对取值很多的特征进行惩罚。举个例子，假设有100个样本，对这100个样本进行均分。如果特征1的取值有2个，则将样本分成50,50的子集。如果特征2的取值有4个，则将样本分成25,25,25,25的子集。可以看出特征的取值越多，就会生成越多的小子集。但是如果小子集越多的话，就会出现过拟合的问题。所以需要对这样的特征添加个惩罚项。这个特征的取值个数越多，惩罚越大。</p><script type="math/tex; mode=display">信息增益比=\frac{信息增益}{惩罚项}</script><p>ID3中如果一个特征取值取值越多，则信息增益越大，但是在C4.5中这个特征的惩罚项也就越大，就可以让信息增益比平衡。</p><ul><li><p>C4.5怎么处理特征的缺失值<br>分两步实现：<br>第一步，计算所有特征的信息增益或者信息增益率的时候，假设数据集一共10000个样本，特征A中缺失了5000个，则无视缺失值，在剩下的5000个特征中计算信息增益（或者信息增益率），最后乘以0.5，思想就是缺失值多的特征通过这种降低权重的方式来体现信息的缺失；</p><p>第二步，如果运气不好，正好这个A特征乘0.5之后得到的信息增益或者增益率还是最大的，那么就像西瓜书中提到的那样，存在缺失值的样板按照比例进入分裂之后的新的分支，假设根据特征A分裂得到两个新的分支，一个分支有2000个样本有2000个样本，一个分支有3000个样本，则按照比例2000个缺失值和3000个缺失值样本分别进入两个分支。<br>缺点：<br>虽然解决了特征取值多的问题，但是仍然有以下问题</p></li><li><p>需要计算信息增益，计算量大</p></li><li>只能处理分类问题，不能处理回归问题</li><li>对缺失值有处理</li></ul><h4><span id="3713-cart分类回归树">3.7.1.3. CART(分类回归树)</span></h4><p>Classification And Regression Tree</p><p>CART可以用来做回归和分类。如果用来做<strong>回归，需要生成回归树，用平方损失选择最优特征</strong>。如果用来做分类，需要生成<strong>分类树，根据基尼指数来选择最优特征</strong>。</p><p>训练数据集$D$的基尼指数为：<br>$Gini(D)=1-\sum_{k=1}^{K}(\frac{|C_k|}{|D|})^2$<br>$C_k$是$D$中属于第$k$类的样本子集<br>若是二分类，则可以简写为$Gini(D)=2p(1-p)$</p><p>如果要按照特征$A$来划分子集的话，需要先计算在特征$A$的条件下，集合$D$的基尼指数为：<br>$Gini(D,A)=\frac{|D_1|}{|D|}Gini(D_1)+\frac{|D_2|}{|D|}Gini(D_2)$<br>特征$A=a$将数据集$D$划分为$D_1和D_2$<br>基尼指数$Gini(D)$表示集合$D$的不确定性。基尼指数$Gini(D,A)$表示特征$A$分割后集合$D$的不确定性。基尼指数越大，集合的不确定性也越大。划分时选择基尼指数小的特征进行划分。</p><ul><li><p>分类树建立<br>如果数据集有4个特征，每个特征有3个取值，则需要计算每个特征每个取值的基尼指数，即$Gini(D,A1=1),Gini(D,A1=2),Gini(D,A1=3)$，在特征1的3个基尼指数中找一个最小的，然后再分别计算特征2,3,4的3个基尼指数，分别找到一个最小的，然后再比较这4个最小的基尼指数，再次找到一个最小的，假设为$Gini(D,A3=2)$，则将根节点按照特征3=2进行划分成2个子集，等于2的划分到一个子集中，不等于2的划分到一个子集中。</p></li><li><p>回归树建立<br><strong>与分类树使用Gini指数分割特征不同，分类树使用平方和误差来分割特征</strong>。比如特征A的按照阈值a1和按照阈值a2，分别将数据集D划分成D1和D2，计算D1的平方和误差、D2的平方和误差、D1+D2的平方和误差，让这3个值同时最小，然后选择使用a1还是a2</p></li><li><p>回归树和分类树的区别：<br>当CART建立好之后，在给定测试集做预测时，CART分类树采用叶子节点里概率最大的类别作为当前节点的预测类别。回归树输出不是类别，采用叶子节点的均值或者中位数来预测输出结果。</p></li><li><p>CART划分的树是二叉树，因此CART每次分类时会将这个特征的特征值分成两堆，划分成左子树和右子树。然后在子树中还会用到这个特征计算基尼指数，因此CART中特征会被重复利用。但是在ID3和C4.5中，选中一个特征后，会划分为多个子树，例如这个特征有5个取值，就会划分成5个子树，在下一层中就不会计算这个特征的信息增益和信息增益比，因此特征只计算一次。</p></li><li><p><strong>CART怎么处理缺失值</strong><br>首先计算所有特征的Gini，对于有缺失值的特征，只用有值的部分计算Gini，然后再乘上非缺失值占的比重。如果最终选择的最优特征恰好有缺失值，则选择其他代理特征，有2种情况：</p><p>1、首先，如果某个存在缺失值的特征恰好是当前的分裂增益最大的特征，那么我们需要遍历剩余的特征，剩余的特征中如果有也存在缺失值的特征，那么这些特征忽略，仅仅在完全没有缺失值的特征上进行选择，我们选择其中能够与最佳增益的缺失特征分裂之后增益最接近的特征进行分裂。</p><p>2、如果我们事先设置了一定的标准仅仅选择差异性在一定范围内的特征作为代理特征进行分裂而导致了没有特征和最佳缺失特征的差异性满足要求，或者所有特征都存在缺失值的情况下，缺失样本默认进入个数最大的叶子节点。</p><p>显然这种缺失值的处理方式的计算量是非常大的，我们需要遍历其它的特征来进行代理特征选择，这个在数据量很大的情况下开销太大，而带来的性能提升确很有限，所以后来就不怎么用这种处理方式，xgb和lgb中就是直接将缺失值划分到增益大的节点里，这样在处理上要快速的多，而且在gbm的框架下一点点的误差其实影响不大。</p></li><li><p>可以处理连续值，因此既可以分类，也可以回归。</p></li><li>对缺失值有处理</li></ul><h4><span id="3714-总结">3.7.1.4. 总结</span></h4><p>ID3：信息增益<br>C4.5：信息增益比<br>CART：最小基尼指数</p><p>以上3个指标都是描述特征的。</p><p>以上三种方法都是对数据划分的方法，通过选择特征将数据划分为更小的子集。</p><p>ID3选择信息增益大的特征来划分，但是会偏好特征取值多的特征，引入C4.5，使用信息增益比，对取值多的特征添加惩罚项。但是以上2种方法都只能处理分类问题，后来引入CART，计算基尼指数，选择基尼指数最小的特征进行划分。</p><p><img src="/2020/06/19/百面机器学习概述/决策树.jpg" alt=""></p><h3><span id="372-树的剪枝">3.7.2. 树的剪枝</span></h3><p>一棵完全生长的决策树会出现过拟合的问题。例如如果按照“编号”进行划分树，则每个节点只包含1个样本，在测试集上的效果将会很差，出现过拟合现象。为了解决这个问题，对决策树进行剪枝，减掉一些枝叶。剪枝方法有2种方式：预剪枝、后剪枝</p><p>决策树的剪枝往往通过极小化决策树损失函数来实现。设决策树$T$中叶子节点个数为$|T|$，$t$为树$T$的叶子节点，每个叶子节点上有$N_t$个样本，这$N_t$个样本中，真实属于第$k$类样本有$N_{tk}$个</p><p>$C(T)=\sum_{t=1}^{t=T}N_tH_t(T)+\alpha|T|$<br>$H_t(T)=\sum_{k}\frac{N_{tk}}{N_t}log\frac{N_{tk}}{N_t}$<br>即所有叶子节点的样本数*该节点的信息熵+正则化</p><p>$\alpha|T|$是正则项，用来控制决策树的复杂程度，防止过拟合。</p><p>剪枝就是在$\alpha$确定时，最小化损失函数。可以看出决策树生成只考虑了提高信息增益或信息增益比来对训练数据更好的拟合，而决策树剪枝通过优化损失函数还考虑了树的复杂程度。决策树生成只考虑局部信息，决策树剪枝考虑全局信息。</p><ul><li><p>预剪枝<br>在生成决策树的时候进行剪枝。在按照某个特征划分之前，先计算当前的划分是否能够带来模型泛化性能的提升，如果不能，则不再生成子树。此时该节点中包含的样本可能属于不同的类别，按照多数投票的原则，将该节点判为多数类别。怎么判断不再划分树：</p><ol><li>当树的深度达到一定深度</li><li>当节点样本个数小于某个阈值</li><li><p>计算每次分裂对测试集的准确率是否提升，当提升小于某个阈值时，停止划分</p><p>缺点：<br>可能会出现欠拟合的问题，应为当前划分可能造成准确率变小，但是可能后续会让准确率变大，但是树的划分已经止步于此了。</p></li></ol></li><li><p>后剪枝<br>先生成一个完整的决策树，然后自底向上的进行剪枝。通过比较在损失函数，如果剪枝后损失函数更小，则剪枝该子树。<br>后剪枝的欠拟合风险很小，泛化能力优于预剪枝，但是开销比较大。</p></li></ul><h2><span id="38-k近邻knn">3.8. K近邻(KNN)</span></h2><h3><span id="381-knn原理">3.8.1. KNN原理</span></h3><p>KNN是一种监督学习方法，一种基本的分类和回归模型。<br>KNN思想：给定一个训练集，其中的样本类别已确定，然后给定<strong>测试样本</strong>，基于某种距离度量在训练集中找出与其最靠近的k个样本，然后基于这k个训练集邻居，对测试集进行预测。通常在决策时：</p><ul><li>分类问题：k个邻居中出现最多的类别作为测试样本的类别</li><li>回归问题中，使用k个邻居的平均作为训练样本的值</li></ul><p>K近邻学习的特点是：没有显示的训练过程，属于懒惰学习。在训练阶段仅仅将样本保存起来，训练时间为0，等到有测试样本时才开始处理。</p><p>KNN的三个主要问题：</p><ul><li>K的选择</li><li>选择哪种距离度量方式</li><li>使用哪种决策手段：（1）多数投票，（2）加权投票，即距离近的样本权重大</li></ul><p><strong>K的选择</strong></p><p>如果选择较小的k，就相当于用较少的邻居来预测，如果邻居是噪声，预测就会出错。较小的k会让模型变得复杂，容易出现过拟合。</p><p>如果选择较大的k，邻居变多，与测试集较远的样本也会影响预测效果，使预测发生UC哦呜。较大的k会让模型变得简单。</p><p>在应用中，k一般取比较小的数值，通常采用交叉验证来选择最优的k</p><p><strong>距离度量方式</strong></p><ol><li>欧氏距离</li><li>曼哈顿距离</li></ol><p><strong>分类决策</strong></p><ol><li>多数投票</li><li>加权投票</li></ol><p><img src="/2020/06/19/百面机器学习概述/knn1.png" alt=""></p><p>KNN的优点：</p><ol><li>思想简单</li><li>可分类，也可回归</li><li>可用于非线性分类</li><li>训练时间段，仅为O(n)</li><li>对异常点不敏感</li><li></li></ol><p>KNN的缺点：</p><ol><li>计算量大</li><li>样本不均衡时，对稀有类别的预测准确率低</li><li>相比决策树，KNN解释性不强</li></ol><h3><span id="382-kd树">3.8.2. KD树</span></h3><p>当训练样本特别大或样本维度特别大时，测试样本需要计算与每个训练样本的距离，然后排序找出前k个样本，时间复杂度大。</p><p>为了提高k近邻搜索的效率，可以通过减少N值，即在计算距离时，不用计算与所有训练样本的距离，只计算一部分，其中一个应用就是KD树。</p><p>KD树算法分为2步：构造KD树、搜索KD树</p><ol><li>构造KD树<br>KD树是对训练集进行存储，以便快速查询。假设训练样本有k维，KD数是二叉树，对k维空间的一个划分，KD树相当于不断地用垂直于坐标轴的超平面将k维空间切分。样本有k维特征，先找出第1维的特征值，找出其中的中位数，超平面经过该样本点将空间划分为左右2部分，然后在左右区域中，再根据第2维特征的中位数划分。然后再根据第3维特征的中位数划分。重复以上操作，知道空间中只包含1个样本点。如果有6个样本，中位数取右中位数。</li></ol><p><strong>常见问题</strong></p><ol><li><p>不平衡的样本给KNN造成什么影响，怎么解决</p><p><img src="/2020/06/19/百面机器学习概述/knn2.png" alt=""><br>l<br>例如上图中样本点y直观上看属于红色类别。但是使用KNN预测时，由于蓝色样本比较多，所以在k个邻居中蓝色点也占多数，导致y分类错误。<br>为了解决以上问题，可以采用加权投票的方式，与测试样本点距离小的样本权重大。</p></li><li>为了解决KNN算法计算量过大的问题，可以使用分组的方式进行计算，简述一下原理<br>先将样本按照距离分组，获得每个组的中心。给定一个测试样本，找出与其最近的那个簇，在这个簇上进行KNN。</li><li><p>KD树在对维度进行划分时，划分顺序是否可以优化？<br>可以先求每一维的方差，方差大说明数据越分散，可以获得比较好的划分效果。</p></li><li><p>KD树在划分时，需要找某个特征上的中位数，计算量大，怎么优化<br>在构建KD树之前，对每一维进行排序，在之后的划分中，直接使用。</p></li></ol><h1><span id="4-聚类">4. 聚类</span></h1><p>聚类是无监督学习，即不知道样本的标签。</p><h2><span id="41-k-means聚类">4.1. K-Means聚类</span></h2><p>K-Means聚类的目标函数为：最小化平方误差和，即SSE</p><script type="math/tex; mode=display">SSE=\sum_{i=1}^{k}\sum_{p \in C_i}|p-m_i|^2</script><p>$m_i$表示第$i$个簇的中心，使得每个样本点到中心的距离之间最小</p><p><strong>算法步骤:</strong></p><ol><li>数据预处理，如归一化，离群点处理等</li><li>随机选k个点，作为聚类中心。这k个点不一定是样本点，可以是任意一点</li><li>计算每个点到k个聚类中心的距离，然后将这个点分到最近的类中</li><li>重新计算每个簇的中心（簇中心为所有点的均值）</li><li>重复2~4，直到聚类中心不再发生改变或达到迭代次数</li></ol><ol><li><p><strong>K-Means常用的距离度量有哪些</strong></p><ul><li>曼哈顿距离<br>$d12=|x_1-x_2|+|y_1-y_2|$ </li><li>欧式距离<br>$d12=\sqrt{(x_1-x_2)^2+(y_1-y_2)^2}$<br>欧式距离体现2个向量距离上的绝对差异</li><li>余弦相似度<br>$con(A,B)=\frac{AB}{||A||*||B||}$<br>相比欧式距离，余弦距离更关注2个向量在方向上的相对差异。2个向量方向越接近，越可能被聚为一类。</li></ul></li><li><p><strong>K-Means中k如何选择</strong></p><ul><li>根据场景选择</li><li>手肘法<br>计算指标SSE（误差平方和）<script type="math/tex; mode=display">SSE=\sum_{i=1}^{k}\sum_{p \in C_i}|p-m_i|^2</script>一共有k个簇，$C_i$为第$i$个簇，$p$是第$i$个簇的样本，$m_i$是第$i$第个簇的中心。$SSE$表示所有样本的误差平方和，表示聚类结果的好坏。核心思想：随着$k$的增大，每个簇中的样本越来越小，那每个簇越聚集，所有样本点的误差平方和$SSE$逐渐变小。假设理想情况下聚成$k’$类。我们从小到大遍历$k$，当$k&lt;k’$时，随着$k$的增加每个簇的聚合程度会迅速增加，那$SSE$会大幅度下降。当$k=k’$时，接下来再增加$k$，$SSE$下降的幅度会变小，此时不同的$k$和$SSE$的关系图就像手肘的形状。例如下图所示，手肘位置所对应的$k$就是最佳的$k$值。</li></ul><p><img src="/2020/06/19/百面机器学习概述/kmeans1.png" alt=""></p><ul><li>轮廓系数法<br>首先求一个样本点的轮廓系数，然后将所有点的轮廓系数求平均得到整个样本的轮廓系数。<br>怎么求一个样本的轮廓系数？<br>$S_i=\frac{b-a}{max(a,b)}$<br>$a$表示样本$x_i$与相同簇的样本的平均距离。$b$为样本$x_i$与最近簇中样本的平均距离。 因此$a$表示簇内的聚合程度，$b$表示簇间的分离程度。下图中显示了$x_i$的轮廓系数计算方法。平均轮廓系数范围[-1,1]，轮廓系数越大，聚类效果越好，说明簇内越紧密(a越小)，簇间越分离(b越大)。</li></ul><p><img src="/2020/06/19/百面机器学习概述/kmeans2.png" alt=""></p><p> 从小到大遍历$k$，然后计算所有样本的平均轮廓系数，找出最大轮廓系数对应的$k$.下图给出$k$与轮廓系数的关系：</p><p> <img src="/2020/06/19/百面机器学习概述/kmeans3.png" alt=""></p><p> 可以看出$k=2$时聚类效果最好。但是$K=2$时SSE却不是最小的，SSE依然很大。猜测是因为：SSE大说明样本间的误差很大。轮廓系数大说明不一定是$a$小，也有可能是$a$很大，但是$b$更大，导致SSE就很大。所以在选择$k$时需要同时看轮廓法和SSE法。</p></li></ol><ul><li><strong>确定了k，k个初始点怎么选</strong><br>（1）则k个初始点要尽可能远<br>（2）可以先对数据进行层次聚类，将层次聚类得到的k个聚类中心作为k-means的初始聚类中心</li><li><strong>K-Means怎么处理超大数据量的聚类</strong><br>K-Means在大数据量时，因为需要计算每个点到质心的距离，非常耗时。一种解决方案是Mini Batch K-Means小批量K-Means，即在计算距离时不必计算所有的样本点，而是从不同类别的样本中抽出一部分计算。这种方法会减少运行时间，但是会造成准确度下降。<br>步骤：<br>（1）给出k个初始质心<br>（2）从每个簇中选出一部分样本计算与k个质心的距离，分到最近的那个簇中<br>（3）根据小批量样本计算新的质心<br>（4）重复2~4，直到质心不再变化或迭代达到上界</li><li><p><strong>K-Means之前需要对数据标准化吗</strong><br>需要，K-Means是建立在距离度量上，如果维度之间的数据量差别太大，则在计算距离时会造成数值大的特征影响特别大。</p></li><li><p>优点<br>（1）原理简单，易于实现<br>（2）可解释强<br>缺点：<br>（1）容易受初始中心的影响，可能会陷入局部最优<br>（2）由于随机初始化中心点，聚类的结果不稳定<br>（3）k的选取会影响聚类结果<br>（4）对噪声和异常点敏感<br>（5）不适合环形数据，适用与球状数据<br>（6）时间复杂度大O(Nkt),N是样本个数，k是簇个数，t是迭代次数，不适用于大数据量</p></li></ul><p>K-Means手写代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">randomCenter</span><span class="params">(samples,k)</span>:</span></span><br><span class="line">    <span class="string">"""根据samples随机生成k个簇中心</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Args:</span></span><br><span class="line"><span class="string">        samples (array): 待分类数据集</span></span><br><span class="line"><span class="string">        k (int): 聚类个数</span></span><br><span class="line"><span class="string">    Returns:</span></span><br><span class="line"><span class="string">        [array]: shape (K,n)随机生成的簇中心</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="comment">#将随机范围控制在样本的分布范围内</span></span><br><span class="line">    m,n = samples.shape</span><br><span class="line">    centers = np.mat(np.zeros((k,n)))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(n):<span class="comment">#遍历每一个特征</span></span><br><span class="line">        max_i = np.max(samples[:,i])</span><br><span class="line">        min_i = np.min(samples[:,i])</span><br><span class="line">        range_i = max_i - min_i</span><br><span class="line">        <span class="comment">#生成K行1列的特征值，random 返回随机的浮点数，在半开区间 [0.0, 1.0)</span></span><br><span class="line">        centers[:,i] = np.mat(min_i+range_i*np.random((k,<span class="number">1</span>)))</span><br><span class="line">    <span class="keyword">return</span> centers</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">calDistance</span><span class="params">(vecA,vecB)</span>:</span></span><br><span class="line">    <span class="string">"""计算2个向量的欧式距离</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Args:</span></span><br><span class="line"><span class="string">        vecA (array): shape:(n,)</span></span><br><span class="line"><span class="string">        vecB (array): shape:(n,)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Returns:</span></span><br><span class="line"><span class="string">        [float]: 2个向量的欧式距离</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">return</span> np.sqrt(np.sum(np.square(vecA-vecB)))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">KMeans</span><span class="params">(dataset,K)</span>:</span></span><br><span class="line">    <span class="string">"""对dataset聚成K类</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Args:</span></span><br><span class="line"><span class="string">        dataset (np.array): 待聚类数据集</span></span><br><span class="line"><span class="string">        K (int): 聚类个数</span></span><br><span class="line"><span class="string">    Returns:</span></span><br><span class="line"><span class="string">        [tupe]: 输出K个簇中心，输出(m个样本属于哪个簇，m个样本到簇重新的距离)</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="comment">#m：样本个数，n：特征个数</span></span><br><span class="line">    m,n = dataset.shape</span><br><span class="line">    <span class="comment">#返回结果一共2维，表示样本所属类别、到簇中心的距离</span></span><br><span class="line">    res = np.zeros((m,<span class="number">2</span>))</span><br><span class="line"></span><br><span class="line">    centers = randomCenter(dataset,K)</span><br><span class="line">    clusterChange = <span class="keyword">True</span><span class="comment">#当簇中心不再变化时，停止迭代</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> clusterChange:</span><br><span class="line">        clusterChange = <span class="keyword">False</span></span><br><span class="line">        <span class="comment">#遍历所有样本</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(m):</span><br><span class="line">            min_distance = float(<span class="string">'inf'</span>)<span class="comment">#当前样本距离簇的最小欧式距离</span></span><br><span class="line">            min_cluster = <span class="number">-1</span><span class="comment">#当前样本所属的簇下标</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(k):<span class="comment">#遍历K个簇</span></span><br><span class="line">                <span class="comment">#计算当前样本到K个簇中心的距离</span></span><br><span class="line">                dis = calDistance(dataset[i,:],centers[j,:])</span><br><span class="line">                <span class="keyword">if</span> dis &lt; min_distance:</span><br><span class="line">                    min_distance = dis</span><br><span class="line">                    min_cluster = j</span><br><span class="line">            <span class="keyword">if</span> res[i,<span class="number">0</span>] != min_cluster:<span class="comment">#如果样本i所属类别改变</span></span><br><span class="line">                clusterChange = <span class="keyword">True</span></span><br><span class="line">            <span class="comment">#更新样本i的聚类结果</span></span><br><span class="line">            res[i,:] = min_cluster,min_distance</span><br><span class="line"></span><br><span class="line">        <span class="comment">#更新簇中心</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(K):</span><br><span class="line">            <span class="comment">#找出属于第i个簇的样本,(z,n)</span></span><br><span class="line">            i_samples = dataset[np.nonzero(res[:,<span class="number">0</span>]==i)[<span class="number">0</span>]]</span><br><span class="line">            centers[i,:]=np.mean(i_samples,axis=<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> centers,res</span><br></pre></td></tr></table></figure><h2><span id="42-k-means的优化">4.2. K-Means的优化</span></h2><p>K-Means的优化有以下几方面：</p><ol><li>数据归一化和离群点处理<br>K-Means是基于距离度量的，聚类之前如果没有归一化，则距离由那些数值大的特征控制，所以需要将数据集归一化到统一量纲。同时离群点和噪声也会对均值产生较大的影响，导致质心偏离，因此需要对数据做预处理。</li><li>选择合适K值<br>手肘法画出不同的K和SSE的关系图，但是这种方法不够自动化，可以采用Gap Statistic法</li><li>采用核函数<br>K-Means要求数据是球状数据，但是实际情况中并不常见。面对非凸的数据分布，需要适用核函数优化，将样本映射到高维空间，在高维空间进行聚类。</li></ol><h3><span id="421-k-means">4.2.1. K-Means++</span></h3><p>K-Means++是K-Means的优化模型，用来改进初始化中心的选择。原始K-Means随机选择k个点作为聚类中心。K-Means++的核心思想是：初始的聚类中心之间的相互距离要尽可能的远。K-Means++采用如下方式选取K个中心点：首先随机选第1个中心点，然后选择和第1个中心点距离最远的点作为2个中心点。在选择第3个中心时，计算每个样本点和最近的中心的距离（中心1或中心2），然后选择距离最大的点作为第3个中心点。以此类推，直到找到k个中心点。</p><h3><span id="422-isodata">4.2.2. ISODATA</span></h3><p>用来确定K值。ISODATA思想很简单：当属于某个类别的样本过少时，删除该类别。当属于某个类别的样本过多时，将该类别分成2个子类别。ISODATA的缺点是指定参数比较多。下面介绍什么时候分裂，什么时候合并</p><ul><li>当2个簇的中心距离小于某个阈值时，合并这2个簇</li><li>当1个簇的方差大于某个阈值时，说明这个簇已经很分散了，将这个簇分成2个簇</li><li>当一个簇中样本个数少于某个阈值时，不再分裂该簇。</li></ul><h2><span id="43-聚类评价指标">4.3. 聚类评价指标</span></h2><ol><li>SSE误差平方和<script type="math/tex; mode=display">SSE=\sum_{i=1}^{k}\sum_{p \in C_i}|p-m_i|^2</script>计算每个样本点与簇中心的距离，SSE越小，聚类效果越好。但是SSE值考虑簇内的紧密程度，没有考虑簇间的分离程度</li><li>轮廓系数<br>描述簇内的聚合程度和簇间的分离程度。<br>$s_i=\frac{b-a}{max(b,a)}$<br>表示样本$x_i$的轮廓系数，每个样本点都计算一次轮廓系数。$a$表示样本$x_i$与本簇其他样本的平均距离，表示簇内聚合程度；$b$是$x_i$与最近的簇中所有样本点的平均距离，表示簇间分离程度。$a$越小，$b$越大，说明聚类效果越好。所有样本点都有一个轮廓系数，将其求平均，得到当前聚类的平均轮廓系数。</li><li>R方<script type="math/tex; mode=display">RS=\frac{\sum_{x \in D}||x-c||^2-\sum_{i}\sum_{x \in C_i}||x-c_i||^2}{\sum_{x \in D}||x-c||^2}</script>其中$D$表示所有样本，$c$表示所有样本的中心点。$\sum_{x \in D}||x-c||^2$表示将所有样本作为1个簇，计算所有样本点与中心点的平方误差和，然后对样本进行聚类，$\sum_{i}\sum_{x \in C_i}||x-c_i||^2$表示聚类之后的样本误差和。$RS$表示聚类之后的结果和聚类之前的结果相比，平方误差和的改进幅度。</li></ol><h1><span id="5-贝叶斯分类">5. 贝叶斯分类</span></h1><h2><span id="51-朴素贝叶斯分类器">5.1. 朴素贝叶斯分类器</span></h2><p>先明确几个概念：<br><strong>先验概率</strong>：P(瓜熟)<br><strong>似然</strong>：P(瓜蒂脱落|瓜熟)<br><strong>后验概率</strong>：P(瓜熟|瓜蒂脱落)<br><strong>联合概率</strong>：P(瓜熟，瓜蒂脱落)<br><strong>全概率公式</strong>：P(瓜蒂脱落)=P(瓜蒂脱落|瓜熟)P(瓜熟)+P(瓜蒂脱落|瓜生)P(瓜生)</p><p><strong>贝叶斯定理</strong></p><script type="math/tex; mode=display">P(A|B)=\frac{P(AB)}{P(B)}=\frac{P(B|A)P(A)}{P(B)}</script><p>贝叶斯定理打通了从$P(B|A)$到$P(A|B)$的道路。</p><p>如果有多个特征，并且多个特征之间相互独立，就是朴素贝叶斯分类器。<br>例如瓜蒂：脱落/未脱，形状：圆尖，颜色：深绿/浅绿/青。已知10个样本如下图所示，现在有一个瓜瓜蒂脱落，形状圆，颜色青色，判断这个瓜是生还是熟。</p><p><img src="/2020/06/19/百面机器学习概述/贝叶斯1.png" alt=""></p><p><strong>这个问题就是朴素贝叶斯分类器：有一些已知样本，样本有n个特征，这n个特征之间相互独立，现在给一个测试样本，知道测试样本这n个特征的值，判断这个测试样本属于哪一类。就需要计算这个样本属于每一类的概率，然后取概率最大的那一类作为测试样本最终的类别。朴素贝叶斯是基于贝叶斯定理和特征条件独立的分类方法。</strong></p><p>问题的关键是：怎么计算测试样本属于每一类的概率？</p><script type="math/tex; mode=display">P(y_i|x)=\frac{P(x|y_i)P(y_i)}{P(x)}</script><p>对于每一类来说分母是一样的，只需要在不同的$y_i$中比较分子哪个大就可以了。由于所有的特征相互独立，所以有下式成立：</p><p>$P(x|y_i)P(y_i)=P(x_1|y_i)P(x_2|y_i)…P(x_n|y_i)P(y_i)$</p><p>由于$P(x_i|y)$也称为“似然”，所以朴素贝叶斯分类器常常和最大化似然联系在一起。</p><p>朴素贝叶斯分类的流程如下图所示：</p><p><img src="/2020/06/19/百面机器学习概述/贝叶斯2.png" alt=""></p><p>朴素贝叶斯分类器有3个阶段：</p><ol><li>准备工作阶段：获取训练数据</li><li>分类器训练阶段：这里并不是真正的训练，只是求先验概率和条件概率，为后续的分类做准备</li><li>分类阶段：给定测试样本，对其进行分类。</li></ol><p>朴素贝叶斯的优点</p><ol><li>算法简单，坚实的数学基础</li><li>在小规模数据上表现好</li><li>能处理多分类任务</li><li>适用于文本分类任务</li></ol><p>朴素贝叶斯的缺点：</p><ol><li>实际应用中，特征往往不是相互独立</li><li>对输入数据的格式很敏感（离散、连续）</li><li>需要知道先验概率，但先验概率很多时候是基于假设的，会造成分类错误</li></ol><p>常见问题</p><ol><li><strong>为什么要引入特征条件独立假设</strong><br>为了避免贝叶斯定理求解时面临的组合爆炸的问题。<br>$P(x|y_i)=P(x_1,x_2,…x_n|y_i)$<br>$x_1,…x_n$表示n个特征，每个特征$s_i$个，$y$的取值有$k$个，则参数个数有$k\prod s_i$，导致条件概率分布的参数数量为指数级别。</li></ol><ul><li><strong>在估计条件概率$P(X|Y)$时出现概率为0怎么办？</strong><br>例如在计算<script type="math/tex; mode=display">P(瓜熟|脱落，圆形，浅绿)=\frac{P(脱落|瓜熟)P(圆形|瓜熟)P(浅绿|瓜熟)P(瓜熟)}{P(脱落，圆形，浅绿)}</script>的概率时，如果$P(浅绿|瓜熟)=0$,这样会造成分子为0，即使其他属性看起来是瓜熟，分类结果都是瓜熟的概率为0。为了避免这一情况，通常使用拉普拉斯修正，在分子分母上加上一个值，避免出现为0的情况<br>修改先验概率公式为：<br>$P(瓜熟)=\frac{瓜熟个数+1}{所有样本+N}$<br>$N$表示类别个数，这里只有2个类别：瓜熟和瓜生，所以N=2<br>修改条件概率公式为：<br>$P(浅绿|瓜熟)=\frac{浅绿且瓜熟个数+1}{瓜熟个数+N_i}$<br>$N_i$表示属性颜色的取值个数，例如这里颜色一共有三个取值：浅绿，深绿，青色，所以$N_i=3$<br>总结一下就是不管是先验概率还是条件概率在分子上都是加1，分母上，先验概率加类别个数，条件概率加属性取值个数。拉普拉斯平滑作用在所有的先验概率和条件概率上，并不是只有为0的概率上。</li><li><strong>朴素贝叶斯分类器和逻辑回归的区别</strong><ol><li>朴素贝叶斯分类器是生成模型，需要先计算出先验概率和联合概率。逻辑回归是判别式模型，直接求出条件概率。</li><li>朴素贝叶斯分类器基于条件独立假设，逻辑回归没有此要求</li><li>朴素贝叶斯适用于数据量少的情景，逻辑回归适用于大规模数据集。</li></ol></li><li><p><strong>在贝叶斯定理中，由于特征相互独立，所以会出现连乘的情况，由于概率值很小，连乘之后趋向于0，怎么解决？</strong><br>对乘积取对数，将连乘变成连加：对每个条件概率取对数$P(x_i|y)$，然后再把所有的对数相加</p></li><li><p><strong>朴素贝叶斯要求特征相互独立，但很多时候并不满足，为什么朴素贝叶斯仍然取得不错的效果？</strong><br>对于分类任务来说，只要各个条件概率的大小排序相对正确，就可以通过比较大小找到正确的类别，并不需要准确的概率值，因为朴素贝叶斯是找后验概率最大的类，不需要知道精确概率值。</p></li><li><p><strong>朴素贝叶斯有没有超参数</strong><br>没有</p></li><li><strong>朴素贝叶斯分类器的应用</strong><br>朴素贝叶斯分类器广泛应用在文本分类上，例如垃圾邮件分类，情感分类等</li><li><strong>朴素贝叶斯分类器对异常值敏感吗</strong><br>对异常值不敏感。所以在数据处理时，不用去除异常值。</li></ul><h2><span id="52-半朴素贝叶斯分类器">5.2. 半朴素贝叶斯分类器</span></h2><p>朴素贝叶斯分类器假设属性条件相互独立，但在实际情况中往往不满足这个假设，于是尝试对这个假设进行放松，生成“半朴素贝叶斯分类器”。<br>在贝叶斯定理中，朴素贝叶斯分类器计算分子公式为</p><script type="math/tex; mode=display">P(x|y)=P(y)P(x_1|y)P(x_2|y)...P(x_n|y)</script><p>半朴素分类器的基本思想是考虑一部分属性之间的关系，并不是完全独立的。半朴素贝叶斯分类器采用“独依赖估计”策略，即每个属性除了类别之外，最多依赖1个其他属性，因此在计算分子时，变成:</p><script type="math/tex; mode=display">P(x|y)=P(y)P(x_1|y,x_j)P(x_2|y,x_j)...P(x_n|y,x_j)</script><p>这里将每个属性依赖的那个属性称为”父属性”。如果知道每个属性的父属性，可以直接计算上述公式，但如果不知道，问题就转化为怎么确定每个属性的父属性，不同的做法产生不同的独依赖分类器（One-Dependent Estimator ODE）。</p><p>最直接的做法是所有的属性都依赖同一个父属性，叫做超父ODE（SPODE）</p><p>还有一种是计算任意2个属性的相关性，为每个属性选择最大相关性的那个属性作为父属性（TAN ODE）</p><h1><span id="6-生成模型和判别模型">6. 生成模型和判别模型</span></h1><p>生成模型是由训练数据学习联合概率$P(X,Y)$，然后求得后验 概率分布$P(Y|X)$，选择后验概率大的那个类作为$X$所属的类。因为对于生成模型，必然要考虑</p><script type="math/tex; mode=display">P(Y|X)=\frac{P(X,Y)}{P(X)}</script><p>判别模式是直接求$P(Y|X)$。</p><p>生成模型：朴素贝叶斯分类器、贝叶斯网络、隐马尔科夫模型</p><p>判别模型：决策树、SVM、神经网络</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;总结《百面机器学习》有关知识点。&lt;/p&gt;
    
    </summary>
    
      <category term="Machine Learning" scheme="http://yoursite.com/categories/Machine-Learning/"/>
    
    
      <category term="machine learning" scheme="http://yoursite.com/tags/machine-learning/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode之位运算</title>
    <link href="http://yoursite.com/2020/06/07/Leetcode%E4%B9%8B%E4%BD%8D%E8%BF%90%E7%AE%97/"/>
    <id>http://yoursite.com/2020/06/07/Leetcode之位运算/</id>
    <published>2020-06-07T09:35:16.000Z</published>
    <updated>2020-07-15T01:58:43.648Z</updated>
    
    <content type="html"><![CDATA[<p>位运算总共有5种运算：与，或，异或，左移，右移。</p><a id="more"></a><!-- TOC --><ul><li><a href="#1-位运算">1. 位运算</a></li><li><a href="#2-总结">2. 总结</a></li></ul><!-- /TOC --><h1><span id="1-位运算">1. 位运算</span></h1><p>位运算总共有5种运算：与，或，异或，左移，右移。<br>左移<code>m&lt;&lt;n</code>表示把m左移n位，在左移n位时，最左边的n位被丢弃，同时最右边补上n个0<br>右移<code>m&gt;&gt;n</code>表示把m右移n位，在右移n位时，最右边的n位被丢弃，在处理左边时比较复杂。如果数字是无符号数，最左边补上n个0。如果数字是一个有符号数，则用数字的符号填补左边的n位。也就是说，如果数字是整数，最左边用0填充，如果数字是负数，最左边用1填充。例如<br>00001010&gt;&gt;2=00000010<br>10001010&gt;&gt;3=11110001</p><p>请实现一个函数，输入一个整数，输出该数二进制表示中 1 的个数。例如，把 9 表示成二进制是 1001，有 2 位是 1。因此，如果输入 9，则该函数输出 2。</p><p>链接：<a href="https://leetcode-cn.com/problems/er-jin-zhi-zhong-1de-ge-shu-lcof" target="_blank" rel="noopener">https://leetcode-cn.com/problems/er-jin-zhi-zhong-1de-ge-shu-lcof</a></p><p><strong>【分析】</strong><br>将一个整数n减去1之后，再和n做与运算，可以将n中最右边的1变成0<br>比如原先n=1100，n-1=1011，n&amp;(n-1)=1000,与运算的结果1000与原先的n=1100相比，就把最后边的1变成0。然后再对1000执行相同的操作，就会变成0000。这样执行2次，说明原始的n中一共有2个1.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hammingWeight</span><span class="params">(self, n)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type n: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        <span class="comment">#n=n&amp;(n-1)可以让原先的n中的1变成0</span></span><br><span class="line">        <span class="keyword">while</span> n:</span><br><span class="line">            res+=<span class="number">1</span></span><br><span class="line">            n=n&amp;(n<span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><p>整数<code>n&amp;1</code>值为0或1，判断n的二进制数的最后一位是0还是1.如果n=8，n&amp;1=0，表示8的二进制1000最后一位是0。如果n=9，n&amp;1=1，表示9的二进制1001最后一位是1.<br>$x^n$中的n变换成二进制为$b_mb_{m-1}…b_2b_1$，二进制和十进制n的关系为$n=2^0b_1+2^1b_2+…+2^{m-1}b_m$,这样就可以把$x^n=x^{2^0b_1+2^1b_2+…+2^{m-1}b_m}=x^{2^0b_1}x^{2^1b_2}…x^{2^{m-1}b_m}$。其中$b_1,b_2….b_m$的值只能为0或1.如果$b_m=0$，那$x^{2^{m-1}b_m}=1$，否则$x^{2^{m-1}b_m}=x^{2^{m-1}}$<br>所以问题的关键就是计算十进制数n，转换成二进制后每一个位数是0还是1.<br>如果第一位是1，就乘上$x^1$,然后把n除以2，就是n=n&gt;&gt;1,然后再判断原始n的第二位。<br>如果第二位是1，就乘上$x^2$<br>如果第三位是1，就乘上$x^4$<br>如果第四位是1，就乘上$x^8$</p><p>n=11，变换成二进制是1011,分别是1,2,4,8，其中只有1,2,8的幂次有效。理论上应该是$x.x^2.x^8$</p><ul><li>进入while循环，n&amp;1=1，$res=x$，然后$x=x^2$，n右移一位成5</li><li>进入while循环，n&amp;1=1，$res=res*x=x^3,x=x^4$,n右移一位变成2</li><li>进入while循环，n&amp;1=0，$x=x^8$,n右移一位变成1</li><li>进入到while循环，n&amp;1=1，$res=x^11,x=x^16$,n右移一位变成0</li><li>退出while循环，返回res</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">myPow</span><span class="params">(self, x, n)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type x: float</span></span><br><span class="line"><span class="string">        :type n: int</span></span><br><span class="line"><span class="string">        :rtype: float</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> x==<span class="number">0</span>:<span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> n==<span class="number">0</span>:<span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        tmp_n = abs(n)</span><br><span class="line">        res=<span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> tmp_n:</span><br><span class="line">            <span class="keyword">if</span> tmp_n&amp;<span class="number">1</span>:</span><br><span class="line">                res*=x</span><br><span class="line">            x*=x</span><br><span class="line">            tmp_n=tmp_n&gt;&gt;<span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> n&gt;<span class="number">0</span>:<span class="keyword">return</span> res</span><br><span class="line">        <span class="keyword">else</span>:<span class="keyword">return</span> <span class="number">1</span>/res</span><br></pre></td></tr></table></figure><ul><li>时间复杂度：O(logn)</li><li>空间复杂度：O(1)</li></ul><h1><span id="2-总结">2. 总结</span></h1><ol><li>将二进制数字n的最右边的1变成0，n=n&amp;(n-1)<br>2.</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;位运算总共有5种运算：与，或，异或，左移，右移。&lt;/p&gt;
    
    </summary>
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode之动态规划</title>
    <link href="http://yoursite.com/2020/06/06/Leetcode%E4%B9%8B%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    <id>http://yoursite.com/2020/06/06/Leetcode之动态规划/</id>
    <published>2020-06-06T06:55:38.000Z</published>
    <updated>2020-07-14T15:33:04.051Z</updated>
    
    <content type="html"><![CDATA[<h1><span id="1-动态规划">1. 动态规划</span></h1><p>如果是求一个问题的最优解（通常是最大值或最小值），而且该问题可以分解成若干个子问题，并且子问题之间还有重叠的更小的子问题，可以考虑使用动态规划。</p><p>在解决动态规划问题时，需要分解成子问题，这里需要将子问题的最优解保存下来（一般是一维或二维数组），作为求取大问题最优解的基础。</p><p>做动态规划的三个关键：</p><ol><li>dp[i]表示什么意思（如果二维，dp[i][j]）</li><li>根据dp[i]和dp[i-1]的关系写出状态转移矩阵</li><li>确定初始条件，dp[0]</li></ol><a id="more"></a><!-- TOC --><ul><li><a href="#1-动态规划">1. 动态规划</a></li><li><a href="#2-剪绳子">2. 剪绳子</a></li><li><a href="#3-最大子序列和">3. 最大子序列和</a></li><li><a href="#4-乘积最大子数组">4. 乘积最大子数组</a></li><li><a href="#5-股票问题">5. 股票问题</a><ul><li><a href="#51-买卖股票的最佳时机">5.1. 买卖股票的最佳时机</a></li><li><a href="#52-买卖股票的最佳时机-ii">5.2. 买卖股票的最佳时机 II</a></li><li><a href="#53-买卖股票的最佳时机-iii">5.3. 买卖股票的最佳时机 III</a></li><li><a href="#54-买卖股票的最佳时机-iv">5.4. 买卖股票的最佳时机 IV</a></li><li><a href="#55-最佳买卖股票时机含冷冻期">5.5. 最佳买卖股票时机含冷冻期</a></li><li><a href="#56-买卖股票的最佳时机含手续费">5.6. 买卖股票的最佳时机含手续费</a></li><li><a href="#57-总结">5.7. 总结</a></li></ul></li><li><a href="#6-打家劫舍">6. 打家劫舍</a><ul><li><a href="#61-打家劫舍-i">6.1. 打家劫舍 I</a></li><li><a href="#62-打家劫舍-ii">6.2. 打家劫舍 II</a></li><li><a href="#63-打家劫舍iii">6.3. 打家劫舍III</a></li><li><a href="#64-总结">6.4. 总结</a></li></ul></li><li><a href="#7-最长回文子串">7. 最长回文子串</a></li><li><a href="#8-回文子串">8. 回文子串</a></li><li><a href="#9-背包问题">9. 背包问题</a><ul><li><a href="#91-0-1背包问题">9.1. 0-1背包问题</a></li><li><a href="#92-背包初始化问题">9.2. 背包初始化问题</a></li><li><a href="#93-完全背包问题">9.3. 完全背包问题</a></li><li><a href="#94-多重背包问题">9.4. 多重背包问题</a></li><li><a href="#95-二维背包问题">9.5. 二维背包问题</a></li><li><a href="#96-分割等和子集">9.6. 分割等和子集</a></li><li><a href="#97-一和零">9.7. 一和零</a></li><li><a href="#98-目标和">9.8. 目标和</a></li><li><a href="#99-零钱兑换">9.9. 零钱兑换</a></li><li><a href="#910-零钱兑换-ii">9.10. 零钱兑换 II</a></li><li><a href="#911-完全平方数">9.11. 完全平方数</a></li><li><a href="#912-整数拆分">9.12. 整数拆分</a></li></ul></li><li><a href="#10-路径问题">10. 路径问题</a><ul><li><a href="#101-不同路径">10.1. 不同路径</a></li><li><a href="#102-不同路径ii">10.2. 不同路径II</a></li><li><a href="#103-下降路径最小和">10.3. 下降路径最小和</a></li><li><a href="#104-下降路径最小和ii">10.4. 下降路径最小和II</a></li><li><a href="#105-最小路径和">10.5. 最小路径和</a></li><li><a href="#106-三角形最小路径和">10.6. 三角形最小路径和</a></li></ul></li><li><a href="#11-统计全为1的正方形子矩形">11. 统计全为1的正方形子矩形</a></li><li><a href="#12-最大正方形">12. 最大正方形</a></li><li><a href="#13-最长上升子序列问题">13. 最长上升子序列问题</a><ul><li><a href="#131-最长上升子序列">13.1. 最长上升子序列</a></li><li><a href="#132-无重叠区间">13.2. 无重叠区间</a></li></ul></li><li><a href="#14-动态规划--博弈问题">14. 动态规划—博弈问题</a><ul><li><a href="#141-石子游戏">14.1. 石子游戏</a></li><li><a href="#142-预测赢家">14.2. 预测赢家</a></li></ul></li><li><a href="#15-总结">15. 总结</a></li></ul><!-- /TOC --><h1><span id="2-剪绳子">2. 剪绳子</span></h1><p>给你一根长度为 n 的绳子，请把绳子剪成整数长度的 m 段（m、n都是整数，n&gt;1并且m&gt;1），每段绳子的长度记为 k[0],k[1]…k[m-1] 。请问 k[0]<em>k[1]</em>…*k[m-1] 可能的最大乘积是多少？例如，当绳子的长度是8时，我们把它剪成长度分别为2、3、3的三段，此时得到的最大乘积是18。</p><p>注意：m&gt;1，说明必须要切分，例如长度为2，必须要切分成1+1</p><p>链接：<a href="https://leetcode-cn.com/problems/jian-sheng-zi-lcof" target="_blank" rel="noopener">https://leetcode-cn.com/problems/jian-sheng-zi-lcof</a></p><p><strong>【方法一】</strong><br>使用动态规划解决。<br>首先需要明确<code>dp[i]</code>的含义：<code>dp[i]</code>表示长度为i的绳子所能产生的最大乘积。</p><p>这道题的本质就是：给定一个数字n，然后对数字n进行分解，使得分解的乘积最大，即动态规划中的最大乘积问题</p><p>状态转移公式：<code>dp[i] = max(dp[i],max(j*(i-j),j*dp[i-j]))</code>,</p><p>首先给一个绳子有三种切割的方式</p><ul><li>不切割绳子，乘积不变，依然是<code>dp[i]</code></li><li>切成长度为<code>j</code>和<code>i-j</code>，并且剪下来的<code>i-j</code>不再分割，乘积为<code>j*(i-j)</code></li><li>先切成长度为<code>j</code>和<code>i-j</code>，然后再继续对<code>i-j</code>进行分割，乘积为<code>j*dp(i-j)</code></li></ul><p>最终的结果是这三种乘积的最大值，即状态转移方程为<br><code>dp[i]=max(dp[i],max( j*(i-j) , j*dp[i-j] ))</code></p><ul><li>初始化<br>绳子长度n最小为2<br>dp[2]=1<br>dp[3]=2<br>dp[4]=4</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">cuttingRope</span><span class="params">(self, n)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type n: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="comment">#状态转移公式</span></span><br><span class="line">        <span class="comment">#dp[i] = max(dp[i],max(j*(i-j),j*dp[i-j]))</span></span><br><span class="line">        dp = [<span class="number">0</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(n+<span class="number">1</span>)]<span class="comment">#从0~n</span></span><br><span class="line">        dp[<span class="number">2</span>]=<span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">3</span>,n+<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(i):</span><br><span class="line">                dp[i] = max(dp[i],max(j*(i-j),j*dp[i-j]))</span><br><span class="line">        <span class="keyword">return</span> dp[n]</span><br></pre></td></tr></table></figure><p><strong>【方法二】</strong><br>找规律，也是贪心法则</p><ul><li>如果绳子长度&gt;=5,则尽可能多的切分成3</li><li>绳子长度为4，分成2+2</li><li>绳子长度为3，切分1+2</li><li>绳子长度为2，分成1+1</li></ul><p>总结如下,绳子长度为L：</p><ul><li>L&lt;3,切分成1+(L-1)</li><li>L&gt;=3<ul><li>L%3==0：全部划分为3</li><li>L%3==1：先划分成2+2，然后把剩下的划分为3</li><li>L%3==2：先划分成1个2，然后把剩下的划分成3 </li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">cuttingRope</span><span class="params">(self, n)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type n: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> n &lt;= <span class="number">3</span>:<span class="keyword">return</span> <span class="number">1</span>*(n<span class="number">-1</span>)</span><br><span class="line">        res = <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> n % <span class="number">3</span> == <span class="number">1</span>:</span><br><span class="line">            res = <span class="number">4</span></span><br><span class="line">            n -= <span class="number">4</span></span><br><span class="line">        <span class="keyword">elif</span> n % <span class="number">3</span> == <span class="number">2</span>:</span><br><span class="line">            res = <span class="number">2</span></span><br><span class="line">            n -= <span class="number">2</span></span><br><span class="line">        <span class="keyword">while</span> n:</span><br><span class="line">            res *= <span class="number">3</span></span><br><span class="line">            n -= <span class="number">3</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h1><span id="3-最大子序列和">3. 最大子序列和</span></h1><p>给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。<br><a href="https://leetcode-cn.com/problems/maximum-subarray/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/maximum-subarray/</a></p><p><strong>【方法一】</strong><br>动态规划<br>dp[i]表示以nums[i]为结尾的最大子序列和<br>dp[0]=nums[0]<br><code>dp[i]=max(dp[i-1]+nums[i],nums[i])</code><br>dp[i]的最大值就是看当前元素nums[i]应该单独成一段，还是加入到上一段中dp[i-1]，所以需要从2个中找最大值。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxSubArray</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="comment">#dp[i]表示nums中以i为结尾的最大和</span></span><br><span class="line">        dp = [<span class="number">0</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums))]</span><br><span class="line">        dp[<span class="number">0</span>] = nums[<span class="number">0</span>]</span><br><span class="line">        <span class="comment">#dp[i] = max(dp[i-1]+nums[i],nums[i])</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,len(nums)):</span><br><span class="line">            dp[i] = max(dp[i<span class="number">-1</span>]+nums[i],nums[i])</span><br><span class="line">        <span class="keyword">return</span> max(dp)</span><br></pre></td></tr></table></figure><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(n)</li></ul><p><strong>【优化】</strong><br>上面方法的空间复杂度是O(n),因为dp需要存储n个数的最大值。但其实在计算dp[i]的时候，只需要用到dp[i-1]，其余都没用，所以我们可以将空间复杂度降到O(1),只保留dp[i-1]的值</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxSubArray</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        dp = nums[<span class="number">0</span>]</span><br><span class="line">        res = dp</span><br><span class="line">        <span class="comment">#dp[i] = max(dp[i-1]+nums[i],nums[i])</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,len(nums)):</span><br><span class="line">            dp = max(dp+nums[i],nums[i])</span><br><span class="line">            res = max(res,dp)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><p><strong>【方法二】</strong><br>使用贪心算法，从左向右遍历，一个个数字相加，使用sum记录当前遍历的和，max记录当前遍历和的最大值。如果sum&lt;0，则将sum更新为当前元素的值，重新找新的子序串，然后将sum和max比较，将max更新为较大的值</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxSubArray</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        sub_sum = nums[<span class="number">0</span>]</span><br><span class="line">        res = nums[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,len(nums)):</span><br><span class="line">            <span class="keyword">if</span> sub_sum &lt; <span class="number">0</span>:</span><br><span class="line">                sub_sum = nums[i]</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                sub_sum += nums[i]</span><br><span class="line">            res = max(res,sub_sum)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h1><span id="4-乘积最大子数组">4. 乘积最大子数组</span></h1><p>给你一个整数数组 nums ，请你找出数组中乘积最大的连续子数组（该子数组中至少包含一个数字），并返回该子数组所对应的乘积。</p><p>示例 1:</p><p>输入: [2,3,-2,4]<br>输出: 6<br>解释: 子数组 [2,3] 有最大乘积 6。</p><p>链接：<a href="https://leetcode-cn.com/problems/maximum-product-subarray" target="_blank" rel="noopener">https://leetcode-cn.com/problems/maximum-product-subarray</a></p><p><strong>【分析一】</strong></p><p>乘积的最大值和和不同，两个负数相乘为正数。一个最大的正数乘以负数会变成最小值。因此最大值和最小值是相互转换的，我们可以将这种转换关系设计到状态转移方程中。<br>在遍历到<code>nums[i]</code>时，当前乘积的最大值可能由<code>pre_max</code>转换，也可能由<code>pre_min</code>转换得到，也可能是当前值。<br><code>cur_max=max(pre_max*nums[i],pre_min*nums[i],nums[i])</code><br><code>cur_min=min(pre_max*nums[i],pre_min*nums[i],nums[i])</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxProduct</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        pre_max = nums[<span class="number">0</span>]</span><br><span class="line">        pre_min = nums[<span class="number">0</span>]</span><br><span class="line">        res = nums[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,len(nums)):</span><br><span class="line">            cur_max = max(pre_max*nums[i],pre_min*nums[i],nums[i])</span><br><span class="line">            cur_min = min(pre_max*nums[i],pre_min*nums[i],nums[i])</span><br><span class="line">            res = max(res,cur_max)</span><br><span class="line"></span><br><span class="line">            pre_max = cur_max</span><br><span class="line">            pre_min = cur_min</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h1><span id="5-股票问题">5. 股票问题</span></h1><h2><span id="51-买卖股票的最佳时机">5.1. 买卖股票的最佳时机</span></h2><p>给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。</p><p>如果你最多只允许完成一笔交易（即买入和卖出一支股票一次），设计一个算法来计算你所能获取的最大利润。</p><p>注意：你不能在买入股票前卖出股票。</p><p>链接：<a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock" target="_blank" rel="noopener">https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock</a></p><p><strong>【方法一】</strong><br>一次遍历，记录前i天的最低价格和最大利润</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxProfit</span><span class="params">(self, prices)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type prices: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> prices:<span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="comment">#对于每个价格，记录在它之前的最低价格，求差值，然后和算出来的最大利润比较</span></span><br><span class="line">        <span class="comment">#如果当前差值大于以前的利润，修改max_profile</span></span><br><span class="line">        min_pricce = prices[<span class="number">0</span>]</span><br><span class="line">        max_profile = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> price <span class="keyword">in</span> prices:</span><br><span class="line">            min_pricce = min(min_pricce,price)</span><br><span class="line">            max_profile = max(max_profile,price-min_pricce)</span><br><span class="line">        <span class="keyword">return</span> max_profile</span><br></pre></td></tr></table></figure><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(1)</li></ul><p><strong>【分析二】</strong></p><p>定义二维dp，<br><code>dp[i][j]</code>表示在第i天结束时，用户的持股状态为<code>j</code>的最大利润。<br><code>j</code>只有2个值，dp[i][0]和dp[i][1]</p><p><code>dp[i][0]</code>表示在第i天手里没有股票时的最大利润<br><code>dp[i][1]</code>表示在第i天手里有股票的最大利润</p><p>考虑<code>dp[i][0]</code>第i天没有股票</p><ul><li>可能是第i-1天手里也没有股票，然后第i天也没有买入，此时<code>dp[i][0]=dp[i-1][0]</code></li><li>可能是第i-1天手里有股票，在第i天买了，此时最大利润为<code>dp[i][0]=dp[i-1][1]+prices[i]</code></li></ul><p>综上所示<code>dp[i][0]=max(dp[i-1][0],dp[i-1][1]+prices[i])</code></p><p><code>dp[i][1]</code>第i天手里有股票</p><ul><li>可能是第i-1天手里也有股票，第i天也没有卖,<code>dp[i][1]=dp[i-1][1]</code></li><li>也可能是第i-1天手里没有股票，在第i天买了一个股票，因为题目要求只能买一次，所以第i-1天的最大利润为0，<code>dp[i][1]=dp[i-1][0]-prices[i]=-prices[i]</code></li></ul><p>综上所示<code>dp[i][1]=max(dp[i-1][1],-prices[i])</code></p><p><strong>考虑初始化</strong></p><ul><li>第0天手里没有股票，<code>dp[0][0]=0</code></li><li>第0天手里有股票，<code>dp[0][0]=-prices[0]</code></li></ul><p>本题要求买股票的最大利润，也就是在最后一天手里没有股票的最大收益<code>dp[n-1][0]</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxProfit</span><span class="params">(self, prices)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type prices: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">#dp[i][0] = max(dp[i-1][0],dp[i-1][1]+prices[i])</span></span><br><span class="line">        <span class="comment">#dp[i][1] = max(d[i-1][1],-prices[i])</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> prices:<span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        n = len(prices)</span><br><span class="line">        dp = [[<span class="number">0</span>,<span class="number">0</span>] <span class="keyword">for</span> _ <span class="keyword">in</span> range(n)]</span><br><span class="line"></span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">1</span>] = -prices[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,n):</span><br><span class="line">            dp[i][<span class="number">0</span>] = max(dp[i<span class="number">-1</span>][<span class="number">0</span>],dp[i<span class="number">-1</span>][<span class="number">1</span>]+prices[i])</span><br><span class="line">            dp[i][<span class="number">1</span>] = max(dp[i<span class="number">-1</span>][<span class="number">1</span>],-prices[i])</span><br><span class="line">        <span class="keyword">return</span> dp[n<span class="number">-1</span>][<span class="number">0</span>]</span><br></pre></td></tr></table></figure><p><strong>【分析三】</strong></p><p>对方法二进行优化，发现<code>dp[i]</code>只和<code>dp[i-1]</code>有关，所以压缩为一维矩阵</p><p><code>dp[0] = max(dp[0],dp[1]+prices[i])</code><br><code>dp[1] = max(d[1],-prices[i])</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxProfit</span><span class="params">(self, prices)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type prices: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="comment">#对其进行优化</span></span><br><span class="line">        <span class="comment">#发现dp[i]之和dp[i-1]有关</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> prices:<span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        n = len(prices)</span><br><span class="line">        dp = [<span class="number">0</span>,<span class="number">0</span>]</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">        dp[<span class="number">1</span>] = -prices[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,n):</span><br><span class="line">            dp[<span class="number">0</span>] = max(dp[<span class="number">0</span>],dp[<span class="number">1</span>]+prices[i])</span><br><span class="line">            dp[<span class="number">1</span>] = max(dp[<span class="number">1</span>],-prices[i])</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">0</span>]</span><br></pre></td></tr></table></figure><h2><span id="52-买卖股票的最佳时机-ii">5.2. 买卖股票的最佳时机 II</span></h2><p>给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。</p><p>设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。</p><p>注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</p><blockquote><p>输入: [7,1,5,3,6,4]<br>输出: 7<br>解释: 在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格=5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。随后，在第 4 天（股票价格=3）的时候买入，在第 5 天（股票价格=6）的时候卖出, 这笔交易所能获得利润 = 6-3 = 3 </p></blockquote><p>链接：<a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii" target="_blank" rel="noopener">https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii</a></p><p><strong>【方法一】</strong></p><p>使用贪心算法只需要一次遍历。其主要想法是逢低便买入，逢高便卖出，即只要明天的价格大于今天的价格，就在今天买下，明天卖出。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxProfit</span><span class="params">(self, prices)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type prices: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="comment">#贪心算法，只遵循一个原则：低价买入，高价出售</span></span><br><span class="line">        <span class="comment">#只要明天的价格比今天高，就买今天的，然后明天卖出，获得差价利润</span></span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(prices)<span class="number">-1</span>):</span><br><span class="line">            diff = prices[i+<span class="number">1</span>] - prices[i]</span><br><span class="line">            <span class="keyword">if</span> diff&gt;<span class="number">0</span>:</span><br><span class="line">                res+=diff</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><p><strong>【方法二】</strong></p><p>问题1：只能买一次<br>问题2：可以买无限次</p><p>一般能用贪心算法解决的，都可以使用动态规划算法。<br>定义dp，使用二维矩阵<br><code>dp[i][j]</code>:表示第i天结束时的状态为j的最大利润，<code>dp[i][0]</code>表示在第i天手里没有股票的最大利润，dp[i][1]表示第i天手里持有股票的最大利润</p><p><strong>状态转移方程</strong></p><p>对于dp[i][0]和dp[i][1]的状态转移需要分情况讨论</p><ul><li>dp[i][0]第i天持有现金状态<ul><li>第i-1天持有股票，第i天卖出股票：<code>dp[i][0]=dp[i-1][1]+prices[i]</code></li><li>第i-1天没有股票，第i天也没有股票：<code>dp[i][0]=dp[i-1][0]</code></li></ul></li></ul><p>最终<code>dp[i][0]=max(dp[i-1][1]+prices[i],dp[i-1][0])</code></p><ul><li><code>dp[i][1]</code>第i天持有股票状态<ul><li>第i-1天没有股票，第i天买入股票：<code>dp[i][1]=dp[i-1][0]-prices[i]</code><br><strong>这里和只买卖一次的问题不同，只买卖一次，在第i-1天没有股票，第i天买入股票，利润只能是<code>-prices[i]</code>，因此只能买卖一次，在第i天买入了，说明前面都没有交易</strong></li><li>第i-1天有股票，第i天没有卖出：<code>dp[i][1]=dp[i-1][1]</code></li></ul></li></ul><p>最终<code>dp[i][1]=max(dp[i-1][0]-prices[i],dp[i-1][1])</code> </p><p><strong>初始化</strong></p><ul><li><code>dp[0][0]</code>表示持有现金，则最大利润为0，<code>dp[0][0]=0</code></li><li><code>dp[0][1]</code>表示持有股票，则最大利润为<code>dp[0][1]=-prices[0]</code>。</li></ul><p>最终返回的结果是最后一天的最大利润，最后一天手里不能有任何股票，全都卖出，即dp[-1][0]</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxProfit</span><span class="params">(self, prices)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type prices: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="comment">#动态规划</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> prices:<span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        dp = [[<span class="number">0</span>,<span class="number">0</span>] <span class="keyword">for</span> i <span class="keyword">in</span> range(len(prices))]</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">0</span></span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">1</span>]=-prices[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,len(prices)):</span><br><span class="line">            dp[i][<span class="number">0</span>] = max(dp[i<span class="number">-1</span>][<span class="number">1</span>]+prices[i],dp[i<span class="number">-1</span>][<span class="number">0</span>])</span><br><span class="line">            dp[i][<span class="number">1</span>] = max(dp[i<span class="number">-1</span>][<span class="number">0</span>]-prices[i],dp[i<span class="number">-1</span>][<span class="number">1</span>])</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">-1</span>][<span class="number">0</span>]</span><br></pre></td></tr></table></figure><h2><span id="53-买卖股票的最佳时机-iii">5.3. 买卖股票的最佳时机 III</span></h2><p>给定一个数组，它的第 i 个元素是一支给定的股票在第 i 天的价格。</p><p>设计一个算法来计算你所能获取的最大利润。你最多可以完成 两笔 交易。</p><p>注意: 你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</p><p>链接：<a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iii" target="_blank" rel="noopener">https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iii</a></p><p><strong>【分析一】</strong></p><p>以前的dp都是一维或二维，本题因为说交易次数最多为2次，因此交易次数也需要当成一个新的维度考虑在dp中，所以dp变成三维。<code>dp[i][k][j]</code>，三个维度表示：天数i（i=0,1,…n-1），<strong>买入股票的次数</strong>（k=0,1,2），<strong>每买一次交易次数加1</strong>，是否持有股票（0表示没有股票，1表示持有股票）。买入股票的次数为k时，隐含了卖出股票的次数为k或k-1。<br>状态转移方程有2个</p><ul><li><code>dp[i][k][0]</code>第i天没有股票<ol><li>第i-1天也没有股票，第i天什么都没做：<code>dp[i][k][0]=dp[i-1][k][0]</code></li><li>第i-1天有股票，第i天卖了：<code>dp[i][k][0]=dp[i-1][k][1]+prices[i]</code></li></ol></li></ul><p><code>dp[i][k][0]=max(dp[i-1][k][0],dp[i-1][k][1]+prices[i])</code></p><ul><li><code>dp[i][k][1]</code>第i天有股票<ol><li>第i-1天也有股票，第i天什么都没做：<code>dp[i][k][1]=dp[i-1][k][1]</code></li><li>第i-1天没有股票，第i天买了股票：<code>dp[i][k][1]=dp[i-1][k-1][0]-prices[i]</code></li></ol></li></ul><p><code>dp[i][k][1]=max(dp[i-1][k][1],dp[i-1][k-1][0]-prices[i])</code></p><p>定义好状态转移矩阵，上面只对第三个维度进行遍历，下面初始化dp的i和k</p><ul><li>i=0，第1天<br><code>for k in range(1,k)</code>:对每个k初始化i=0，因为下面的已经包含k=0了，这里从k=1开始遍历<ol><li><code>dp[0][k][0]</code>：第1天没有买股票，<code>dp[0][k][0]=0</code></li><li><code>dp[0][k][1]</code>：第1天买了股票，<code>dp[0][k][1]=-prices[0]</code></li></ol></li><li>k=0，买入股票次数为0<br>for _i in range(i)，对每个i初始化k=0，因为i=0已经在<ol><li><code>dp[i][0][0]</code>：在第i天从来没有买过股票，<code>dp[i][0][0]=0</code></li><li><code>dp[i][0][1]</code>：在第i天从来没有股票，所以也不可能持股，即利润为负无穷，<code>dp[i][0][1]=-float(&#39;inf&#39;)</code></li></ol></li></ul><p>以前2种遍历有重叠的部分：</p><ul><li><code>dp[0][0][0]=0</code></li><li><code>dp[0][0][1]=-float(&#39;inf&#39;)</code></li></ul><p><strong>返回值</strong></p><p>返回值<code>dp[i][k][j]</code>中的i肯定是最后一天即i=n-1，j肯定是手里没有股票，j=0，然后遍历不同的k=0，1，2表示买入0次，1次，2次的最大利润，然后返回最大值</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxProfit</span><span class="params">(self, prices)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type prices: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        n = len(prices)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> prices:<span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        dp = [[[<span class="number">0</span>,<span class="number">0</span>] <span class="keyword">for</span> k <span class="keyword">in</span> range(<span class="number">3</span>)] <span class="keyword">for</span> i <span class="keyword">in</span> range(n)]</span><br><span class="line">        <span class="comment">#初始化，当i=0时</span></span><br><span class="line">        <span class="keyword">for</span> k <span class="keyword">in</span> range(<span class="number">1</span>,<span class="number">3</span>):</span><br><span class="line">            dp[<span class="number">0</span>][k][<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">            dp[<span class="number">0</span>][k][<span class="number">1</span>] = -prices[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">            dp[i][<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">            dp[i][<span class="number">0</span>][<span class="number">1</span>] = -float(<span class="string">'inf'</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 状态转移</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,n):</span><br><span class="line">            <span class="keyword">for</span> k <span class="keyword">in</span> range(<span class="number">1</span>,<span class="number">3</span>):</span><br><span class="line">                dp[i][k][<span class="number">0</span>]=max(dp[i<span class="number">-1</span>][k][<span class="number">0</span>],dp[i<span class="number">-1</span>][k][<span class="number">1</span>]+prices[i])</span><br><span class="line">                dp[i][k][<span class="number">1</span>]=max(dp[i<span class="number">-1</span>][k][<span class="number">1</span>],dp[i<span class="number">-1</span>][k<span class="number">-1</span>][<span class="number">0</span>]-prices[i])</span><br><span class="line">        </span><br><span class="line">        res = -float(<span class="string">'inf'</span>)</span><br><span class="line">        <span class="keyword">for</span> k <span class="keyword">in</span> range(<span class="number">3</span>):</span><br><span class="line">            <span class="keyword">if</span> dp[n<span class="number">-1</span>][k][<span class="number">0</span>]&gt;res:</span><br><span class="line">                res = dp[n<span class="number">-1</span>][k][<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h2><span id="54-买卖股票的最佳时机-iv">5.4. 买卖股票的最佳时机 IV</span></h2><p>给定一个数组，它的第 i 个元素是一支给定的股票在第 i 天的价格。</p><p>设计一个算法来计算你所能获取的最大利润。你最多可以完成 k 笔交易。</p><p>注意: 你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</p><p>链接：<a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iv" target="_blank" rel="noopener">https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iv</a></p><p><strong>【分析一】</strong></p><p>和上一题一样，只是把原先的2换成k，其余代码不变，但是提交时，出现内存溢出的错误，因为当k较大时，比如k=1000000000，dp[i][k][j]占用的空间太大。所以需要对此进行优化。<br>prices中有n天的价格，题目要求需要交易k次，因为有效的交易由买入和卖出组成，至少需要2天，所以有效的交易（有买有卖）次数限制k应该&lt;=n/2，如果k&gt;n/2，就没有约束作用了，相当于k=inf，这和leetcode122题一样。<br>所以代码分成2部分，</p><ul><li>if k&gt;n/2，按照leetcode122的解法（贪心）</li><li>else，按照leetcode123的解法（动态规划）</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxProfit</span><span class="params">(self, k, prices)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type k: int</span></span><br><span class="line"><span class="string">        :type prices: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        n = len(prices)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> prices:<span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> k&gt;n/<span class="number">2</span>:</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(n<span class="number">-1</span>):</span><br><span class="line">                diff = prices[i+<span class="number">1</span>]-prices[i]</span><br><span class="line">                <span class="keyword">if</span> diff&gt;<span class="number">0</span>:</span><br><span class="line">                    res+=diff</span><br><span class="line">            <span class="keyword">return</span> res</span><br><span class="line">        <span class="keyword">else</span>:    </span><br><span class="line">            dp = [[[<span class="number">0</span>,<span class="number">0</span>] <span class="keyword">for</span> _ <span class="keyword">in</span> range(k+<span class="number">1</span>)] <span class="keyword">for</span> i <span class="keyword">in</span> range(n)]</span><br><span class="line">            <span class="comment">#初始化，当i=0时</span></span><br><span class="line">            <span class="keyword">for</span> _k <span class="keyword">in</span> range(<span class="number">1</span>,k+<span class="number">1</span>):</span><br><span class="line">                dp[<span class="number">0</span>][_k][<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">                dp[<span class="number">0</span>][_k][<span class="number">1</span>] = -prices[<span class="number">0</span>]</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">                dp[i][<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">                dp[i][<span class="number">0</span>][<span class="number">1</span>] = -float(<span class="string">'inf'</span>)</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 状态转移</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,n):</span><br><span class="line">                <span class="keyword">for</span> _k <span class="keyword">in</span> range(<span class="number">1</span>,k+<span class="number">1</span>):</span><br><span class="line">                    dp[i][_k][<span class="number">0</span>]=max(dp[i<span class="number">-1</span>][_k][<span class="number">0</span>],dp[i<span class="number">-1</span>][_k][<span class="number">1</span>]+prices[i])</span><br><span class="line">                    dp[i][_k][<span class="number">1</span>]=max(dp[i<span class="number">-1</span>][_k][<span class="number">1</span>],dp[i<span class="number">-1</span>][_k<span class="number">-1</span>][<span class="number">0</span>]-prices[i])</span><br><span class="line">            <span class="keyword">return</span> dp[<span class="number">-1</span>][<span class="number">-1</span>][<span class="number">0</span>]</span><br></pre></td></tr></table></figure><h2><span id="55-最佳买卖股票时机含冷冻期">5.5. 最佳买卖股票时机含冷冻期</span></h2><p>给定一个整数数组，其中第 i 个元素代表了第 i 天的股票价格 。​</p><p>设计一个算法计算出最大利润。在满足以下约束条件下，你可以尽可能地完成更多的交易（多次买卖一支股票）:</p><ul><li>你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</li><li>卖出股票后，你无法在第二天买入股票 (即冷冻期为 1 天)。</li></ul><p>链接：<a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-cooldown" target="_blank" rel="noopener">https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-cooldown</a></p><blockquote><p>输入: [1,2,3,0,2]<br>输出: 3<br>解释: 对应的交易状态为: [买入, 卖出, 冷冻期, 买入, 卖出]</p></blockquote><p><strong>【分析一】</strong></p><p>该题和leetcode122类似，除了增加冷冻期。<br>同样定义dp，使用二维矩阵<br>dp[i][j]:第一维dp[i]表示前i天能获得的最大利润，第二维dp[i][j]表示在第i天手里有没有股票，dp[i][0]表示没有股票，手里持有现金时的最大利润，dp[i][1]表示持有股票的最大利润</p><p>对于dp[i][0]和dp[i][1]的状态转移需要分情况讨论</p><ul><li>dp[i][0]第i天持有现金状态<ul><li>第i-1天持有股票，第i天卖出股票：dp[i][0]=dp[i-1][1]+prices[i]</li><li>第i-1天没有股票，第i天也没有股票：dp[i][0]=dp[i-1][0]<br>最终dp[i][0]从以上2种情况选最大的作为最终利润 </li></ul></li></ul><p>下面这个转移公式与122题有变化。因为增加了冷冻期，在第i天买入股票，状态要从i-2天转移，因为第i-1天是冷冻期。</p><ul><li>dp[i][1]第i天持有股票状态<ul><li>第i-2天卖出股票，第i-1天是冷冻期，第i天买入股票：dp[i][1]=dp[i-2][0]-prices[i]</li><li>第i-1天有股票，第i天没有卖出：dp[i][1]=dp[i-1][1]<br>最终dp[i][1]从以上2种情况选最大的作为最终利润 </li></ul></li></ul><p>对dp进行初始化</p><ul><li>第一天，dp[0][0]表示持有现金，则最大利润为0，dp[0][0]=0</li><li>dp[0][1]表示第一天持有股票，则最大利润为dp[0][1]=-prices[0]</li><li>dp[1][0]表示第2天持有现金，有2种可能：（1）昨天也是持有现金dp[0][0],（2）昨天持有股票，今天卖了，dp[0][1]+prices[1]</li><li>dp[1][1]表示第2天持有股票，有2种情况：（1）昨天也持有股票dp[0][1]，（2）昨天持有现金，今天买了股票dp[0][0]-prices[1]</li></ul><p>最终返回的结果是最后一天的最大利润，最后一天手里不能有任何股票，全都卖出，即dp[-1][0]</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxProfit</span><span class="params">(self, prices)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type prices: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        n = len(prices)</span><br><span class="line">        <span class="keyword">if</span> n&lt;=<span class="number">1</span>:<span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        dp = [[<span class="number">0</span>,<span class="number">0</span>] <span class="keyword">for</span> i <span class="keyword">in</span> range(n)]</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">0</span></span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">1</span>]=-prices[<span class="number">0</span>]</span><br><span class="line">        dp[<span class="number">1</span>][<span class="number">0</span>]=max(dp[<span class="number">0</span>][<span class="number">0</span>],dp[<span class="number">0</span>][<span class="number">1</span>]+prices[<span class="number">1</span>])</span><br><span class="line">        dp[<span class="number">1</span>][<span class="number">1</span>]=max(dp[<span class="number">0</span>][<span class="number">1</span>],dp[<span class="number">0</span>][<span class="number">0</span>]-prices[<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>,n):</span><br><span class="line">            dp[i][<span class="number">0</span>]=max(dp[i<span class="number">-1</span>][<span class="number">0</span>],dp[i<span class="number">-1</span>][<span class="number">1</span>]+prices[i])</span><br><span class="line">            dp[i][<span class="number">1</span>]=max(dp[i<span class="number">-1</span>][<span class="number">1</span>],dp[i<span class="number">-2</span>][<span class="number">0</span>]-prices[i])</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">-1</span>][<span class="number">0</span>]</span><br></pre></td></tr></table></figure><h2><span id="56-买卖股票的最佳时机含手续费">5.6. 买卖股票的最佳时机含手续费</span></h2><p>给定一个整数数组 prices，其中第 i 个元素代表了第 i 天的股票价格 ；非负整数 fee 代表了交易股票的手续费用。</p><p>你可以无限次地完成交易，但是你每笔交易都需要付手续费。如果你已经购买了一个股票，在卖出它之前你就不能再继续购买股票了。</p><p>返回获得利润的最大值。</p><p>注意：这里的一笔交易指买入持有并卖出股票的整个过程，每笔交易你只需要为支付一次手续费。</p><p>链接：<a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with" target="_blank" rel="noopener">https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with</a></p><p><strong>【分析】</strong><br>这道题在leetcode122的基础上改进，每卖出一个股票就要支付手续费。</p><p>定义dp，使用二维矩阵<br>dp[i][j]:第一维dp[i]表示前i天能获得的最大利润，第二维dp[i][j]表示在第i天手里有没有股票，dp[i][0]表示没有股票，手里持有现金时的最大利润，dp[i][1]表示持有股票的最大利润<br>第一天，dp[0][0]表示持有现金，则最大利润为0，dp[0][0]=0；dp[0][1]表示持有股票，则最大利润为dp[0][1]=-prices[0]。<br>对于dp[i][0]和dp[i][1]的状态转移需要分情况讨论</p><ul><li><p>dp[i][0]第i天持有现金状态</p><ul><li>第i-1天持有股票，第i天卖出股票：dp[i][0]=dp[i-1][1]+prices[i]-fee</li><li>第i-1天没有股票，第i天也没有股票：dp[i][0]=dp[i-1][0]<br>最终dp[i][0]从以上2种情况选最大的作为最终利润 </li></ul></li><li><p>dp[i][1]第i天持有股票状态</p><ul><li>第i-1天没有股票，第i天买入股票：dp[i][1]=dp[i-1][0]-prices[i]</li><li>第i-1天有股票，第i天没有卖出：dp[i][1]=dp[i-1][1]<br>最终dp[i][1]从以上2种情况选最大的作为最终利润 </li></ul></li></ul><p>最终返回的结果是最后一天的最大利润，最后一天手里不能有任何股票，全都卖出，即dp[-1][0]</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxProfit</span><span class="params">(self, prices, fee)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type prices: List[int]</span></span><br><span class="line"><span class="string">        :type fee: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        n = len(prices)</span><br><span class="line">        <span class="keyword">if</span> n==<span class="number">0</span>:<span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        dp = [[<span class="number">0</span>,<span class="number">0</span>] <span class="keyword">for</span> i <span class="keyword">in</span> range(n)]</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">0</span></span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">1</span>]=-prices[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,n):</span><br><span class="line">            dp[i][<span class="number">0</span>]=max(dp[i<span class="number">-1</span>][<span class="number">0</span>],dp[i<span class="number">-1</span>][<span class="number">1</span>]+prices[i]-fee)</span><br><span class="line">            dp[i][<span class="number">1</span>]=max(dp[i<span class="number">-1</span>][<span class="number">1</span>],dp[i<span class="number">-1</span>][<span class="number">0</span>]-prices[i])</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">-1</span>][<span class="number">0</span>]</span><br></pre></td></tr></table></figure><h2><span id="57-总结">5.7. 总结</span></h2><p>对以上6个问题做一个分类</p><ul><li>Leetcode121：只交易一次（k=1，贪心或DP）</li><li>Leetcode122：不限交易次数（k=inf，贪心或二维DP）<ul><li>Leetcode309：不限交易次数（k=inf），但有冷冻期的条件</li><li>Leetcode714：不限交易次数（k=inf），但有手续费的条件</li></ul></li><li>Leetcode188：最多交易k次（三维DP）<ul><li>Leetcode123：最多交易2次（k=2，三维DP）</li></ul></li></ul><h1><span id="6-打家劫舍">6. 打家劫舍</span></h1><h2><span id="61-打家劫舍-i">6.1. 打家劫舍 I</span></h2><p>你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。</p><p>给定一个代表每个房屋存放金额的非负整数数组，计算你 不触动警报装置的情况下 ，一夜之内能够偷窃到的最高金额。</p><p>链接：<a href="https://leetcode-cn.com/problems/house-robber" target="_blank" rel="noopener">https://leetcode-cn.com/problems/house-robber</a></p><p>输入：[1,2,3,1]<br>输出：4<br>解释：偷窃 1 号房屋 (金额 = 1) ，然后偷窃 3 号房屋 (金额 = 3)。<br>     偷窃到的最高金额 = 1 + 3 = 4 。</p><p><strong>【分析一】</strong></p><p><code>dp[i]</code>表示在第i家的最大金额。<br>动态转移方程：<br><code>dp[i] = max(dp[i-2]+nums[i],dp[i-1])</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">rob</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> nums:<span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> len(nums)&lt;=<span class="number">2</span>:<span class="keyword">return</span> max(nums)</span><br><span class="line">        <span class="comment">#dp[i]表示偷到的i个房屋所获得的最大金额</span></span><br><span class="line">        dp = [<span class="number">0</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums))]</span><br><span class="line">        <span class="comment">#dp[i] = max(dp[i-2]+nums[i],dp[i-1])</span></span><br><span class="line">        dp[<span class="number">0</span>] = nums[<span class="number">0</span>]</span><br><span class="line">        dp[<span class="number">1</span>] = max(nums[<span class="number">0</span>],nums[<span class="number">1</span>])</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>,len(nums)):</span><br><span class="line">            dp[i] = max(dp[i<span class="number">-2</span>]+nums[i],dp[i<span class="number">-1</span>])</span><br><span class="line">        <span class="keyword">return</span> max(dp)</span><br></pre></td></tr></table></figure><p><strong>【优化】</strong></p><p>观察动态转移方程，dp[i]只和dp[i-2]和dp[i-1]有关，所以只用2个变量来保存这2个值就可以了，不用数组来保存。<br><code>dp[i] = max(dp[i-2]+nums[i],dp[i-1])</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> nums:<span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> len(nums)&lt;=<span class="number">2</span>:<span class="keyword">return</span> max(nums)</span><br><span class="line">        pre_pre = nums[<span class="number">0</span>]</span><br><span class="line">        pre = max(nums[<span class="number">0</span>],nums[<span class="number">1</span>])</span><br><span class="line">        max_res = <span class="number">0</span></span><br><span class="line">        cur = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>,len(nums)):</span><br><span class="line">            cur = max(pre_pre+nums[i],pre)</span><br><span class="line">            <span class="keyword">if</span> cur&gt;max_res:</span><br><span class="line">                max_res = cur</span><br><span class="line">            pre_pre = pre</span><br><span class="line">            pre = cur</span><br><span class="line">        <span class="keyword">return</span> max_res</span><br></pre></td></tr></table></figure><h2><span id="62-打家劫舍-ii">6.2. 打家劫舍 II</span></h2><p>你是一个专业的小偷，计划偷窃沿街的房屋，每间房内都藏有一定的现金。这个地方所有的房屋都围成一圈，这意味着第一个房屋和最后一个房屋是紧挨着的。同时，相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。</p><p>给定一个代表每个房屋存放金额的非负整数数组，计算你在不触动警报装置的情况下，能够偷窃到的最高金额。</p><p>示例 1:</p><p>输入: [2,3,2]<br>输出: 3<br>解释: 你不能先偷窃 1 号房屋（金额 = 2），然后偷窃 3 号房屋（金额 = 2）, 因为他们是相邻的。</p><p>链接：<a href="https://leetcode-cn.com/problems/house-robber-ii" target="_blank" rel="noopener">https://leetcode-cn.com/problems/house-robber-ii</a></p><p>【注】这道题和上一题的区别是：屋子围成环形，第一个房子和最后一个房子相邻</p><p>将环形问题变成单排问题来解决.第一间房子和最后一间房子相邻，有以下3种偷窃情况:</p><ol><li>偷第一间房子，不偷最后一间房子</li><li>不偷第一间房子，偷最后一间房子</li><li>2间房子都不偷<br>综合以上3种情况，可以总结为情况1和情况2，因为房子金额为非负数，多偷一间房子的钱肯定&gt;=不偷</li></ol><p>则环形房子偷的最大金额是情况1和情况2的最大值。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">rob</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">sub_rob</span><span class="params">(nums)</span>:</span></span><br><span class="line">            pre_pre = nums[<span class="number">0</span>]</span><br><span class="line">            pre = max(nums[<span class="number">0</span>],nums[<span class="number">1</span>])</span><br><span class="line">            res_max = max(pre_pre,pre)</span><br><span class="line">            cur = <span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>,len(nums)):</span><br><span class="line">                cur = max(pre_pre+nums[i],pre)</span><br><span class="line">                <span class="keyword">if</span> cur&gt;res_max:</span><br><span class="line">                    res_max = cur</span><br><span class="line">                pre_pre = pre</span><br><span class="line">                pre = cur</span><br><span class="line">            <span class="keyword">return</span> res_max</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> nums:<span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> len(nums)&lt;=<span class="number">2</span>:<span class="keyword">return</span> max(nums)</span><br><span class="line">        n = len(nums)</span><br><span class="line">        <span class="keyword">return</span> max(sub_rob(nums[<span class="number">0</span>:n<span class="number">-1</span>]),sub_rob(nums[<span class="number">1</span>:n]))</span><br></pre></td></tr></table></figure><h2><span id="63-打家劫舍iii">6.3. 打家劫舍III</span></h2><p>在上次打劫完一条街道之后和一圈房屋后，小偷又发现了一个新的可行窃的地区。这个地区只有一个入口，我们称之为“根”。 除了“根”之外，每栋房子有且只有一个“父“房子与之相连。一番侦察之后，聪明的小偷意识到“这个地方的所有房屋的排列类似于一棵二叉树”。 如果两个直接相连的房子在同一天晚上被打劫，房屋将自动报警。</p><p>计算在不触动警报的情况下，小偷一晚能够盗取的最高金额。</p><p>链接：<a href="https://leetcode-cn.com/problems/house-robber-iii" target="_blank" rel="noopener">https://leetcode-cn.com/problems/house-robber-iii</a></p><p><img src="/2020/06/06/Leetcode之动态规划/1.png" alt=""></p><p><strong>【分析一】</strong></p><p>这道题考察的是怎么在二叉树上进行动态规划。<br>每个节点有2个孩子。根节点称为爷爷，有2个儿子，有4个孙子。相邻节点不能同时偷的意思是爷爷偷了，那儿子就不能偷，但是孙子可以偷。那最大金额=爷爷的钱+4个孙子的钱 VS 2个儿子的钱，看哪个组合多</p><p>使用递归，但是这种方法超时。因为递归会重复计算。比如在计算2个儿子的最大金额时，当这2个儿子称为爷爷时又会重新计算一遍孙子的金额。</p><p>注意：递归需要从树的下面往上看，在叶子节点的金额是最少的，儿子的金额比孙子多，爷爷的金额比儿子多。可能会有这样的疑问：既然不能相邻的节点连续偷，那可以左孩子偷的钱+右孩子的2个孩子偷的钱。其实这种情况已经被2个儿子偷考虑进去了，因为左孩子+2个孙子 《 2个儿子</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">rob</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type root: TreeNode</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:<span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        root_money = root.val</span><br><span class="line">        method1 = root_money<span class="comment">#爷爷加上4个孙子的钱</span></span><br><span class="line">        method2 = <span class="number">0</span><span class="comment">#2个孩子的钱</span></span><br><span class="line">        <span class="keyword">if</span> root.left:</span><br><span class="line">            method1+=(self.rob(root.left.left)+self.rob(root.left.right))</span><br><span class="line">        <span class="keyword">if</span> root.right:</span><br><span class="line">            method1+=(self.rob(root.right.left)+self.rob(root.right.right))</span><br><span class="line">        method2 = self.rob(root.left)+self.rob(root.right)</span><br><span class="line">        <span class="keyword">return</span> max(method1,method2)</span><br></pre></td></tr></table></figure><p><strong>【分析二】</strong></p><p>为了解决上述重复计算的问题，使用空间换时间的方法，将已经计算的金额保存起来。二叉树不适合使用数组来当缓存，使用哈希表存储，节点作为key，当前节点的最大金额为value</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode(object):</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">rob</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type root: TreeNode</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">sub_rob</span><span class="params">(root,max_val)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> root:<span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">            <span class="keyword">if</span> root <span class="keyword">in</span> max_val:<span class="keyword">return</span> max_val[root]</span><br><span class="line">            </span><br><span class="line">            method1 = root.val<span class="comment">#爷爷加上4个孙子的钱</span></span><br><span class="line">            <span class="keyword">if</span> root.left:</span><br><span class="line">                method1+=(sub_rob(root.left.left,max_val)+sub_rob(root.left.right,max_val))</span><br><span class="line">            <span class="keyword">if</span> root.right:</span><br><span class="line">                method1+=(sub_rob(root.right.left,max_val)+sub_rob(root.right.right,max_val))</span><br><span class="line">            method2 = sub_rob(root.left,max_val)+sub_rob(root.right,max_val)</span><br><span class="line">            max_val[root] = max(method1,method2)</span><br><span class="line">            <span class="keyword">return</span> max_val[root]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:<span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        max_val = dict()</span><br><span class="line">        <span class="keyword">return</span> sub_rob(root,max_val)</span><br></pre></td></tr></table></figure><p><strong>【分析三】</strong></p><p>参照买股票问题，每个节点都有2种状态：偷和不偷。dp使用二维数据组，</p><ul><li>dp[i][0]：节点i不偷时的最大金额。节点i不偷，那i.left和i.right可以偷也可以不偷。则<code>dp[i][0] = max(dp[i.left][1],dp[i.left][0]) + max(dp[i.right][1],dp[i.right][0])</code></li><li>dp[i][1]：节点i偷时的最大金额。节点i偷，那i.left和i.right只能选择不偷，则<code>dp[i][1] = dp[i.left][0]+dp[i.right][0]+i.val</code></li><li>空间优化：由于在计算dp[i]时，只需要dp[i.left]和dp[i.right]的信息，所以不需要使用dp[][]二维数组。只需要3个一维数组，left[0]和left[1]表示左节点偷和不偷的最大金额，right[0]和right[1]表示右节点偷和不偷的最大金额。root[0]和root[1]表示根节点</li><li>初始化</li><li>返回结果：输出根节点中2个状态的最大值</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">rob</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type root: TreeNode</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">sub_rob</span><span class="params">(root)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> root:<span class="keyword">return</span> [<span class="number">0</span>,<span class="number">0</span>]</span><br><span class="line">            left = sub_rob(root.left)</span><br><span class="line">            right = sub_rob(root.right)</span><br><span class="line"></span><br><span class="line">            root_val = [<span class="number">0</span>,<span class="number">0</span>]<span class="comment">#根节点2种状态的最大金额</span></span><br><span class="line">            root_val[<span class="number">0</span>] = max(left[<span class="number">0</span>],left[<span class="number">1</span>])+max(right[<span class="number">0</span>],right[<span class="number">1</span>])</span><br><span class="line">            root_val[<span class="number">1</span>] = left[<span class="number">0</span>]+right[<span class="number">0</span>]+root.val</span><br><span class="line">            <span class="keyword">return</span> root_val</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:<span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        root_val = sub_rob(root)</span><br><span class="line">        <span class="keyword">return</span> max(root_val)</span><br></pre></td></tr></table></figure><h2><span id="64-总结">6.4. 总结</span></h2><p>第一题是单排动态规划问题<br>第二题是环形动态规划问题，可以转换为多个单排问题解决，然后求多个单排问题的最大值<br>第三题是树形动态规划问题，使用递归解决</p><h1><span id="7-最长回文子串">7. 最长回文子串</span></h1><p>给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为 1000。</p><p>示例 1：</p><p>输入: “babad”<br>输出: “bab”<br>注意: “aba” 也是一个有效答案。</p><p>链接：<a href="https://leetcode-cn.com/problems/longest-palindromic-substring" target="_blank" rel="noopener">https://leetcode-cn.com/problems/longest-palindromic-substring</a></p><p><strong>【分析一】</strong></p><p>暴力求解</p><p>先以第一个字符为头，找长度为2,3，。。。的字符串中是否是回文字符串，使用res_str记录下来。然后以第二个字符为头，找长度为2,3，。。。的字符串中是否是回文字符串。。。</p><p>但是这种方法超时</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">longestPalindrome</span><span class="params">(self, s)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type s: str</span></span><br><span class="line"><span class="string">        :rtype: str</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="comment">#暴力求解</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> s:<span class="keyword">return</span> <span class="string">''</span></span><br><span class="line">        <span class="keyword">if</span> len(s)==<span class="number">1</span>:<span class="keyword">return</span> s</span><br><span class="line">        n = len(s)</span><br><span class="line">        res_len = <span class="number">0</span><span class="comment">#当前回文子串的最长长度</span></span><br><span class="line">        res_str = <span class="string">''</span><span class="comment">#当前最长的回文串</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">#以第一个字符为头，长度为2,3，。。。的字符串中是否是回文字符串，使用res_str记录下来</span></span><br><span class="line">        <span class="comment">#然后以第二个字符为头，找长度为2,3，。。。的字符串中是否是回文字符串。。。</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>,n<span class="number">-1</span>):<span class="comment">#当前开始遍历的字符下标</span></span><br><span class="line">            <span class="keyword">for</span> cur_len <span class="keyword">in</span> range(<span class="number">2</span>,n-i+<span class="number">1</span>):<span class="comment">#字符串的长度</span></span><br><span class="line">                cur_str = s[i:i+cur_len]</span><br><span class="line">                <span class="keyword">if</span> cur_str == cur_str[::<span class="number">-1</span>]:</span><br><span class="line">                    <span class="keyword">if</span> cur_len&gt;res_len:</span><br><span class="line">                        res_len = cur_len</span><br><span class="line">                        res_str = cur_str</span><br><span class="line">        <span class="keyword">return</span> s[<span class="number">0</span>] <span class="keyword">if</span> res_str==<span class="string">''</span> <span class="keyword">else</span> res_str</span><br></pre></td></tr></table></figure><p><strong>【分析二】</strong></p><p>动态规划的关键就是找出什么是状态和状态转移方程，<br>我们先看问题：找出最长的回文子串</p><ul><li>一个回文串去掉2个头后，剩下的依然是回文串</li><li>如果一个字符串的头尾2个字符不相等，一定不是回文串</li><li>如果一个字符串的头尾2个字符相等，才有必要继续判断下去：<ul><li>如果里面的子串是回文，则整个字符串就是回文</li><li>如果里面的子串不是回文，则整个字符串不是回文</li></ul></li></ul><ol><li>定义状态<br><code>dp[i][j]</code>表示子串s[i..j]是否是回文串。因此dp[][]是bool类型的值。这里的s[i…j]是左闭右闭区间，包括s[i]和s[j]<br>一个字符肯定是回文字符串，所以<code>dp[i][i]=True</code></li><li><p>状态转移方程<br><code>dp[i][j] = (s[i]==s[j]) and dp[i+1][j-1]</code></p><ul><li>这里的<code>i&lt;=j</code>，因此只用填二维表的对角线和对角线以上的部分就可以了。</li><li>对于字符串<code>s[i...j]</code>，如果<code>s[i]!=s[j]</code>，肯定不会回文子串</li><li>当<code>s[i]==s[j]</code>的时候，此时<code>dp[i][j]=dp[i+1][j-1]</code>，但如果出现<code>abba</code>这种情况，此时<code>i=1,j=2</code>,<code>s[i]=s[j]</code>，然后如果直接使得<code>dp[1][2]=dp[2][1]</code>，这样就会出错，因为<code>j&gt;=i</code>，所以当出现<code>s[i]==s[j]</code>时需要有2种情况：<ul><li><code>if j==i+1</code>,就是上面<code>bb</code>的情况，则肯定是回文子串，<code>dp[i][j]=True</code></li><li>否则 <code>dp[i][j]=dp[i+1][j-1]</code></li></ul></li></ul></li><li><p>初始化<br>初始化时，单个字符串一定是回文，因此对角线先初始化为True，即<code>dp[i][i]=True</code></p></li><li>返回值<br>只要一得到<code>dp[i][j]=True</code>，就将该回文子串的长度和以前记录的最大长度比较，如果比原先的长度大，则替换为当前长度，并记录起始位置。最终返回最大长度的回文子串</li><li>考虑优化空间<br>在填表的过程中，<code>dp[i][j]</code>只和<code>dp[i+1][j-1]</code>有关，即和左下放的表格有关，因此是可以优化的，但是优化后可读性就会变差，这里就不优化了。</li></ol><p><code>dp[i][j]=dp[i+1][j-1]</code></p><p>可以看到<code>dp[i]</code>依赖于<code>dp[i+1]</code>，所以在求<code>dp[i]</code>的时候，此时的<code>dp[i+1]</code>已经求出来了。<br>如果放在网格中来看，<code>dp[i][j]</code>是当前网格，<code>dp[i+1][j-1]</code>是它左下角的网格。再求当前网格时，需要保证它左下角的网格已经被遍历过。<br>有2种方案：</p><ul><li>外循环遍历j，内循环遍历i。这样就会先求出<code>dp[:][j-1]</code>的值，然后在求<code>dp[i][j]</code>的时候，此时<code>dp[i+1][j-1]</code>肯定已经求出来了。</li><li>外循环遍历i，内循环遍历j，只是在遍历i的是从倒序遍历，即先遍历最后一行，这样再求第i行的内容时，第i+1行的值肯定被求出来了。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">longestPalindrome</span><span class="params">(self, s)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type s: str</span></span><br><span class="line"><span class="string">        :rtype: str</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="comment">#dp[i][j]表示s[i...j]左闭右闭是否是回文字符串</span></span><br><span class="line">        <span class="comment">#dp[i][j]=s[i]==s[j] and dp[i+1][j-1]</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> s:<span class="keyword">return</span> <span class="string">''</span></span><br><span class="line">        n = len(s)</span><br><span class="line">        dp = [[<span class="keyword">False</span> <span class="keyword">for</span> _ <span class="keyword">in</span> range(n)] <span class="keyword">for</span> _ <span class="keyword">in</span> range(n)]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">            dp[i][i] = <span class="keyword">True</span></span><br><span class="line">        </span><br><span class="line">        start = <span class="number">0</span></span><br><span class="line">        max_len = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># for i in range(n-2,-1,-1):</span></span><br><span class="line">        <span class="comment">#     for j in range(i+1,n):</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>,n):</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>,j):</span><br><span class="line">                <span class="keyword">if</span> s[i]!=s[j]:</span><br><span class="line">                    dp[i][j]=<span class="keyword">False</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">if</span> j == i+<span class="number">1</span>:</span><br><span class="line">                        dp[i][j] = <span class="keyword">True</span></span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        dp[i][j] = dp[i+<span class="number">1</span>][j<span class="number">-1</span>]</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> dp[i][j]:</span><br><span class="line">                    <span class="keyword">if</span> j-i+<span class="number">1</span> &gt; max_len:</span><br><span class="line">                        max_len = j-i+<span class="number">1</span></span><br><span class="line">                        start = i</span><br><span class="line">        <span class="keyword">return</span> s[start:start+max_len]</span><br></pre></td></tr></table></figure><ul><li>时间复杂度：O(n^2)</li><li>空间复杂度：O(n^2)</li></ul><p><strong>【分析三】</strong></p><p>中心扩散法：枚举可能出现的回文子串的中心位置，从中心位置尝试尽可能扩散出去，得到一个回文串。</p><p>中心扩散法的思路是：遍历每个字符，以这个字符为中心，利用回文串左右对称的特征，向两边扩散，看最多能扩散多远。<br>枚举中心位置的时间复杂度是O(N)，从中心扩散得到回文子串的时间复杂度为O(N)，因此时间复杂度为O(N^2)</p><p>注意：回文串的长度为奇数和偶数时，中心不一样</p><ul><li>当回文串长度为奇数时，中心是中间的具体字符，例如<code>bab</code>,中心为<code>a</code></li><li>当回文串长度为偶数时，中心是中间2个字符的空隙，例如<code>baab</code>的中心是2个<code>a</code>中间的空隙</li></ul><p><img src="/2020/06/06/Leetcode之动态规划/2.png" alt=""></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">longestPalindrome</span><span class="params">(self, s)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type s: str</span></span><br><span class="line"><span class="string">        :rtype: str</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="comment">#暴力求解</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> s:<span class="keyword">return</span> <span class="string">''</span></span><br><span class="line">        <span class="keyword">if</span> len(s)==<span class="number">1</span>:<span class="keyword">return</span> s</span><br><span class="line">        n = len(s)</span><br><span class="line"></span><br><span class="line">        res_len = <span class="number">1</span><span class="comment">#回文串的长度，不能为0，比如"ac"不是回文字符串，但是只有1个字符'a'或'c'是回文字符串，因此回文字符串的长度最小也是1</span></span><br><span class="line">        res_max = s[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n):<span class="comment">#遍历中心节点</span></span><br><span class="line">            str_odd,len_odd = self.center_spread(s,i,i)</span><br><span class="line">            str_even,len_even = self.center_spread(s,i,i+<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">            <span class="comment">#找到当前的最长回文子串,首先求出奇偶长度的最大值</span></span><br><span class="line">            <span class="comment">#然后看这个最大值和当前的res_len比较</span></span><br><span class="line">            tmp_len = len_odd <span class="keyword">if</span> len_odd&gt;len_even <span class="keyword">else</span> len_even</span><br><span class="line">            tmp_res = str_odd <span class="keyword">if</span> tmp_len%<span class="number">2</span>==<span class="number">1</span> <span class="keyword">else</span> str_even</span><br><span class="line">            <span class="keyword">if</span> tmp_len&gt;res_len:</span><br><span class="line">                res_len = tmp_len</span><br><span class="line">                res_max = tmp_res</span><br><span class="line">        <span class="keyword">return</span> res_max</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">center_spread</span><span class="params">(self,s,left,right)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        left,right为中心位置</span></span><br><span class="line"><span class="string">        如果left==right，说明之后找到的回文串长度为奇数</span></span><br><span class="line"><span class="string">        如果left+1=right，说明之后找到的回文串长度为偶数</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        i,j = left,right</span><br><span class="line">        n = len(s)</span><br><span class="line">        <span class="comment">#babad举例，第2个b为中心位</span></span><br><span class="line">        <span class="keyword">while</span> i&gt;=<span class="number">0</span> <span class="keyword">and</span> j&lt;n <span class="keyword">and</span> s[i] == s[j]:</span><br><span class="line">            i-=<span class="number">1</span></span><br><span class="line">            j+=<span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> s[i+<span class="number">1</span>:j],j-i+<span class="number">1</span></span><br></pre></td></tr></table></figure><h1><span id="8-回文子串">8. 回文子串</span></h1><p>给定一个字符串，你的任务是计算这个字符串中有多少个回文子串。</p><p>具有不同开始位置或结束位置的子串，即使是由相同的字符组成，也会被计为是不同的子串。</p><p>示例 1:<br>输入: “abc”<br>输出: 3<br>解释: 三个回文子串: “a”, “b”, “c”.</p><p>链接：<a href="https://leetcode-cn.com/problems/palindromic-substrings" target="_blank" rel="noopener">https://leetcode-cn.com/problems/palindromic-substrings</a></p><p>【分析一】</p><p>参考上一题，使用dp[i][j]来记录s[i]…s[j]是否为回文串，<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">countSubstrings</span><span class="params">(self, s)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type s: str</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="comment">#dp[i][j] = (s[i]==s[j]) and dp[i+1][j-1]</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> s:<span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> len(s)==<span class="number">1</span>:<span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        n = len(s)</span><br><span class="line">        dp = [[<span class="keyword">False</span> <span class="keyword">for</span> _ <span class="keyword">in</span> range(n)] <span class="keyword">for</span> _ <span class="keyword">in</span> range(n)]</span><br><span class="line">        count = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">            dp[i][i] = <span class="keyword">True</span></span><br><span class="line">            count+=<span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">#j&gt;=i</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>,n):</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>,j):</span><br><span class="line">                <span class="keyword">if</span> s[i]==s[j]:</span><br><span class="line">                    <span class="keyword">if</span> j-i&lt;<span class="number">3</span>:</span><br><span class="line">                        dp[i][j] = <span class="keyword">True</span></span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        dp[i][j] = dp[i+<span class="number">1</span>][j<span class="number">-1</span>]</span><br><span class="line">                <span class="keyword">if</span> dp[i][j]:</span><br><span class="line">                    count+=<span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> count</span><br></pre></td></tr></table></figure></p><h1><span id="9-背包问题">9. 背包问题</span></h1><ol><li>0-1背包问题<br>每个物品最多只能放一次</li><li>完全背包问题<br>每个物品可以放无限次</li><li>多重背包问题<br>每个物品有一个固定的次数上限</li><li>混合三种背包问题<br>将前面三种简单问题叠加成复杂的问题</li><li>二维费用的背包问题<br>背包有体积和重量2个维度的限制</li><li>分组背包问题<br>将物品分组，每组最多只能选一件</li><li>背包问题求方案数</li><li>求背包问题的方案</li><li>有依赖的背包问题</li></ol><h2><span id="91-0-1背包问题">9.1. 0-1背包问题</span></h2><p>0-1背包问题：给定背包体积$V$，n个物品的体积$v_i$和价值$w_i$，每个物品只能拿一次，求所拿的最大价值。</p><p><a href="https://www.acwing.com/problem/content/2/" target="_blank" rel="noopener">https://www.acwing.com/problem/content/2/</a></p><p>输入格式<br>第一行两个整数，N，V，用空格隔开，分别表示物品数量和背包容积。</p><p>接下来有 N 行，每行两个整数 $v_i$,$w_i$，用空格隔开，分别表示第 i 件物品的体积和价值。</p><p>输出格式<br>输出一个整数，表示最大价值。</p><p>数据范围<br>$0&lt;N,V≤1000$<br>$0&lt;v_i,w_i≤1000$</p><blockquote><p>输入样例<br>4 5<br>1 2<br>2 4<br>3 4<br>4 5</p><p>输出样例：<br>8</p></blockquote><p><strong>定义状态</strong><br><code>f[i][j]</code>表示只看前i个物品(1&lt;=i&lt;=n,只知道前i个物品，并不是把前i个物品都放在包中)，背包容量为j的情况下，能拿到的最大价值。<br>最终求的值是<code>f[N][V]</code>，知道前N个物品，背包容量为V的最大价值。<br>看一下f[i][j]怎么算，假设前i-1个物品都考虑完了，现在考虑第i个物品，第i个物品有2种选择：放包里和不放包里。</p><ul><li>放包里：则前i-1个物品能够用的空间为$j-v_i$，$f[i][j]=f[i-1][j-v_i]+w_i$</li><li>不放包里：$f[i][j]=f[i-1][j]$<br>则$f[i][j]=max\{f[i-1][j],f[i-1][j-v_i]+w_i\}$</li></ul><p><strong>初始化</strong><br><code>f[][]</code>全都初始化为0，其中包括：<br><code>f[0][0~V]</code>：物体个数为0<br><code>f[1~N][0]</code>：背包容量为0</p><ul><li>时间复杂度：O(NV)，N为物品个数，V为背包体积</li><li>空间复杂度：O(NV)</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">package</span><span class="params">(V,N,volume,value)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    V：背包的容量</span></span><br><span class="line"><span class="string">    N：物体的个数</span></span><br><span class="line"><span class="string">    volume：N个物体的体积</span></span><br><span class="line"><span class="string">    value：N个物体的价值</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="comment">#f[i][j]:前i个物体，背包容量为j的最大价值</span></span><br><span class="line">    f = [[<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> range(V+<span class="number">1</span>)] <span class="keyword">for</span> _ <span class="keyword">in</span> range(N+<span class="number">1</span>)]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,N+<span class="number">1</span>):<span class="comment">#遍历每个物体</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>,V+<span class="number">1</span>):<span class="comment">#遍历每个体积</span></span><br><span class="line">            <span class="keyword">if</span> volume[i]&gt;j:</span><br><span class="line">                f[i][j] = f[i<span class="number">-1</span>][j]</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                f[i][j] = max(f[i<span class="number">-1</span>][j],f[i<span class="number">-1</span>][j-volume[i]]+value[i])</span><br><span class="line">    print(f[N][V])</span><br><span class="line">    </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    <span class="comment">#读取输入数据</span></span><br><span class="line">    <span class="comment">#N：物品个数、V：背包体积</span></span><br><span class="line">    N,V = map(int,input().split())</span><br><span class="line">    volume,value = [<span class="number">0</span>,],[<span class="number">0</span>,]<span class="comment">#体积、价值</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(N):</span><br><span class="line">        volume_i,value_i = map(int,input().split())</span><br><span class="line">        volume.append(volume_i)</span><br><span class="line">        value.append(value_i)</span><br><span class="line">    package(V,N,volume,value)</span><br></pre></td></tr></table></figure><p><strong>【优化】</strong><br>发现<code>f[i][j]</code>只和<code>f[i-1]</code>的值有关<br>$f[i][j]=max\{f[i-1][j],f[i-1][j-v_i]+w_i\}$<br>所以不需要使用二维数组，使用一维数组就可以了，状态转移方程变成<br>$f[j]=max\{f[j],f[j-v_i]+w_i\}$<br>第二重for循环时，体积遍历从大到小遍历，这样在进行第i个循环时，计算$f[j]$时用到的$f[j]$和$f[j-v_i]$用到的都是上一个循环i-1的值。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">package</span><span class="params">(V,N,volume,value)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    V：背包的容量</span></span><br><span class="line"><span class="string">    N：物体的个数</span></span><br><span class="line"><span class="string">    volume：N个物体的体积</span></span><br><span class="line"><span class="string">    value：N个物体的价值</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="comment">#f[j]:只看前i个物体，背包容量为j的最大价值</span></span><br><span class="line">    f = [<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> range(V+<span class="number">1</span>)]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,N+<span class="number">1</span>):<span class="comment">#遍历每个物体</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(V,volume[i]+<span class="number">1</span>,<span class="number">-1</span>):<span class="comment">#遍历每个体积</span></span><br><span class="line">                <span class="comment">#第一个f[j]表示前i个物体，容量为j的最大价值</span></span><br><span class="line">                <span class="comment">#第二个f[j]表示前i-1个物体，容量为j的最大价值</span></span><br><span class="line">                f[j] = max(f[j],f[j-volume[i]]+value[i])</span><br><span class="line">    print(f[V])</span><br><span class="line">    </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    <span class="comment">#读取输入数据</span></span><br><span class="line">    <span class="comment">#N：物品个数、V：背包体积</span></span><br><span class="line">    N,V = map(int,input().split())</span><br><span class="line">    volume,value = [<span class="number">0</span>,],[<span class="number">0</span>,]<span class="comment">#体积、价值</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(N):</span><br><span class="line">        volume_i,value_i = map(int,input().split())</span><br><span class="line">        volume.append(volume_i)</span><br><span class="line">        value.append(value_i)</span><br><span class="line">    package(V,N,volume,value)</span><br></pre></td></tr></table></figure><h2><span id="92-背包初始化问题">9.2. 背包初始化问题</span></h2><p>上一题没有要求把背包装满，但是有的问题可能要求“恰好装满背包的最优解”。注意这2种问法在初始化的时候有所不同。</p><ul><li>恰好装满背包。只有f[0]=0，其余f[1~V]全都初始化为$-\infty$</li><li>没有要求背包装满，f[0~V]=0</li></ul><p>可以这样理解：初始化的f事实上就是在0个物体放入背包的状态。f[0]表示0个物体放入容量0的背包的最大价值，f[V]表示0个物体放入容量0的背包的最大价值。如果要求背包恰好装满，那么此时只有容量为0的背包才能被体积为0的物体恰好填满。$f[1,…V]$在物体个数为0时都不能被填满，即属于未定义的状态，那就初始化为$-\infty$。如果背包没有要求被填满，那任意一个背包容量都有一个合法解，$f[1,…V]$都不能被0个物体填满，所以$f[0,1,…V]$都可以初始化为0.</p><h2><span id="93-完全背包问题">9.3. 完全背包问题</span></h2><p>背包容量为V，有N个物体，体积为$v_i$，价值为$w_i$，每个物体可以被无限装入包中。求将哪些物体装入包中价值最大。</p><p>输入格式<br>第一行两个整数，N，V，用空格隔开，分别表示物品种数和背包容积。</p><p>接下来有 N 行，每行两个整数 $v_i,w_i$，用空格隔开，分别表示第 i 种物品的体积和价值。</p><p>输出格式<br>输出一个整数，表示最大价值。</p><p>数据范围<br>$0&lt;N,V≤1000$<br>$0&lt;v_i,w_i≤1000$</p><blockquote><p>输入样例<br>4 5<br>1 2<br>2 4<br>3 4<br>4 5</p><p>输出样例：<br>10</p></blockquote><p><strong>【分析一】</strong></p><p>每个物体可以选多次，则完全背包问题的二维状态转移方程变成</p><p>$f[i][j]=max\{f[i-1][j-k<em>v_i]+k</em>w_i \quad| \quad 0&lt;=k*v_i&lt;=j\}$</p><p>在考虑第i件物体时，可以放0,1,2,…k件，只要$0&lt;=k<em>v_i&lt;=j$，那前i-1件物体能用的背包容量为$j-k</em>v_i$。现在要做的就是在看k等于多少时，背包的价值最大。</p><p>以上使用的是二维数组，$f[i]$的值和$f[i-1]$的值有关系。现在考虑$f[i][j]$和本层的$f[i][0,…V]$有什么关系。<br>$f[i][j]$和$f[i][0,..V]$都有可能包含第i个物品，所以将问题转换成“每次添加一个物品i的状态转移”</p><ol><li>$f[i][j]$如果包含物品i，则$f[i][j-v_i]$中物品i的数量比$f[i][j]$少一个，此时$f[i][j]=f[i][j-v_i]+w_i$</li><li>如果f[i][j]不包含物品i，则$f[i][j]=f[i-1][j]$</li></ol><p>则<strong>完全背包</strong>的一维状态转移方程变成<br>$f[i][j]=max\{f[i-1][j],f[i][j-v_i]+w_i\}$</p><p>这个转移方程和<strong>0-1背包问题</strong>的转移方程$f[i][j]=max\{f[i-1][j],f[i-1][j-v_i]+w_i\}$类似。</p><blockquote><p>需要注意的是：<br>对于二维数组的0-1背包问题，第二层循环（遍历背包容量V）可以是正序，也可以逆序。对于一维数组的0-1背包问题，第二层循环必须逆序。<br>对于完全背包问题，无论是二维数组还是一维数组，第二层循环都必须是正序。</p></blockquote><p>完全背包的一维状态转移方程：<br>$f[j]=max\{f[j],f[j-v_i]+w_i\}$</p><p>在第二层for循环时，正序遍历V。在遍历第i个物品时，第一个$f[j]$表示$f[i][j]$，第二个$f[j]$表示上一个循环的最大价值，即$f[i-1][j]$，$f[j-v_i]+w_i$表示当前循环的最大价值，即$f[i][j-v_i]+w_i$。因为在计算f[j]的时候用到$f[j-v_i]$，因为容量是正序遍历，所有比j小的容量都已经被计算过，所以$f[j-v_i]$表示在考虑前i个物品时(包括第i个物品)，当背包容量为$j-v_i$时的最大价值,$f[j-v_i]$可能已经包含若干个第i个物品了。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">package</span><span class="params">(V,N,volume,value)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    V：背包的体积</span></span><br><span class="line"><span class="string">    N：物体的个数</span></span><br><span class="line"><span class="string">    volume：N个物体的体积</span></span><br><span class="line"><span class="string">    value：N个物体的价值</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    f = [<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> range(V+<span class="number">1</span>)]</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(N+<span class="number">1</span>):<span class="comment">#遍历每个物品</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>,V+<span class="number">1</span>):<span class="comment">#遍历每个体积</span></span><br><span class="line">            <span class="keyword">if</span> j &gt;= volume[i]:</span><br><span class="line">                f[j] = max(f[j],f[j-volume[i]]+value[i])</span><br><span class="line">    print(f[V])</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    N,V = map(int,input().split())</span><br><span class="line">    volume,value = [<span class="number">0</span>,],[<span class="number">0</span>,]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(N):</span><br><span class="line">        volume_tmp,value_tmp = map(int,input().split())</span><br><span class="line">        volume.append(volume_tmp)</span><br><span class="line">        value.append(value_tmp)</span><br><span class="line">    package(V,N,volume,value)</span><br></pre></td></tr></table></figure><h2><span id="94-多重背包问题">9.4. 多重背包问题</span></h2><p>背包容量为V，有N种物品，每种物品最多有$s_i$件，体积为$v_i$，价值为$w_i$。怎么装物品才能使背包价值最大。</p><p>输入格式<br>第一行两个整数，N，V，用空格隔开，分别表示物品种数和背包容积。</p><p>接下来有 N 行，每行三个整数 vi,wi,si，用空格隔开，分别表示第 i 种物品的体积、价值和数量。</p><p>输出格式<br>输出一个整数，表示最大价值。</p><p>数据范围<br>$0&lt;N,V≤100$<br>$0&lt;v_i,w_i,s_i≤100$</p><blockquote><p>输入样例<br>4 5<br>1 2 3<br>2 4 1<br>3 4 3<br>4 5 2</p><p>输出样例：<br>10</p></blockquote><p><strong>【分析一】</strong></p><p>多重背包是0-1背包的扩展，所以枚举体积的时候也是从大到小。<br>0-1背包问题每个物品只有2个选择：选和不选<br>多重背包问题每种物品有s+1中选择：选0个，选1个，选2个，….，选s个。<br>多重背包问题的二维状态转移方程为：<br>$f[i][j] = max\{f[i][j],f[i-1][j-k<em>v_i]+k</em>w_i\} \quad  0&lt;=k&lt;=s_i$</p><p>在第一次遍历k时，此时k=0，<code>f[i][j]</code>为初始化的0，和<code>f[i-1][j]</code>比较，选最大的那个作为新的<code>f[i][j]</code>。再次遍历k的时候，此时的<code>f[i][j]</code>不再是初始化的值，而是上一个循环中求得的最大值，所以这里的状态转移矩阵中写成<code>f[i][j]</code>而不是<code>f[i-1][j]</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">package</span><span class="params">(N,V,volume,value,s)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    N：N中物品</span></span><br><span class="line"><span class="string">    V：背包体积</span></span><br><span class="line"><span class="string">    volume：每种物品的体积</span></span><br><span class="line"><span class="string">    value：每种物品的价值</span></span><br><span class="line"><span class="string">    s：每种物品的数量</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    dp = [[<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> range(V+<span class="number">1</span>)] <span class="keyword">for</span> _ <span class="keyword">in</span> range(N+<span class="number">1</span>)]</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,N+<span class="number">1</span>):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>,V+<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> k <span class="keyword">in</span> range(<span class="number">0</span>,s[i]+<span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> k*volume[i]&lt;=j:</span><br><span class="line">                    dp[i][j] = max(dp[i][j],dp[i<span class="number">-1</span>][j-k*volume[i]]+k*value[i])</span><br><span class="line">    print(dp[<span class="number">-1</span>][<span class="number">-1</span>])</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    N,V = map(int,input().split())</span><br><span class="line">    volume,value,s = [<span class="number">0</span>,],[<span class="number">0</span>,],[<span class="number">0</span>,]</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(N):</span><br><span class="line">        volume_tmp,value_tmp,s_tmp = map(int,input().split())</span><br><span class="line">        volume.append(volume_tmp)</span><br><span class="line">        value.append(value_tmp)</span><br><span class="line">        s.append(s_tmp)</span><br><span class="line">    package(N,V,volume,value,s)</span><br></pre></td></tr></table></figure><p>【分析二】</p><p>对以上的二维状态转移方程压缩为一维，</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">package</span><span class="params">(N,V,volume,value,s)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    N：N中物品</span></span><br><span class="line"><span class="string">    V：背包体积</span></span><br><span class="line"><span class="string">    volume：每种物品的体积</span></span><br><span class="line"><span class="string">    value：每种物品的价值</span></span><br><span class="line"><span class="string">    s：每种物品的数量</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    f =  [<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> range(V+<span class="number">1</span>)]</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,N+<span class="number">1</span>):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(V,<span class="number">0</span>,<span class="number">-1</span>):</span><br><span class="line">            <span class="keyword">for</span> k <span class="keyword">in</span> range(<span class="number">0</span>,s[i]+<span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> k * volume[i]&lt;=j:<span class="comment">#物品i选k个</span></span><br><span class="line">                    f[j] = max(f[j],f[j-k*volume[i]]+k*value[i])</span><br><span class="line">    print(f[V])</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    N,V = map(int,input().split())</span><br><span class="line">    volume,value,s = [<span class="number">0</span>,],[<span class="number">0</span>,],[<span class="number">0</span>,]</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(N):</span><br><span class="line">        volume_tmp,value_tmp,s_tmp = map(int,input().split())</span><br><span class="line">        volume.append(volume_tmp)</span><br><span class="line">        value.append(value_tmp)</span><br><span class="line">        s.append(s_tmp)</span><br><span class="line">    package(N,V,volume,value,s)</span><br></pre></td></tr></table></figure><h2><span id="95-二维背包问题">9.5. 二维背包问题</span></h2><p>背包容量为V，能承受的重量为M。<br>有N个物品，体积为$v_i$，重量为$m_i$，价值为$v_i$<br>每个物品只能用一次，求背包的最大价值。</p><p><a href="https://www.acwing.com/problem/content/8/" target="_blank" rel="noopener">https://www.acwing.com/problem/content/8/</a></p><p>输入格式<br>第一行两个整数，N,V,M，用空格隔开，分别表示物品件数、背包容积和背包可承受的最大重量。</p><p>接下来有 N 行，每行三个整数 $v_i,m_i,w_i$，用空格隔开，分别表示第 i 件物品的体积、重量和价值。</p><p>输出格式<br>输出一个整数，表示最大价值。</p><p>数据范围<br>$0&lt;N≤1000$<br>$0&lt;V,M≤100$<br>$0&lt;v_i,m_i≤100$<br>$0&lt;w_i≤1000$</p><blockquote><p>输入样例<br>4 5 6<br>1 2 3<br>2 4 4<br>3 4 5<br>4 5 6</p><p>输出样例：<br>8</p></blockquote><p><strong>【分析一】</strong></p><p>一个物品有2种代价：体积和重量。在定义状态的时候也需要加一维。<br><code>f[i][j][k]</code>表示前i件物品在体积为j，承重为k的包中获得的最大价值。状态转移方程为<br>$f[i][j][k] = max\{f[i-1][j][k],f[i-1][j-v_i][k-m_i]+w_i\}$</p><p>同0-1背包一样，对空间进行优化，将三维数据优化为二维数组。有3重for循环，第一层for遍历N，第二层for遍历体积V，第三层for遍历重量M。其中第二层和第三层是倒序遍历。</p><p>$f[j][k] = max\{f[j][k],f[j-v_i][k-m_i]+w_i\}$</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">package</span><span class="params">(N,M,V,volume,weight,value)</span>:</span></span><br><span class="line">    f = [[<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> range(M+<span class="number">1</span>)] <span class="keyword">for</span> _ <span class="keyword">in</span> range(V+<span class="number">1</span>)]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,N+<span class="number">1</span>):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(V,volume[i]<span class="number">-1</span>,<span class="number">-1</span>):</span><br><span class="line">            <span class="keyword">for</span> k <span class="keyword">in</span> range(M,weight[i]<span class="number">-1</span>,<span class="number">-1</span>):</span><br><span class="line">                f[j][k] = max(f[j][k],f[j-volume[i]][k-weight[i]]+value[i])</span><br><span class="line">    print(f[V][M])</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    N,V,M = map(int,input().split())</span><br><span class="line">    volume,weight,value = [<span class="number">0</span>,],[<span class="number">0</span>,],[<span class="number">0</span>,]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(N):</span><br><span class="line">        volume_tmp,weight_tmp,value_tmp = map(int,input().split())</span><br><span class="line">        volume.append(volume_tmp)</span><br><span class="line">        weight.append(weight_tmp)</span><br><span class="line">        value.append(value_tmp)</span><br><span class="line">    package(N,M,V,volume,weight,value)</span><br></pre></td></tr></table></figure><h2><span id="96-分割等和子集">9.6. 分割等和子集</span></h2><p>给定一个只包含正整数的非空数组，是否可以将这个数组分割成2个子集，使这2个子集的元素和相等，</p><p>注意:</p><p>每个数组中的元素不会超过 100<br>数组的大小不会超过 200</p><blockquote><p>示例 1:<br>输入: [1, 5, 11, 5]<br>输出: true<br>解释: 数组可以分割成 [1, 5, 5] 和 [11].</p></blockquote><p>链接：<a href="https://leetcode-cn.com/problems/partition-equal-subset-sum" target="_blank" rel="noopener">https://leetcode-cn.com/problems/partition-equal-subset-sum</a></p><p><strong>【分析一】</strong></p><p>这道题的等价替换：从一个数组中挑选一些元素，使得这些元素和是整个数组元素和的一半。前提是数组的和一定是偶数。<br>本题的原型是0-1背包问题，给定一个背包容量为sum/2，和N个物品，每个物品的体积为$v_i$，是否存在一种装法，恰好能装满背包。</p><ul><li>0-1背包问题选取物品的容量不能超过背包容量</li><li>本题选取的数字之和恰好等于规定和的一半。<br>这一点区别，决定了在初始化的时候，所有值应该初始化为False。<br>作为0-1背包问题，它的特点是：物品一个个的选，背包容量一点一点的加。</li></ul><p><strong>定义状态</strong></p><p><code>dp[i][j]</code>在前i个数中挑选一些正整数，使得元素和恰好为j。<code>dp[i][j]=True</code>，表示和恰好为j，<code>dp[i][j]=False</code>表示和不能恰好为j，小于j。<br>在考虑第i个数时，有2种选择</p><ul><li>不选第i个数nums[i]，则和是否恰好为j取决于上一阶段的状态，<code>dp[i][j] = dp[i-1][j]</code></li><li>选第i个数nums[i]，则<code>dp[i][j] = dp[i-1][j-nums[i]]</code></li></ul><p><strong>状态转移方程</strong></p><p><code>dp[i][j] = dp[i-1][j] or dp[i-1][j-nums[i]]</code></p><p>首先求nums的和，如果和为奇数，说明找不到一些元素使其元素和为总和的一半，直接返回false</p><p>这里的target为总和的一半，可以看做是背包的容量。<br>假设nums中有5个元素，则状态转移方程f中有5行，第一行表示从前1个数中挑选，第二行表示从前2个数中挑选。假设target=12，先初始化状态转移矩，初始化第一行，即只从前1个数中查找，假设nums[0]为5，则f[0][5] = True，表示5这个数恰好能把容量为5的背包填满。</p><p>然后遍历后面的几行。</p><ul><li>如果<code>nums[i]==j</code>，说明当前这个数就能把背包填满，则f[i][j]=True</li><li>如果<code>nums[i]&lt;j</code>，则当前nums[i]有2种选择：选或者不选。</li><li>否则<code>nums[i]&gt;j</code>，说明nums[i]一定不能选，则f[i][j]=f[i-1][j]</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">canPartition</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> len(nums)==<span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">        <span class="keyword">if</span> sum(nums)&amp;<span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">        n = len(nums)</span><br><span class="line">        target = sum(nums)&gt;&gt;<span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">#f[0~n-1][0~target]</span></span><br><span class="line">        </span><br><span class="line">        f = [[<span class="keyword">False</span> <span class="keyword">for</span> _ <span class="keyword">in</span> range(target+<span class="number">1</span>)] <span class="keyword">for</span> _ <span class="keyword">in</span> range(n)]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> nums[<span class="number">0</span>] &lt;= target:</span><br><span class="line">            f[<span class="number">0</span>][nums[<span class="number">0</span>]] = <span class="keyword">True</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">#写法1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,n):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">0</span>,target+<span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> nums[i] == j:</span><br><span class="line">                    f[i][j] = <span class="keyword">True</span></span><br><span class="line">                <span class="keyword">elif</span> nums[i] &lt; j:</span><br><span class="line">                    f[i][j] = f[i<span class="number">-1</span>][j-nums[i]] <span class="keyword">or</span> f[i<span class="number">-1</span>][j]</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    f[i][j] = f[i<span class="number">-1</span>][j]</span><br><span class="line">        <span class="comment">#写法2</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,n):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">0</span>,target+<span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> nums[i] &lt;= j:</span><br><span class="line">                    f[i][j] = f[i<span class="number">-1</span>][j-nums[i]] <span class="keyword">or</span> f[i<span class="number">-1</span>][j]</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    f[i][j] = f[i<span class="number">-1</span>][j]</span><br><span class="line">                    </span><br><span class="line">        <span class="keyword">return</span> f[n<span class="number">-1</span>][target]</span><br></pre></td></tr></table></figure><p><strong>【优化】</strong></p><p>参考0-1背包问题，将二维矩阵优化为一维矩阵</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">canPartition</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> len(nums)==<span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">        <span class="keyword">if</span> sum(nums)&amp;<span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">        n = len(nums)</span><br><span class="line">        target = sum(nums)&gt;&gt;<span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">#f[0~target]</span></span><br><span class="line">        f = [<span class="keyword">False</span> <span class="keyword">for</span> _ <span class="keyword">in</span> range(target+<span class="number">1</span>)]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> nums[<span class="number">0</span>] &lt;= target:</span><br><span class="line">            f[nums[<span class="number">0</span>]] = <span class="keyword">True</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,n):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(target,nums[i]<span class="number">-1</span>,<span class="number">-1</span>):</span><br><span class="line">                <span class="keyword">if</span> f[target]:<span class="comment">#提前剪枝</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">                f[j] = f[j-nums[i]] <span class="keyword">or</span> f[j]</span><br><span class="line">        <span class="keyword">return</span> f[target]</span><br></pre></td></tr></table></figure><h2><span id="97-一和零">9.7. 一和零</span></h2><p>在计算机界中，我们总是追求用有限的资源获取最大的收益。</p><p>现在，假设你分别支配着 m 个 0 和 n 个 1。另外，还有一个仅包含 0 和 1 字符串的数组。</p><p>你的任务是使用给定的 m 个 0 和 n 个 1 ，找到能拼出存在于数组中的字符串的最大数量。每个 0 和 1 至多被使用一次。</p><p>注意:</p><p>给定 0 和 1 的数量都不会超过 100。<br>给定字符串数组的长度不会超过 600。<br>示例 1:</p><p>输入: Array = {“10”, “0001”, “111001”, “1”, “0”}, m = 5, n = 3<br>输出: 4</p><p>解释: 总共 4 个字符串可以通过 5 个 0 和 3 个 1 拼出，即 “10”,”0001”,”1”,”0”</p><p>链接：<a href="https://leetcode-cn.com/problems/ones-and-zeroes" target="_blank" rel="noopener">https://leetcode-cn.com/problems/ones-and-zeroes</a></p><p><strong>【分析一】</strong></p><p>这道题的本质是二维背包问题。背包能装m个0，n个1，现在有N个字符串，每个字符串只由0和1组成，问装哪些字符串使得背包中字符串个数最多。每个字符串有2个代价，分别是消耗的0和1，价值都是1，即个数，每次向包中加一个字符串，价值（个数）就加1。<br>将问题形式化为二维背包问题之后就很简单了，二维背包问题的状态转移方程为：</p><p>$f[j][k] = max\{f[j][k],f[j-v_i][k-m_i]+1\}$</p><p>j表示背包中0的个数，k表示背包中1的个数。</p><p>首先需要定义一个函数，输入一个字符串，计算该字符串中0和1的个数。<br>然后使用二维背包问题的模板解决该问题。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findMaxForm</span><span class="params">(self, strs, m, n)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type strs: List[str]</span></span><br><span class="line"><span class="string">        :type m: int#0的个数</span></span><br><span class="line"><span class="string">        :type n: int#1的个数</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> strs:<span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        f = [[<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> range(n+<span class="number">1</span>)] <span class="keyword">for</span> _ <span class="keyword">in</span> range(m+<span class="number">1</span>)]</span><br><span class="line">        <span class="keyword">for</span> cur_str <span class="keyword">in</span> strs:</span><br><span class="line">            count_0,count_1 = self.countZeroAndOne(cur_str)</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(m,count_0<span class="number">-1</span>,<span class="number">-1</span>):</span><br><span class="line">                <span class="keyword">for</span> k <span class="keyword">in</span> range(n,count_1<span class="number">-1</span>,<span class="number">-1</span>):</span><br><span class="line">                    f[j][k]=max(f[j][k],f[j-count_0][k-count_1]+<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> f[m][n]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">countZeroAndOne</span><span class="params">(self,input_str)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        计算输入字符串中0和1的个数</span></span><br><span class="line"><span class="string">        input_str:当前输入的字符串</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        count_0,count_1 = <span class="number">0</span>,<span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> input_str:</span><br><span class="line">            <span class="keyword">if</span> i == <span class="string">'0'</span>:</span><br><span class="line">                count_0+=<span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                count_1+=<span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> count_0,count_1</span><br></pre></td></tr></table></figure><h2><span id="98-目标和">9.8. 目标和</span></h2><p>给定一个非负整数数组，a1, a2, …, an, 和一个目标数，S。现在你有两个符号 + 和 -。对于数组中的任意一个整数，你都可以从 + 或 -中选择一个符号添加在前面。<br>返回可以使最终数组和为目标数 S 的所有添加符号的方法数。</p><blockquote><p>示例：<br>输入：nums: [1, 1, 1, 1, 1], S: 3<br>输出：5<br>解释：<br>-1+1+1+1+1 = 3<br>+1-1+1+1+1 = 3<br>+1+1-1+1+1 = 3<br>+1+1+1-1+1 = 3<br>+1+1+1+1-1 = 3<br>一共有5种方法让最终目标和为3。</p></blockquote><p>链接：<a href="https://leetcode-cn.com/problems/target-sum" target="_blank" rel="noopener">https://leetcode-cn.com/problems/target-sum</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商</p><p><strong>【分析一】</strong></p><p>怎么看出这是一道背包问题呢？<br>在给定的数组中，找最大利益或达到某个值，这类问题可以被归为背包问题。</p><p>定义状态<br><code>dp[i][j]</code>表示考虑前i个数，使其元素和为j的方案数。<br>对于第i个数nums[i]，我们考虑的不是nums[i]选还是不选，而是nums[i]是加还是减，</p><ul><li>如果nums[i]为减，则前i-1个数的和为j+nums[i]，方案数为<code>dp[i-1][j+nums[i]]</code></li><li>如果nums[i]为加，则前i-1个数的和为j-nums[i],方案数为<code>dp[i-1][j-nums[i]]</code></li></ul><p>状态转移方程为<br><code>dp[i][j]=dp[i-1][j+nums[i]] + dp[i-1][j-nums[i]]</code></p><p>假设nums=[1,1,1,1,1]，则i的取值为0,1,2,3,4，表示考虑前1,…5个数。j的取值为-5,-4,-3,-2,-1,0,1,2,3,4,5，表示nums中可能的和。</p><p>初始化<br><code>dp[0][0]=1</code>表示考虑前0个数，和为0的方案数为1</p><p>状态转移矩阵为</p><p><img src="/2020/06/06/Leetcode之动态规划/3.png" alt=""></p><p>j表示元素之和，例如上面的例子中j取值-5,-4,…5，但是在dp数组中，数组下标从0开始，也是就是原先j=-5，在dp中下标为0，j=-4，下标为1，j=0，下标为5。所以代码实现中第二层for循环，j取值从-5到5，在dp的下标中需要加上max_sum，将其变换成0~10</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findTargetSumWays</span><span class="params">(self, nums, S)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :type S: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> nums:<span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> abs(sum(nums)) &lt; abs(S):<span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        N = len(nums)</span><br><span class="line">        max_sum = sum(nums)</span><br><span class="line"></span><br><span class="line">        dp = [[<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> range(<span class="number">2</span>*max_sum+<span class="number">1</span>)] <span class="keyword">for</span> _ <span class="keyword">in</span> range(N)]</span><br><span class="line"></span><br><span class="line">        dp[<span class="number">0</span>][nums[<span class="number">0</span>]+max_sum] = <span class="number">1</span></span><br><span class="line">        <span class="comment">#注意这里是累加1，而不是直接赋值为1</span></span><br><span class="line">        <span class="comment">#因为nums[0]+max_sum和-nums[0]+max_sum可能相同，此时dp[0][-nums[0]+max_sum]应该为2，即在原先1的基础上再加1。如果不设置为累加，则dp[0][-nums[0]+max_sum]就为1，初始化就错了。</span></span><br><span class="line">        <span class="comment">#例如[0,0,0,0,1]</span></span><br><span class="line">        dp[<span class="number">0</span>][-nums[<span class="number">0</span>]+max_sum] += <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,N):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(-max_sum,max_sum+<span class="number">1</span>):</span><br><span class="line">                tmp1,tmp2 = <span class="number">0</span>,<span class="number">0</span></span><br><span class="line">                <span class="keyword">if</span> j-nums[i]+max_sum&lt;<span class="number">0</span>:</span><br><span class="line">                    tmp1 = <span class="number">0</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    tmp1 = dp[i<span class="number">-1</span>][j-nums[i]+max_sum]</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">if</span> j+nums[i]+max_sum&gt;<span class="number">2</span>*max_sum:</span><br><span class="line">                    tmp2 = <span class="number">0</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    tmp2 = dp[i<span class="number">-1</span>][j+nums[i]+max_sum]</span><br><span class="line">                dp[i][j+max_sum] = tmp1 + tmp2</span><br><span class="line">        <span class="keyword">return</span> dp[N<span class="number">-1</span>][S+max_sum]</span><br></pre></td></tr></table></figure><h2><span id="99-零钱兑换">9.9. 零钱兑换</span></h2><p>给定不同面额的硬币 coins 和一个总金额 amount。编写一个函数来计算可以凑成总金额所需的最少的硬币个数。如果没有任何一种硬币组合能组成总金额，返回 -1。</p><p>说明:<br>你可以认为每种硬币的数量是无限的。</p><blockquote><p>示例 1:<br>输入: coins = [1, 2, 5], amount = 11<br>输出: 3<br>解释: 11 = 5 + 5 + 1</p></blockquote><p>链接：<a href="https://leetcode-cn.com/problems/coin-change" target="_blank" rel="noopener">https://leetcode-cn.com/problems/coin-change</a></p><p><strong>【分析一】</strong></p><p>这是一道完全背包问题，背包容量为amount，从一堆硬币中选出一些，使得总金额恰好等于amount。与标准完全背包问题不同的是</p><ul><li>本题要求恰好装满背包，即总金额恰好为amount。标准背包问题只要求容量小于等于背包</li><li>本题求最少的硬币数。标准背包问题求最大价值。</li></ul><p>完全背包问题可以使用一维数组来转移，这里直接写一维状态转移方程。<br><strong>定义状态</strong><br><code>f[i][j]</code>:考虑前i个硬币，背包中硬币总金额恰好为j的硬币个数<br><code>f[i][j]=min(f[i-1][j],f[i][j-coins[i]+1])</code></p><p>压缩成一维状态转移矩阵为：<br><code>f[j]=min(f[j],f[j-coins[i]+1])</code><br>第一个<code>f[j]</code>表示考虑前i个硬币，背包总金额为j的硬币数<br>第二个<code>f[j]</code>表示考虑前i-1个硬币，背包总金额为j的硬币数<br><code>f[j-coins[i]]</code>表示考虑前i个硬币，向背包中多放一个第i个硬币，</p><p><strong>初始化</strong><br>因为题目要求背包金额恰好为amount的硬币个数。<br>初始化即考虑前0个硬币的情况，使用一个不可能的值，即正无穷进行初始化。<br>对于一些特殊情况，单独处理：</p><ul><li>当amount=0时，用0个硬币恰好装满背包。</li><li>当coins[0]=5时，说明用第一个硬币恰好能装满容量为5的背包，即<code>f[coins[0]] = 1</code></li></ul><p>第一层for循环遍历所有的硬币。第二层for循环遍历所有的总金额。当j=amount时，找出当前的硬币数，并记录最小的硬币数。最终返回的时候，需要判断res的值。如果res为inf时，说明没有一种方案可以使总金额为amount，题目要求这种无解的情况返回-1，否则返回最少的硬币数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">coinChange</span><span class="params">(self, coins, amount)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type coins: List[int]</span></span><br><span class="line"><span class="string">        :type amount: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> coins:<span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">        <span class="keyword">if</span> amount == <span class="number">0</span>:<span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        n = len(coins)</span><br><span class="line">        <span class="comment">#f[i][j]:考虑前i个硬币，恰好凑成j的硬币数</span></span><br><span class="line">        f = [float(<span class="string">'inf'</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> range(amount+<span class="number">1</span>)]</span><br><span class="line"></span><br><span class="line">        f[<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> coins[<span class="number">0</span>] &lt;= amount:</span><br><span class="line">            f[coins[<span class="number">0</span>]] = <span class="number">1</span></span><br><span class="line">            </span><br><span class="line">        <span class="comment">#对于第i个硬币，有2种选择：选、不选</span></span><br><span class="line">        <span class="comment">#第i个硬币可以选0,1,2,...k个，f[i][j]= f[i-1][j-k*coins[i]]+k</span></span><br><span class="line">        <span class="comment">#将其优化到本层，f[i][j] = f[i][j-coins[i]]+1</span></span><br><span class="line">        res = float(<span class="string">'inf'</span>)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>,n):<span class="comment">#考虑前i个硬币</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(coins[i],amount+<span class="number">1</span>):<span class="comment">#总金额为j</span></span><br><span class="line">                f[j] = min(f[j],f[j-coins[i]]+<span class="number">1</span>)</span><br><span class="line">                <span class="keyword">if</span> j == amount <span class="keyword">and</span> f[j] &lt; res:</span><br><span class="line">                    res = f[j]</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span> <span class="keyword">if</span> res==float(<span class="string">'inf'</span>) <span class="keyword">else</span> res</span><br></pre></td></tr></table></figure><h2><span id="910-零钱兑换-ii">9.10. 零钱兑换 II</span></h2><p>给定不同面额的硬币和一个总金额。写出函数来计算可以凑成总金额的硬币组合数。假设每一种面额的硬币有无限个。 </p><blockquote><p>示例 1:<br>输入: amount = 5, coins = [1, 2, 5]<br>输出: 4<br>解释: 有四种方式可以凑成总金额:<br>5=5<br>5=2+2+1<br>5=2+1+1+1<br>5=1+1+1+1+1</p></blockquote><p>链接：<a href="https://leetcode-cn.com/problems/coin-change-2" target="_blank" rel="noopener">https://leetcode-cn.com/problems/coin-change-2</a></p><p><strong>【分析一】</strong><br>这道题相对上一道题求得是组合数，而不是硬币数。所以状态的定义也需要修改以下。<br><strong>定义状态</strong><br><code>f[j]</code>：表示考虑前i个硬币时，背包金额恰好为j的组合数。当j为0时，说明背包中金额为0，这是不向背包中装任何硬币，恰好满足金额为0，这是一种方案，所以f[0]=1。<br><strong>状态转移方程</strong><br>对于第i个硬币，有2种选择：选和不选。</p><ul><li>不选第i个硬币，则前i-1个硬币的总金额为j，组合数为<code>f[i-1][j]</code></li><li>选第i个硬币，则没选这个硬币之前的金额为j-coins[i]，组合数为<code>f[i][j-coins[i]]</code></li></ul><p>则<code>f[i][j] = f[i-1][j]+f[i][j-coins[i]]</code><br>将其压缩为一维状态方程，第二层for循环必须从小到大。<br><code>f[j]=f[j]+f[j-coins[i]]</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">change</span><span class="params">(self, amount, coins)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type amount: int</span></span><br><span class="line"><span class="string">        :type coins: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> amount==<span class="number">0</span>:<span class="keyword">return</span> <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">#f[j]表示考虑前i个硬币时，总金额为j的组合数</span></span><br><span class="line">        <span class="comment">#f[j] = f[j]+f[j-coins[i]]</span></span><br><span class="line">        f = [<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> range(amount+<span class="number">1</span>)]</span><br><span class="line">        f[<span class="number">0</span>]=<span class="number">1</span></span><br><span class="line">        n = len(coins)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(coins[i],amount+<span class="number">1</span>):</span><br><span class="line">                f[j] += f[j-coins[i]]</span><br><span class="line">        <span class="keyword">return</span> f[amount]</span><br></pre></td></tr></table></figure><h2><span id="911-完全平方数">9.11. 完全平方数</span></h2><p>给定正整数 n，找到若干个完全平方数（比如 1, 4, 9, 16, …）使得它们的和等于 n。你需要让组成和的完全平方数的个数最少。</p><blockquote><p>示例 1:<br>输入: n = 12<br>输出: 3<br>解释: 12 = 4 + 4 + 4.</p></blockquote><p>链接：<a href="https://leetcode-cn.com/problems/perfect-squares" target="_blank" rel="noopener">https://leetcode-cn.com/problems/perfect-squares</a></p><p><strong>【分析一】</strong></p><p>我觉得这是完全背包问题，和找零钱一样。<br>背包容量为n，给定一个数组nums，从nums中挑选一些数，使得恰好装满背包，并且个数最少。<br>这里需要提前求出nums，即先使用一个for循环求出所有小于等于n的完全平方数。<br><code>dp[j]</code>表示考虑前i个平方数，和恰好为j的数字个数。对于第i个平方数，有2各种选择：选，不选</p><ul><li>选：dp[j]=dp[j-nums[i]]+1</li><li>不选：dp[j]=dp[j]</li></ul><p><code>dp[j]=min(dp[j-nums[i]]+1,dp[j])</code><br>第一个<code>dp[j]</code>表示考虑前i个平方数的数字个数<br>第二个<code>dp[j]</code>表示只考虑前i-1个平方数的数字个数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">numSquares</span><span class="params">(self, n)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type n: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">1</span>:<span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        nums = []<span class="comment">#存储所有&lt;=n的平方数</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,n):</span><br><span class="line">            <span class="keyword">if</span> i*i&lt;=n:</span><br><span class="line">                nums.append(i*i)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        dp = [float(<span class="string">'inf'</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> range(n+<span class="number">1</span>)]</span><br><span class="line">        <span class="comment">#完全背包问题，背包容量为n，从nums中</span></span><br><span class="line">        dp[<span class="number">0</span>]=<span class="number">0</span></span><br><span class="line">        dp[<span class="number">1</span>]=<span class="number">1</span></span><br><span class="line">        res = float(<span class="string">'inf'</span>)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums)):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>,n+<span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> nums[i]&lt;=j:</span><br><span class="line">                    dp[j]=min(dp[j-nums[i]]+<span class="number">1</span>,dp[j])</span><br><span class="line">                <span class="keyword">if</span> j == n:</span><br><span class="line">                    res = min(res,dp[j])</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><p><strong>【分析二】</strong></p><p>同样使用二重循环，外层for循环遍历背包容量，内层循环遍历所有的平方数。<br>注意：内层循环不能使用for循环，否则超时</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">numSquares</span><span class="params">(self, n)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type n: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">1</span>:<span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        dp = [float(<span class="string">'inf'</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> range(n+<span class="number">1</span>)]</span><br><span class="line">        <span class="comment">#完全背包问题，背包容量为n，从nums中</span></span><br><span class="line">        dp[<span class="number">0</span>]=<span class="number">0</span></span><br><span class="line">        dp[<span class="number">1</span>]=<span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>,n+<span class="number">1</span>):</span><br><span class="line">            j=<span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> j*j&lt;=i:</span><br><span class="line">                dp[i] = min(dp[i-j*j]+<span class="number">1</span>,dp[i])</span><br><span class="line">                j+=<span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> dp[n]</span><br></pre></td></tr></table></figure><h2><span id="912-整数拆分">9.12. 整数拆分</span></h2><p>给定一个正整数 n，将其拆分为至少两个正整数的和，并使这些整数的乘积最大化。 返回你可以获得的最大乘积。</p><blockquote><p>示例 1:<br>输入: 2<br>输出: 1<br>解释: 2 = 1 + 1, 1 × 1 = 1。</p></blockquote><p>链接：<a href="https://leetcode-cn.com/problems/integer-break" target="_blank" rel="noopener">https://leetcode-cn.com/problems/integer-break</a></p><p><strong>【分析一】</strong></p><p>这道题同样是完全背包问题<br>背包的容量为n，在数组中挑选一些数，使得这些数之和为n，问怎么挑选才能使得这些数的乘积最大。</p><p><code>dp[j]</code>考虑前i个数，和为j的最大乘积<br><code>dp[j]=max(dp[j-k]*k,dp[j])</code></p><p>第一层for循环遍历所有的数，考虑前1个数，考虑前n-1个数，这里不能取到n，因为题目要求将n拆分成至少2个正整数的和，所以不能是n=n+0。第二层for循环遍历所有的和，从1到n。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">integerBreak</span><span class="params">(self, n)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type n: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="comment">#dp[j]:考虑前i个数，和恰好为j的乘积</span></span><br><span class="line">        dp = [<span class="number">0</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(n+<span class="number">1</span>)]</span><br><span class="line">        dp[<span class="number">0</span>]=<span class="number">1</span></span><br><span class="line">        <span class="comment">#dp[j]=max(dp[j-k]*k,dp[j])</span></span><br><span class="line"></span><br><span class="line">        res = float(<span class="string">'-inf'</span>)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,n):<span class="comment">#考虑前i个数</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(i,n+<span class="number">1</span>):<span class="comment">#和为j</span></span><br><span class="line">                dp[j] = max(dp[j-i]*i,dp[j])</span><br><span class="line">            <span class="keyword">if</span> j == n:</span><br><span class="line">                res = max(res,dp[j])</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h1><span id="10-路径问题">10. 路径问题</span></h1><p>在矩阵中找最小路径和、最大路径和、路径条数</p><h2><span id="101-不同路径">10.1. 不同路径</span></h2><p>一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。</p><p>机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。<br>问总共有多少条不同的路径？</p><p><img src="/2020/06/06/Leetcode之动态规划/4.png" alt=""></p><p>链接：<a href="https://leetcode-cn.com/problems/unique-paths" target="_blank" rel="noopener">https://leetcode-cn.com/problems/unique-paths</a></p><p><strong>【分析一】</strong></p><p>定义状态<br><code>dp[i][j]</code>表示从原点走到(i,j)的路径条数。由于机器人只能向下或向右移动一步，所以对于(i,j)来说，只有它上面的格子和它左边的格子能够到达它，所以<code>dp[i][j]</code>为上面格子(i-1,j)的路径 + 左边格子(i,j-1)的路径之和。<br>状态转移方程<br><code>dp[i][j]=dp[i-1][j]+dp[i][j-1]</code></p><p><strong>初始化</strong><br>对于边界信息，例如第一行<code>dp[0][j]</code>和第一列<code>dp[i][0]</code>，初始化为1，因为从原点到第一行、第一列某个格子只有1条路径</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">uniquePaths</span><span class="params">(self, m, n)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type m: int，行</span></span><br><span class="line"><span class="string">        :type n: int，列</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        dp = [[<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> range(n)] <span class="keyword">for</span> _ <span class="keyword">in</span> range(m)]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(m):</span><br><span class="line">            dp[i][<span class="number">0</span>]=<span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(n):</span><br><span class="line">            dp[<span class="number">0</span>][j]=<span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,m):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>,n):</span><br><span class="line">                dp[i][j]=dp[i<span class="number">-1</span>][j]+dp[i][j<span class="number">-1</span>]</span><br><span class="line">        <span class="keyword">return</span> dp[m<span class="number">-1</span>][n<span class="number">-1</span>]</span><br></pre></td></tr></table></figure><ul><li>时间复杂度：O(m*n)</li><li>空间复杂度：O(m*n)</li></ul><p><strong>【空间优化】</strong></p><p>每个点只需要知道它上面格子和左边格子的路径即可，所以不需要使用数组，只用2个变量来记录。</p><ul><li>时间复杂度：O(m*n)</li><li>空间复杂度：O(2*n)</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">uniquePaths</span><span class="params">(self, m, n)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type m: int，行</span></span><br><span class="line"><span class="string">        :type n: int，列</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="comment">#使用pre记录上一行的值，cur记录当前行的值</span></span><br><span class="line">        pre = [<span class="number">1</span> <span class="keyword">for</span> _ <span class="keyword">in</span> range(n)]</span><br><span class="line">        cur = [<span class="number">1</span> <span class="keyword">for</span> _ <span class="keyword">in</span> range(n)]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,m):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>,n):</span><br><span class="line">                cur[j] = pre[j]+cur[j<span class="number">-1</span>]</span><br><span class="line">            pre = cur[:]</span><br><span class="line">        <span class="keyword">return</span> cur[<span class="number">-1</span>]</span><br></pre></td></tr></table></figure><p>上面使用2个数组来保存上一行的值和当前的值。下面再次进行空间优化，只使用一个数组cur，既保存上一行的值，也保存当前行的值。</p><ul><li>时间复杂度：O(m*n)</li><li>空间复杂度：O(n)</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">uniquePaths</span><span class="params">(self, m, n)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type m: int，行</span></span><br><span class="line"><span class="string">        :type n: int，列</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="comment">#只使用一个数组</span></span><br><span class="line">        cur = [<span class="number">1</span> <span class="keyword">for</span> _ <span class="keyword">in</span> range(n)]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,m):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>,n):</span><br><span class="line">                cur[j] += cur[j<span class="number">-1</span>]</span><br><span class="line">        <span class="keyword">return</span> cur[<span class="number">-1</span>]</span><br></pre></td></tr></table></figure><h2><span id="102-不同路径ii">10.2. 不同路径II</span></h2><p>一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。<br>机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。<br>现在考虑网格中有障碍物，网格中的障碍物和空位置分别用 1 和 0 来表示。那么从左上角到右下角将会有多少条不同的路径？</p><p>链接：<a href="https://leetcode-cn.com/problems/unique-paths-ii" target="_blank" rel="noopener">https://leetcode-cn.com/problems/unique-paths-ii</a></p><p><img src="/2020/06/06/Leetcode之动态规划/4.png" alt=""></p><blockquote><p>示例 1:<br>输入:<br>[<br>  [0,0,0],<br>  [0,1,0],<br>  [0,0,0]<br>]<br>输出: 2<br>解释:<br>3x3 网格的正中间有一个障碍物。<br>从左上角到右下角一共有 2 条不同的路径：<br>向右 -&gt; 向右 -&gt; 向下 -&gt; 向下<br>向下 -&gt; 向下 -&gt; 向右 -&gt; 向右</p></blockquote><p><strong>【分析一】</strong></p><p>同样使用二维数组来保存每个格子的路径数。<br>在初始化的时候需要注意：初始化第一行或第一列的时候，一旦遇到了1，在这一行后面的格子和这一列后面的格子都不能到达，所以为0。即初始化时使用while而不能使用for。使用while一段遇到1就退出while循环，而使用for会一直走到这一行和这一列的末尾。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">uniquePathsWithObstacles</span><span class="params">(self, obstacleGrid)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type obstacleGrid: List[List[int]]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> obstacleGrid:<span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> obstacleGrid[<span class="number">0</span>][<span class="number">0</span>]==<span class="number">1</span>:<span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        m,n = len(obstacleGrid),len(obstacleGrid[<span class="number">0</span>])<span class="comment">#m行，n列</span></span><br><span class="line">        dp = [[<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> range(n)] <span class="keyword">for</span> _ <span class="keyword">in</span> range(m)]</span><br><span class="line">        i = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> i &lt; m <span class="keyword">and</span> obstacleGrid[i][<span class="number">0</span>]!=<span class="number">1</span>:</span><br><span class="line">            dp[i][<span class="number">0</span>]=<span class="number">1</span></span><br><span class="line">            i+=<span class="number">1</span></span><br><span class="line">        j = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> j &lt; n <span class="keyword">and</span> obstacleGrid[<span class="number">0</span>][j]!=<span class="number">1</span>:</span><br><span class="line">            dp[<span class="number">0</span>][j]=<span class="number">1</span></span><br><span class="line">            j+=<span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,m):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>,n):</span><br><span class="line">                <span class="keyword">if</span> obstacleGrid[i][j]!=<span class="number">1</span>:<span class="comment">#如果能到达</span></span><br><span class="line">                    dp[i][j]=dp[i<span class="number">-1</span>][j]+dp[i][j<span class="number">-1</span>]</span><br><span class="line">                <span class="comment">#否则dp[i][j]=0</span></span><br><span class="line">        <span class="keyword">return</span> dp[m<span class="number">-1</span>][n<span class="number">-1</span>]</span><br></pre></td></tr></table></figure><p><strong>【空间优化】</strong></p><p>将dp优化为一维数组，用来保存上一层和当前层的路径条数。<br>首先dp初始化为0，然后对于第一行的值，在障碍之前的格子路径再次初始化为1，之后的格子路径还是0.这里只对第一行进行初始化。<br>然后2重for循环遍历时，i从第二行开始，j也从第二列开始。但是对于第二行的第一列还没有初始化，所以在第一层for循环之后先对改行的第1列进行初始化。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">uniquePathsWithObstacles</span><span class="params">(self, obstacleGrid)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type obstacleGrid: List[List[int]]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> obstacleGrid[<span class="number">0</span>][<span class="number">0</span>]==<span class="number">1</span>:<span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">#dp[i][j]表示点(i,j)的路径数</span></span><br><span class="line">        m,n = len(obstacleGrid),len(obstacleGrid[<span class="number">0</span>])</span><br><span class="line">        dp = [<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> range(n)]</span><br><span class="line"></span><br><span class="line">        <span class="comment">#初始化,第一行和第一列中，1后面的路径都为0</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(n):</span><br><span class="line">            <span class="keyword">if</span> obstacleGrid[<span class="number">0</span>][j] !=<span class="number">1</span>:</span><br><span class="line">                dp[j] = <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line"> </span><br><span class="line">        <span class="comment">#dp[i][j] = dp[i-1][j]+dp[i][j-1]</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,m):</span><br><span class="line">            <span class="comment">#先初始化第i行的第一列</span></span><br><span class="line">            <span class="keyword">if</span> obstacleGrid[i][<span class="number">0</span>] == <span class="number">1</span>:</span><br><span class="line">                dp[<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>,n):</span><br><span class="line">                <span class="keyword">if</span> obstacleGrid[i][j] == <span class="number">1</span>:</span><br><span class="line">                    dp[j] = <span class="number">0</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    dp[j] = dp[j]+dp[j<span class="number">-1</span>]</span><br><span class="line">        <span class="keyword">return</span> dp[n<span class="number">-1</span>]</span><br></pre></td></tr></table></figure><p>这道题和上一道题的区别是这道题有障碍，上一题没有障碍。所以上一题对dp初始化为1，表示每个格子至少有1条路径可以到达。但是这一道题对dp初始化为0，然后再对第一行和第一列的某些特殊格子再单独初始化为1。</p><h2><span id="103-下降路径最小和">10.3. 下降路径最小和</span></h2><p>给定一个方形整数数组 A，我们想要得到通过 A 的下降路径的最小和。</p><p>下降路径可以从第一行中的任何元素开始，并从每一行中选择一个元素。在下一行选择的元素和当前行所选元素最多相隔一列。</p><p>链接：<a href="https://leetcode-cn.com/problems/minimum-falling-path-sum" target="_blank" rel="noopener">https://leetcode-cn.com/problems/minimum-falling-path-sum</a></p><blockquote><p>输入：<code>[[1,2,3],[4,5,6],[7,8,9]]</code><br>输出：12<br>解释：<br>可能的下降路径有：<br>[1,4,7], [1,4,8], [1,5,7], [1,5,8], [1,5,9]<br>[2,4,7], [2,4,8], [2,5,7], [2,5,8], [2,5,9], [2,6,8], [2,6,9]<br>[3,5,7], [3,5,8], [3,5,9], [3,6,8], [3,6,9]<br>和最小的下降路径是 [1,4,7]，所以答案是 12。</p></blockquote><p><strong>【分析一】</strong></p><p>定义状态<br><code>dp[i][j]</code>表示格子(i,j)的最小路径和。<br>一个格子只能向左下，正下，右下移动，所以(i,j)的最小路径和为min(左上，正上，右上)+A[i][j]，即状态转移方程为：<br><code>dp[i][j]=min(dp[i-1][j-1],dp[i-1][j],dp[i-1][j+1])</code></p><p>需要注意边界情况：</p><ul><li>在求第一列的dp时，它的左上方没有元素，所以只用求正上方和右上方的最小值</li><li>在求最后一列的dp时，它的右上方没有元素，所以只用求左上方和正上方的最小值</li></ul><p>遍历完整个数组后，得到完整的dp，然后求最后一行路径的最小值，作为结果返回。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minFallingPathSum</span><span class="params">(self, A)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type A: List[List[int]]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        m = len(A)</span><br><span class="line">        dp = [[<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> range(m)] <span class="keyword">for</span> _ <span class="keyword">in</span> range(m)]</span><br><span class="line"></span><br><span class="line">        <span class="comment">#初始化第一行</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(m):</span><br><span class="line">            dp[<span class="number">0</span>][j] = A[<span class="number">0</span>][j]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,m):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(m):</span><br><span class="line">                <span class="keyword">if</span> j<span class="number">-1</span>&lt;<span class="number">0</span>:</span><br><span class="line">                    dp[i][j]=min(dp[i<span class="number">-1</span>][j],dp[i<span class="number">-1</span>][j+<span class="number">1</span>])+A[i][j]</span><br><span class="line">                <span class="keyword">elif</span> j+<span class="number">1</span>&gt;=m:</span><br><span class="line">                    dp[i][j]=min(dp[i<span class="number">-1</span>][j<span class="number">-1</span>],dp[i<span class="number">-1</span>][j])+A[i][j]</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    dp[i][j]=min(dp[i<span class="number">-1</span>][j<span class="number">-1</span>],dp[i<span class="number">-1</span>][j],dp[i<span class="number">-1</span>][j+<span class="number">1</span>])+A[i][j]</span><br><span class="line"></span><br><span class="line">        res = float(<span class="string">'inf'</span>)</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(m):</span><br><span class="line">            <span class="keyword">if</span> dp[m<span class="number">-1</span>][j]&lt;res:</span><br><span class="line">                res = dp[m<span class="number">-1</span>][j]</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h2><span id="104-下降路径最小和ii">10.4. 下降路径最小和II</span></h2><p>给你一个整数方阵 arr ，定义「非零偏移下降路径」为：从 arr 数组中的每一行选择一个数字，且按顺序选出来的数字中，相邻数字不在原数组的同一列。<br>请你返回非零偏移下降路径数字和的最小值。</p><p>链接：<a href="https://leetcode-cn.com/problems/minimum-falling-path-sum-ii" target="_blank" rel="noopener">https://leetcode-cn.com/problems/minimum-falling-path-sum-ii</a></p><blockquote><p>示例 1：<br>输入：arr = [[1,2,3],[4,5,6],[7,8,9]]<br>输出：13<br>解释：<br>所有非零偏移下降路径包括：<br>[1,5,9], [1,5,7], [1,6,7], [1,6,8],<br>[2,4,8], [2,4,9], [2,6,7], [2,6,8],<br>[3,4,8], [3,4,9], [3,5,7], [3,5,9]<br>下降路径中数字和最小的是 [1,5,7] ，所以答案是 13 。</p></blockquote><p><strong>【分析一】</strong></p><p><code>dp[i][j]</code>表示以<code>arr[i][j]</code>为结尾的最小路径和。每一行和上一行的值不能是同一列，所以需要找出上一行除了当前列的最小值。下面使用三重循环，第一个for循环遍历所有的行，第二个for循环遍历当前行所有的列，第三个for循环遍历上一行所有的列，除了当前列j,并记录上一行所有的最小路径和。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minFallingPathSum</span><span class="params">(self, arr)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type arr: List[List[int]]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="comment">#dp[i][j]表示以arr[i][j]为结尾的最小和</span></span><br><span class="line">        <span class="comment">#dp[i][j]=min&#123;dp[i-1][k]&#125;+arr[i][j],(k!=j)</span></span><br><span class="line">        m,n = len(arr),len(arr[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line">        dp = [[<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> range(n)] <span class="keyword">for</span> _ <span class="keyword">in</span> range(m)]</span><br><span class="line"></span><br><span class="line">        <span class="comment">#dp的第一行就是该行的值</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(n):</span><br><span class="line">            dp[<span class="number">0</span>][j] = arr[<span class="number">0</span>][j]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(m):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(n):</span><br><span class="line">                last_min = float(<span class="string">'inf'</span>)</span><br><span class="line">                <span class="keyword">for</span> k <span class="keyword">in</span> range(n):</span><br><span class="line">                    <span class="keyword">if</span> k != j:</span><br><span class="line">                        last_min = min(last_min,dp[i<span class="number">-1</span>][k])</span><br><span class="line">                dp[i][j] = last_min + arr[i][j]</span><br><span class="line">        <span class="comment">#找出最后一行最小的和</span></span><br><span class="line">        res = float(<span class="string">'inf'</span>)</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(n):</span><br><span class="line">            res = min(res,dp[m<span class="number">-1</span>][j])</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h2><span id="105-最小路径和">10.5. 最小路径和</span></h2><p>给定一个包含非负整数的 m x n 网格，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。</p><p>说明：每次只能向下或者向右移动一步。</p><blockquote><p>示例:<br>输入:<br>[<br>  [1,3,1],<br>  [1,5,1],<br>  [4,2,1]<br>]<br>输出: 7<br>解释: 因为路径 1→3→1→1→1 的总和最小。</p></blockquote><p>链接：<a href="https://leetcode-cn.com/problems/minimum-path-sum" target="_blank" rel="noopener">https://leetcode-cn.com/problems/minimum-path-sum</a></p><p><strong>【分析一】</strong><br><code>dp[i][j]</code>表示在(i,j)的最小路径和。首先将dp初始化为0，然后再单独处理dp的第一行和第一列。<br>状态转移方程<br><code>dp[i][j]=min(dp[i-1][j],dp[i][j-1])+grid[i][j]</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minPathSum</span><span class="params">(self, grid)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type grid: List[List[int]]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> grid:<span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        m,n = len(grid),len(grid[<span class="number">0</span>])</span><br><span class="line">        <span class="comment">#dp[i][j]=min(dp[i-1][j],dp[i][j-1])+grid[i][j]</span></span><br><span class="line">        dp = [[<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> range(n)] <span class="keyword">for</span> _ <span class="keyword">in</span> range(m)]</span><br><span class="line">        </span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = grid[<span class="number">0</span>][<span class="number">0</span>]</span><br><span class="line">        </span><br><span class="line">        <span class="comment">#初始化第一行和第一列</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>,n):</span><br><span class="line">            dp[<span class="number">0</span>][j] = dp[<span class="number">0</span>][j<span class="number">-1</span>]+grid[<span class="number">0</span>][j]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,m):</span><br><span class="line">            dp[i][<span class="number">0</span>] = dp[i<span class="number">-1</span>][<span class="number">0</span>]+grid[i][<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,m):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>,n):</span><br><span class="line">                dp[i][j] = min(dp[i<span class="number">-1</span>][j],dp[i][j<span class="number">-1</span>])+grid[i][j]</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">-1</span>][<span class="number">-1</span>]</span><br></pre></td></tr></table></figure><p><strong>【空间优化】</strong><br>将二维数组优化为一维数组，<br><code>dp[j]=min(dp[j],dp[j-1])+grid[i][j]</code><br>第一个<code>dp[j]</code>表示当前行的最小路径和<br>第二个<code>dp[j]</code>表示正上方的最小路径和<br><code>dp[j-1]</code>表示当前行左边的最小路径和</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minPathSum</span><span class="params">(self, grid)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type grid: List[List[int]]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> grid:<span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        m,n = len(grid),len(grid[<span class="number">0</span>])</span><br><span class="line">        <span class="comment">#dp[j]=min(dp[j],dp[j-1])+grid[i][j]</span></span><br><span class="line">        dp = [<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> range(n)]</span><br><span class="line">        </span><br><span class="line">        dp[<span class="number">0</span>] = grid[<span class="number">0</span>][<span class="number">0</span>]</span><br><span class="line">        </span><br><span class="line">        <span class="comment">#初始化第一行</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>,n):</span><br><span class="line">            dp[j] = dp[j<span class="number">-1</span>]+grid[<span class="number">0</span>][j]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,m):</span><br><span class="line">            dp[<span class="number">0</span>]=dp[<span class="number">0</span>]+grid[i][<span class="number">0</span>]</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>,n):</span><br><span class="line">                dp[j] = min(dp[j],dp[j<span class="number">-1</span>])+grid[i][j]</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">-1</span>]</span><br></pre></td></tr></table></figure><h2><span id="106-三角形最小路径和">10.6. 三角形最小路径和</span></h2><p>给定一个三角形，找出自顶向下的最小路径和。每一步只能移动到下一行中相邻的结点上。</p><p>相邻的结点 在这里指的是 下标 与 上一层结点下标 相同或者等于 上一层结点下标 + 1 的两个结点。</p><p>链接：<a href="https://leetcode-cn.com/problems/triangle" target="_blank" rel="noopener">https://leetcode-cn.com/problems/triangle</a></p><blockquote><p>例如，给定三角形：<br>[<br>     [2],<br>    [3,4],<br>   [6,5,7],<br>  [4,1,8,3]<br>]<br>自顶向下的最小路径和为 11（即，2 + 3 + 5 + 1 = 11）。</p></blockquote><p><strong>【分析一】</strong><br><code>dp[i][j]</code>表示以<code>triangle[i][j]</code>为结尾的最小路径和。当前值由正上方<code>dp[i-1][j]</code>和左上方的值<code>dp[i-1][j-1]</code>转移得到。<br>即<code>dp[i][j]=min(dp[i-1][j],dp[i-1][j-1])+triangle[i][j]</code><br>使用一维数据进行空间优化<br><code>dp[j]=min(dp[j],dp[j-1])+triangle[i][j]</code><br>需要注意的时，等号后面的<code>dp[j]</code>和<code>dp[j-1]</code>都是上一行的值，所以在第二层for循环需要倒序遍历<code>j</code>，这是<code>dp[j-1]</code>才不会被当前行的值所覆盖。<br>同时需要注意，三角形中每一行的元素个数不一样，注意边界问题。</p><ul><li>当<code>j=0</code>时，<code>dp[j]</code>只能由正上方的元素转移，因为它左上方没有值</li><li>当<code>j=i</code>时，即当前行的最后一个元素，只能由左上方的元素转移，因为它正上方没有元素</li><li>其余元素由正上方和左上方的元素转移</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minimumTotal</span><span class="params">(self, triangle)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type triangle: List[List[int]]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        n = len(triangle)<span class="comment">#三角形的行数</span></span><br><span class="line">        dp = [<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> range(n)]</span><br><span class="line">        <span class="comment">#dp[j] = min(dp[j],dp[j-1])+triangle[j]</span></span><br><span class="line">        <span class="comment">#初始化</span></span><br><span class="line">        dp[<span class="number">0</span>]=triangle[<span class="number">0</span>][<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,n):<span class="comment">#从第二行开始遍历</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(i,<span class="number">-1</span>,<span class="number">-1</span>):</span><br><span class="line">                <span class="keyword">if</span> j == <span class="number">0</span>:</span><br><span class="line">                    dp[j] = dp[j]+triangle[i][j]</span><br><span class="line">                <span class="keyword">elif</span> j == i:</span><br><span class="line">                    dp[j] = dp[j<span class="number">-1</span>]+triangle[i][j]</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    dp[j] = min(dp[j],dp[j<span class="number">-1</span>])+triangle[i][j]</span><br><span class="line">        <span class="keyword">return</span> min(dp)</span><br></pre></td></tr></table></figure><h1><span id="11-统计全为1的正方形子矩形">11. 统计全为1的正方形子矩形</span></h1><p>给你一个 m * n 的矩阵，矩阵中的元素不是 0 就是 1，请你统计并返回其中完全由 1 组成的 正方形 子矩阵的个数。</p><blockquote><p>示例 1：<br>输入：matrix =<br>[<br>  [0,1,1,1],<br>  [1,1,1,1],<br>  [0,1,1,1]<br>]<br>输出：15<br>解释：<br>边长为 1 的正方形有 10 个。<br>边长为 2 的正方形有 4 个。<br>边长为 3 的正方形有 1 个。<br>正方形的总数 = 10 + 4 + 1 = 15.</p></blockquote><p>链接：<a href="https://leetcode-cn.com/problems/count-square-submatrices-with-all-ones" target="_blank" rel="noopener">https://leetcode-cn.com/problems/count-square-submatrices-with-all-ones</a></p><p><strong>【分析一】</strong></p><p><code>dp[i][j][k]</code>表示以<code>matrix[i][j]</code>为右下角，边长为k的正方形区域是否全为1，全为1,<code>dp[i][j][k]=True</code>,否则为<code>False</code>.<br>以(2,3)为右下角，边长为3的正方形区域是否全为1：</p><ul><li>先判断(i,j)位置是否为1，如果不是1，说明不能组成正方形，如果是，进行下一步判断</li><li>分别判断以<code>(i-1,j),(i-1,j-1),(i,j-1)</code>为右下角的区域是否能构成边长为2的正方形，如果能构成，说明<code>dp[i][j][k]=True</code></li></ul><p><img src="/2020/06/06/Leetcode之动态规划/5.png" alt=""></p><p>状态转移方程为:<br><code>dp[i][j][k]=(matrix[i][j] and dp[i-1][j][k-1] and dp[i-1][j-1][k-1] and dp[i][j-1][k-1])</code></p><p>但是这样时间复杂度太多，三重循环，超时</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">countSquares</span><span class="params">(self, matrix)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type matrix: List[List[int]]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="comment">#dp[i][j][k]以matrix[i][j]为右下角，边长为k的正方形是否全是1，True或者False</span></span><br><span class="line">        m,n = len(matrix),len(matrix[<span class="number">0</span>])</span><br><span class="line">        max_len = min(m,n)<span class="comment">#正方形最大的边长</span></span><br><span class="line"></span><br><span class="line">        dp = [[[<span class="keyword">False</span> <span class="keyword">for</span> _ <span class="keyword">in</span> range(max_len+<span class="number">1</span>)] <span class="keyword">for</span> _ <span class="keyword">in</span> range(n)] <span class="keyword">for</span> _ <span class="keyword">in</span> range(m)]</span><br><span class="line">        <span class="comment">#初始化边长为1的正方形的个数</span></span><br><span class="line">        count = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(m):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(n):</span><br><span class="line">                <span class="keyword">if</span> matrix[i][j]==<span class="number">1</span>:</span><br><span class="line">                    dp[i][j][<span class="number">1</span>]=<span class="keyword">True</span></span><br><span class="line">                    count+=<span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,m):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>,n):</span><br><span class="line">                <span class="keyword">for</span> k <span class="keyword">in</span> range(<span class="number">2</span>,max_len+<span class="number">1</span>):</span><br><span class="line">                    <span class="keyword">if</span> matrix[i][j] == <span class="number">1</span>:</span><br><span class="line">                        dp[i][j][k] = dp[i<span class="number">-1</span>][j][k<span class="number">-1</span>] <span class="keyword">and</span> dp[i][j<span class="number">-1</span>][k<span class="number">-1</span>] <span class="keyword">and</span> dp[i<span class="number">-1</span>][j<span class="number">-1</span>][k<span class="number">-1</span>]</span><br><span class="line">                    <span class="keyword">if</span> dp[i][j][k]:</span><br><span class="line">                        count+=<span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> count</span><br></pre></td></tr></table></figure><p><strong>【空间优化】</strong></p><p>这里针对上述情况进行优化，将三维数组压缩为二维。<br>题目并不关心边长为1,2..k的正方形各有多少，并且以(i,j)为右下角边长为k的正方形全为1的话，那么以(i,j)为右下角，边长为1,2,…k-1的正方形也一定全为1.</p><p><img src="/2020/06/06/Leetcode之动态规划/6.png" alt=""></p><p>如上图所示，红色区域中是以(2,3)为右下角边长为3的正方形，这里以(2,3)为右下角的正方形还有边长为1，边长的2的这2个正方形。所以以(2,3)为右下角的正方形个数有3个，正是最大正方形的边长。</p><p>所以状态<code>dp[i][j]</code>表示以<code>matrix[i][j]</code>为右下角的正方形最大边长。<br><code>dp[i][j]=min(dp[i-1][j],dp[i-1][j-1],dp[i][j-1])+1</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">countSquares</span><span class="params">(self, matrix)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type matrix: List[List[int]]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="comment">#dp[i][j][k]以matrix[i][j]为右下角，边长为k的正方形是否全是1，True或者False</span></span><br><span class="line">        m,n = len(matrix),len(matrix[<span class="number">0</span>])</span><br><span class="line">        dp = [[<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> range(n)] <span class="keyword">for</span> _ <span class="keyword">in</span> range(m)]</span><br><span class="line"></span><br><span class="line">        <span class="comment">#初始化边长为1的正方形的个数</span></span><br><span class="line">        count = <span class="number">0</span></span><br><span class="line">        <span class="comment">#初始化第一行和第一列</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(n):</span><br><span class="line">            <span class="keyword">if</span> matrix[<span class="number">0</span>][j] == <span class="number">1</span>:</span><br><span class="line">                dp[<span class="number">0</span>][j] = <span class="number">1</span></span><br><span class="line">                count+=<span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(m):</span><br><span class="line">            <span class="keyword">if</span> matrix[i][<span class="number">0</span>]==<span class="number">1</span>:</span><br><span class="line">                dp[i][<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">                count+=<span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> matrix[<span class="number">0</span>][<span class="number">0</span>]==<span class="number">1</span>:</span><br><span class="line">            count-=<span class="number">1</span> <span class="comment"># matrix[0][0]被计算了2次</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,m):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>,n):</span><br><span class="line">                <span class="keyword">if</span> matrix[i][j] == <span class="number">1</span>:</span><br><span class="line">                    dp[i][j] = min(dp[i<span class="number">-1</span>][j],dp[i<span class="number">-1</span>][j<span class="number">-1</span>],dp[i][j<span class="number">-1</span>])+<span class="number">1</span></span><br><span class="line">                    count+=dp[i][j]</span><br><span class="line">        <span class="keyword">return</span> count</span><br></pre></td></tr></table></figure><h1><span id="12-最大正方形">12. 最大正方形</span></h1><p>在一个由 0 和 1 组成的二维矩阵内，找到只包含 1 的最大正方形，并返回其面积。</p><blockquote><p>示例:<br>输入:<br>1 0 1 0 0<br>1 0 1 1 1<br>1 1 1 1 1<br>1 0 0 1 0<br>输出: 4</p></blockquote><p>链接：<a href="https://leetcode-cn.com/problems/maximal-square" target="_blank" rel="noopener">https://leetcode-cn.com/problems/maximal-square</a></p><p><strong>【分析一】</strong></p><p>和和上一题的状态转移方程一样<br><code>dp[i][j]=min(dp[i-1][j],dp[i-1][j-1],dp[i][j-1])+1</code><br><code>dp[i][j]</code>表示以<code>matrix[i][j]</code>为右下角的正方形的最大边长</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maximalSquare</span><span class="params">(self, matrix)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type matrix: List[List[str]]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> matrix:<span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        m,n = len(matrix),len(matrix[<span class="number">0</span>])<span class="comment">#二维矩阵的行数，列数</span></span><br><span class="line"></span><br><span class="line">        res = <span class="number">0</span><span class="comment">#正方形最大边长</span></span><br><span class="line">        dp = [[<span class="number">0</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(n)] <span class="keyword">for</span> _ <span class="keyword">in</span> range(m)]</span><br><span class="line">        <span class="comment">#初始化第一行和第一列</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(n):</span><br><span class="line">            <span class="keyword">if</span> matrix[<span class="number">0</span>][j]==<span class="string">'1'</span>:</span><br><span class="line">                dp[<span class="number">0</span>][j]=<span class="number">1</span></span><br><span class="line">                res = max(res,dp[<span class="number">0</span>][j])</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(m):</span><br><span class="line">            <span class="keyword">if</span> matrix[i][<span class="number">0</span>]==<span class="string">'1'</span>:</span><br><span class="line">                dp[i][<span class="number">0</span>]=<span class="number">1</span></span><br><span class="line">                res = max(res,dp[i][<span class="number">0</span>])</span><br><span class="line">        </span><br><span class="line">        <span class="comment">#i，j表示正方形的左边界和右边界</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,m):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>,n):</span><br><span class="line">                <span class="keyword">if</span> matrix[i][j]==<span class="string">'1'</span>:</span><br><span class="line">                    dp[i][j]=min(dp[i<span class="number">-1</span>][j],dp[i<span class="number">-1</span>][j<span class="number">-1</span>],dp[i][j<span class="number">-1</span>])+<span class="number">1</span></span><br><span class="line">                    res = max(res,dp[i][j])</span><br><span class="line">        <span class="keyword">return</span> res*res</span><br></pre></td></tr></table></figure><h1><span id="13-最长上升子序列问题">13. 最长上升子序列问题</span></h1><h2><span id="131-最长上升子序列">13.1. 最长上升子序列</span></h2><p>给定一个无序的整数数组，找到其中最长上升子序列的长度</p><blockquote><p>示例:<br>输入: [10,9,2,5,3,7,101,18]<br>输出: 4<br>解释: 最长的上升子序列是 [2,3,7,101]，它的长度是 4。</p></blockquote><p>说明：可能有多个最长上升子序列，只需要返回对应的长度即可。</p><p>【分析一】</p><ul><li><p>首先需要明确几个概念</p><ol><li>子序列和子串<br>子序列不要求连续。例如<code>[3,6,8]</code>是<code>[3,4,5,6,7,8]</code>的子序列。子串要求连续。</li><li>这里是上升是严格上升，<code>[1,2,2,3]</code>不是上升子序列</li><li>子序列在原始数组中的相对位置不能变</li></ol></li></ul><ul><li><p>定义状态<br><code>dp[i]</code>表示以<code>nums[i]</code>为结尾的上升子序列长度，<code>nums[i]</code>一定要被选上，是上升子序列的最后一个元素。<br><strong>注意：我们以前定义的状态<code>dp[i]</code>大多是考虑前i个元素的xx，这里的<code>nums[i]</code>可选可不选，但是这里的<code>nums[i]</code>必须被选上</strong></p></li><li><p>状态转移方程<br>对于<code>nums[i]</code>，它前面的数有[0,1,…i-1]，如果上升子序列以<code>nums[i]</code>为结果，那前面<code>nums[0,1,..i-1]</code>必须要有比<code>nums[i]</code>小的数，在这些数中找一个最大的dp值，在此基础上加1<br><code>if nums[j] &lt; nums[i]</code>，j的取值为<code>0,1,2,..i-1</code><br><code>dp[i]=max(dp[j])+1</code><br>如果前面没有比<code>nums[i]</code>小的数，那只能<code>nums[i]</code>自己组成一个上升子序列，<code>dp[i]=1</code><br>状态转移方程为<br><code>dp[i]=max(dp[i],dp[j]+1) for j in [0,i)</code></p></li></ul><p>例如<code>[10,9,2,5,3,7,100,18]</code><br>首先初始化<code>dp=[1,1,1,1,1,1,1,1]</code></p><ul><li>第一个for循环首先遍历到9，第二个for循环遍历9之前的数[10]，没有比9小，所以dp[1]=1表示以9为结尾的上升子序列长度为1.</li><li>然后遍历到2，找到2之前的元素[10,9]，没有比2小的，所以dp[2]=1</li><li>然后遍历到5，找到5之前的元素[10,9,2],其中2比5小，dp[3]=2，表示以5为结尾的上升子序列长度为2</li><li>然后遍历到3，之前的元素只有2比3小，所以dp[4]=2</li><li>然后遍历到7，之前的元素有[2,5,3]比7小，这3个数组dp最大的是5和3，都是2，所以dp[5]=2+1=3</li><li>然后遍历到100，之前的元素有[10,9,2,5,3,7]比100小，这些数中dp最大的是7，dp为3，所以100的dp[6]=4</li><li>然后遍历到18，之前的元素有[10,9,2,5,3,7]比18小，这些数中dp最大的是7，dp为3，所以dp[7]=4</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lengthOfLIS</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> nums:<span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="comment">#dp[i]以nums[i]为结尾的最长上升子序列</span></span><br><span class="line">        n = len(nums)</span><br><span class="line">        dp = [<span class="number">1</span> <span class="keyword">for</span> _ <span class="keyword">in</span> range(n)]</span><br><span class="line">        <span class="comment">#对于第i个数有2个选择：选，不选</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,n):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">0</span>,i):</span><br><span class="line">                <span class="keyword">if</span> nums[j] &lt; nums[i]:</span><br><span class="line">                    dp[i] = max(dp[i],dp[j]+<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> max(dp)</span><br></pre></td></tr></table></figure><ul><li>时间复杂度：O(n^2)</li><li>空间复杂度：O(n)</li></ul><p>【优化】</p><ul><li>时间复杂度：O(nlogn)</li><li>空间复杂度：O(n)</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lengthOfLIS</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> nums:<span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        n = len(nums)</span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">1</span>:<span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        last = [nums[<span class="number">0</span>],]</span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> nums[<span class="number">1</span>:n]:<span class="comment">#遍历nums中每个元素</span></span><br><span class="line">            <span class="keyword">if</span> num &gt; last[<span class="number">-1</span>]:<span class="comment">#如果nums大于last中所有元素，插入到last的末尾</span></span><br><span class="line">                last.append(num)</span><br><span class="line">                <span class="keyword">continue</span><span class="comment">#遍历下一个元素</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">#如果num&lt;=last中的元素，则将num替换掉比num大的最小的元素</span></span><br><span class="line">            left,right = <span class="number">0</span>,len(last)<span class="number">-1</span></span><br><span class="line">            <span class="keyword">while</span> left &lt; right:</span><br><span class="line">                mid = left+(right-left)/<span class="number">2</span></span><br><span class="line">                <span class="keyword">if</span> last[mid] &lt; num:</span><br><span class="line">                    left = mid+<span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    right = mid</span><br><span class="line">            last[left] = num</span><br><span class="line">        <span class="keyword">return</span> len(last)</span><br></pre></td></tr></table></figure><h2><span id="132-无重叠区间">13.2. 无重叠区间</span></h2><h1><span id="14-动态规划博弈问题">14. 动态规划—博弈问题</span></h1><h2><span id="141-石子游戏">14.1. 石子游戏</span></h2><p>亚历克斯和李用几堆石子在做游戏。偶数堆石子排成一行，每堆都有正整数颗石子 piles[i] 。</p><p>游戏以谁手中的石子最多来决出胜负。石子的总数是奇数，所以没有平局。</p><p>亚历克斯和李轮流进行，亚历克斯先开始。 每回合，玩家从行的开始或结束处取走整堆石头。 这种情况一直持续到没有更多的石子堆为止，此时手中石子最多的玩家获胜。</p><p>假设亚历克斯和李都发挥出最佳水平，当亚历克斯赢得比赛时返回 true ，当李赢得比赛时返回 false 。</p><blockquote><p>示例：<br>输入：[5,3,4,5]<br>输出：true<br>解释：<br>亚历克斯先开始，只能拿前 5 颗或后 5 颗石子 。<br>假设他取了前 5 颗，这一行就变成了 [3,4,5] 。<br>如果李拿走前 3 颗，那么剩下的是 [4,5]，亚历克斯拿走后 5 颗赢得 10 分。<br>如果李拿走后 5 颗，那么剩下的是 [3,4]，亚历克斯拿走后 4 颗赢得 9 分。<br>这表明，取前 5 颗石子对亚历克斯来说是一个胜利的举动，所以我们返回 true 。</p></blockquote><p>链接：<a href="https://leetcode-cn.com/problems/stone-game" target="_blank" rel="noopener">https://leetcode-cn.com/problems/stone-game</a></p><p><strong>【分析一】</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">stoneGame</span><span class="params">(self, piles)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type piles: List[int]</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        n = len(piles)</span><br><span class="line">        dp = [[<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> range(n)] <span class="keyword">for</span> _ <span class="keyword">in</span> range(n+<span class="number">1</span>)]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">            dp[i][i] = piles[i]</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n<span class="number">-1</span>,<span class="number">-1</span>,<span class="number">-1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(i+<span class="number">1</span>,n):</span><br><span class="line">                dp[i][j] = max(piles[i]-dp[i+<span class="number">1</span>][j],piles[j]-dp[i][j<span class="number">-1</span>])</span><br><span class="line">        <span class="keyword">if</span> dp[<span class="number">0</span>][n<span class="number">-1</span>]&lt;<span class="number">0</span>:<span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">        <span class="keyword">else</span>:<span class="keyword">return</span> <span class="keyword">True</span></span><br></pre></td></tr></table></figure><h2><span id="142-预测赢家">14.2. 预测赢家</span></h2><p>给定一个表示分数的非负整数数组。 玩家1从数组任意一端拿取一个分数，随后玩家2继续从剩余数组任意一端拿取分数，然后玩家1拿，……。每次一个玩家只能拿取一个分数，分数被拿取之后不再可取。直到没有剩余分数可取时游戏结束。最终获得分数总和最多的玩家获胜。</p><p>给定一个表示分数的数组，预测玩家1是否会成为赢家。你可以假设每个玩家的玩法都会使他的分数最大化。</p><blockquote><p>示例 1:<br>输入: [1, 5, 2]<br>输出: False<br>解释: 一开始，玩家1可以从1和2中进行选择。<br>如果他选择2（或者1），那么玩家2可以从1（或者2）和5中进行选择。如果玩家2选择了5，那么玩家1则只剩下1（或者2）可选。<br>所以，玩家1的最终分数为 1 + 2 = 3，而玩家2为 5。<br>因此，玩家1永远不会成为赢家，返回 False。</p></blockquote><p>链接：<a href="https://leetcode-cn.com/problems/predict-the-winner" target="_blank" rel="noopener">https://leetcode-cn.com/problems/predict-the-winner</a></p><p><strong>【分析一】</strong></p><p><code>dp[i][j]</code>表示在<code>nums[i,...,j]</code>中，当前人（不一定是先手）与另一个人总数的最大分差。<br>对于<code>nums[i,...,j]</code>这些数字，当前操作人可以选择<code>nums[i]</code>，也可以选择<code>nums[j]</code></p><ul><li>当前人选择<code>nums[i]</code>,留给对手的是<code>nums[i+1,...,j]</code>，减去对手在<code>dp[i+1][j]</code>的领先，就是当前人的领先</li><li>当前人选择<code>nums[j]</code>，留给对手的是<code>nums[i,...,j-1]</code>，减去对手在<code>dp[i][j-1]</code>的领先，就是当前人的领先</li><li>在这2个领先中取最大的那个<br><code>dp[i][j]-max(nums[i]-dp[i+1][j],nums[j]-dp[i][j-1])</code></li></ul><p>因为在计算<code>dp[i][j]</code>时需要用到<code>dp[i+1][j]</code>和<code>dp[i][j-1]</code>，所以需要计算<code>dp[i+1]</code>，即i要从后往前遍历，<code>d[j-1]</code>，j要从前往后遍历。并且<code>j&gt;=i</code></p><p>初始化<br><code>dp[i][i]=nums[i]</code>，表示当前人只剩下<code>nums[i]</code>可以选择，对手没有数可以选择，所以最差分差为<code>nums[i]</code></p><ul><li>时间复杂度：O(n2)</li><li>空间复杂度：O(n2)</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">PredictTheWinner</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        n = len(nums)</span><br><span class="line">        <span class="comment">#这里的行为n+1，是为了状态转移时i+1越界</span></span><br><span class="line">        dp = [[<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> range(n)] <span class="keyword">for</span> _ <span class="keyword">in</span> range(n+<span class="number">1</span>)]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">            dp[i][i] = nums[i]</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n<span class="number">-1</span>,<span class="number">-1</span>,<span class="number">-1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(i+<span class="number">1</span>,n):</span><br><span class="line">                dp[i][j] = max(nums[i]-dp[i+<span class="number">1</span>][j],nums[j]-dp[i][j<span class="number">-1</span>])</span><br><span class="line">        <span class="keyword">if</span> dp[<span class="number">0</span>][n<span class="number">-1</span>]&lt;<span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">True</span></span><br></pre></td></tr></table></figure><h1><span id="15-总结">15. 总结</span></h1><ol><li><p>动态规划的思路是自底向上，先从最基本最简单的问题出发，逐步计算中间过程，最后得到需要求的解。<br>动态规划要求“后无效性”，即dp[i]依赖dp的某个值，这个值必须在dp[i]之前已经被正确求出来。<br>在做动态规划问题时，需要考虑以下问题</p><ul><li>状态<br>首先定义状态，看看题目问的问题可不可以作为状态。哪个状态方便转移就定义哪个状态</li><li>状态转移方程<br>其实就是多个问题找最优解。将当前问题分解成多个子问题，找出子问题的解，然后再从子问题中找出最优解</li><li>初始化<br>对dp进行初始化</li><li>返回结果<br>通过求解dp，思考怎么返回最终的结果，有些问题并不是返回dp[-1]</li><li>优化空间<br>写完代码之后，看一下是否可以优化空间，即表格，数组复用。观察状态转移矩阵，看看是否有些dp在用了之后就不再用到，可以使用变量来代替数据<br>多练习0-1背包问题</li></ul></li><li><p>对于<code>dp[i][j]</code>需要关注2方面</p><ul><li>for循环遍历i和j时，是i在外循环，还是j在外循环</li><li><p>在遍历i和j时，是正序遍历还是倒序遍历<br>参考回文串的题 </p><p><code>dp[i]</code>依赖于<code>dp[i-1]</code>，外循环遍历i，或者正序遍历i<br><code>dp[i]</code>依赖于<code>dp[i-1]</code>，内循环遍历i，或者外循环遍历i，但是倒序遍历i</p></li></ul></li></ol><ol><li><p>动态规划在求子序列，子数组，例如最大子序列和，最大子序列乘积等问题时，状态dp[i]为以i为结尾的最大值。这是一个经验。</p></li><li><p>在给定的数组中，找最大利益或达到某个值，这类问题可以被归为背包问题。</p><ul><li>第一层for遍历数组</li><li>第二层遍历背包容量</li><li>然后找出状态转移方程。背包问题需要注意初始化的值，例如f[0],f[nums[0]]的初始值。</li></ul></li><li><p>动态规划和贪心的区别<br>动态规划简单点说就是填写表格，用表格记录以前问题的最优解。可以用二层for循环实现。动态规划就是用空间换时间，避免子问题重复计算。<br>贪心算法不需要填表，只着眼于当前最优的解。<br>时间复杂度：暴力&gt;动态规划&gt;贪心</p></li><li>博弈问题一般都是涉及2个聪明人</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;1-动态规划&quot;&gt;&lt;a href=&quot;#1-动态规划&quot; class=&quot;headerlink&quot; title=&quot;1. 动态规划&quot;&gt;&lt;/a&gt;1. 动态规划&lt;/h1&gt;&lt;p&gt;如果是求一个问题的最优解（通常是最大值或最小值），而且该问题可以分解成若干个子问题，并且子问题之间还有重叠的更小的子问题，可以考虑使用动态规划。&lt;/p&gt;
&lt;p&gt;在解决动态规划问题时，需要分解成子问题，这里需要将子问题的最优解保存下来（一般是一维或二维数组），作为求取大问题最优解的基础。&lt;/p&gt;
&lt;p&gt;做动态规划的三个关键：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;dp[i]表示什么意思（如果二维，dp[i][j]）&lt;/li&gt;
&lt;li&gt;根据dp[i]和dp[i-1]的关系写出状态转移矩阵&lt;/li&gt;
&lt;li&gt;确定初始条件，dp[0]&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode之回溯</title>
    <link href="http://yoursite.com/2020/06/06/Leetcode%E4%B9%8B%E5%9B%9E%E6%BA%AF/"/>
    <id>http://yoursite.com/2020/06/06/Leetcode之回溯/</id>
    <published>2020-06-06T02:41:31.000Z</published>
    <updated>2020-07-15T01:58:26.961Z</updated>
    
    <content type="html"><![CDATA[<p>回溯可以看做是暴力法的升级。回溯法非常适合由多个步骤组成的问题，每个步骤都有多个选项。当我们在某一步选择了其中一个选项时，就进入到下一步，然后又面临新的选项，就这样重读选择，直至达到最终的状态。</p><a id="more"></a><!-- TOC --><ul><li><a href="#1-回溯">1. 回溯</a></li><li><a href="#2-矩阵中单词路径搜索">2. 矩阵中单词路径搜索</a></li><li><a href="#3-机器人的运动范围">3. 机器人的运动范围</a></li><li><a href="#4-全排列">4. 全排列</a></li><li><a href="#5-全排列-ii">5. 全排列 II</a></li><li><a href="#6-组合">6. 组合</a></li><li><a href="#7-组合总和">7. 组合总和</a></li><li><a href="#8-组合总和-ii">8. 组合总和 II</a></li><li><a href="#9-组合总和-iii">9. 组合总和 III</a></li><li><a href="#10-括号生成">10. 括号生成</a></li><li><a href="#11-n皇后">11. N皇后</a></li><li><a href="#12-总结">12. 总结</a></li></ul><!-- /TOC --><h1><span id="1-回溯">1. 回溯</span></h1><p>回溯问题可以理解成在一个树上进行深度优先遍历。例如给定[1,2,3]，求一共有多少种组合。第一个数字可以是1,2,3，有3种选择。然后第二个数字有2种选择，第三个数字有1个选择。<br>回溯就是在这个树上进行深度遍历时，从较深的节点层返回较浅的节点层，需要将状态回复到过去，这个恢复的过程就是“回溯”<br>回溯算法一般用递归实现。回溯算法的时间复杂度很高，因此在遍历时，如果能提前直到这一分支不可能达到满意的结果，就可以提前结束，这一操作称为“剪枝”<br>回溯+剪枝可以加快搜索速度，在这之前，一般需要做一些预处理工作来达到剪枝的目的，例如排序。但这会节省很多剪枝的时间。在回溯+剪枝时，因为时间复杂度很高，所以能用空间换时间就尽量用空间，来减少时间的消耗。</p><p><img src="/2020/06/06/Leetcode之回溯/1.png" alt=""></p><p>做回溯问题时，最好先画图，考虑以下问题</p><ul><li>分支如何产生</li><li>题目需要的解在哪里，是在叶子节点，还是非叶子节点，还是在从根节点到叶子节点的路径上</li><li>哪些搜索会产生不必要的解，如果知道这个分支会产生不必要的解，应该做剪枝，剪枝的条件是什么，代码怎么写。</li></ul><p><img src="/2020/06/06/Leetcode之回溯/3.png" alt=""></p><p>在二维矩阵寻找路径的问题，基本都可以用回溯解决</p><p>【参考资料】</p><p><a href="https://leetcode-cn.com/problems/permutations/solution/hui-su-suan-fa-python-dai-ma-java-dai-ma-by-liweiw/" target="_blank" rel="noopener">从全排列问题开始理解「回溯」算法</a></p><p><a href="https://leetcode-cn.com/problems/permutations/solution/hui-su-suan-fa-xiang-jie-by-labuladong-2/" target="_blank" rel="noopener">扒一扒回溯算法的裤子</a></p><p><strong>【回溯算法模板】</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">result = []</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">backtrack</span><span class="params">(路径, 选择列表)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> 满足结束条件:</span><br><span class="line">        result.add(路径)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> 选择 <span class="keyword">in</span> 选择列表:</span><br><span class="line">        做选择</span><br><span class="line">        backtrack(路径, 选择列表)</span><br><span class="line">        撤销选择  <span class="comment">#在递归后撤销选择</span></span><br></pre></td></tr></table></figure><h1><span id="2-矩阵中单词路径搜索">2. 矩阵中单词路径搜索</span></h1><p>请设计一个函数，用来判断在一个矩阵中是否存在一条包含某字符串所有字符的路径。路径可以从矩阵中的任意一格开始，每一步可以在矩阵中向左、右、上、下移动一格。如果一条路径经过了矩阵的某一格，那么该路径不能再次进入该格子。例如，在下面的3×4的矩阵中包含一条字符串“bfce”的路径（路径中的字母用加粗标出）。</p><p>[[“a”,”<strong>b</strong>“,”c”,”e”],</p><p>[“s”,”<strong>f</strong>“,”<strong>c</strong>“,”s”],</p><p>[“a”,”d”,”<strong>e</strong>“,”e”]]</p><p>但矩阵中不包含字符串“abfb”的路径，因为字符串的第一个字符b占据了矩阵中的第一行第二个格子之后，路径不能再次进入这个格子。</p><p>链接：<a href="https://leetcode-cn.com/problems/ju-zhen-zhong-de-lu-jing-lcof" target="_blank" rel="noopener">https://leetcode-cn.com/problems/ju-zhen-zhong-de-lu-jing-lcof</a></p><p><strong>【分析】</strong></p><p>使用深度有限搜索DFS+回溯方法来解决</p><p>深度优先搜索：先找到一个可能的方向，朝这个方向搜到底，如果不满足，再回溯到上一个节点，沿这个方向搜索<br>回溯：在搜索中，遇到这条路不可能和目标字符串匹配的情况，则返回</p><p>这道题使用递归</p><ul><li>递归的参数：当前元素在board的位置<code>board[i][j]</code>,当前需要匹配的字符<code>word[k]</code></li><li>递归终止条件<ul><li>返回false：i和j越界，当前元素board[i][j]和board[k]不相等，当前元素board[i][j]已经被访问过</li><li>返回true：字符串word已经全部匹配，即k=len(word)-1<br>递推工作：</li></ul></li></ul><ol><li>标记当前元素已经被访问过</li><li>搜索board[i][j]的上下左右4个方向，是否和board[k+1]匹配</li><li>如果匹配，返回True，如果都不匹配，回溯，说明当前元素board[i][j]行不通，将其标记为未采纳该节点</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">exist</span><span class="params">(self, board, word)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type board: List[List[str]]</span></span><br><span class="line"><span class="string">        :type word: str</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        rows,cols = len(board),len(board[<span class="number">0</span>])</span><br><span class="line">        <span class="comment">#标记当前是否被访问</span></span><br><span class="line">        visit = [[<span class="number">0</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(cols)] <span class="keyword">for</span> i <span class="keyword">in</span> range(rows)]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(rows):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(cols):</span><br><span class="line">                <span class="keyword">if</span> board[i][j] == word[<span class="number">0</span>]:</span><br><span class="line">                    <span class="keyword">if</span> self.dfs(i,j,<span class="number">0</span>,board,word,visit):<span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(self,i,j,k,board,word,visit)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        board[i][j]</span></span><br><span class="line"><span class="string">        word[k]</span></span><br><span class="line"><span class="string">        判断board[i][j]和word[k]是否匹配，如果匹配，则判断board[i][j]的下一个元素和word[k+1]是否匹配</span></span><br><span class="line"><span class="string">        如果不匹配，直接返回false</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="comment">#递归结束的条件</span></span><br><span class="line">        <span class="comment">#1.board[i][j]已经访问过，返回false</span></span><br><span class="line">        <span class="comment">#2.board[i][j]与word[k]不相等，返回false</span></span><br><span class="line">        <span class="comment">#3.board[i][j]超出索引，返回false</span></span><br><span class="line">        <span class="comment">#4.word已全部匹配，即k=len(word)-1</span></span><br><span class="line">        deltas = [[<span class="number">0</span>,<span class="number">1</span>],[<span class="number">0</span>,<span class="number">-1</span>],[<span class="number">1</span>,<span class="number">0</span>],[<span class="number">-1</span>,<span class="number">0</span>]]</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> <span class="number">0</span> &lt;= i &lt; len(board) <span class="keyword">or</span> <span class="keyword">not</span> <span class="number">0</span> &lt;= j &lt; len(board[<span class="number">0</span>]) <span class="keyword">or</span> board[i][j]!= word[k] <span class="keyword">or</span> visit[i][j] == <span class="number">1</span>:<span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">        <span class="keyword">if</span> k == len(word)<span class="number">-1</span>:<span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">        visit[i][j] = <span class="number">1</span><span class="comment">#board[i][j]和word[k]匹配</span></span><br><span class="line">        <span class="keyword">for</span> delta <span class="keyword">in</span> deltas:<span class="comment">#搜索board的上下左右是否和word[k+1]匹配</span></span><br><span class="line">            next_i = i+delta[<span class="number">0</span>]</span><br><span class="line">            next_j = j+delta[<span class="number">1</span>]</span><br><span class="line">            <span class="keyword">if</span> self.dfs(next_i,next_j,k+<span class="number">1</span>,board,word,visit):<span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">        visit[i][j] = <span class="number">0</span><span class="comment">#上下左右都不匹配，回溯        </span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">False</span></span><br></pre></td></tr></table></figure><h1><span id="3-机器人的运动范围">3. 机器人的运动范围</span></h1><p>地上有一个m行n列的方格，从坐标 [0,0] 到坐标 [m-1,n-1] 。一个机器人从坐标 [0, 0] 的格子开始移动，它每次可以向左、右、上、下移动一格（不能移动到方格外），也不能进入行坐标和列坐标的数位之和大于k的格子。例如，当k为18时，机器人能够进入方格 [35, 37] ，因为3+5+3+7=18。但它不能进入方格 [35, 38]，因为3+5+3+8=19。请问该机器人能够到达多少个格子？</p><p>链接：<a href="https://leetcode-cn.com/problems/ji-qi-ren-de-yun-dong-fan-wei-lcof" target="_blank" rel="noopener">https://leetcode-cn.com/problems/ji-qi-ren-de-yun-dong-fan-wei-lcof</a></p><ul><li>深度优先搜索+回溯</li><li>用队列实现广度优先搜索</li></ul><p><strong>【方法一】</strong><br>深度优先搜搜+回溯<br>使用visit记录m行n列矩阵的遍历情况。</p><ul><li>递归的参数：当前元素在board的位置<code>[i][j]</code></li><li>递归终止条件<ul><li>返回0（当前元素没有被访问）：i和j越界，i和j位数和大于k，当前元素[i][j]已经被访问过，</li></ul></li></ul><p>递推工作：</p><ol><li>当前元素符合条件，标记当前元素已经被访问过</li><li>搜索[i][j]的上下左右4个方向，记录每个方向走过的格子个数，</li><li>返回结果+1，表示除了4个方向访问的格子，还要加上当前访问的格子[i][j]</li></ol><p>优化：</p><ul><li>其实只需要访问下和右2个方向就可以了，不需要访问4个方向</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">movingCount</span><span class="params">(self, m, n, k)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type m: int</span></span><br><span class="line"><span class="string">        :type n: int</span></span><br><span class="line"><span class="string">        :type k: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="comment">#时间复杂度：O(mn)</span></span><br><span class="line">        <span class="comment">#空间复杂度：O(mn),visit数组</span></span><br><span class="line">        <span class="comment">#优化：搜索反向其实只用向下和向右就可以了</span></span><br><span class="line">        visit = [[<span class="number">0</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(n)] <span class="keyword">for</span> j <span class="keyword">in</span> range(m)]</span><br><span class="line">        all_sum = self.dfs(<span class="number">0</span>,<span class="number">0</span>,m,n,k,visit)</span><br><span class="line">        <span class="keyword">return</span> all_sum</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(self,i,j,m,n,k,visit)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        i和j表示机器人当前的格子</span></span><br><span class="line"><span class="string">        m和n，k是题目给定的参数</span></span><br><span class="line"><span class="string">        visit记录遍历情况</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        deltas = [[<span class="number">0</span>,<span class="number">1</span>],[<span class="number">0</span>,<span class="number">-1</span>],[<span class="number">1</span>,<span class="number">0</span>],[<span class="number">-1</span>,<span class="number">0</span>]]</span><br><span class="line">        <span class="comment">#递归结束的条件</span></span><br><span class="line">        <span class="comment">#1.i和j超过范围</span></span><br><span class="line">        <span class="comment">#2.i和j的位数之和超过k</span></span><br><span class="line">        <span class="comment">#3.i和j已经被访问过</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> <span class="number">0</span>&lt;=i&lt;m <span class="keyword">or</span> <span class="keyword">not</span> <span class="number">0</span>&lt;=j&lt;n <span class="keyword">or</span> self.digit_sum(i)+self.digit_sum(j)&gt;k <span class="keyword">or</span> visit[i][j]==<span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        visit[i][j] = <span class="number">1</span></span><br><span class="line">        all_sum = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> delta <span class="keyword">in</span> deltas:</span><br><span class="line">            next_i = i + delta[<span class="number">0</span>]</span><br><span class="line">            next_j = j + delta[<span class="number">1</span>]</span><br><span class="line">            all_sum += self.dfs(next_i,next_j,m,n,k,visit)</span><br><span class="line">        <span class="keyword">return</span> all_sum + <span class="number">1</span><span class="comment">#加1是为了加上当前访问的格子i,j</span></span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">digit_sum</span><span class="params">(self,i)</span>:</span></span><br><span class="line">        all_sum = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> i &gt; <span class="number">0</span>:</span><br><span class="line">            all_sum += i%<span class="number">10</span></span><br><span class="line">            i /= <span class="number">10</span></span><br><span class="line">        <span class="keyword">return</span> all_sum</span><br></pre></td></tr></table></figure><p><strong>【方法二】</strong></p><p>广度优先遍历BFS</p><p>queue中保存当前待检测的格子，里面保存的值有4个元素(i,j,sum_i,sum_j)，分别表示：当前格子的下标i和j，下标的位数</p><p>因为机器人要求从(0,0)出发，所以首先将(0,0,0,0)加入到queue中，遍历第一个格子，判断当前格式是否符合要求，如果不符合要求，则遍历下一个格子。如果符合要求，将当前格子(i,j)加入到visit中，然后将该格子的下和右格子加入队列中，等待遍历。最终返回visit的长度即为访问的格子数量</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">movingCount</span><span class="params">(self, m, n, k)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type m: int</span></span><br><span class="line"><span class="string">        :type n: int</span></span><br><span class="line"><span class="string">        :type k: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        queue = [(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>)]<span class="comment">#当前元素的位置i,j和位数和</span></span><br><span class="line">        visit = set()</span><br><span class="line">        <span class="keyword">while</span> queue:</span><br><span class="line">            i,j,sum_i,sum_j = queue.pop(<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> <span class="number">0</span>&lt;=i&lt;m <span class="keyword">or</span> <span class="keyword">not</span> <span class="number">0</span>&lt;=j&lt;n <span class="keyword">or</span> sum_i+sum_j&gt;k <span class="keyword">or</span> (i,j) <span class="keyword">in</span> visit:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            visit.add((i,j))</span><br><span class="line">            queue.append((i+<span class="number">1</span>,j,self.digit_sum(i+<span class="number">1</span>),sum_j))</span><br><span class="line">            queue.append((i,j+<span class="number">1</span>,sum_i,self.digit_sum(j+<span class="number">1</span>)))</span><br><span class="line">        <span class="keyword">return</span> len(visit)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">digit_sum</span><span class="params">(self,i)</span>:</span></span><br><span class="line">        all_sum = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> i &gt; <span class="number">0</span>:</span><br><span class="line">            all_sum += i%<span class="number">10</span></span><br><span class="line">            i /= <span class="number">10</span></span><br><span class="line">        <span class="keyword">return</span> all_sum</span><br></pre></td></tr></table></figure><h1><span id="4-全排列">4. 全排列</span></h1><p>给定一个 <strong>没有重复 数字</strong>的序列，返回其所有可能的全排列。</p><blockquote><p>输入: [1,2,3]<br>输出:<br>[<br>  [1,2,3],<br>  [1,3,2],<br>  [2,1,3],<br>  [2,3,1],<br>  [3,1,2],<br>  [3,2,1]<br>]</p></blockquote><p>链接：<a href="https://leetcode-cn.com/problems/permutations" target="_blank" rel="noopener">https://leetcode-cn.com/problems/permutations</a></p><p><strong>【分析】</strong></p><p><img src="/2020/06/06/Leetcode之回溯/1.png" alt=""></p><ol><li>这棵树中，除了根节点和叶子节点，其余节点做的事情都一样，都是在还未选择的数字中选一个数，可以用递归实现</li><li>递归结束条件：当递归到树的最后一层时，需要一个变量<code>depth</code>来记录当前遍历到树的第几层</li></ol><p>本题要点</p><ul><li><code>depth</code>：记录当前递归遍历到树的层数</li><li><code>path=[]</code>，记录当前路径中的节点，例如path=[1,2,3]，当下一层选择节点4时，将4添加到path中，path=[1,2,3,4]，然后在回溯的过程中，撤销4的选择，也需要修改path=[1,2,3]，然后再选择3的其他子孩子，例如path=[1,2,3,5]</li><li><code>visit=[]</code>：记录<code>path</code>中哪些数据没有被遍历过。path=[1,2]，则visit[1]=ture,visit[2]=true，剩余没被遍历的节点为false，这样在path考虑下一个数字时，可以直接从visit为false的数字中选择。</li><li>在path选择下一个节点时，visit中有多个未被访问的节点，使用循环遍历visit中所有未被访问的节点。</li><li><code>res</code>：记录所有的组合结果，例如[[1,2,3],[1,3,2],…]</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">permutation</span><span class="params">(self, s)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type s: str</span></span><br><span class="line"><span class="string">        :rtype: List[str]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(depth)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> depth == len(s):</span><br><span class="line">                res.append(<span class="string">''</span>.join(path[:]))</span><br><span class="line">                <span class="keyword">return</span> </span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(len(s)):</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> visit[i]:</span><br><span class="line">                    visit[i]=<span class="keyword">True</span></span><br><span class="line">                    path.append(s[i])</span><br><span class="line">                    dfs(depth+<span class="number">1</span>)</span><br><span class="line">                    visit[i]=<span class="keyword">False</span></span><br><span class="line">                    path.pop()</span><br><span class="line">        res,path = [],[]</span><br><span class="line">        visit = [<span class="keyword">False</span> <span class="keyword">for</span> _ <span class="keyword">in</span> range(len(s))]</span><br><span class="line">        dfs(depth=<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h1><span id="5-全排列-ii">5. 全排列 II</span></h1><p>给定一个可包含<strong>重复数字</strong>的序列，返回所有不重复的全排列。</p><p>示例:</p><p>输入: [1,1,2]<br>输出:<br>[<br>  [1,1,2],<br>  [1,2,1],<br>  [2,1,1]<br>]</p><p>链接：<a href="https://leetcode-cn.com/problems/permutations-ii" target="_blank" rel="noopener">https://leetcode-cn.com/problems/permutations-ii</a></p><p><strong>【分析一】</strong></p><ul><li><code>depth</code>：记录当前递归遍历到树的层数</li><li><code>path=[]</code>，记录当前路径中的节点，例如path=[a,b,c]</li><li><code>visit=[]</code>：记录<code>path</code>中哪些数据没有被遍历过。path=[a,b]，则visit[1]=ture,visit[2]=true，剩余没被遍历的节点为false，这样在path考虑下一个节点时，可以直接从visit为false的节点中选择。</li><li>在path选择下一个节点时，visit中有多个未被访问的节点，使用循环遍历visit中所有未被访问的节点。</li><li><code>res</code>：记录所有的组合结果，例如[abc],[acb],…]</li></ul><p>depth = 0时，处于第一层[]，depth=3时，说明已经将所有的字母都加入到path中，然后将当前path加入到res中</p><p><strong>一般都是在递归的后面进行回溯</strong>,例如在<code>dfs</code>中，递归函数后，使用<code>visit[i]=False,path.pop()</code>进行回溯</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">              []</span><br><span class="line">    a          <span class="keyword">b </span>           c</span><br><span class="line"> ab  ac     <span class="keyword">ba </span>  <span class="keyword">bc </span>    ca    cb</span><br><span class="line"><span class="symbol">abc</span>  acb   <span class="keyword">bac </span>  <span class="keyword">bca </span>   cab   cba</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">permutation</span><span class="params">(self, s)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type s: str</span></span><br><span class="line"><span class="string">        :rtype: List[str]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(depth)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> depth == len(s):</span><br><span class="line">                res.append(<span class="string">''</span>.join(path[:]))</span><br><span class="line">                <span class="keyword">return</span> </span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(len(s)):</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> visit[i]:</span><br><span class="line">                    visit[i]=<span class="keyword">True</span></span><br><span class="line">                    path.append(s[i])</span><br><span class="line">                    dfs(depth+<span class="number">1</span>)</span><br><span class="line">                    visit[i]=<span class="keyword">False</span></span><br><span class="line">                    path.pop()</span><br><span class="line">        res,path = [],[]</span><br><span class="line">        visit = [<span class="keyword">False</span> <span class="keyword">for</span> _ <span class="keyword">in</span> range(len(s))]</span><br><span class="line">        dfs(depth=<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> list(set(res))</span><br></pre></td></tr></table></figure><p><strong>【分析二】</strong></p><p>上面那个方法没有对重复元素进行判断，只在最后返回值时将list转换为set进行去重，如果数组中全是重复元素，且个数较多，例如[aaaaaaaaaaaaaaaaaaaaaaaaaa……]，那么就会非常耗时。下面对此进行改进。<br>首先需要对s进行排序，然后在<code>dfs</code>中对s进行遍历时，如果当前元素没有被访问，判断当前元素和前一个元素是否相等，且前一个元素已经遍历完成，且被撤销了。<br>这里<code>not visit[i-1]</code>的理解如下：当前数组为[1,1,2]，为了区分这2个1，写成[1,1’,2]。首先第一次选择1，会形成2个组合[1,1’,2]和[1,2,1’]，将这2个组合加入到res中，然后回溯，依次将visit[1’]=false,visit[2]=false,visit[1]=false。然后在进行下一次循环时，第一个数据选中1<code>，此时的s[i]=1&#39;和s[i-1]=1相等，且前面的1已经完成组合和回溯，visit[i-1]==false，这就说明此时的1&#39;可以不用遍历了。如果不加</code>not visit[i-1]`，那么就会在第一个分支中的[1,1’]中，遍历到1’，和上一个元素1相同，就会continue。但当前的visit[1]=true，数字1还没有完成回溯，还需要继续进行。</p><p><img src="/2020/06/06/Leetcode之回溯/2.png" alt=""></p><p>要点</p><ul><li><strong>先对nums进行排序，<code>nums=sorted(nums)</code></strong></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">permuteUnique</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: List[List[int]]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(depth)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> depth == len(nums):</span><br><span class="line">                res.append(path[:])</span><br><span class="line">                <span class="keyword">return</span> </span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums)):</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> visit[i]:<span class="comment">#当前字符为访问，理论上来说可以把该字符加入到path中</span></span><br><span class="line">                    <span class="comment">#但是如果当前字符和前一个字符一样，说明当前字符是重复字符</span></span><br><span class="line">                    <span class="comment">#并且visit[i-1]为false表示前面那个相同的字符之前被访问到根节点，然后被撤销</span></span><br><span class="line">                    <span class="keyword">if</span> i&gt;<span class="number">0</span> <span class="keyword">and</span> nums[i]==nums[i<span class="number">-1</span>] <span class="keyword">and</span> <span class="keyword">not</span> visit[i<span class="number">-1</span>]:</span><br><span class="line">                        <span class="keyword">continue</span></span><br><span class="line">                    visit[i]=<span class="keyword">True</span></span><br><span class="line">                    path.append(nums[i])</span><br><span class="line">                    dfs(depth+<span class="number">1</span>)</span><br><span class="line">                    visit[i] = <span class="keyword">False</span></span><br><span class="line">                    path.pop()</span><br><span class="line">        res,path = [],[]</span><br><span class="line">        visit = [<span class="keyword">False</span> <span class="keyword">for</span> _ <span class="keyword">in</span> range(len(nums))]</span><br><span class="line">        nums = sorted(nums)</span><br><span class="line">        dfs(depth=<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h1><span id="6-组合">6. 组合</span></h1><p>给定两个整数 n 和 k，返回 1 … n 中所有可能的 k 个数的组合。</p><p>示例:</p><p>输入: n = 4, k = 2<br>输出:<br>[<br>  [2,4],<br>  [3,4],<br>  [2,3],<br>  [1,2],<br>  [1,3],<br>  [1,4],<br>]</p><p>链接：<a href="https://leetcode-cn.com/problems/combinations" target="_blank" rel="noopener">https://leetcode-cn.com/problems/combinations</a></p><p><strong>【分析一】</strong></p><p>分析可以发现，第一个选择的数假设为1，第二个选择数要严格大于第一个数，当path的长度为k时，结束递归。</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">                    []</span><br><span class="line">    <span class="number">1</span>                 <span class="number">2</span>              <span class="number">3</span>              <span class="number">4</span>    </span><br><span class="line"><span class="number">12</span>   <span class="number">13</span>  <span class="number">14</span>        <span class="number">23</span>    <span class="number">24</span>          <span class="number">34</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">combine</span><span class="params">(self, n, k)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type n: int</span></span><br><span class="line"><span class="string">        :type k: int</span></span><br><span class="line"><span class="string">        :rtype: List[List[int]]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(res,path)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> len(path) == k:</span><br><span class="line">                res.append(path[:])</span><br><span class="line">                <span class="keyword">return</span> </span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,n+<span class="number">1</span>):<span class="comment">#依次选择</span></span><br><span class="line">                <span class="keyword">if</span> len(path)&gt;<span class="number">0</span> <span class="keyword">and</span> i &lt;= path[<span class="number">-1</span>]:<span class="comment">#只选择比path中大的数,如果&lt;=path[-1]，则继续遍历下一个数</span></span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                path.append(i)</span><br><span class="line">                dfs(res,path)</span><br><span class="line">                path.pop()</span><br><span class="line">        </span><br><span class="line">        res,path = [],[]</span><br><span class="line">        dfs(res,path)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><p><strong>【优化一】</strong><br>对上一种方法进行优化，上一种方法中for循环遍历时，从1开始遍历，然后再使用if语句判断是否比path中的数大。这里改为在for循环中，只遍历比path大的数，即使用start来标识for从哪里开始，这样for出来的数肯定比path中大，不用再使用if语句判断。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">combine</span><span class="params">(self, n, k)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type n: int</span></span><br><span class="line"><span class="string">        :type k: int</span></span><br><span class="line"><span class="string">        :rtype: List[List[int]]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(start,res,path)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> len(path) == k:</span><br><span class="line">                res.append(path[:])</span><br><span class="line">                <span class="keyword">return</span> </span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(start,n+<span class="number">1</span>):</span><br><span class="line">                path.append(i)</span><br><span class="line">                dfs(i+<span class="number">1</span>,res,path)</span><br><span class="line">                path.pop()</span><br><span class="line">        </span><br><span class="line">        res,path = [],[]</span><br><span class="line">        dfs(<span class="number">1</span>,res,path)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><p><strong>【优化二】</strong></p><p>在for循环中，不但可以对开始位置进行剪枝，还可以对结束位置进行剪枝。原先i的取值为[start,n]，但其实在递归中，并不是每次递归i都会取到n，i有一个上限。<br>下面来找规律，如果n=15，k=4<br>当选定了一个元素，即len(path)=1，接下来还可以再选3个元素，i最大为13，选[13,14,15]<br>当选定了两个元素，即len(path)=2，接下来还可以选2个元素，i最大为14，选[14,15]<br>当选定了三个元素，即len(path)=3，接下来还可以选1个元素，i最大为15，选[15]<br>在每个循环中可以选择的元素个数为<code>k-len(path)</code>，i的最大值分别为13,14,15，即<code>max(i)=n-(k-len(path))+1</code></p><p><img src="/2020/06/06/Leetcode之回溯/4.png" alt=""></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">combine</span><span class="params">(self, n, k)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type n: int</span></span><br><span class="line"><span class="string">        :type k: int</span></span><br><span class="line"><span class="string">        :rtype: List[List[int]]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(start,res,path)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> len(path) == k:</span><br><span class="line">                res.append(path[:])</span><br><span class="line">                <span class="keyword">return</span> </span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(start,n-(k-len(path))+<span class="number">2</span>):</span><br><span class="line">                <span class="comment"># if len(path)&gt;0 and i &lt;= path[-1]:</span></span><br><span class="line">                <span class="comment">#     continue</span></span><br><span class="line">                <span class="comment">#i&gt;path[-1]</span></span><br><span class="line">                path.append(i)</span><br><span class="line">                dfs(i+<span class="number">1</span>,res,path)</span><br><span class="line">                path.pop()</span><br><span class="line">        </span><br><span class="line">        res,path = [],[]</span><br><span class="line">        dfs(<span class="number">1</span>,res,path)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h1><span id="7-组合总和">7. 组合总和</span></h1><p>给定一个<strong>无重复元素</strong>的数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。</p><p>candidates 中的数字可以无限制重复被选取。</p><p>说明：<br>所有数字（包括 target）都是正整数。<br>解集不能包含重复的组合。 </p><p>链接：<a href="https://leetcode-cn.com/problems/combination-sum" target="_blank" rel="noopener">https://leetcode-cn.com/problems/combination-sum</a></p><p><strong>重点</strong></p><ul><li>candidates中没有重复元素</li><li>path中元素可以重复被选取</li></ul><p>输入: candidates = [2,3,6,7], target = 7,<br>所求解集为:<br>[<br>  [7],<br>  [2,2,3]<br>]</p><p><strong>【分析一】</strong></p><p>如果path中的和等于target，则将path加入到res中。</p><ul><li>如果path中数字可以重复选取，则递归中开始下标为i</li><li>如果path中数组不可以重复选取，则递归中开始下标为i+1</li></ul><p>先对candidates从小到大排序，在遍历到当前元素时，如果candidates[i]+sum(path)&gt;target，那后面的元素肯定也不可能了，使用break退出for循环进行剪枝。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">combinationSum</span><span class="params">(self, candidates, target)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type candidates: List[int]</span></span><br><span class="line"><span class="string">        :type target: int</span></span><br><span class="line"><span class="string">        :rtype: List[List[int]]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(start,res,path)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> sum(path)==target:</span><br><span class="line">                res.append(path[:])</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(start,len(candidates)):</span><br><span class="line">                <span class="keyword">if</span> candidates[i]+sum(path)&gt;target:<span class="comment">#剪枝</span></span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">                path.append(candidates[i])</span><br><span class="line">                dfs(i,res,path)</span><br><span class="line">                path.pop()</span><br><span class="line">        candidates = sorted(candidates)</span><br><span class="line">        res,path = [],[]</span><br><span class="line">        dfs(<span class="number">0</span>,res,path)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h1><span id="8-组合总和-ii">8. 组合总和 II</span></h1><p>给定一个数组 candidates 和一个目标数 target ，candidates中<strong>有重复元素</strong>，找出 candidates 中所有可以使数字和为 target 的组合。</p><p>candidates 中的每个数字在每个组合中只能使用一次。</p><p>说明：</p><p>所有数字（包括目标数）都是正整数。<br>解集不能包含重复的组合。 </p><p>链接：<a href="https://leetcode-cn.com/problems/combination-sum-ii" target="_blank" rel="noopener">https://leetcode-cn.com/problems/combination-sum-ii</a></p><p>输入: candidates = [10,1,2,7,6,1,5], target = 8,<br>所求解集为:<br>[<br>  [1, 7],<br>  [1, 2, 5],<br>  [2, 6],<br>  [1, 1, 6]<br>]</p><p><strong>重点</strong></p><ul><li>candidates中有重复元素</li><li>每个数字在path中只能使用一次</li></ul><p>在回溯题中，如果数组中有重复元素，在回溯的过程，需要去重，步骤如下</p><ul><li>先对数组排序，<code>nums = sorted(nums)</code></li><li>在for循环内部，使用<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(start,len(nums)):</span><br><span class="line">    <span class="keyword">if</span> i &gt; statr <span class="keyword">and</span> nums[i]==nums[i<span class="number">-1</span>]:</span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">path.append(nums[i])</span><br><span class="line">dfs(...)</span><br><span class="line">path.pop()</span><br></pre></td></tr></table></figure></li></ul><p>对candidates排完序后为[1,1,2,5,6,7,10]<br><code>i</code>是当前考察元素的下标，<code>start</code>是本层最开始的那个元素下标。<strong>这里的去重是同层去重</strong>，例如下图中，第一层的1和1<em>重复，需要将`1</em><code>去掉。在第一个分支中第一层是1，第二层是</code>1<em><code>，这2个1在不同的层，不需要去重。如果只写成</code>nums[i]==nums[i-1]<code>,在树中处于不同层的相同元素也生成不了。为了保留不同层的相同元素，使用</code>i&gt;start<code>将这种情况排除，因为在不同层第一次出现的数字</code>i=start<code>，而在同一层出现的相同的数字</code>i&gt;start<code>，这样就可以把第一层出现的</code>1</em>`给剪枝掉。</p><p><img src="/2020/06/06/Leetcode之回溯/5.png" alt=""></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">combinationSum2</span><span class="params">(self, candidates, target)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type candidates: List[int]</span></span><br><span class="line"><span class="string">        :type target: int</span></span><br><span class="line"><span class="string">        :rtype: List[List[int]]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(start,res,path)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> sum(path)==target:</span><br><span class="line">                res.append(path[:])</span><br><span class="line">                <span class="keyword">return</span> </span><br><span class="line">            </span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(start,len(candidates)):</span><br><span class="line">                <span class="keyword">if</span> candidates[i]+sum(path)&gt;target:</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">                <span class="keyword">if</span> i &gt; start <span class="keyword">and</span> candidates[i]==candidates[i<span class="number">-1</span>]:</span><br><span class="line">                    <span class="keyword">continue</span> </span><br><span class="line">                path.append(candidates[i])</span><br><span class="line">                dfs(i+<span class="number">1</span>,res,path)</span><br><span class="line">                path.pop()</span><br><span class="line">        res,path = [],[]</span><br><span class="line">        candidates = sorted(candidates)</span><br><span class="line">        dfs(<span class="number">0</span>,res,path)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h1><span id="9-组合总和-iii">9. 组合总和 III</span></h1><p>找出所有相加之和为 n 的 k 个数的组合。组合中只允许含有 1 - 9 的正整数，并且每种组合中不存在重复的数字。</p><p>说明：</p><p>所有数字都是正整数。<br>解集不能包含重复的组合。 </p><blockquote><p>示例 1:<br>输入: k = 3, n = 7<br>输出: <code>[[1,2,4]]</code></p></blockquote><p>链接：<a href="https://leetcode-cn.com/problems/combination-sum-iii" target="_blank" rel="noopener">https://leetcode-cn.com/problems/combination-sum-iii</a></p><p><strong>【分析一】</strong></p><ul><li>数组中不包含重复的数字，所以不需要去重</li><li>每个数字只能用一次，所以在递归时start=i+1</li></ul><p>在for循环遍历所有的数字时，i的最大值为9，但并不是每次i都可以取到9，下面举例找i的最大值</p><p>1~9个数，找k个数，和为n，假设k=5，n=15</p><p>当len(path)=0，还可以选5个数，i的最大值为5，选[5,6,7,8,9]<br>当len(path)=1，还可以选4个数，i的最大值为6，选[6,7,8,9]<br>当len(path)=2，还可以选3个数，i的最大值为7，选[7,8,9]</p><p>即i的最大值为<code>10-(k-len(path))</code>,在for循环中，<code>range(start,10-(k-len(path))+1)</code></p><p>在进入<code>dfs</code>之前，先判断n是否符合实际情况，从1~9中选出k个数，最大为[9,8,…9-k+1],即和最大为(19-k)*k/2，如果n大于这个最大值，则不可能找出这k个数，所以这个提前判断一下n的值是否符合实际情况。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">combinationSum3</span><span class="params">(self, k, n)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type k: int</span></span><br><span class="line"><span class="string">        :type n: int</span></span><br><span class="line"><span class="string">        :rtype: List[List[int]]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(start,path,res)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> sum(path)==n <span class="keyword">and</span> len(path)==k:</span><br><span class="line">                res.append(path[:])</span><br><span class="line">                <span class="keyword">return</span> </span><br><span class="line">            </span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(start,<span class="number">10</span>-(k-len(path))+<span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> i+sum(path)&gt;n <span class="keyword">or</span> len(path)&gt;k:</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">                path.append(i)</span><br><span class="line">                dfs(i+<span class="number">1</span>,path,res)</span><br><span class="line">                path.pop()</span><br><span class="line">        <span class="keyword">if</span> k&lt;=<span class="number">0</span> <span class="keyword">or</span> n&lt;=<span class="number">0</span> <span class="keyword">or</span> k&gt;= n:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        <span class="keyword">if</span> n&gt;(<span class="number">19</span>-k)*k/<span class="number">2</span>:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        res,path = [],[]</span><br><span class="line">        dfs(<span class="number">1</span>,path,res)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h1><span id="10-括号生成">10. 括号生成</span></h1><p>数字 n 代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且 有效的 括号组合。</p><p>示例：</p><p>输入：n = 3<br>输出：[<br>       “((()))”,<br>       “(()())”,<br>       “(())()”,<br>       “()(())”,<br>       “()()()”<br>     ]</p><p>链接：<a href="https://leetcode-cn.com/problems/generate-parentheses" target="_blank" rel="noopener">https://leetcode-cn.com/problems/generate-parentheses</a></p><p><strong>【分析一】</strong></p><p>在递归中，使用left和right表示左右括号使用的个数。使用path存储当前括号的组合。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">generateParenthesis</span><span class="params">(self, n)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type n: int</span></span><br><span class="line"><span class="string">        :rtype: List[str]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(path,res,left,right)</span>:</span></span><br><span class="line">            <span class="string">"""</span></span><br><span class="line"><span class="string">            left:左括号已经使用的个数</span></span><br><span class="line"><span class="string">            right:右括号已经使用的个数</span></span><br><span class="line"><span class="string">            """</span></span><br><span class="line">            <span class="keyword">if</span> left==n <span class="keyword">and</span> right==n:</span><br><span class="line">                res.append(<span class="string">""</span>.join(path[:]))</span><br><span class="line">                <span class="keyword">return</span> </span><br><span class="line">            <span class="keyword">if</span> left&lt;right:</span><br><span class="line">                <span class="keyword">return</span> </span><br><span class="line">            <span class="keyword">if</span> left &lt; n:</span><br><span class="line">                path.append(<span class="string">'('</span>)</span><br><span class="line">                dfs(path,res,left+<span class="number">1</span>,right)</span><br><span class="line">                path.pop()</span><br><span class="line">            <span class="keyword">if</span> right &lt; n:</span><br><span class="line">                path.append(<span class="string">')'</span>)</span><br><span class="line">                dfs(path,res,left,right+<span class="number">1</span>)</span><br><span class="line">                path.pop()</span><br><span class="line">        res,path = [],[]</span><br><span class="line">        dfs(path,res,<span class="number">0</span>,<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><p>这个方法和上面的区别是使用path是字符串类型。并且递归时，在传入的参数中对path进行改变，在外部path并没有变化，所以不需要回溯。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">generateParenthesis</span><span class="params">(self, n)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type n: int</span></span><br><span class="line"><span class="string">        :rtype: List[str]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(path,res,left,right)</span>:</span></span><br><span class="line">            <span class="string">"""</span></span><br><span class="line"><span class="string">            left:左括号已经使用的个数</span></span><br><span class="line"><span class="string">            right:右括号已经使用的个数</span></span><br><span class="line"><span class="string">            """</span></span><br><span class="line">            <span class="keyword">if</span> left==n <span class="keyword">and</span> right==n:</span><br><span class="line">                res.append(path)</span><br><span class="line">                <span class="keyword">return</span> </span><br><span class="line">            <span class="keyword">if</span> left&lt;right:</span><br><span class="line">                <span class="keyword">return</span> </span><br><span class="line">            <span class="keyword">if</span> left &lt; n:</span><br><span class="line">                dfs(path+<span class="string">'('</span>,res,left+<span class="number">1</span>,right)</span><br><span class="line">            <span class="keyword">if</span> right &lt; n:</span><br><span class="line">                dfs(path+<span class="string">')'</span>,res,left,right+<span class="number">1</span>)</span><br><span class="line">        res,path = [],<span class="string">''</span></span><br><span class="line">        dfs(path,res,<span class="number">0</span>,<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h1><span id="11-n皇后">11. N皇后</span></h1><p>n 皇后问题研究的是如何将 n 个皇后放置在 n×n 的棋盘上，并且使皇后彼此之间不能相互攻击。即任意2个皇后不能除以同一行，同一列，或者同一对角线上。给定一个整数 n，返回所有不同的 n 皇后问题的解决方案。</p><p>每一种解法包含一个明确的 n 皇后问题的棋子放置方案，该方案中 ‘Q’ 和 ‘.’ 分别代表了皇后和空位。</p><p>链接：<a href="https://leetcode-cn.com/problems/n-queens" target="_blank" rel="noopener">https://leetcode-cn.com/problems/n-queens</a></p><p><strong>【分析一】</strong></p><p>首先board表示某一种摆放方案。先摆放row_start=0的第一行，将皇后摆放在某一列，然后再摆放下一行，因为一行只摆放了一个皇后，所以行没有冲突，在递归中，我们只需要判断列，左上对角线，右上对角线是否有冲突。如果不冲突，在该位置上摆放皇后，即<code>board[row][col]=&#39;Q&#39;</code>,否则回溯<code>board[row][col]=&#39;.&#39;</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">solveNQueens</span><span class="params">(self, n)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type n: int</span></span><br><span class="line"><span class="string">        :rtype: List[List[str]]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(row_start,res,board)</span>:</span></span><br><span class="line">            <span class="string">"""</span></span><br><span class="line"><span class="string">            row_start:当前在row_start行的哪一列摆放皇后，取值0~n-1</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">            """</span></span><br><span class="line">            <span class="keyword">if</span> row_start==n:</span><br><span class="line">                res.append([<span class="string">''</span>.join(board[i]) <span class="keyword">for</span> i <span class="keyword">in</span> range(n)])</span><br><span class="line">                <span class="keyword">return</span> </span><br><span class="line">            </span><br><span class="line">            cols = len(board[<span class="number">0</span>])</span><br><span class="line">            <span class="keyword">for</span> col <span class="keyword">in</span> range(cols):</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> is_valid(board,row_start,col):</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                board[row_start][col]=<span class="string">'Q'</span></span><br><span class="line">                dfs(row_start+<span class="number">1</span>,res,board)</span><br><span class="line">                board[row_start][col]=<span class="string">'.'</span></span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">is_valid</span><span class="params">(borad,row_start,col)</span>:</span></span><br><span class="line">            <span class="string">"""</span></span><br><span class="line"><span class="string">            判断将皇后放在board[row_start][col]是否合理</span></span><br><span class="line"><span class="string">            即判断在col列上是否已经有皇后</span></span><br><span class="line"><span class="string">            判断row_start以上的左上方和右上方的对角线上是否有皇后</span></span><br><span class="line"><span class="string">            """</span></span><br><span class="line">            n = len(board)</span><br><span class="line"></span><br><span class="line">            <span class="comment">#判断所有行在col列是否有皇后</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">                <span class="keyword">if</span> board[i][col] == <span class="string">'Q'</span>:</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment">#判断左上方是否有皇后</span></span><br><span class="line">            i,j = row_start<span class="number">-1</span>,col+<span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> i&gt;=<span class="number">0</span> <span class="keyword">and</span> j&lt;=n<span class="number">-1</span>:</span><br><span class="line">                <span class="keyword">if</span> board[i][j]==<span class="string">'Q'</span>:</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">                i-=<span class="number">1</span></span><br><span class="line">                j+=<span class="number">1</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment">#p判断右上方是否有皇后</span></span><br><span class="line">            i,j = row_start<span class="number">-1</span>,col<span class="number">-1</span></span><br><span class="line">            <span class="keyword">while</span> i&gt;=<span class="number">0</span> <span class="keyword">and</span> j&gt;=<span class="number">0</span>:</span><br><span class="line">                <span class="keyword">if</span> board[i][j]==<span class="string">'Q'</span>:</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">                i-=<span class="number">1</span></span><br><span class="line">                j-=<span class="number">1</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">        res = []</span><br><span class="line">        board = [[<span class="string">'.'</span> <span class="keyword">for</span> _ <span class="keyword">in</span> range(n) ] <span class="keyword">for</span> _ <span class="keyword">in</span> range(n)]</span><br><span class="line">        dfs(<span class="number">0</span>,res,board)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h1><span id="12-总结">12. 总结</span></h1><p>在回溯题中，需要判断给定数组中是否有重复元素，如果有重复元素，在回溯的过程，需要去重，步骤如下</p><ul><li>先对数组排序，<code>nums = sorted(nums)</code></li><li><p>在for循环内部，使用</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(start,len(nums)):</span><br><span class="line">    <span class="keyword">if</span> i &gt; statr <span class="keyword">and</span> nums[i]==nums[i<span class="number">-1</span>]:</span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">path.append(nums[i])</span><br><span class="line">dfs(...)</span><br><span class="line">path.pop()</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;回溯可以看做是暴力法的升级。回溯法非常适合由多个步骤组成的问题，每个步骤都有多个选项。当我们在某一步选择了其中一个选项时，就进入到下一步，然后又面临新的选项，就这样重读选择，直至达到最终的状态。&lt;/p&gt;
    
    </summary>
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title>How to Build a Graph-Based Deep Learning Architecture in Traffic Domain: A Survey</title>
    <link href="http://yoursite.com/2020/06/02/How-to-Build-a-Graph-Based-Deep-Learning-Architecture-in-Traffic-Domain-A-Survey/"/>
    <id>http://yoursite.com/2020/06/02/How-to-Build-a-Graph-Based-Deep-Learning-Architecture-in-Traffic-Domain-A-Survey/</id>
    <published>2020-06-02T01:41:59.000Z</published>
    <updated>2020-06-18T02:33:30.602Z</updated>
    
    <content type="html"><![CDATA[<p>这篇综述性论文介绍图神经网络在交通领域的应用。</p><a id="more"></a><!-- TOC --><ul><li><a href="#1-摘要">1. 摘要</a></li><li><a href="#2-前言">2. 前言</a></li><li><a href="#3-研究方向">3. 研究方向</a></li><li><a href="#4-问题定义">4. 问题定义</a><ul><li><a href="#41-构建图">4.1. 构建图</a></li><li><a href="#42-构造邻接矩阵">4.2. 构造邻接矩阵</a></li></ul></li><li><a href="#5-前人的模型">5. 前人的模型</a><ul><li><a href="#51-gnn">5.1. GNN</a></li><li><a href="#52-rnn">5.2. RNN</a></li><li><a href="#53-tcn">5.3. TCN</a></li><li><a href="#54-seq2seq">5.4. Seq2Seq</a></li><li><a href="#55-gan">5.5. GAN</a></li></ul></li><li><a href="#6-挑战">6. 挑战</a><ul><li><a href="#61-空间依赖">6.1. 空间依赖</a></li><li><a href="#62-时间依赖">6.2. 时间依赖</a></li><li><a href="#63-时空依赖">6.3. 时空依赖</a></li><li><a href="#64-外部因素">6.4. 外部因素</a></li></ul></li><li><a href="#7-未来方向">7. 未来方向</a></li></ul><!-- /TOC --><h1><span id="1-摘要">1. 摘要</span></h1><p>在交通数据中，有很多数据以图的形式存在，为了充分利用其中的空间信息，很多模型使用图神经网络来处理交通图数据。本文针对交通领域的图网络模型进行总结。</p><h1><span id="2-前言">2. 前言</span></h1><p>在交通预测领域，（1）早期采用的方法有：ARIMA,VAR,Kalman过滤器等，然而，这些方法通常需要一些前提假设，例如数据是静态且线性相关，不能应用在实际数据中。（2）机器学习方法例如SVM，K近邻可以建模交通数据中的非线性相关性，但是模型结构较浅，且需要人工构造和选择特征，不能满足大量交通数据的应用需求。（3）深度学习方法，例如RNN无法捕获空间相关性，CNN无法应用在图数据中，并且CNN更关注local相关性，忽略了global相关性。（4）图神经网络，使用图神经网络来解决交通领域的预测问题。<br>贡献总结如下：</p><ul><li>第一篇介绍图神经网络在交通领域应用的综述</li><li>系统地列出交通领域的研究方向和挑战</li><li>针对4种交通领域数据，介绍如何构建图</li><li>分析了5种应用在图交通领域的技术，介绍了它们的优缺点，以及变体</li><li>讨论了基于图网络的交通任务中4种常见的挑战，并总结对应的解决方案</li><li>收集数据集，开源代码</li></ul><h1><span id="3-研究方向">3. 研究方向</span></h1><p>给出了交通领域的一些研究问题<br><img src="/2020/06/02/How-to-Build-a-Graph-Based-Deep-Learning-Architecture-in-Traffic-Domain-A-Survey/1.png" alt=""></p><ol><li>交通拥堵</li><li>交通需求<br>出租车、自行车、公共交通的需求预测，像滴滴，Uber等线上打车平台经常做这一类问题。</li><li>交通安全<br>预测交通事故的风险，严重程度</li><li>交通监控<br>主要通过监控的图像和视频检测车辆，行人检测。</li><li>自动驾驶<br>自动驾驶要求检测树木，道路，行人，一般和CV领域相关。</li></ol><p>图神经网络在交通领域的应用</p><ol><li>交通状态预测<br>交通状态：交通流量、速度、时间ETA、密度等。</li><li>交通需求预测<br>预测将来用户对出租车、自行车的需求</li><li>交通信号预测<br>减低用户在交叉路口的等待时间，避免交通拥堵</li><li>司机行为分类</li></ol><p>交通事故预测还没有用到图模型。</p><h1><span id="4-问题定义">4. 问题定义</span></h1><p>基于图的交通预测问题，首先需要构件图G。</p><ul><li>图：无权图，有权图，无向图，有向图，取决于具体的任务。</li><li>节点：传感器sensor，路段，道路交叉口，GPS交叉点。</li><li>邻接矩阵A：非0即1，浮点数（表示2个节点的关系，例如相似性，距离）</li></ul><p>给定历史P个时间段所有节点的信息，维度是$\left[\mathcal{X}_{1}, \cdots, \mathcal{X}_{i}, \cdots, \mathcal{X}_{\mathbf{P}}\right] \in \mathbb{R}^{\mathbf{P} \times \mathbf{N} \times \mathbf{F}_{1}}$预测未来Q个时间段的$\mathcal{Y}=\left[\mathcal{Y}_{1}, \cdots, \mathcal{Y}_{j}, \cdots, \mathcal{Y}_{\mathrm{Q}}\right] \in \mathbb{R}^{\mathbf{Q} \times \mathbf{N} \times \mathrm{F}_{\mathrm{O}}}$</p><ul><li>预测的特征只有1个，即$F_O=1$，预测特征有多个，即$F_O&gt;1$</li><li>预测未来时间段只有1个，单步预测，即$Q=1$，预测未来时间段有多个，多步预测，即$Q&gt;1$</li><li>多步预测问题中，一般使用FC（将输出reshape成需要的维度，ASTGCN,T-GCN,），Seq2Seq（使用RNN循环输出预测结果,DCRNN,GMAN），空洞技术（WaveNet）</li></ul><h2><span id="41-构建图">4.1. 构建图</span></h2><p>在构建图时，一般使用3类数据：传感器，GPS轨迹，打车订单数据，</p><ol><li>传感器数据<br>最常用的加州PEMS数据，图中的每个节点表示一个传感器，同一条路上的传感器有边相连。</li><li>GPS数据<br>GPS轨迹数据，需要将GPS匹配到最近的路段上，以路段为节点创建图，或者以交叉路口为节点创建图。这里的图可以是有向，也可以无向。</li></ol><p><img src="/2020/06/02/How-to-Build-a-Graph-Based-Deep-Learning-Architecture-in-Traffic-Domain-A-Survey/3.png" alt="">  </p><ol><li>订单数据<br>将城市划分为网格，每个节点表示一个网格，边表示连通性。可以根据不同的特征来构件图，例如下图使用邻近区域、道路连通性、功能相似区域分别构建3个图。</li></ol><p><img src="/2020/06/02/How-to-Build-a-Graph-Based-Deep-Learning-Architecture-in-Traffic-Domain-A-Survey/4.png" alt="">  </p><ol><li>公共交通数据<ul><li>地铁图：每个地铁站表示一个节点，如果一条线上的2个地铁站相邻则有边。图信号矩阵是inflow和outflow</li><li>公交车图：每个公交站是一个节点，如果一条线上的2个公交站相邻则有边。图信号矩阵进站记录</li></ul></li></ol><h2><span id="42-构造邻接矩阵">4.2. 构造邻接矩阵</span></h2><ol><li>静态邻接矩阵<br>邻接矩阵不会随着时间变化。可以根据节点之间的特征构建多个邻接矩阵，例如功能相似，道路相通，时间相似。邻接矩阵中的值可以是非0即1，也可以表示节点间距离或者相似性。一般通过阈值来定义邻接矩阵，通过调整阈值来控制邻接矩阵的稀疏性。<script type="math/tex; mode=display">\mathbf{a}_{i j}=\left\{\begin{array}{l}\exp \left(-\frac{\mathbf{d}_{i j}^{2}}{\sigma^{2}}\right), i \neq j \text { and } \mathbf{d}_{i j} \geq \epsilon \\0 \quad, i=j \text { or } \mathbf{d}_{i j}<\epsilon\end{array}\right.</script></li></ol><ol><li>动态邻接矩阵<br>有2种情况：1. 邻接矩阵不随着时间变化，但是邻接矩阵不是预先定义好的，而是模型先动态学习节点嵌入，然后根据学习到的节点嵌入构造邻接矩阵。2. 邻接矩阵随着时间变化。</li></ol><h1><span id="5-前人的模型">5. 前人的模型</span></h1><p>分析图神经网络在交通领域的应用，发现GNN通常和其他组件一起用，类似RNN,Seq2Seq，TCN等。</p><h2><span id="51-gnn">5.1. GNN</span></h2><p>GNN在交通领域的应用主要有3个：谱图卷积for无向图，扩散卷积for有向图。</p><ol><li><p>谱图卷积</p><script type="math/tex; mode=display">\begin{aligned}Y_{j} &=\rho\left(\Theta_{j} *_{\mathcal{G}} X\right) \\&=\rho\left(\sum_{i=1}^{\mathbf{F}_{\mathrm{I}}} \theta_{i, j} \tilde{\mathbf{D}}^{-\frac{1}{2}} \tilde{\mathbf{A}} \tilde{\mathbf{D}}^{-\frac{1}{2}} X_{i}\right), 1 \leq j \leq \mathbf{F}_{\mathbf{O}} \\Y &=\rho\left(\tilde{\mathbf{D}}^{-\frac{1}{2}} \tilde{\mathbf{A}} \tilde{\mathbf{D}}^{-\frac{1}{2}} X W\right)\end{aligned}</script><p>谱图卷积要求对称的拉普拉斯矩阵，来实现特征值分解。</p></li><li><p>扩散卷积<br>谱图卷积要求对称的拉普拉斯矩阵，来实现特征值分解。但是对于有向图来说，拉普拉斯矩阵不是对称的。扩散卷积对图的结构，邻接矩阵，拉普拉斯矩阵没有任何限制。扩散卷积可以看做是转移矩阵的幂次，表示从节点i到节点j的转移概率。</p><script type="math/tex; mode=display">y=\Theta *_{\mathcal{G}} x=\sum_{k=0}^{\mathrm{K}-1}\left(\theta_{k, 1}\left(\mathrm{D}_{\mathrm{O}}^{-1} \mathrm{A}\right)^{k}+\theta_{k, 2}\left(\mathrm{D}_{\mathrm{I}}^{-1} \mathrm{A}^{T}\right)^{k}\right) x</script></li></ol><p>总结：谱图卷积和扩散卷积的不同：谱图卷积的邻接矩阵揭示中心节点和它直接邻近的节点更相关。而扩散卷积揭示空间依赖是随机且动态的。扩散卷积比谱图卷积更复杂。扩散卷积可以适用在任何交通网络上，而谱图卷积只能用在对称的图上，即无向图中。</p><p>有些工作在使用SGC和DGC使用以下tricks</p><ul><li>使用SGC时，引入attention机制<br>S表示图信号矩阵，使用切比雪夫多项式计算图卷积时，对S求attention，计算节点之间的影响程度。</li></ul><script type="math/tex; mode=display">\Theta *_{\mathcal{G}} x \approx \sum_{k=0}^{K-1} \theta_{k}\left(T_{k}(\tilde{\mathbf{L}}) \odot \mathbf{S}\right) x$$ $$\mathbf{S} = W_{1} \odot \rho\left(\left(X W_{2}\right) W_{3}(W_{4} X)^{T}+b\right) \in \mathbb{R}^{N \times N}</script><ul><li><p>直接使用邻接矩阵，FFR表示道路特征</p><script type="math/tex; mode=display">\Theta *_{\mathcal{G}} x=\left(W \odot \tilde{\mathbf{A}}^{\mathrm{K}} \odot \mathcal{F} \mathcal{F} \mathcal{R}\right) x</script></li><li><p>在邻接矩阵中引入地理位置信息</p><script type="math/tex; mode=display">\mathbf{S}=\mathbf{A} \odot \omega$$$$Y=\rho\left(\tilde{\mathbf{Q}}^{-\frac{1}{2}} \tilde{\mathbf{S}} \tilde{\mathbf{Q}}^{-\frac{1}{2}} X W\right)</script></li></ul><h2><span id="52-rnn">5.2. RNN</span></h2><p>交通任务预测中很多都是时间序列数据，适用RNN来捕获时间相关性。这里包括三类：RNN,LSTM,GRU</p><ul><li>RNN：输入层，隐藏层，输出层</li><li>LSTM：为了解决RNN的梯度消失和梯度爆炸问题，引入输入门，遗忘门，输出门。</li><li>GRU：LSTM结构复杂，参数更多，用更简单的GRU来代替，只有2个门：重置门</li></ul><p>在交通预测领域中，很少用RNN，大部分都是用GRU，少数用LSTM。在用GRU或LSTM时，有很多小tricks，例如attention，门控机制，残差机制。<br>在使用RNN所用到的tricks</p><ul><li>在RNN中引入空间信息<script type="math/tex; mode=display">\mathbf{H}_{t} = R N N\left(\left[\mathbf{H}_{t-1}, \mathbf{X}_{t}\right] \odot S\right)</script></li><li>引入外部因素<script type="math/tex; mode=display">\mathbf{H}_{t}=G R U\left(\left[\mathbf{H}_{t-1}, \mathbf{X}_{t}\right], \mathbf{E}_{t}\right)+\mathbf{H}_{t-1} W</script></li><li>使用空洞RNN<script type="math/tex; mode=display">\mathbf{H}_{t}=G R U\left(\mathbf{H}_{t-s}, \mathbf{X}_{t}\right)</script></li><li>RNN和图卷积结合<script type="math/tex; mode=display">\begin{aligned}r_{t} &=\sigma\left(\left[\mathbf{H}_{t-1}, \mathbf{X}_{t}\right] *_{\mathcal{G}} W_{r}+b_{r}\right) \\u_{t} &=\boldsymbol{\sigma}\left(\left[\mathbf{H}_{t-1}, \mathbf{X}_{t}\right] *_{\mathcal{G}} W_{u}+b_{u}\right) \\\tilde{\mathbf{H}}_{t} &=\tanh \left(r_{t} \odot\left[\mathbf{H}_{t-1}, \mathbf{X}_{t}\right] *_{\mathcal{G}} W_{h}+b_{h}\right) \\\mathbf{H}_{t} &=u_{t} \odot \mathbf{H}_{t-1}+\left(1-u_{t}\right) \odot \tilde{\mathbf{H}}_{t}\end{aligned}</script></li></ul><h2><span id="53-tcn">5.3. TCN</span></h2><p>虽然RNN可以捕获时间的相关性，但是其不能并行计算，耗时。与之对比，1D卷积运行更快，同样也可以捕获时间相关性。然后1D卷积与RNN相比应用更少，由于1D卷积缺少长期建模的memory机制。后来提出空洞卷积，在长期时间建模上，比RNN效果更好。之后，TCN被广泛应用在时间建模上。</p><p><img src="/2020/06/02/How-to-Build-a-Graph-Based-Deep-Learning-Architecture-in-Traffic-Domain-A-Survey/5.png" alt=""> </p><p>在使用TCN时，有一些小traick</p><ul><li><p>堆叠不同的TCN层，每层使用不同的dilation rate</p><script type="math/tex; mode=display">\mathcal{Y}^{(l+1)}=\sigma\left(\Theta^{l} *_{\mathcal{T} \mathrm{d}^{l}} \mathcal{Y}^{(l)}\right)</script></li><li><p>残差，原始输入+TCN的输出</p><script type="math/tex; mode=display">\mathcal{Y}^{(l+1)}=\mathcal{Y}^{(l)}+\boldsymbol{\operatorname { R e }} \boldsymbol{L} \boldsymbol{U}\left(\Theta_{1}^{l} *_{\mathcal{T}^{\mathrm{d}}}\left(\boldsymbol{\operatorname { R e }} \boldsymbol{L} \boldsymbol{U}\left(\Theta_{0}^{l} *_{\mathcal{T}^{\mathrm{d}}} \mathcal{Y}^{(l)}\right)\right)\right)</script></li><li><p>使用门控机制</p><script type="math/tex; mode=display">\mathcal{Y}=\rho\left(\Theta_{1} *_{\mathcal{T}^{\mathrm{d}}} \mathcal{X}+b_{1}\right) \odot \sigma\left(\Theta_{2} *_{\mathcal{T}^{\mathrm{d}}} \mathcal{X}+b_{2}\right)</script></li></ul><h2><span id="54-seq2seq">5.4. Seq2Seq</span></h2><p>原始的Seq2Seq模型为对输入进行建模，得到一个隐变量$C$,然后将$C$输入到解码器中，进行预测。</p><p><img src="/2020/06/02/How-to-Build-a-Graph-Based-Deep-Learning-Architecture-in-Traffic-Domain-A-Survey/6.png" alt=""> </p><p>对Seq2Seq的改进主要有2点：</p><ul><li><p>改变隐变量C<br>原先输入到decoder的C是固定的，对decoder中所有的时间步来说都一样，然后输入中的值对不同的输出影响程度不同，这里引入attention机制，动态改变C</p><script type="math/tex; mode=display">\begin{array}{l}\mathbf{H}_{i}=\operatorname{Encoder}\left(\mathbf{X}_{i}, \mathbf{H}_{i-1}\right) \\\mathbf{C}_{j}=\sum_{i=1}^{\mathbf{P}}\left(\theta_{j i} \mathbf{H}_{i}\right), \mathbf{S}_{0}=\mathbf{H}_{\mathbf{P}} \\\mathbf{S}_{j}=\operatorname{Decoder}\left(\mathbf{C}_{j}, \mathbf{Y}_{j-1}, \mathbf{S}_{j-1}\right) \\\mathbf{Y}_{j}=\mathbf{S}_{j} W\end{array}</script></li><li><p>采样<br>在decoder在训练阶段和测试阶段的输入是不同的。在训练阶段，decoder的不同时间步输入的真实的label，而在测试阶段，因为不知道label，输入的是上一个时间步预测的结果，这样可能会造成错误累积的问题。为了解决这个问题，可以在训练阶段进行采样，即并不总是输入真实的label，以$\epsilon_{j}$输入真实babel，以$1-\epsilon_{j}$输入上个时间步的预测结果。</p></li></ul><p>交通领域中的多步预测通常采用Seq2Seq架构。Seq2Seq中的encoder和decoder架构通常采用RNN，但是也不一定相同。</p><h2><span id="55-gan">5.5. GAN</span></h2><p>这一模块看的论文较少，以后补充</p><h1><span id="6-挑战">6. 挑战</span></h1><p>尽管交通领域有很多研究方向，但它们都有一些共同的挑战，如下所示，主要分为三类：空间依赖，时间依赖，外部因素。</p><p><img src="/2020/06/02/How-to-Build-a-Graph-Based-Deep-Learning-Architecture-in-Traffic-Domain-A-Survey/2.png" alt=""> </p><h2><span id="61-空间依赖">6.1. 空间依赖</span></h2><p>在一个双向的道路中，R1只受R2的影响，R3对R1的影响较小。如果采用网格的形式，R3和R2对R1的影响相同，这不符合实际。如果采用图的形式，R2对R1的影响较大，R3对R1的影响较小，符合实际。</p><p><img src="/2020/06/02/How-to-Build-a-Graph-Based-Deep-Learning-Architecture-in-Traffic-Domain-A-Survey/7.png" alt=""> </p><p>交通网络中空间依赖十分复杂，可以分成三类：空间局部性，多元关系，全局连通性。</p><ol><li>空间局部性<br>空间局部性表示邻近区域比较远的区域更相关。K阶局部谱图卷积SGCN可以聚合0~K-1跳的邻居信息。还有一些其他工作可以捕获空间局部相关性。比如动态计算邻接矩阵</li><li>多元关系<br>目标区域也可能与距离较远的区域相关。例如功能相似的区域，交通连通的区域。根据这些不同的相似性来创建不同的图。</li><li>全局连通性<br>以上2点更关注网络部分，而忽略了整体的结构。全局连通性表示不同区域的交通情况在整个网络上互相影响。使用扩散卷积、pooling层、self-adaptive邻接矩阵可以捕获到这种全局连通性。</li></ol><h2><span id="62-时间依赖">6.2. 时间依赖</span></h2><p>使用RNN或TCN来捕获时间依赖</p><ol><li>多粒度<br>时间有不同的周期性，例如recent，daily，weekly。</li><li>不同的权重<br>历史信息对目标时间段的影响权重不同。使用Attention机制计算权重分数。</li></ol><h2><span id="63-时空依赖">6.3. 时空依赖</span></h2><p>以上对时间和空间依赖分别建模，如果对时空依赖同时建模，预测效果可能会更好。例如STSGCN</p><h2><span id="64-外部因素">6.4. 外部因素</span></h2><p>天气（雨/温度/空气质量），时间（节假日/周几/几点），特殊时间，POI等信息都会影响交通预测。<br>对于外部因素的处理通常有2种方法：</p><ol><li>和其他因素拼接，输入到模型中</li><li>设计外部因素处理模块，对外部因素单独处理。通常是2个FCN，第一个FCN提取重要信息，第二个FCN从低维特征映射到高维特征</li></ol><h1><span id="7-未来方向">7. 未来方向</span></h1><ol><li>在司机行为分类，车辆/人们轨迹预测，交通事故预测使用图模型。</li><li>大多使用SGCN和DGCN，很少使用GAT,GAE,RNN+GCN，可以使用以上模型解决交通问题</li><li>交通问题大多是回归问题，很少有分类问题，可以使用图模型研究分类问题</li><li>现有模型对外部因素处理比较简单，可以设计更复杂的模型捕获外部因素信息。</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这篇综述性论文介绍图神经网络在交通领域的应用。&lt;/p&gt;
    
    </summary>
    
      <category term="论文阅读笔记" scheme="http://yoursite.com/categories/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="时空领域" scheme="http://yoursite.com/tags/%E6%97%B6%E7%A9%BA%E9%A2%86%E5%9F%9F/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode之树</title>
    <link href="http://yoursite.com/2020/05/29/Leetcode%E4%B9%8B%E6%A0%91/"/>
    <id>http://yoursite.com/2020/05/29/Leetcode之树/</id>
    <published>2020-05-29T13:11:48.000Z</published>
    <updated>2020-07-13T04:33:08.080Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><!-- TOC --><ul><li><a href="#1-树概念介绍">1. 树概念介绍</a></li><li><a href="#2-树的前向遍历">2. 树的前向遍历</a></li><li><a href="#3-二叉树的中序遍历">3. 二叉树的中序遍历</a></li><li><a href="#4-后序遍历">4. 后序遍历</a></li><li><a href="#5-二叉搜索树的第k大节点">5. 二叉搜索树的第k大节点</a></li><li><a href="#6-树的层次遍历">6. 树的层次遍历</a></li><li><a href="#7-二叉树z形层次遍历">7. 二叉树Z形层次遍历</a></li><li><a href="#8-二叉树从下往上层次遍历">8. 二叉树从下往上层次遍历</a></li><li><a href="#9-根据前序和中序创建二叉树">9. 根据前序和中序创建二叉树</a></li><li><a href="#10-根据中序和后续构建二叉树">10. 根据中序和后续构建二叉树</a></li><li><a href="#11-计算树的最大深度">11. 计算树的最大深度</a></li><li><a href="#12-对称二叉树">12. 对称二叉树</a></li><li><a href="#13-平衡二叉树">13. 平衡二叉树</a></li><li><a href="#14-二叉树的镜像">14. 二叉树的镜像</a></li><li><a href="#15-二叉搜索树的后序遍历序列">15. 二叉搜索树的后序遍历序列</a></li><li><a href="#16-树的子结构">16. 树的子结构</a></li><li><a href="#17-二叉树中和为某个值的路径">17. 二叉树中和为某个值的路径</a></li><li><a href="#18-根节点到某个节点的路径">18. 根节点到某个节点的路径</a><ul><li><a href="#181-二叉树从根节点到叶子节点的路径">18.1. 二叉树从根节点到叶子节点的路径</a></li><li><a href="#182-根节点到任意一个节点的路径">18.2. 根节点到任意一个节点的路径</a></li></ul></li><li><a href="#19-最近公共祖先lca">19. 最近公共祖先(LCA)</a><ul><li><a href="#191-二叉搜索树的最近公共祖先">19.1. 二叉搜索树的最近公共祖先</a></li><li><a href="#192-二叉树的最近公共祖先">19.2. 二叉树的最近公共祖先</a></li><li><a href="#193-多叉树的最近公共祖先">19.3. 多叉树的最近公共祖先</a></li><li><a href="#194-tarjan离线算法">19.4. Tarjan离线算法</a></li></ul></li><li><a href="#20-总结">20. 总结</a></li></ul><!-- /TOC --><h1><span id="1-树概念介绍">1. 树概念介绍</span></h1><ul><li>二叉树一般有2种通用的遍历策略<ul><li>深度优先搜索DFS<ol><li>前序遍历：根左右</li><li>中序遍历：左根右</li><li>后序遍历：左右根</li></ol></li><li>广度优先搜索BFS<br>先遍历第一层，再遍历第二层</li></ul></li></ul><p>值得注意的是，在删除树中的节点时，删除过程将按照后序遍历的顺序进行，也就是先删除左节点和右节点，然后再删除节点本身。</p><ul><li><p>平衡二叉树，需要满足1个条件：</p><ul><li>左右子树深度之差&lt;=1</li></ul></li><li><p>二叉搜索树，需要满足以下2个条件：<br>二叉搜索树中肯定不会存在2个大小相同的元素</p><ul><li>左子树的值&lt;父节点，右子树的值&gt;父节点</li><li>所有左子树和右子树是二叉搜索树</li></ul></li></ul><p>二叉树常见问题<br><a href="https://zhuanlan.zhihu.com/p/91243381" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/91243381</a></p><h1><span id="2-树的前向遍历">2. 树的前向遍历</span></h1><p>给定一个二叉树，返回它的前序遍历序列。</p><p><a href="https://leetcode-cn.com/problems/binary-tree-preorder-traversal/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/binary-tree-preorder-traversal/</a></p><p><strong>【方法1】</strong></p><p>前序遍历：根左右<br>迭代遍历树，使用栈的思想来实现。<br>定义一个stack数据，作为临时的存储栈。首先cur指向根节点，循环遍历所有的节点，当cur不为空时，因为先遍历根节点，所以将cur的值保存在res中，然后将cur保存至stack中，然后遍历cur的左节点，直到cur的左节点为空（cur没有左节点，或cur是叶子节点）。当cur为空时，进入到else中，从stack中弹出cur的父节点，然后遍历其右子树。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">preorderTraversal</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type root: TreeNode</span></span><br><span class="line"><span class="string">        :rtype: List[int]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:<span class="keyword">return</span> []</span><br><span class="line">        <span class="comment">#stack作为临时栈，先弹出根节点，再压入右节点和左节点</span></span><br><span class="line">        stack,res = [],[]</span><br><span class="line">        cur = root</span><br><span class="line">        <span class="keyword">while</span> cur <span class="keyword">or</span> stack:</span><br><span class="line">            <span class="keyword">if</span> cur:<span class="comment">#只要根节点不为空，一直向下遍历，知道cur为空</span></span><br><span class="line">                res.append(cur.val)<span class="comment">#将当前根节点的存储到res中</span></span><br><span class="line">                stack.append(cur)</span><br><span class="line">                cur = cur.left</span><br><span class="line">            <span class="keyword">else</span>:<span class="comment">#cur为空，说明该子树没有左子树或者是叶子节点</span></span><br><span class="line">                top = stack.pop()</span><br><span class="line">                cur = top.right</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><p><strong>【方法二】</strong></p><p>迭代方法</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">preorderTraversal</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type root: TreeNode</span></span><br><span class="line"><span class="string">        :rtype: List[int]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:<span class="keyword">return</span> []</span><br><span class="line">        res = []</span><br><span class="line">        self.dfs(root,res)</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(self,root,res)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> root:</span><br><span class="line">            res.append(root.val)</span><br><span class="line">            self.dfs(root.left,res)</span><br><span class="line">            self.dfs(root.right,res)</span><br></pre></td></tr></table></figure><h1><span id="3-二叉树的中序遍历">3. 二叉树的中序遍历</span></h1><p>给定一个二叉树，返回它的中序 遍历。<br><a href="https://leetcode-cn.com/problems/binary-tree-inorder-traversal/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/binary-tree-inorder-traversal/</a></p><p><strong>【方法一】</strong><br>中序遍历：左根右，<br>每到一个节点A，因为需要先遍历左子树，所以需要把根节点先存储在stack中，然后一直遍历左子树，直到cur为None时，说明当前节点没有左子树，再从stack中弹出None的根节点，然后再遍历根节点的右子树。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inorderTraversal</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type root: TreeNode</span></span><br><span class="line"><span class="string">        :rtype: List[int]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root: <span class="keyword">return</span> []</span><br><span class="line">        stack,res = [],[]</span><br><span class="line">        cur = root</span><br><span class="line">        <span class="keyword">while</span> cur <span class="keyword">or</span> stack:</span><br><span class="line">            <span class="keyword">if</span> cur:</span><br><span class="line">                stack.append(cur)</span><br><span class="line">                cur = cur.left</span><br><span class="line">            <span class="keyword">else</span>:<span class="comment">#当某个节点的左子树为None时，弹出该节点（根节点），然后再遍历其右子树</span></span><br><span class="line">                cur = stack.pop()</span><br><span class="line">                res.append(cur.val)</span><br><span class="line">                cur = cur.right</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><p><strong>【方法二】</strong><br>递归<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inorderTraversal</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type root: TreeNode</span></span><br><span class="line"><span class="string">        :rtype: List[int]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root: <span class="keyword">return</span> []</span><br><span class="line">        res = []</span><br><span class="line">        self.dfs(root,res)</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(self,root,res)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> root:</span><br><span class="line">            <span class="keyword">if</span> root.left:</span><br><span class="line">                self.dfs(root.left,res)</span><br><span class="line">            res.append(root.val)</span><br><span class="line">            <span class="keyword">if</span> root.right:</span><br><span class="line">                self.dfs(root.right,res)</span><br></pre></td></tr></table></figure></p><h1><span id="4-后序遍历">4. 后序遍历</span></h1><p><a href="https://leetcode-cn.com/problems/binary-tree-postorder-traversal/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/binary-tree-postorder-traversal/</a></p><p><strong>【方法一】</strong><br>后续遍历：左右根，使用res保存根右左的节点顺序，返回时倒序输出<br>每到一个节点A，先遍历根节点，因为左子树最后遍历，所以先把左子树压入栈中，然后遍历右子树</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">postorderTraversal</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type root: TreeNode</span></span><br><span class="line"><span class="string">        :rtype: List[int]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:<span class="keyword">return</span> []</span><br><span class="line">        stack,res = [],[]</span><br><span class="line">        cur = root</span><br><span class="line">        <span class="keyword">while</span> cur <span class="keyword">or</span> stack:</span><br><span class="line">            <span class="keyword">if</span> cur:</span><br><span class="line">                res.append(cur.val)</span><br><span class="line">                stack.append(cur.left)</span><br><span class="line">                cur = cur.right</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                cur = stack.pop()</span><br><span class="line">        <span class="keyword">return</span> res[::<span class="number">-1</span>]</span><br></pre></td></tr></table></figure><p><strong>【方法二】</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">postorderTraversal</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type root: TreeNode</span></span><br><span class="line"><span class="string">        :rtype: List[int]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:<span class="keyword">return</span> []</span><br><span class="line">        res = []</span><br><span class="line">        self.dfs(root,res)</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(self,root,res)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> root:</span><br><span class="line">            <span class="keyword">if</span> root.left:</span><br><span class="line">                self.dfs(root.left,res)</span><br><span class="line">            <span class="keyword">if</span> root.right:</span><br><span class="line">                self.dfs(root.right,res)</span><br><span class="line">            res.append(root.val)</span><br></pre></td></tr></table></figure><h1><span id="5-二叉搜索树的第k大节点">5. 二叉搜索树的第k大节点</span></h1><p>给定一棵二叉搜索树，请找出其中第k大的节点。</p><p><a href="https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-di-kda-jie-dian-lcof/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-di-kda-jie-dian-lcof/</a></p><p><img src="/2020/05/29/Leetcode之树/第k大节点.jpg" alt=""></p><p><strong>【分析】</strong></p><p>二叉搜索树的左节点小于根节点，右节点大于根节点。<br>如果用<code>右中左</code>将得到从大到小的序列，可以上面树的中序遍历”左中右”。<br>使用<code>count</code>记录当前已经遍历了多少个节点，当<code>count==k</code>时，直接返回当前节点的值，否则继续遍历。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode(object):</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">kthLargest</span><span class="params">(self, root, k)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type root: TreeNode</span></span><br><span class="line"><span class="string">        :type k: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="comment">#右中左遍历二叉搜索树</span></span><br><span class="line">        stack=[]</span><br><span class="line">        count = <span class="number">0</span></span><br><span class="line">        cur = root</span><br><span class="line">        <span class="keyword">while</span> cur <span class="keyword">or</span> stack:</span><br><span class="line">            <span class="keyword">if</span> cur:</span><br><span class="line">                stack.append(cur)</span><br><span class="line">                cur = cur.right</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                top = stack.pop()</span><br><span class="line">                count+=<span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> count==k:</span><br><span class="line">                    <span class="keyword">return</span> top.val</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    cur = top.left</span><br></pre></td></tr></table></figure><h1><span id="6-树的层次遍历">6. 树的层次遍历</span></h1><p>给你一个二叉树，请你返回其按 层序遍历 得到的节点值。 （即逐层地，从左到右访问所有节点）。</p><p><a href="https://leetcode-cn.com/problems/binary-tree-level-order-traversal/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/binary-tree-level-order-traversal/</a></p><p><strong>【方法一】</strong></p><p>参考<a href="https://leetcode-cn.com/problems/binary-tree-level-order-traversal/solution/die-dai-di-gui-duo-tu-yan-shi-102er-cha-shu-de-cen/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/binary-tree-level-order-traversal/solution/die-dai-di-gui-duo-tu-yan-shi-102er-cha-shu-de-cen/</a></p><p>首先队列中存储根节点，每一次队列中只存储某一层的元素。当队列中存储根节点时，进入while循环，弹出根节点，再将左右子节点压入到队列中。然后再遍历队列的左子节点，弹出左子节点，并将左子节点的孩子压入到队列中，然后遍历队列的右子节点，并将右子节点的孩子压入到队列中。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">levelOrder</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type root: TreeNode</span></span><br><span class="line"><span class="string">        :rtype: List[List[int]]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:<span class="keyword">return</span> []</span><br><span class="line">        queue,res = [root],[]</span><br><span class="line">        <span class="keyword">while</span> queue:</span><br><span class="line">            cur_len = len(queue)<span class="comment">#当前层节点个数</span></span><br><span class="line">            cur_nodes = []<span class="comment">#用来存储当前层的节点</span></span><br><span class="line">            <span class="keyword">for</span> _ <span class="keyword">in</span> range(cur_len):</span><br><span class="line">                <span class="comment">#对于当前层的每个节点，将其左右子节点压入队列中</span></span><br><span class="line">                cur = queue.pop(<span class="number">0</span>)<span class="comment">#注意弹出第一个元素，pop()默认弹出最后一个元素</span></span><br><span class="line">                cur_nodes.append(cur.val)</span><br><span class="line">                <span class="keyword">if</span> cur.left:</span><br><span class="line">                    queue.append(cur.left)</span><br><span class="line">                <span class="keyword">if</span> cur.right:</span><br><span class="line">                    queue.append(cur.right)</span><br><span class="line">            res.append(cur_nodes)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h1><span id="7-二叉树z形层次遍历">7. 二叉树Z形层次遍历</span></h1><p>请实现一个函数按照之字形顺序打印二叉树，即第一行按照从左到右的顺序打印，第二层按照从右到左的顺序打印，第三行再按照从左到右的顺序打印，其他行以此类推。</p><p><a href="https://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-iii-lcof/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-iii-lcof/</a></p><p><img src="/2020/05/29/Leetcode之树/层次遍历.jpg" alt=""></p><p><strong>【分析】</strong></p><p>和上一道题一样，将每层的节点存储到队列中。唯一的区别是在向<code>res</code>中插入每一层的节点时需要看当前行的行号，如果是第一行，正序插入，如果是第二行，倒序插入。即奇数行正序插入，偶数行倒序插入</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode(object):</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">levelOrder</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type root: TreeNode</span></span><br><span class="line"><span class="string">        :rtype: List[List[int]]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:<span class="keyword">return</span> []</span><br><span class="line">        queue,res = [root,],[]</span><br><span class="line">        row_idx = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> queue:</span><br><span class="line">            row_idx+=<span class="number">1</span></span><br><span class="line">            cur_len = len(queue)</span><br><span class="line">            cur_nodes = []</span><br><span class="line">            <span class="keyword">for</span> _ <span class="keyword">in</span> range(cur_len):</span><br><span class="line">                cur = queue.pop(<span class="number">0</span>)</span><br><span class="line">                cur_nodes.append(cur.val)</span><br><span class="line">                <span class="keyword">if</span> cur.left:</span><br><span class="line">                    queue.append(cur.left)</span><br><span class="line">                <span class="keyword">if</span> cur.right:</span><br><span class="line">                    queue.append(cur.right)</span><br><span class="line">            <span class="keyword">if</span> row_idx%<span class="number">2</span>!=<span class="number">0</span>:</span><br><span class="line">                res.append(cur_nodes)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                res.append(cur_nodes[::<span class="number">-1</span>])</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h1><span id="8-二叉树从下往上层次遍历">8. 二叉树从下往上层次遍历</span></h1><p>给定一个二叉树，返回其节点值自底向上的层次遍历。 （即按从叶子节点所在层到根节点所在的层，逐层从左向右遍历）</p><p><a href="https://leetcode-cn.com/problems/binary-tree-level-order-traversal-ii/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/binary-tree-level-order-traversal-ii/</a></p><p><img src="/2020/05/29/Leetcode之树/层次遍历2.jpg" alt=""></p><p><strong>【分析】</strong></p><p>层次遍历，从底向上插入节点。</p><p>和从上往下的层次遍历一样，将每一层的节点存储在<code>cur_nodes</code>中，但是在向<code>res</code>中插入的时候向开头的位置插入，这样最后一层的节点在<code>res</code>的最前面</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode(object):</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">levelOrderBottom</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type root: TreeNode</span></span><br><span class="line"><span class="string">        :rtype: List[List[int]]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:<span class="keyword">return</span> []</span><br><span class="line"></span><br><span class="line">        queue,res = [root,],[]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> queue:</span><br><span class="line">            cur_len = len(queue)</span><br><span class="line">            cur_nodes = []</span><br><span class="line">            <span class="keyword">for</span> _ <span class="keyword">in</span> range(cur_len):</span><br><span class="line">                cur = queue.pop(<span class="number">0</span>)</span><br><span class="line">                cur_nodes.append(cur.val)</span><br><span class="line">                <span class="keyword">if</span> cur.left:</span><br><span class="line">                    queue.append(cur.left)</span><br><span class="line">                <span class="keyword">if</span> cur.right:</span><br><span class="line">                    queue.append(cur.right)</span><br><span class="line">            res.insert(<span class="number">0</span>,cur_nodes)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h1><span id="9-根据前序和中序创建二叉树">9. 根据前序和中序创建二叉树</span></h1><p>输入某二叉树的前序遍历和中序遍历的结果，请重建该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。</p><p><a href="https://leetcode-cn.com/problems/zhong-jian-er-cha-shu-lcof/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/zhong-jian-er-cha-shu-lcof/</a></p><p><strong>【分析】</strong><br>使用递归的方式。首先找到整个树的根节点（前序的第一个节点），然后找到该节点在中序的下标（使用字典记录中序每个数字的下标），左边的即为左子树，右边的即为右子树。</p><p>例如：从前序中可以看到根节点为3，其在中序的下标为1，则左边的9为左子树节点，右边的15,20,7为右子树节点。然后递归遍历左子树，返回左子树的根节点作为3的左子树，递归遍历右子树，返回右子树的根节点作为3的右子树。</p><p>前序：3,9,20,15,7<br>中序：9,3,15,20,7</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode(object):</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">buildTree</span><span class="params">(self, preorder, inorder)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type preorder: List[int]</span></span><br><span class="line"><span class="string">        :type inorder: List[int]</span></span><br><span class="line"><span class="string">        :rtype: TreeNode</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="comment">#原理：首先在先序遍历中，第一个节点作为根节点，然后在中序遍历中，找出根节点在中序中的位置，区分哪些是左子树，哪些是右子树，然后分别对左子树和右子树递归</span></span><br><span class="line"></span><br><span class="line">        self.dic = dict()<span class="comment">#用来标记每个节点在中序遍历的位置，key：节点，value：下标</span></span><br><span class="line">        self.pre= preorder<span class="comment">#保存先序遍历</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">#遍历中序，为self.dic赋值</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(inorder)):</span><br><span class="line">            self.dic[inorder[i]] = i</span><br><span class="line">        <span class="keyword">return</span> self.recur(<span class="number">0</span>,<span class="number">0</span>,len(inorder)<span class="number">-1</span>)</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">recur</span><span class="params">(self,pre_root,in_left,in_right)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        pre_root：根节点在前序中的下标</span></span><br><span class="line"><span class="string">        in_left：以pre_root为根节点的子树在中序的最左下标</span></span><br><span class="line"><span class="string">        in_right：以pre_root为根节点的子树在中序的最右下标</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> in_left &gt; in_right:<span class="keyword">return</span> <span class="comment">#递归中止条件</span></span><br><span class="line">        root= TreeNode(self.pre[pre_root])<span class="comment">#创建当前子树的根节点</span></span><br><span class="line">        i = self.dic[root.val]<span class="comment">#搜索根节点在中序的索引</span></span><br><span class="line">        root.left= self.recur(pre_root+<span class="number">1</span>,in_left,i<span class="number">-1</span>)<span class="comment">#递归遍历左子树</span></span><br><span class="line">        root.right = self.recur(pre_root+i-in_left+<span class="number">1</span>,i+<span class="number">1</span>,in_right)</span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure><p>需要解释下，遍历左右子树的下标。<br>根节点在前序的下标为pre_root，在中序的下标为i，整个树在中序的左边界为in_left，右边界为in_right。</p><p><img src="/2020/05/29/Leetcode之树/7-1.png" alt=""></p><ul><li>时间复杂度：O(N)</li><li>空间复杂度：O(N)</li></ul><h1><span id="10-根据中序和后续构建二叉树">10. 根据中序和后续构建二叉树</span></h1><p>根据一棵树的中序遍历与后序遍历构造二叉树。</p><p>注意:<br>你可以假设树中没有重复的元素。<br><a href="https://leetcode-cn.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal/</a></p><p><img src="/2020/05/29/Leetcode之树/构建二叉树.jpg" alt=""></p><p><strong>【分析】</strong><br>前序：中左右<br>中序：左中右<br>后序：左右中</p><p>已知后序和中序，求前序。这道题和“已知前序和中序，求后序”类似。</p><ol><li>首先找到根节点在后序中的下标<br>在上一道题中，根节点在前序的第一个节点，这本题中，根节点在后序的最后一个节点。在后序中找到根节点，然后找出这个根节点在中序的下标</li><li>根据根节点在中序的下标分割左右子树<br>现在知道根节点在中序的下标，则根节点左边的就是左子树的节点，右边就是右子树的节点</li><li>递归构建左子树和右子树</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode(object):</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">buildTree</span><span class="params">(self, inorder, postorder)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type inorder: List[int]</span></span><br><span class="line"><span class="string">        :type postorder: List[int]</span></span><br><span class="line"><span class="string">        :rtype: TreeNode</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        self.post = postorder</span><br><span class="line">        self.in_dict = dict()</span><br><span class="line">        n = len(inorder)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(inorder)):</span><br><span class="line">            self.in_dict[inorder[i]] = i</span><br><span class="line">        <span class="keyword">return</span> self.recur(n<span class="number">-1</span>,<span class="number">0</span>,n<span class="number">-1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">recur</span><span class="params">(self,post_root,in_left,in_right)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        post_root:根节点在后序中的下标</span></span><br><span class="line"><span class="string">        in_left:以post_root为根节点的子树最左下标</span></span><br><span class="line"><span class="string">        in_right:以post_root为根节点的子树最右下标</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> in_left&gt;in_right:<span class="keyword">return</span> </span><br><span class="line">        <span class="comment">#找出根节点在中序中的下标</span></span><br><span class="line">        i = self.in_dict[self.post[post_root]]</span><br><span class="line">        root = TreeNode(self.post[post_root])</span><br><span class="line">        root.left = self.recur(post_root+i-in_right<span class="number">-1</span>,in_left,i<span class="number">-1</span>)</span><br><span class="line">        root.right = self.recur(post_root<span class="number">-1</span>,i+<span class="number">1</span>,in_right)</span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure><h1><span id="11-计算树的最大深度">11. 计算树的最大深度</span></h1><p>主要最后要加1<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">depth</span><span class="params">(self,root)</span>:</span></span><br><span class="line">        <span class="comment">#计算树root的最大深度</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:<span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">return</span> max(self.depth(root.left),self.depth(root.right))+<span class="number">1</span></span><br></pre></td></tr></table></figure></p><h1><span id="12-对称二叉树">12. 对称二叉树</span></h1><p>给定一个二叉树，检查它是否是镜像对称的。<br><a href="https://leetcode-cn.com/problems/symmetric-tree/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/symmetric-tree/</a></p><p>镜像对称<br>终止条件：</p><ul><li>如果left和right同时为空，返回True</li><li>如果left和right中有一个为空，或者2个都不为空，但是值不相等，返回False</li></ul><p>在递归中：</p><ul><li>将左节点的左孩子和右节点的右孩子比较</li><li>将左节点的右孩子和右节点的左孩子比较</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isSymmetric</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type root: TreeNode</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:<span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">        <span class="keyword">return</span> self.mirror(root.left,root.right)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">mirror</span><span class="params">(self,left,right)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> left == <span class="keyword">None</span> <span class="keyword">and</span> right == <span class="keyword">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">        <span class="keyword">if</span> left == <span class="keyword">None</span> <span class="keyword">or</span> right == <span class="keyword">None</span> <span class="keyword">or</span> left.val != right.val:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">        <span class="keyword">return</span> self.mirror(left.left,right.right) <span class="keyword">and</span> self.mirror(left.right,right.left)</span><br></pre></td></tr></table></figure><h1><span id="13-平衡二叉树">13. 平衡二叉树</span></h1><p>给定一个二叉树，判断它是否是高度平衡的二叉树。</p><p>本题中，一棵高度平衡二叉树定义为：<br>一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过1。</p><p><strong>【分析一】</strong><br><code>isBalanced(root)</code>判断树root是否是平衡二叉树</p><ul><li>特例处理：如果root为None，返回True</li><li><p>判断是否为平衡二叉树<br>  首先求<code>root</code>的左右子树的高度，如果高度差&lt;=1，再继续往下判断，左右子树是否都是平衡树，如果都是平衡树，那整棵树就是平衡树。如果以下三个条件有1个不满足就不是平衡树。</p><ul><li><code>abs(self.depth(root.left)-self.depth(root.right))&lt;=1</code>root的左右高度差&lt;=1</li><li><code>self.isBalanced(root.left)</code>root的左子树是平衡树</li><li><code>self.isBalanced(root.right)</code>root的右子树是平衡树</li></ul></li></ul><p><code>depth(root)</code>计算树root的最大深度</p><ul><li>终止条件：当root为空时，说明root已经越过叶子节点，返回高度0</li><li>返回左子树和右子树的最大高度+1</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isBalanced</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type root: TreeNode</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:<span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">        <span class="comment">#如果root的左子树和右子树深度之差&lt;=1，且左右子树都是平衡树</span></span><br><span class="line">        <span class="keyword">if</span> abs(self.depth(root.left)-self.depth(root.right))&lt;=<span class="number">1</span> <span class="keyword">and</span> self.isBalanced(root.left) <span class="keyword">and</span> self.isBalanced(root.right):</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">depth</span><span class="params">(self,root)</span>:</span></span><br><span class="line">        <span class="comment">#计算树root的最大深度</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:<span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">return</span> max(self.depth(root.left),self.depth(root.right))+<span class="number">1</span></span><br></pre></td></tr></table></figure><p><strong>【分析二】</strong></p><p>自底向上<br><code>recur(root)</code>返回树root的最大深度</p><ul><li><p>返回值：如果root的左右子树深度差&lt;=1，返回root的深度，max(左,右)+1，否则说明root树不是平衡树，返回-1</p></li><li><p>递归终止条件：root为None时，说明已经越过叶子节点，返回深度为0</p></li><li>当root的左右子树返回值为-1时，表示左或右子树不是平衡树，root直接返回-1</li></ul><p><code>isBalanced(root)</code>判断root是否是平衡树</p><ul><li>判断recur(root)返回值是否为-1，为-1则不是平衡树，否则是平衡树</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isBalanced</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type root: TreeNode</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:<span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">        <span class="keyword">return</span> self.recur(root) != <span class="number">-1</span></span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">recur</span><span class="params">(self,root)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        返回以root为根的树最大深度</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:<span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        left_h= self.recur(root.left)</span><br><span class="line">        <span class="keyword">if</span> left_h==<span class="number">-1</span>:<span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">        right_h = self.recur(root.right)</span><br><span class="line">        <span class="keyword">if</span> right_h == <span class="number">-1</span>:<span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">        <span class="keyword">return</span> max(left_h,right_h)+<span class="number">1</span> <span class="keyword">if</span> abs(left_h-right_h)&lt;=<span class="number">1</span> <span class="keyword">else</span> <span class="number">-1</span></span><br></pre></td></tr></table></figure><h1><span id="14-二叉树的镜像">14. 二叉树的镜像</span></h1><p>请完成一个函数，输入一个二叉树，该函数输出它的镜像。</p><p><a href="https://leetcode-cn.com/problems/er-cha-shu-de-jing-xiang-lcof/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/er-cha-shu-de-jing-xiang-lcof/</a></p><p><strong>【分析一】</strong><br>使用递归</p><ol><li>递归终止条件：当节点root为空时，返回None</li><li>递归工作<ul><li>先使用tmp保存节点root的左子树</li><li>给root.left赋予新的值</li><li>给root.right赋予新的值</li></ul></li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">mirrorTree</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type root: TreeNode</span></span><br><span class="line"><span class="string">        :rtype: TreeNode</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:<span class="keyword">return</span> <span class="keyword">None</span></span><br><span class="line">        <span class="comment">#不用生成新的树，直接在原始树进行修改</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:<span class="keyword">return</span> <span class="keyword">None</span></span><br><span class="line">        tmp = root.left</span><br><span class="line">        root.left = self.mirrorTree(root.right)</span><br><span class="line">        root.right = self.mirrorTree(tmp)</span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure><p><strong>【分析二】</strong><br>使用栈stack遍历树的所有节点，并交换每个节点的左右子树</p><p><img src="/2020/05/29/Leetcode之树/2.png" alt=""></p><ol><li>特例处理：当root为空时，直接使用return</li><li>初始化栈，将root加入到栈中</li><li>遍历栈，刚开始弹出节点4，并将节点2和节点7压入栈中，然后交换节点4的左右节点。然后再进入到while循环中，弹出节点7，再将节点6和节点9压入栈中，交换节点7的左右节点。然后再将节点9弹出栈，因为节点9的左右节点为空，所以没有节点压入stack中，然后交换节点9的左右节点（交换None）。然后弹出节点6出栈，因为节点6没有左右子树，所以没有节点入栈。然后弹出节点2，将节点1和3压入栈</li></ol><p>使用栈，可以看做是DFS，先将右子树内部的节点交换，然后再将左子树内部的节点交换<br>如果使用队列，可以看做是BFS，先交换第一层的左右节点，再交换第二层的左右节点。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">mirrorTree</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type root: TreeNode</span></span><br><span class="line"><span class="string">        :rtype: TreeNode</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:<span class="keyword">return</span> <span class="keyword">None</span></span><br><span class="line">        <span class="comment">#不用生成新的树，直接在原始树进行修改</span></span><br><span class="line">        stack = [root]</span><br><span class="line">        <span class="keyword">while</span> stack:</span><br><span class="line">            cur = stack.pop()</span><br><span class="line">            <span class="keyword">if</span> cur.left:</span><br><span class="line">                stack.append(cur.left)</span><br><span class="line">            <span class="keyword">if</span> cur.right:</span><br><span class="line">                stack.append(cur.right)</span><br><span class="line">            cur.left,cur.right = cur.right,cur.left</span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure><h1><span id="15-二叉搜索树的后序遍历序列">15. 二叉搜索树的后序遍历序列</span></h1><p>输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历结果。如果是则返回 true，否则返回 false。假设输入的数组的任意两个数字都互不相同。</p><p><a href="https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-hou-xu-bian-li-xu-lie-lcof/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-hou-xu-bian-li-xu-lie-lcof/</a></p><p><strong>【分析一】</strong><br>二叉搜索树：左子树&lt;根节点，右子树&gt;根节点<br>后序遍历：左右根<br>给定后序序列的最后一个元素肯定是整个树的根，然后向前找，比它小的是左子树，比它大的是右子树</p><p><img src="/2020/05/29/Leetcode之树/3.png" alt=""></p><p>使用递归的方法，递归函数传入的参数是后序序列。</p><ul><li>递归终止条件：后序序列为空，返回True</li><li>递归返回值：如果当前postorder可以构成二叉搜索树，返回True，否则返回False</li><li>递归工作：<ul><li>找根节点，即postorder的最后一个元素</li><li>找左子树的范围，从postorder第一个元素向后找，找第一个大于根节点的元素，在这之前的元素都是左子树，剩下的元素是右子树</li><li>在右子树中，如果有小于root的值，返回false。如果没有的话，说明root的左右子树都正常</li><li>下面递归判断左子树的后序序列和右子树的后序序列是否正常</li><li>返回2者的and值</li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">verifyPostorder</span><span class="params">(self, postorder)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type postorder: List[int]</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> postorder:<span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">isTree</span><span class="params">(postorder)</span>:</span></span><br><span class="line">            <span class="string">"""</span></span><br><span class="line"><span class="string">            输入一个后续序列，判断是否是某个二叉搜索树的后续序列</span></span><br><span class="line"><span class="string">            如果是，返回True，否则返回False</span></span><br><span class="line"><span class="string">            """</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> postorder:<span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">            root = postorder[<span class="number">-1</span>]</span><br><span class="line">            left,right = <span class="number">0</span>,<span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(len(postorder)):</span><br><span class="line">                <span class="keyword">if</span> postorder[i] &gt; root:</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">            <span class="comment">#跳出for循环的i指向第一个大于root的节点,左子树[0,i-1]</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(i,len(postorder)<span class="number">-1</span>):</span><br><span class="line">                <span class="comment">#如果右子树中有比root小的，返回false</span></span><br><span class="line">                <span class="keyword">if</span> postorder[j] &lt; root:</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">            is_left,is_right = <span class="keyword">False</span>,<span class="keyword">False</span><span class="comment">#判断左后续序列是否能组成二叉搜索树</span></span><br><span class="line">            is_left = isTree(postorder[:i])</span><br><span class="line">            is_right = isTree(postorder[i:<span class="number">-1</span>])</span><br><span class="line">            <span class="keyword">return</span> is_left <span class="keyword">and</span> is_right</span><br><span class="line">        <span class="keyword">return</span> isTree(postorder)</span><br></pre></td></tr></table></figure><ul><li>时间复杂度：O(n2)</li><li>空间复杂度：O(N)</li></ul><h1><span id="16-树的子结构">16. 树的子结构</span></h1><p>输入两棵二叉树A,B,判断B是否是A的子结构（空树不是任意一个树的子结构）<br>B是A的子结构，即A中有出现和B相同的结构和节点值。</p><p><a href="https://leetcode-cn.com/problems/shu-de-zi-jie-gou-lcof/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/shu-de-zi-jie-gou-lcof/</a></p><p><img src="/2020/05/29/Leetcode之树/子结构.jpg" alt=""></p><p><strong>【分析】</strong></p><p>如果B是A的子结构，则B的根节点可能是A的任意一个节点，所以树B需要和A的所有节点对比。<br>首先<code>树B</code>先和<code>以A为根节点的树</code>比较，如果B是<code>以A为根节点的树</code>的子结构，则返回True，否则再将B和<code>A的左子树</code>比较，B和<code>A的右子树</code>比较，只有有1个返回True最终结果就返回True，所以是2个结果的<code>或</code></p><p><code>isSubStructure(A, B)</code>函数判断树B是否是树A的子结构，如果是返回True，否则返回False</p><ul><li>当A或B为空时，返回False，如果A为空，所有树都不是它的子结构，所以返回False。如果B为空，题目中说空树不是任何树的子树，所以也返回False</li><li>如果B是A的子结构，则需要同时满足以下3个条件：<ol><li>A中某个节点值和B的根节点相等</li><li>根节点相等之后，再判断这个节点的左子树和B的左子树是否相等</li><li>这个节点的右子树是否和B的右子树是否相等</li></ol></li></ul><p><code>isSame(A,B)</code>判断B是不是<strong>以A为根节点的子树</strong></p><ul><li>如果B为空，说明B都遍历完了，还没有返回False，则说明B中的所有节点都在A中，返回True</li><li>如果A为空，则直接返回False</li><li>如果A的根节点和B的根节点不相等，直接返回False</li><li>如果A的根节点和B的根节点相等<code>A.val==B.val</code>，继续向下判断，判断A的左子树和B的左子树是否相等，判断A的右子树是否和B的右子树相等</li></ul><p><code>isSubStructure</code>用来决定A中的子树和B进行比较，<br><code>isSame</code>用来比较这个子树是否和B相等</p><p>【注意】在<code>isSame</code>中可能A和B同时是空，如下图所示，此时返回的True，而不是False。所以在<code>isSame</code>中需要先判断B是否为空，如果B为空则返回True。在判断A是否为空。</p><p><img src="/2020/05/29/Leetcode之树/子结构2.jpg" alt=""></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode(object):</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isSubStructure</span><span class="params">(self, A, B)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type A: TreeNode</span></span><br><span class="line"><span class="string">        :type B: TreeNode</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> A <span class="keyword">or</span> <span class="keyword">not</span> B:<span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">        <span class="comment">#从A的根节点和B的根节点开始比较，</span></span><br><span class="line">        <span class="keyword">if</span> self.isSame(A,B):</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> self.isSubStructure(A.left,B) <span class="keyword">or</span> self.isSubStructure(A.right,B)</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isSame</span><span class="params">(self,A,B)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        判断B是不是以A为根节点的子树</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="comment">#注意这里先判断B是否为空，再判断A，否则会出错</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> B:<span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> A:<span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> A.val!=B.val:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">        <span class="keyword">return</span> self.isSame(A.left,B.left) <span class="keyword">and</span> self.isSame(A.right,B.right)</span><br></pre></td></tr></table></figure><h1><span id="17-二叉树中和为某个值的路径">17. 二叉树中和为某个值的路径</span></h1><p>输入一棵二叉树和一个整数，打印出二叉树中节点的和为输入整数的<strong>所有路径</strong>，从树的根节点到叶子节点形成一条路径。</p><p><a href="https://leetcode-cn.com/problems/er-cha-shu-zhong-he-wei-mou-yi-zhi-de-lu-jing-lcof/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/er-cha-shu-zhong-he-wei-mou-yi-zhi-de-lu-jing-lcof/</a></p><p><strong>【分析】</strong></p><p>二叉树和回溯法的结合</p><p>求得结果需要满足2个条件，满足2个条件才加入到结果集中</p><ul><li>最后一个节点必须是叶子节点</li><li>路径上节点和为sum</li></ul><p>递归函数<code>recur(root,sum)</code><br>判断以<code>root</code>为根节点的子树是否能找到和为<code>sum</code>路径</p><ul><li>递归结束条件：root为空时，直接返回，不再向下执行</li><li>如果root不为空，将root的值加入到path中，然后判断加入root后剩下的值是否为0，并且root是否为叶子节点，如果同时满足这2个条件，则将path加入到结果集中</li><li>如果不满足这2个条件，递归遍历root的左子树和右子树。当左子树和右子树都遍历完了，说明root已经没有可以遍历的了，则将root弹出path</li></ul><p>【注意】在将<code>path</code>加入到<code>res</code>中，不能使用<code>res.append(path)</code>，而是使用<code>res.append(path[:])</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode(object):</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pathSum</span><span class="params">(self, root, sum)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type root: TreeNode</span></span><br><span class="line"><span class="string">        :type sum: int</span></span><br><span class="line"><span class="string">        :rtype: List[List[int]]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="comment">#res：最终返回的结果</span></span><br><span class="line">        <span class="comment">#path：存储一条路径</span></span><br><span class="line">        res,path = [],[]</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">recur</span><span class="params">(root,sum)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> root:<span class="keyword">return</span> </span><br><span class="line">            <span class="comment">#先把这个值加入到path中，如果不符合再回退</span></span><br><span class="line">            path.append(root.val)</span><br><span class="line">            tar = sum-root.val</span><br><span class="line">            <span class="comment">#路径和为sum，且当前root是叶子节点，才加入到结果集中</span></span><br><span class="line">            <span class="keyword">if</span> tar==<span class="number">0</span> <span class="keyword">and</span> <span class="keyword">not</span> root.left <span class="keyword">and</span> <span class="keyword">not</span> root.right:</span><br><span class="line">                res.append(path[:])</span><br><span class="line">            recur(root.left,tar)</span><br><span class="line">            recur(root.right,tar)</span><br><span class="line">            path.pop()</span><br><span class="line"></span><br><span class="line">        recur(root,sum)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h1><span id="18-根节点到某个节点的路径">18. 根节点到某个节点的路径</span></h1><h2><span id="181-二叉树从根节点到叶子节点的路径">18.1. 二叉树从根节点到叶子节点的路径</span></h2><p>给定一个二叉树，返回所有从根节点到叶子节点的路径</p><p><strong>【分析】</strong></p><p>深度遍历二叉树<code>dfs</code>，传入<code>root,path</code>，root表示子树的根节点，<code>path</code>表示从根节点到叶子节点的路径</p><ul><li>如果传入的root为空，则返回</li><li>如果不为空，将root的值加入到path中<ul><li>如果root为叶子节点，将path加入到res中，<strong>再将root节点弹出</strong></li><li>如果root不是叶子节点，则遍历root的左右子树，遍历完成之后，将root弹出</li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode(object):</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">binaryTreePaths</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type root: TreeNode</span></span><br><span class="line"><span class="string">        :rtype: List[str]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        self.res = []</span><br><span class="line">        path = []</span><br><span class="line">        self.dfs(root,path)</span><br><span class="line">        tmp = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> self.res:</span><br><span class="line">            tmp.append(<span class="string">'-&gt;'</span>.join(map(str,i)))</span><br><span class="line">        <span class="keyword">return</span> tmp</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(self,root,path)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        找到从root到根节点的路径</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:<span class="comment">#当前节点为空</span></span><br><span class="line">            <span class="keyword">return</span> </span><br><span class="line">        <span class="comment">#当前节点不为空</span></span><br><span class="line">        path.append(root.val)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root.left <span class="keyword">and</span> <span class="keyword">not</span> root.right:</span><br><span class="line">            self.res.append(path[:])</span><br><span class="line">            path.pop()<span class="comment">#注意这里需要弹出，否则出错</span></span><br><span class="line">            <span class="keyword">return</span> </span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.dfs(root.left,path)</span><br><span class="line">            self.dfs(root.right,path)</span><br><span class="line">            path.pop()</span><br></pre></td></tr></table></figure><h2><span id="182-根节点到任意一个节点的路径">18.2. 根节点到任意一个节点的路径</span></h2><p>二叉树根节点到任意一个节点的路径</p><p><img src="/2020/05/29/Leetcode之树/路径.jpg" alt=""></p><p>例如根节点到节点5的路径<br><code>getPath(root,p)</code>找到从root到节点p的路径</p><p><code>getNodePath(self,root,target,path)</code>是用来递归，函数返回值为bool，False说明没有从root到target的路径，返回True说明找到了</p><ul><li>递归结束条件：当root为空时，递归还没有结束，说明树中不存target这个节点，返回False</li><li>当root不为空，先把root的值加入到path中，然后判断root是否是target<ul><li>如果root是target，说明路径已经找到了，found设置为True</li><li>如果root不是target，且found为False，则继续遍历root的左子树和右子树</li><li>如果左子树和右子树都没有找到，则回溯，将root弹出path</li><li>返回found值</li></ul></li></ul><p><strong>【分析】</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode(object):</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getPath</span><span class="params">(self, root, p)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type root: TreeNode</span></span><br><span class="line"><span class="string">        :type p: TreeNode</span></span><br><span class="line"><span class="string">        :rtype: TreeNode</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        path_p = []</span><br><span class="line">        self.getNodePath(root,p,path_p)</span><br><span class="line">        print(path_p)</span><br><span class="line">        <span class="keyword">return</span> path_p</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getNodePath</span><span class="params">(self,root,target,path)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        找到从root到target的路径</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">        found = <span class="keyword">False</span> </span><br><span class="line">        path.append(root)</span><br><span class="line">        <span class="keyword">if</span> target == root:</span><br><span class="line">            found = <span class="keyword">True</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> found <span class="keyword">and</span> root.left:</span><br><span class="line">            found = self.getNodePath(root.left,target,path)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> found <span class="keyword">and</span> root.right:</span><br><span class="line">            found = self.getNodePath(root.right,target,path)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> found:</span><br><span class="line">            path.pop()</span><br><span class="line">        <span class="keyword">return</span> found</span><br></pre></td></tr></table></figure><h1><span id="19-最近公共祖先lca">19. 最近公共祖先(LCA)</span></h1><h2><span id="191-二叉搜索树的最近公共祖先">19.1. 二叉搜索树的最近公共祖先</span></h2><p>给定一个二叉搜索树, 找到该树中两个指定节点的最近公共祖先。</p><p>百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”</p><p>链接：<a href="https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-zui-jin-gong-gong-zu-xian-lcof" target="_blank" rel="noopener">https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-zui-jin-gong-gong-zu-xian-lcof</a></p><p><img src="/2020/05/29/Leetcode之树/最近祖先.jpg" alt=""></p><p><strong>【分析】</strong></p><p>给定2个节点<code>p,q</code>，找这2个节点的最近祖先。<br>因为给定的树是二叉搜索树，左边的所有值都比根节点小，右边的所有值都比根节点大。</p><p>首先判断<code>p,q</code>是否相等，若相等，则返回<code>p,q</code>其中任意一个，程序结束<br>如果不相等，则需要判断<code>p,q</code>在root的左边还是右边</p><ul><li>如果<code>p,q</code>一个比root小（左子树），一个比root大（右子树），则这2个节点的最近祖先肯定是root。例如上图中，节点4和节点8的最近祖先为节点6</li><li>如果<code>p,q</code>都小于root，则<code>p,q</code>的最近祖先在root的左子树中</li><li>如果<code>p,q</code>都大于root，则<code>p,q</code>的最近祖先在root的右子树中</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode(object):</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lowestCommonAncestor</span><span class="params">(self, root, p, q)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type root: TreeNode</span></span><br><span class="line"><span class="string">        :type p: TreeNode</span></span><br><span class="line"><span class="string">        :type q: TreeNode</span></span><br><span class="line"><span class="string">        :rtype: TreeNode</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:<span class="keyword">return</span> </span><br><span class="line">        <span class="keyword">if</span> p.val == q.val:<span class="keyword">return</span> p</span><br><span class="line">        <span class="keyword">while</span> root:</span><br><span class="line">            <span class="keyword">if</span> root.val &lt; q.val <span class="keyword">and</span> root.val &lt; p.val:</span><br><span class="line">                root = root.right</span><br><span class="line">            <span class="keyword">elif</span> root.val &gt; q.val <span class="keyword">and</span> root.val &gt; p.val:</span><br><span class="line">                root = root.left</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure><h2><span id="192-二叉树的最近公共祖先">19.2. 二叉树的最近公共祖先</span></h2><p>给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。</p><p>百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”</p><p>链接：<a href="https://leetcode-cn.com/problems/er-cha-shu-de-zui-jin-gong-gong-zu-xian-lcof" target="_blank" rel="noopener">https://leetcode-cn.com/problems/er-cha-shu-de-zui-jin-gong-gong-zu-xian-lcof</a></p><p><img src="/2020/05/29/Leetcode之树/最近祖先2.jpg" alt=""></p><p><strong>【分析】</strong></p><p>使用后序遍历二叉树。<br>如果root为空，或者当前root为p，或者root为q，则向父节点返回root</p><p>例如<code>p=7,q=4</code>，先遍历3，然后递归到5，递归到6，再递归到6的左节点None，然后遇到<code>not root</code>，返回给null，然后节点6又把null返回节点5。即节点5的左子树返回给5的left=null。然后开始遍历节点5的右子树。遍历节点2，递归到节点7，此时节点7等于p，返回节点7，即节点2的左子树返回的left=7，然后递归到节点4，此时节点4等于q，返回节点4，即节点2的右子树返回的right=4，由于left和right都不为空，所以最终返回节点2，即节点5的右子树返回的right=2，由于节点5的左子树返回的left=null，而右子树返回的right=2不为空，所以节点5返回2，则节点3接收到的左子树的返回值为2，然后接收到右子树返回的值为null，即最终返回左子树的返回的值left=2</p><p><img src="/2020/05/29/Leetcode之树/最近祖先3.jpg" alt=""></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode(object):</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lowestCommonAncestor</span><span class="params">(self, root, p, q)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type root: TreeNode</span></span><br><span class="line"><span class="string">        :type p: TreeNode</span></span><br><span class="line"><span class="string">        :type q: TreeNode</span></span><br><span class="line"><span class="string">        :rtype: TreeNode</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root <span class="keyword">or</span> root==p <span class="keyword">or</span> root==q:</span><br><span class="line">            <span class="keyword">return</span> root</span><br><span class="line">        left = self.lowestCommonAncestor(root.left,p,q)</span><br><span class="line">        right = self.lowestCommonAncestor(root.right,p,q)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> left:<span class="keyword">return</span> right</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> right:<span class="keyword">return</span> left</span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(n)</li></ul><p><strong>【分析二】</strong></p><p><img src="/2020/05/29/Leetcode之树/最近祖先5.jpg" alt=""></p><p>比如找6和4的最近祖先，可以先从前序遍历找到从根节点到6和4的路径，分别是3-&gt;5-&gt;6，3-&gt;5-&gt;2-&gt;4，然后找这条路径的最后一个公共节点，就是5，所以5就是6和4的最近公共祖先</p><p>步骤：</p><ol><li>首先找到从根节点到6和4的路径</li><li>找到这2条路径的最后一个公共节点</li><li>返回这个公共节点，即是6和4的最近公共祖先</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode(object):</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lowestCommonAncestor</span><span class="params">(self, root, p, q)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type root: TreeNode</span></span><br><span class="line"><span class="string">        :type p: TreeNode</span></span><br><span class="line"><span class="string">        :type q: TreeNode</span></span><br><span class="line"><span class="string">        :rtype: TreeNode</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        path_p,path_q = [],[]</span><br><span class="line">        self.getNodePath(root,p,path_p)</span><br><span class="line">        self.getNodePath(root,q,path_q)</span><br><span class="line">        last_common = self.getLastCommonNode(path_p,path_q)</span><br><span class="line">        <span class="keyword">return</span> last_common</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getNodePath</span><span class="params">(self,root,target,path)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        找到从root到target的路径</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">        found = <span class="keyword">False</span> </span><br><span class="line">        path.append(root)</span><br><span class="line">        <span class="keyword">if</span> target == root:</span><br><span class="line">            found = <span class="keyword">True</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> found <span class="keyword">and</span> root.left:</span><br><span class="line">            found = self.getNodePath(root.left,target,path)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> found <span class="keyword">and</span> root.right:</span><br><span class="line">            found = self.getNodePath(root.right,target,path)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> found:</span><br><span class="line">            path.pop()</span><br><span class="line">        <span class="keyword">return</span> found</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getLastCommonNode</span><span class="params">(self,path_p,path_q)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        找到2个序列最后一个相同元素</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        n = min(len(path_p),len(path_q))</span><br><span class="line">        last_common = <span class="keyword">None</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">            <span class="keyword">if</span> path_p[i]==path_q[i]:</span><br><span class="line">                last_common = path_p[i]</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">return</span> last_common</span><br></pre></td></tr></table></figure><p>这种方法也可以适用于多叉树中的最近组件，只需要修改<code>getNodePath</code>函数就可以了，如果是多叉树，就需要递归遍历所有的子树</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2><span id="193-多叉树的最近公共祖先">19.3. 多叉树的最近公共祖先</span></h2><p>上面是二叉树，如果树是多叉树</p><p><img src="/2020/05/29/Leetcode之树/最近祖先4.jpg" alt=""></p><p><strong>【分析】</strong></p><p>比如找F和H的最近祖先，可以先从前序遍历找到从根节点到F和H的路径，分别是A-&gt;B-&gt;D-&gt;F，A-&gt;B-&gt;E-&gt;H，然后找这条路径的最后一个公共节点，就是B，所以B就是F和H的最近公共祖先</p><p>步骤：</p><ol><li>首先找到从根节点到F和H的路径</li><li>找到这2条路径的最后一个公共节点</li><li>返回这个公共节点，即是F和H的最近公共祖先</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2><span id="194-tarjan离线算法">19.4. Tarjan离线算法</span></h2><p>对于一个二叉树给定n个节点，找这n个节点最近祖先</p><p><strong>【分析】</strong></p><p>首先的想法是先将n个节点分组，每组有2个节点，先找出每组的最近祖先，然后找出最终的最近祖先。这就需要多次调用上面的二叉树最近祖先的算法，相当于批量查找，时间复杂度很高。</p><p>下面介绍Tarjan离线算法，在一次遍历中将所有的查找一次性解决。</p><p><a href="https://www.cnblogs.com/wkfvawl/p/9415280.html" target="_blank" rel="noopener">参考资料</a></p><h1><span id="20-总结">20. 总结</span></h1><ul><li>深度优先搜索DFS一般使用栈结构存储，广度优先搜索BFS一般使用队列结构存储</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;!-- TOC --&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#1-树概念介绍&quot;&gt;1. 树概念介绍&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#2-树的前向遍历&quot;&gt;2. 树的前向遍历&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#3-二叉树的
      
    
    </summary>
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
      <category term="树" scheme="http://yoursite.com/tags/%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode之链表</title>
    <link href="http://yoursite.com/2020/05/24/Leetcode%E4%B9%8B%E9%93%BE%E8%A1%A8/"/>
    <id>http://yoursite.com/2020/05/24/Leetcode之链表/</id>
    <published>2020-05-24T08:19:04.000Z</published>
    <updated>2020-07-12T17:04:45.308Z</updated>
    
    <content type="html"><![CDATA[<p>链表遍历数据时，需要从头遍历。链表只需要给出头指针就可以</p><a id="more"></a><!-- TOC --><ul><li><a href="#1-快慢指针">1. 快慢指针</a><ul><li><a href="#11-找链表的中间节点">1.1. 找链表的中间节点</a></li><li><a href="#12-倒数第k个节点">1.2. 倒数第K个节点</a></li><li><a href="#13-环形链表">1.3. 环形链表</a></li><li><a href="#14-环形链表ii">1.4. 环形链表II</a></li><li><a href="#15-相交链表">1.5. 相交链表</a></li></ul></li><li><a href="#2-合并有序链表">2. 合并有序链表</a><ul><li><a href="#21-合并2个有序链表">2.1. 合并2个有序链表</a></li><li><a href="#22-合并k个有序链表">2.2. 合并K个有序链表</a></li></ul></li><li><a href="#3-从尾到头打印链表">3. 从尾到头打印链表</a></li><li><a href="#4-反转链表">4. 反转链表</a><ul><li><a href="#41-反转链表">4.1. 反转链表</a></li><li><a href="#42-k个一组反转链表">4.2. K个一组反转链表</a></li></ul></li><li><a href="#5-添加新的头结点">5. 添加新的头结点</a><ul><li><a href="#51-两两交换链表中的节点">5.1. 两两交换链表中的节点</a></li><li><a href="#52-删除链表的倒数第n个节点">5.2. 删除链表的倒数第N个节点</a></li><li><a href="#53-移除重复节点">5.3. 移除重复节点</a></li><li><a href="#54-删除链表的节点">5.4. 删除链表的节点</a></li><li><a href="#55-删除中间节点">5.5. 删除中间节点</a></li></ul></li><li><a href="#6-链表求和">6. 链表求和</a><ul><li><a href="#61-链表求和">6.1. 链表求和</a></li><li><a href="#62-进阶">6.2. 进阶</a></li></ul></li><li><a href="#7-回文链表">7. 回文链表</a></li><li><a href="#8-重排链表">8. 重排链表</a></li><li><a href="#9-总结">9. 总结</a></li></ul><!-- /TOC --><h1><span id="1-快慢指针">1. 快慢指针</span></h1><h2><span id="11-找链表的中间节点">1.1. 找链表的中间节点</span></h2><p>给定一个带有头结点 head 的非空单链表，返回链表的中间结点。</p><p>如果有两个中间结点，则返回第二个中间结点。</p><p><strong>【分析】</strong></p><ul><li>当链表中个数为奇数时，返回中间的节点。例如1-&gt;2-&gt;3-&gt;4-&gt;5，返回节点3</li><li>当链表中个数为偶数时，返回右节点。例如1-&gt;2-&gt;3-&gt;4，中间的节点有2和3，返回右节点3</li><li>当链表中个数为偶数时，返回左节点。例如1-&gt;2-&gt;3-&gt;4，中间的节点有2和3，返回右节点2</li></ul><p>使用双指针，慢指针一次走一步，快指针一次走两步</p><p><img src="/2020/05/24/Leetcode之链表/876-1.png" alt=""></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">middleNode</span><span class="params">(self, head)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type head: ListNode</span></span><br><span class="line"><span class="string">        :rtype: ListNode</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        fast,low = head,head</span><br><span class="line">        <span class="comment">#返回右节点</span></span><br><span class="line">        <span class="keyword">while</span> fast <span class="keyword">and</span> fast.next:</span><br><span class="line">            fast = fast.next.next</span><br><span class="line">            low = low.next</span><br><span class="line">        <span class="keyword">return</span> low</span><br></pre></td></tr></table></figure><p><img src="/2020/05/24/Leetcode之链表/876-2.png" alt=""></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">middleNode</span><span class="params">(self, head)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type head: ListNode</span></span><br><span class="line"><span class="string">        :rtype: ListNode</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        fast,low = head,head</span><br><span class="line">        <span class="comment">#返回左节点</span></span><br><span class="line">        <span class="keyword">while</span> fast.next <span class="keyword">and</span> fast.next.next:</span><br><span class="line">            fast = fast.next.next</span><br><span class="line">            low = low.next</span><br><span class="line">        <span class="keyword">return</span> low</span><br></pre></td></tr></table></figure><h2><span id="12-倒数第k个节点">1.2. 倒数第K个节点</span></h2><p>输入一个链表，输出该链表中倒数第k个节点。尾节点是倒数第1个节点。</p><p>例如：给定一个链表: 1-&gt;2-&gt;3-&gt;4-&gt;5, 和 k = 2.<br>返回链表 4-&gt;5</p><p><strong>【分析】</strong><br>使用快慢指针，快指针先向前移动k个节点，慢指针指向head，然后快慢指针一起向前走，当快指针指向null时，此时慢指针指向倒数第k个节点，返回即可。<br>举例：1-&gt;3-&gt;9-&gt;7-&gt;6-&gt;12，k=3，首先fast和low都指向1，然后fast向前移动3步指向7，然后fast和low同时向前走，当fast指向null时，此时low指向7，返回即可。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getKthFromEnd</span><span class="params">(self, head, k)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type head: ListNode</span></span><br><span class="line"><span class="string">        :type k: int</span></span><br><span class="line"><span class="string">        :rtype: ListNode</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> head:<span class="keyword">return</span> head</span><br><span class="line">        <span class="keyword">if</span> k==<span class="number">0</span>:<span class="keyword">return</span> <span class="keyword">None</span></span><br><span class="line">        fast,low = head,head</span><br><span class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> range(k):</span><br><span class="line">            <span class="keyword">if</span> fast:</span><br><span class="line">                fast = fast.next</span><br><span class="line">            <span class="keyword">else</span>:<span class="comment">#防止k大于链表个数</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">None</span></span><br><span class="line">        <span class="keyword">while</span> fast:</span><br><span class="line">            fast = fast.next</span><br><span class="line">            low = low.next</span><br><span class="line">        <span class="keyword">return</span> low</span><br></pre></td></tr></table></figure><h2><span id="13-环形链表">1.3. 环形链表</span></h2><p><a href="https://leetcode-cn.com/problems/linked-list-cycle/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/linked-list-cycle/</a><br>给定一个链表，判断链表中是否有环。</p><ul><li><p><strong>使用set</strong><br>使用set保存节点的引用，而不是节点的值</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">hasCycle</span><span class="params">(self, head)</span>:</span></span><br><span class="line">      <span class="string">"""</span></span><br><span class="line"><span class="string">      :type head: ListNode</span></span><br><span class="line"><span class="string">      :rtype: bool</span></span><br><span class="line"><span class="string">      """</span></span><br><span class="line">      <span class="comment">#使用set，这里set保存的是节点的引用，而不是节点的值</span></span><br><span class="line">      nodes = set()</span><br><span class="line">      <span class="keyword">while</span> head:</span><br><span class="line">          <span class="keyword">if</span> head <span class="keyword">in</span> nodes:</span><br><span class="line">              <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">          nodes.add(head)</span><br><span class="line">          head = head.next</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">False</span></span><br></pre></td></tr></table></figure></li><li><p><strong>快慢指针</strong><br>快指针每次走2步，慢指针每次走1步，如果链表中有环，两者迟早会碰上，如果始终碰不上，则链表中没有环。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">hasCycle</span><span class="params">(self, head)</span>:</span></span><br><span class="line">      <span class="string">"""</span></span><br><span class="line"><span class="string">      :type head: ListNode</span></span><br><span class="line"><span class="string">      :rtype: bool</span></span><br><span class="line"><span class="string">      """</span></span><br><span class="line">      <span class="keyword">if</span> <span class="keyword">not</span> head:<span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">      fast,low = head,head</span><br><span class="line">      <span class="keyword">while</span> fast.next <span class="keyword">and</span> fast.next.next:</span><br><span class="line">          fast = fast.next.next</span><br><span class="line">          low = low.next</span><br><span class="line">          <span class="keyword">if</span> fast == low:</span><br><span class="line">              <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">False</span></span><br></pre></td></tr></table></figure></li></ul><h2><span id="14-环形链表ii">1.4. 环形链表II</span></h2><p>给定一个链表，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。<br>说明：不允许修改给定的链表。<br>链接：<a href="https://leetcode-cn.com/problems/linked-list-cycle-ii" target="_blank" rel="noopener">https://leetcode-cn.com/problems/linked-list-cycle-ii</a></p><p><strong>【分析】</strong><br><a href="https://leetcode-cn.com/problems/linked-list-cycle-ii/solution/wo-dui-di-er-jie-duan-de-li-jie-by-fei-er-10/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/linked-list-cycle-ii/solution/wo-dui-di-er-jie-duan-de-li-jie-by-fei-er-10/</a></p><p><img src="/2020/05/24/Leetcode之链表/142-1.png" alt=""></p><p>快指针每次走2步，慢指针每次走1步，如果链表中存在环，则一定会相遇。如上图所示，2指针在C点相遇，然后让一个指针退回到头结点A，一个指针继续待在C，然后向前走，两指针再次相遇的点就是入环的第一个节点。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">detectCycle</span><span class="params">(self, head)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type head: ListNode</span></span><br><span class="line"><span class="string">        :rtype: ListNode</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> head:<span class="keyword">return</span> <span class="keyword">None</span></span><br><span class="line">        fast,slow = head,head</span><br><span class="line">        <span class="keyword">while</span> fast.next <span class="keyword">and</span> fast.next.next:</span><br><span class="line">            fast = fast.next.next</span><br><span class="line">            slow = slow.next</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> fast == slow:</span><br><span class="line">                slow = head</span><br><span class="line">                <span class="keyword">while</span> slow != fast:</span><br><span class="line">                    slow = slow.next</span><br><span class="line">                    fast = fast.next</span><br><span class="line">                <span class="keyword">return</span> fast</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">None</span></span><br></pre></td></tr></table></figure><h2><span id="15-相交链表">1.5. 相交链表</span></h2><p>编写一个程序，找到两个单链表相交的起始节点。<br><a href="https://leetcode-cn.com/problems/intersection-of-two-linked-lists/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/intersection-of-two-linked-lists/</a></p><p><strong>【分析】</strong></p><p>A链表：1-&gt;2-&gt;3-&gt;8-&gt;7-&gt;9-&gt;11<br>B链表：10-&gt;6-&gt;8-&gt;7-&gt;9-&gt;11<br>相交节点为8，共同拥有部分长度c=4，A和B分别单独拥有的长度a=3，b=2<br>a+c不等于b+c，但如果2个节点同时遍历a+c+b,b+c+a，因为长度一样，则一定会同时结束。<br>使用指针A和指针B用来遍历链表1和链表2，当链表1遍历完之后，指针A指向链表2的头结点，开始遍历链表2。当链表2遍历完之后，指针B指向链表1的头结点，开始遍历链表1。</p><ul><li>如果链表1和链表2有交点，则A和B一定会在交点处遇见，此时返回即可。</li><li>如果链表1和链表2不相交，则指针A会走到链表2的None，指针B会走到链表1的None，此时A==B，跳出循环，返回A，即返回None，表示没有交点。</li></ul><p><img src="/2020/05/24/Leetcode之链表/相交.jpg" alt=""></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getIntersectionNode</span><span class="params">(self, headA, headB)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type head1, head1: ListNode</span></span><br><span class="line"><span class="string">        :rtype: ListNode</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        A,B = headA,headB</span><br><span class="line">        <span class="keyword">while</span> A!=B:</span><br><span class="line">            <span class="keyword">if</span> A:</span><br><span class="line">                A = A.next</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                A = headB   </span><br><span class="line">            <span class="keyword">if</span> B:</span><br><span class="line">                B = B.next</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                B = headA</span><br><span class="line">        <span class="comment">#最终肯定会跳出训练，如果没有交点，此时A指向链表B的None，B指向链表A的None，返回None</span></span><br><span class="line">        <span class="comment">#如果有交点，则A和B指向相交的位置</span></span><br><span class="line">        <span class="keyword">return</span> A</span><br></pre></td></tr></table></figure><h1><span id="2-合并有序链表">2. 合并有序链表</span></h1><h2><span id="21-合并2个有序链表">2.1. 合并2个有序链表</span></h2><p>将两个升序链表合并为一个新的 升序 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 </p><blockquote><p>示例：<br>输入：1-&gt;2-&gt;4, 1-&gt;3-&gt;4<br>输出：1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4</p></blockquote><p>链接：<a href="https://leetcode-cn.com/problems/merge-two-sorted-lists" target="_blank" rel="noopener">https://leetcode-cn.com/problems/merge-two-sorted-lists</a></p><p><strong>【分析】</strong></p><p>新建一个链表来保存合并之后的值</p><p>l1和l2指向当前需要比较的2个节点</p><ul><li>如果l1小于l2，则将l1插入到新的链表中，然后将l1向后移一位，把新链表中的pre向后移一位。</li><li>如果l2比较小，把l2插入到新链表中，然后将l2向后移一位，把新链表中的pre向后移一位。</li></ul><p>跳出while循环时，肯定是有一个链表已经为空了，如果另一个链表不为空，则把这个链表直接加到新的链表中</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode(object):</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">mergeTwoLists</span><span class="params">(self, l1, l2)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type l1: ListNode</span></span><br><span class="line"><span class="string">        :type l2: ListNode</span></span><br><span class="line"><span class="string">        :rtype: ListNode</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> l1:<span class="keyword">return</span> l2</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> l2:<span class="keyword">return</span> l1</span><br><span class="line">        thread = ListNode(<span class="number">-1</span>)</span><br><span class="line"></span><br><span class="line">        pre = thread</span><br><span class="line">        <span class="keyword">while</span> l1 <span class="keyword">and</span> l2:</span><br><span class="line">            <span class="keyword">if</span> l1.val &lt;= l2.val:</span><br><span class="line">                pre.next = l1</span><br><span class="line">                l1 = l1.next</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                pre.next = l2</span><br><span class="line">                l2 = l2.next</span><br><span class="line">            pre = pre.next</span><br><span class="line">        <span class="keyword">if</span> l1:pre.next = l1</span><br><span class="line">        <span class="keyword">if</span> l2:pre.next = l2</span><br><span class="line">        <span class="keyword">return</span> thread.next</span><br></pre></td></tr></table></figure><ul><li>时间复杂度：O(n+m)，n和m表示2个链表的长度</li><li>空间复杂度：O(1)</li></ul><p><strong>【分析二】</strong></p><p>使用递归方法</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">mergeTwoList</span><span class="params">(self,l1,l2)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> l1:<span class="keyword">return</span> l2</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> l2:<span class="keyword">return</span> l1</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> l1.val &lt;= l2.val:</span><br><span class="line">            l1.next = self.mergeTwoList(l1.next,l2)</span><br><span class="line">            <span class="keyword">return</span> l1</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            l2.next = self.mergeTwoList(l1,l2.next)</span><br><span class="line">            <span class="keyword">return</span> l2</span><br></pre></td></tr></table></figure><h2><span id="22-合并k个有序链表">2.2. 合并K个有序链表</span></h2><p>合并 k 个排序链表，返回合并后的排序链表。请分析和描述算法的复杂度。</p><blockquote><p>示例:<br>输入:<br>[<br>  1-&gt;4-&gt;5,<br>  1-&gt;3-&gt;4,<br>  2-&gt;6<br>]<br>输出: 1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4-&gt;5-&gt;6</p></blockquote><p>链接：<a href="https://leetcode-cn.com/problems/merge-k-sorted-lists" target="_blank" rel="noopener">https://leetcode-cn.com/problems/merge-k-sorted-lists</a></p><p><strong>【分析一】</strong></p><p>一共有K个有序链表，空链表先和链表1合并，得到链表a，链表a再和链表2合并得到链表b，。。。一直合并到链表K。但是这种方法超时</p><p>2个链表合并的时间复杂度是O(N)，其中N是2个链表节点数之和。<br>这里假设一个链表的节点个数为N，第一个合并时间复杂度为0，因为是和空链表合并，第二次合并复杂度为2N，第三个合并时间复杂度为3N，第K次合并时间复杂度为KN<br>即2N+3N+…+KN=(K+2)(K-1)N/2<br>近似是K*KN，这里把KN看成是所有链表的节点数N，则时间复杂度为O(KN)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode(object):</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">mergeKLists</span><span class="params">(self, lists)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type lists: List[ListNode]</span></span><br><span class="line"><span class="string">        :rtype: ListNode</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> lists:<span class="keyword">return</span> <span class="keyword">None</span></span><br><span class="line">        <span class="comment">#每次只合并2个链表</span></span><br><span class="line">        res = <span class="keyword">None</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(lists)):</span><br><span class="line">            res = self.mergeTwoList(res,lists[i])</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">mergeTwoList</span><span class="params">(self,l1,l2)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> l1:<span class="keyword">return</span> l2</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> l2:<span class="keyword">return</span> l1</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> l1.val &lt;= l2.val:</span><br><span class="line">            l1.next = self.mergeTwoList(l1.next,l2)</span><br><span class="line">            <span class="keyword">return</span> l1</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            l2.next = self.mergeTwoList(l1,l2.next)</span><br><span class="line">            <span class="keyword">return</span> l2</span><br></pre></td></tr></table></figure><p><strong>【分析二】</strong></p><p>分治合并<br>一共K个有序链表，先分组，每2个为一组，先把一组内的2个链表合并，变成K/2个链表，然后再分组再合并。<br>在合并2个有序链表时有2种方法：递归和迭代。<br>在本题中当使用迭代方式时，超时<br>使用递归方法不超时</p><p><img src="/2020/05/24/Leetcode之链表/合并.jpg" alt=""></p><p>假设K个链表一共有N个节点，每个链表有N/K个节点，2个链表合并的时间复杂度是o(N/K)，一个链表被合并logK次，一共有K个链表，则时间复杂度是O(NlogK)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode(object):</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">mergeKLists</span><span class="params">(self, lists)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type lists: List[ListNode]</span></span><br><span class="line"><span class="string">        :rtype: ListNode</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> lists:<span class="keyword">return</span> <span class="keyword">None</span></span><br><span class="line">        <span class="keyword">return</span> self.merge(lists,<span class="number">0</span>,len(lists)<span class="number">-1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">merge</span><span class="params">(self,lists,left,right)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> left==right:</span><br><span class="line">            <span class="keyword">return</span> lists[left]</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            mid = left+(right-left)//<span class="number">2</span></span><br><span class="line">            l1 = self.merge(lists,left,mid)</span><br><span class="line">            l2 = self.merge(lists,mid+<span class="number">1</span>,right)</span><br><span class="line">            <span class="keyword">return</span> self.mergeTwoList(l1,l2)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">mergeTwoList</span><span class="params">(self,l1,l2)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> l1:<span class="keyword">return</span> l2</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> l2:<span class="keyword">return</span> l1</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> l1.val &lt;= l2.val:</span><br><span class="line">            l1.next = self.mergeTwoList(l1.next,l2)</span><br><span class="line">            <span class="keyword">return</span> l1</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            l2.next = self.mergeTwoList(l1,l2.next)</span><br><span class="line">            <span class="keyword">return</span> l2</span><br></pre></td></tr></table></figure><h1><span id="3-从尾到头打印链表">3. 从尾到头打印链表</span></h1><p>输入一个链表的头节点，从尾到头反过来返回每个节点的值（用数组返回）。</p><blockquote><p>示例 1：<br>输入：head = [1,3,2]<br>输出：[2,3,1]</p></blockquote><p><a href="https://leetcode-cn.com/problems/cong-wei-dao-tou-da-yin-lian-biao-lcof/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/cong-wei-dao-tou-da-yin-lian-biao-lcof/</a></p><p><strong>【分析】</strong></p><p>使用数组保存从前到后遍历的值，返回的时候倒序返回</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode(object):</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reversePrint</span><span class="params">(self, head)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type head: ListNode</span></span><br><span class="line"><span class="string">        :rtype: List[int]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> head:<span class="keyword">return</span> []</span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">while</span> head:</span><br><span class="line">            res.append(head.val)</span><br><span class="line">            head = head.next</span><br><span class="line">        <span class="keyword">return</span> res[::<span class="number">-1</span>]</span><br></pre></td></tr></table></figure><h1><span id="4-反转链表">4. 反转链表</span></h1><h2><span id="41-反转链表">4.1. 反转链表</span></h2><p><strong>【分析】</strong></p><p>反转列表，原先的头结点变成尾节点，首先cur为头结点，pre为None，第一次循环时，先把cur的下一个节点保存成tmp，然后改变cur的next为None，这样就把头结点变成尾节点（next节点为空），然后cur变成pre，开始遍历下一个节点，即tmp，使用cur=tmp赋值。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverseList</span><span class="params">(self, head)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type head: ListNode</span></span><br><span class="line"><span class="string">        :rtype: ListNode</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        cur,pre = head,<span class="keyword">None</span></span><br><span class="line">        <span class="keyword">while</span> cur:</span><br><span class="line">            tmp = cur.next</span><br><span class="line">            cur.next = pre</span><br><span class="line">            pre = cur</span><br><span class="line">            cur = tmp</span><br><span class="line">        <span class="keyword">return</span> pre</span><br></pre></td></tr></table></figure><h2><span id="42-k个一组反转链表">4.2. K个一组反转链表</span></h2><p>给你一个链表，每k个节点一组进行翻转，请返回翻转后的链表。k是一个正整数，它的值小于等于链表长度。<br>如果节点总数不是k的倍数，那么请将最后剩余的节点保持原有顺序</p><p>要求：</p><ol><li>只能使用常数额外空间</li><li>不能只改变节点内部的值，而是要交换节点</li></ol><blockquote><p>示例：<br>给你这个链表：1-&gt;2-&gt;3-&gt;4-&gt;5<br>当 k = 2 时，应当返回: 2-&gt;1-&gt;4-&gt;3-&gt;5<br>当 k = 3 时，应当返回: 3-&gt;2-&gt;1-&gt;4-&gt;5</p></blockquote><p>链接：<a href="https://leetcode-cn.com/problems/reverse-nodes-in-k-group" target="_blank" rel="noopener">https://leetcode-cn.com/problems/reverse-nodes-in-k-group</a></p><p><strong>【分析】</strong></p><p>需要把链表按照k个分成一组，使用<code>head</code>指向每组的头结点，然后向前移动K步，如果还没移动到k步就到达链表尾部，说明后面的这部分不够K个元素，就不用反转了，直接返回。如果够K个节点，则需要反转这K个节点。</p><p><code>reverse(self,head,tail)</code>用来反转这K个元素，传入K个元素的头和尾，反转之后返回新的头和尾。</p><p>将这K个元素反转之后返回新的头和尾，在把这K个元素加到原先的链表上。<br>在反转之前，记录<code>head</code>的前一个节点，用<code>pre</code>表示，记录<code>tail</code>的后一个节点，用<code>tail_next</code>表示。反转之后，把新的<code>head</code>放在<code>pre</code>后面，把新的<code>tail</code>放在<code>tail_next</code>前面。则这K个元素就处理完了。接着处理下K个元素。需要移动<code>head</code>和<code>pre</code>，<code>head</code>移到下K个元素的头，即<code>head=tail.next</code>，<code>pre</code>移动到这K个元素的前一个节点，即<code>pre=tail</code>，然后继续while循环，<code>tail</code>此时指向<code>pre</code>，然后<code>tail</code>向前移动K个元素</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode(object):</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverseKGroup</span><span class="params">(self, head, k)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type head: ListNode</span></span><br><span class="line"><span class="string">        :type k: int</span></span><br><span class="line"><span class="string">        :rtype: ListNode</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        thread = ListNode(<span class="number">-1</span>)</span><br><span class="line">        thread.next = head</span><br><span class="line">        pre = thread</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> head:</span><br><span class="line">            tail = pre</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(k):</span><br><span class="line">                tail = tail.next</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> tail:</span><br><span class="line">                    <span class="keyword">return</span> thread.next</span><br><span class="line">            <span class="comment">#此时已经找到k个节点的head和tail</span></span><br><span class="line"></span><br><span class="line">            tail_next = tail.next<span class="comment">#记录tail的next的值</span></span><br><span class="line"></span><br><span class="line">            head,tail = self.reverse(head,tail)<span class="comment">#返回反转后新的head和tail</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">#把反转后的k个元素加入到链表中</span></span><br><span class="line">            pre.next = head</span><br><span class="line">            tail.next = tail_next</span><br><span class="line"></span><br><span class="line">            <span class="comment">#移动head和pre找下k个元素</span></span><br><span class="line">            pre = tail</span><br><span class="line">            head = tail.next</span><br><span class="line">        <span class="keyword">return</span> thread.next</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverse</span><span class="params">(self,head,tail)</span>:</span></span><br><span class="line">        pre = tail.next</span><br><span class="line">        cur = head</span><br><span class="line">        <span class="keyword">while</span> pre!=tail:</span><br><span class="line">            tmp = cur.next</span><br><span class="line">            cur.next = pre</span><br><span class="line">            pre = cur</span><br><span class="line">            cur = tmp</span><br><span class="line">        <span class="keyword">return</span> tail,head</span><br></pre></td></tr></table></figure><ul><li>时间复杂度：O(n)遍历了整个链表，但每隔K个元素，会消耗O(K)的时间来进行反转</li><li>空间复杂度：O(1)</li></ul><h1><span id="5-添加新的头结点">5. 添加新的头结点</span></h1><p>什么样的链表题需要添加新的头结点？<br>在操作当前节点时，需要记录前一个节点的值时，一般都需要添加新的头结点<br>添加方式为：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">thread = ListNode(<span class="number">-1</span>)</span><br><span class="line">thread.next = head</span><br></pre></td></tr></table></figure><h2><span id="51-两两交换链表中的节点">5.1. 两两交换链表中的节点</span></h2><p>给定一个链表，两两交换其中相邻的节点，并返回交换后的链表。</p><p>你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。</p><p><a href="https://leetcode-cn.com/problems/swap-nodes-in-pairs/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/swap-nodes-in-pairs/</a></p><p>例如：给定 1-&gt;2-&gt;3-&gt;4, 你应该返回 2-&gt;1-&gt;4-&gt;3.</p><p><strong>【分析】</strong><br>在原始链表上添加一个头节点thread，将thread指向原始头结点head。每次交换顺序时，需要有3个指针：a：当前交换的左节点，b：当前交换的右节点，c：a的前一个节点。例如要交换1和2的顺序时，c=-1，a=1，b=2，交换后变成-1-&gt;2-&gt;1-&gt;3-&gt;4，要交换3和4的顺序时，c=1，a=3，b=4，交换后变成-1-&gt;2-&gt;1-&gt;4-&gt;3，然后返回thread的下一个节点，即新的头结点2。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">swapPairs</span><span class="params">(self, head)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type head: ListNode</span></span><br><span class="line"><span class="string">        :rtype: ListNode</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> head <span class="keyword">or</span> <span class="keyword">not</span> head.next:</span><br><span class="line">            <span class="keyword">return</span> head</span><br><span class="line">        thred = ListNode(<span class="number">-1</span>)</span><br><span class="line">        thred.next = head</span><br><span class="line">        c = thred</span><br><span class="line">        <span class="keyword">while</span> c.next <span class="keyword">and</span> c.next.next:</span><br><span class="line">            a,b = c.next,c.next.next</span><br><span class="line">            c.next,a.next = b,b.next</span><br><span class="line">            b.next = a</span><br><span class="line">            c = c.next.next</span><br><span class="line">        <span class="keyword">return</span> thred.next</span><br></pre></td></tr></table></figure><h2><span id="52-删除链表的倒数第n个节点">5.2. 删除链表的倒数第N个节点</span></h2><p>给定一个链表，删除链表的倒数第 n 个节点，并且返回链表的头结点。<br><a href="https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list/</a></p><p>给定一个链表: 1-&gt;2-&gt;3-&gt;4-&gt;5, 和 n = 2.<br>当删除了倒数第二个节点后，链表变为 1-&gt;2-&gt;3-&gt;5.</p><p><strong>【分析】</strong><br>这一题是”找链表中倒数第N个节点”的进阶版。首先使用快慢指针找到倒数第N个节点，同时还要删除，这里需要记录倒数第N个节点的前一个节点。本题通过添加一个头结点来实现。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">removeNthFromEnd</span><span class="params">(self, head, n)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type head: ListNode</span></span><br><span class="line"><span class="string">        :type n: int</span></span><br><span class="line"><span class="string">        :rtype: ListNode</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        fast,low = head,head</span><br><span class="line">        thread = ListNode(<span class="number">-1</span>)<span class="comment">#low的前一个节点</span></span><br><span class="line">        thread.next = head</span><br><span class="line">        pre = thread</span><br><span class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> range(n):</span><br><span class="line">            fast = fast.next</span><br><span class="line">        <span class="keyword">while</span> fast:</span><br><span class="line">            pre = low</span><br><span class="line">            fast = fast.next</span><br><span class="line">            low = low.next</span><br><span class="line">        pre.next = low.next</span><br><span class="line">        <span class="keyword">return</span> thread.next</span><br></pre></td></tr></table></figure><h2><span id="53-移除重复节点">5.3. 移除重复节点</span></h2><p>编写代码，移除<strong>未排序链表</strong>中的重复节点。保留最开始出现的节点。</p><blockquote><p>示例1:<br> 输入：[1, 2, 3, 3, 2, 1]<br> 输出：[1, 2, 3]</p></blockquote><p><a href="https://leetcode-cn.com/problems/remove-duplicate-node-lcci/submissions/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/remove-duplicate-node-lcci/submissions/</a></p><p><strong>【分析】</strong></p><p>删除链表中的节点，根据经验，添加一个新的头结点</p><p>使用set来保存链表中不重复的值。当有一个节点在set中已经有了，则把这个节点删掉，即<code>pre.next=cur.next</code>，同时更新cur的值。当这个点在set中没有，pre和cur同时移向下一个节点</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode(object):</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">removeDuplicateNodes</span><span class="params">(self, head)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type head: ListNode</span></span><br><span class="line"><span class="string">        :rtype: ListNode</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        thread = ListNode(<span class="number">-1</span>)</span><br><span class="line">        thread.next = head</span><br><span class="line"></span><br><span class="line">        node_set = set()</span><br><span class="line">        pre,cur = thread,head</span><br><span class="line">        <span class="keyword">while</span> cur:</span><br><span class="line">            <span class="keyword">if</span> cur.val <span class="keyword">in</span> node_set:</span><br><span class="line">                pre.next = cur.next</span><br><span class="line">                cur = cur.next</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                node_set.add(cur.val)</span><br><span class="line">                cur = cur.next</span><br><span class="line">                pre = pre.next</span><br><span class="line">        <span class="keyword">return</span> thread.next</span><br></pre></td></tr></table></figure><h2><span id="54-删除链表的节点">5.4. 删除链表的节点</span></h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode(object):</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">deleteNode</span><span class="params">(self, head, val)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type head: ListNode</span></span><br><span class="line"><span class="string">        :type val: int</span></span><br><span class="line"><span class="string">        :rtype: ListNode</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> head:<span class="keyword">return</span> <span class="keyword">None</span></span><br><span class="line">        <span class="comment">#删除这个节点，首先要找到这个节点的位置</span></span><br><span class="line">        <span class="comment">#然后把这个节点的前一个节点的next指向当前节点的next</span></span><br><span class="line">        <span class="comment">#所以需要记录被删除节点的前一个节点</span></span><br><span class="line">        thread = ListNode(<span class="number">-1</span>)</span><br><span class="line">        thread.next = head</span><br><span class="line"></span><br><span class="line">        pre,cur = thread,head</span><br><span class="line">        <span class="keyword">while</span> cur:</span><br><span class="line">            <span class="keyword">if</span> cur.val == val:</span><br><span class="line">                pre.next = cur.next</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                pre = cur</span><br><span class="line">                cur = cur.next</span><br><span class="line">        <span class="keyword">return</span> thread.next</span><br></pre></td></tr></table></figure><h2><span id="55-删除中间节点">5.5. 删除中间节点</span></h2><p>实现一种算法，删除单向链表中间的某个节点（即不是第一个或最后一个节点），<strong>假定你只能访问该节点</strong>。</p><blockquote><p>输入：单向链表a-&gt;b-&gt;c-&gt;d-&gt;e-&gt;f中的节点c<br>结果：不返回任何数据，但该链表变为a-&gt;b-&gt;d-&gt;e-&gt;f</p></blockquote><p><a href="https://leetcode-cn.com/problems/delete-middle-node-lcci/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/delete-middle-node-lcci/</a></p><p><strong>【分析】</strong></p><p>第一次做误以为node就是链表的头结点，然后使用快慢指针找到链表的中间节点，并同时记录中间节点的前一个节点，来删除中间节点。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode(object):</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">deleteNode</span><span class="params">(self, node)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type node: ListNode</span></span><br><span class="line"><span class="string">        :rtype: void Do not return anything, modify node in-place instead.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="comment">#首先找到中间节点，当节点个数为奇数时，正好是中间节点</span></span><br><span class="line">        <span class="comment">#当节点个数是偶数时，中间节点为左中位数</span></span><br><span class="line"></span><br><span class="line">        pre = <span class="keyword">None</span></span><br><span class="line">        low,fast = node,node</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> fast.next <span class="keyword">and</span> fast.next.next:</span><br><span class="line">            pre = low</span><br><span class="line">            low = low.next</span><br><span class="line">            fast=fast.next.next</span><br><span class="line">        pre.next = low.next</span><br></pre></td></tr></table></figure><p>但是仔细读了题发现<code>node</code>并不是链表的头结点，而是需要删除的节点，这里并不知道链表的头结点，只知道被删除的这个节点。</p><p>1-&gt;2-&gt;3-&gt;4，假设需要节点2，这里只知道节点2，其余都不知道。</p><p>将节点3的值赋值给节点2，这样节点2的值变成3，然后在让这个节点指向节点4，最终变成1-&gt;3-&gt;4</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode(object):</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">deleteNode</span><span class="params">(self, node)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type node: ListNode</span></span><br><span class="line"><span class="string">        :rtype: void Do not return anything, modify node in-place instead.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        node.val = node.next.val</span><br><span class="line">        node.next = node.next.next</span><br></pre></td></tr></table></figure><h1><span id="6-链表求和">6. 链表求和</span></h1><h2><span id="61-链表求和">6.1. 链表求和</span></h2><p>给定两个用链表表示的整数，每个节点包含一个数位。<br>这些数位是反向存放的，也就是个位排在链表首部。<br>编写函数对这两个整数求和，并用链表形式返回结果。</p><blockquote><p>示例：<br>输入：(7 -&gt; 1 -&gt; 6) + (5 -&gt; 9 -&gt; 2)，即617 + 295<br>输出：2 -&gt; 1 -&gt; 9，即912</p></blockquote><p><a href="https://leetcode-cn.com/problems/sum-lists-lcci/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/sum-lists-lcci/</a></p><p><strong>【分析】</strong></p><p>链表的第一个节点表示个位，即使2个链表长度不一样，也是从头结点+头结点开始。</p><ol><li>先将对应位相加</li><li>再加上前一位的进位</li><li>根据当前位的和，模10，得到当前位的数，然后创建节点，并将这个节点加入到结果链表中</li><li>当前位的和除以10得到向下一位的进位</li></ol><p>只有当2个链表中最长的那个链表遍历到末尾，并且没有前一位的进位时，才退出循环。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode(object):</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">addTwoNumbers</span><span class="params">(self, l1, l2)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type l1: ListNode</span></span><br><span class="line"><span class="string">        :type l2: ListNode</span></span><br><span class="line"><span class="string">        :rtype: ListNode</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="comment">#链表的头节点表示个位数</span></span><br><span class="line"></span><br><span class="line">        thread = ListNode(<span class="number">-1</span>)</span><br><span class="line">        head = thread</span><br><span class="line">        p1,p2 = l1,l2</span><br><span class="line">        <span class="comment">#cur_sum当前位的和，carry：前一位的进位</span></span><br><span class="line">        cur_sum,carry = <span class="number">0</span>,<span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> p1 <span class="keyword">or</span> p2 <span class="keyword">or</span> carry:</span><br><span class="line">            cur_sum = <span class="number">0</span></span><br><span class="line">            <span class="keyword">if</span> p1:</span><br><span class="line">                cur_sum+=p1.val</span><br><span class="line">                p1 = p1.next</span><br><span class="line">            <span class="keyword">if</span> p2:</span><br><span class="line">                cur_sum+=p2.val</span><br><span class="line">                p2 = p2.next</span><br><span class="line">            cur_sum+=carry<span class="comment">#当前为的和加上前一个的进位</span></span><br><span class="line"></span><br><span class="line">            cur_node = ListNode(cur_sum%<span class="number">10</span>)<span class="comment">#得到当前为的节点</span></span><br><span class="line">            head.next = cur_node</span><br><span class="line">            head = head.next</span><br><span class="line">            carry = cur_sum//<span class="number">10</span><span class="comment">#传给下一位的进位</span></span><br><span class="line">        <span class="keyword">return</span> thread.next</span><br></pre></td></tr></table></figure><h2><span id="62-进阶">6.2. 进阶</span></h2><p>进阶：假设这些数位是正向存放的，请再做一遍。</p><blockquote><p>示例：<br>输入：(8 -&gt; 6 -&gt; 1 -&gt; 7) + (2 -&gt; 9 -&gt; 5)，即8617 + 295<br>输出：8 -&gt; 9 -&gt; 1 -&gt; 2，即8912</p></blockquote><p><strong>【分析】</strong></p><p>个位数在最后一个节点，所以从最后一个节点开始相加，但是链表无法刚开始就取到最后一位，这里利用栈来存储链表中的值。栈先进后出，现将高位的数字放到栈中，个数为最后放入栈中，在相加的时候从栈中取数据，先取出个位数，然后相加，再加上进位。将得到的和模10得到当前位的值并创建节点。这里需要注意再将节点加入到结果链表中，个位的节点在最后一个，其余的节点都在它前面。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">addTwoNumbers</span><span class="params">(self, l1, l2)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type l1: ListNode</span></span><br><span class="line"><span class="string">        :type l2: ListNode</span></span><br><span class="line"><span class="string">        :rtype: ListNode</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        stack1,stack2 = [],[]</span><br><span class="line"></span><br><span class="line">        p1,p2 = l1,l2</span><br><span class="line">        <span class="keyword">while</span> p1:</span><br><span class="line">            stack1.append(p1.val)</span><br><span class="line">            p1 = p1.next</span><br><span class="line">        <span class="keyword">while</span> p2:</span><br><span class="line">            stack2.append(p2.val)</span><br><span class="line">            p2 = p2.next</span><br><span class="line"></span><br><span class="line">        tail = <span class="keyword">None</span></span><br><span class="line">        <span class="comment">#cur_sum当前位的和，carry：前一位的进位</span></span><br><span class="line">        cur_sum,carry = <span class="number">0</span>,<span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> stack1 <span class="keyword">or</span> stack2 <span class="keyword">or</span> carry:</span><br><span class="line">            cur_sum = <span class="number">0</span></span><br><span class="line">            <span class="keyword">if</span> stack1:</span><br><span class="line">                cur_sum+=stack1.pop()</span><br><span class="line">            <span class="keyword">if</span> stack2:</span><br><span class="line">                cur_sum+=stack2.pop()</span><br><span class="line">            cur_sum+=carry<span class="comment">#当前为的和加上前一个的进位</span></span><br><span class="line"></span><br><span class="line">            cur_node = ListNode(cur_sum%<span class="number">10</span>)<span class="comment">#得到当前为的节点</span></span><br><span class="line">            cur_node.next = tail</span><br><span class="line">            tail = cur_node</span><br><span class="line">    </span><br><span class="line">            carry = cur_sum//<span class="number">10</span><span class="comment">#传给下一位的进位</span></span><br><span class="line">        <span class="keyword">return</span> tail</span><br></pre></td></tr></table></figure><h1><span id="7-回文链表">7. 回文链表</span></h1><p>判断一个链表是否是回文链表</p><blockquote><p>示例 1：<br>输入： 1-&gt;2<br>输出： false<br>示例 2：<br>输入： 1-&gt;2-&gt;2-&gt;1<br>输出： true </p></blockquote><p><a href="https://leetcode-cn.com/problems/palindrome-linked-list-lcci/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/palindrome-linked-list-lcci/</a></p><p><strong>【分析】</strong></p><p>回文链表即链表的后半部分反转之后和前半部分相等。所以判断一个链表是否是回文链表分为3步：</p><ol><li>找到链表的中间节点（左中位数）</li><li>反转后半部分</li><li>比较前后是否相等</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode(object):</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isPalindrome</span><span class="params">(self, head)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type head: ListNode</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> head:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">        <span class="comment">#分3步：找链表的中间节点，反转后半部分，前后比较</span></span><br><span class="line">        midNode = self.findMid(head)</span><br><span class="line">        <span class="comment">#secondStart为后半部分的开始节点</span></span><br><span class="line">        secondStart = self.reverseLinked(midNode.next)</span><br><span class="line">        cur1 = head</span><br><span class="line">        cur2 = secondStart </span><br><span class="line">        <span class="keyword">while</span> cur2:</span><br><span class="line">            <span class="keyword">if</span> cur1.val != cur2.val:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">            cur1 = cur1.next</span><br><span class="line">            cur2 = cur2.next</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findMid</span><span class="params">(self,head)</span>:</span></span><br><span class="line">        <span class="comment">#找到列表的中间节点，快指针一次走2步，满指针一次走1步</span></span><br><span class="line">        <span class="comment">#1-&gt;2-&gt;3-&gt;3-&gt;2-&gt;1,最终low指向第一个3</span></span><br><span class="line">        <span class="comment">#1-&gt;2-&gt;3-&gt;4-&gt;3-&gt;2-&gt;1,最终low指向4</span></span><br><span class="line">        fast,low = head,head</span><br><span class="line">        <span class="keyword">while</span> fast.next <span class="keyword">and</span> fast.next.next:</span><br><span class="line">            fast = fast.next.next</span><br><span class="line">            low = low.next</span><br><span class="line">        <span class="keyword">return</span> low</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverseLinked</span><span class="params">(self,head)</span>:</span></span><br><span class="line">        <span class="comment">#将3-&gt;2-&gt;1变成1-&gt;2-&gt;3，返回节点1</span></span><br><span class="line">        cur = head</span><br><span class="line">        pre = <span class="keyword">None</span></span><br><span class="line">        <span class="keyword">while</span> cur:</span><br><span class="line">            tmp = cur.next</span><br><span class="line">            cur.next = pre</span><br><span class="line">            pre = cur</span><br><span class="line">            cur = tmp</span><br><span class="line">        <span class="keyword">return</span> pre</span><br></pre></td></tr></table></figure><h1><span id="8-重排链表">8. 重排链表</span></h1><p><img src="/2020/05/24/Leetcode之链表/重排链表.jpg" alt=""></p><p><strong>【分析】</strong></p><p>分为3步：</p><ol><li>找出链表的中位数</li><li>反转后半部分</li><li>将前后两部分交叉拼接</li></ol><p>这道题和回文链表的前2步相似</p><p>这里找的是左中位数，但是反转的时候是从右中位数开始反转。<br>例如1-&gt;2-&gt;3-&gt;4，找到的左中位数是2，对3-&gt;4进行反转，然后将2的next置为None<br>例如1-&gt;2-&gt;3-&gt;4-&gt;5，找到的中位数是3，对4-&gt;5进行反转，然后将3的next置为None。<br>反转之后，得到前半部分为1-&gt;2-&gt;3-&gt;None，后半部分为5-&gt;4-&gt;None，然后将这2部分交叉拼接</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode(object):</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, next=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.next = next</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reorderList</span><span class="params">(self, head)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type head: ListNode</span></span><br><span class="line"><span class="string">        :rtype: None Do not return anything, modify head in-place instead.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> head:<span class="keyword">return</span> <span class="keyword">None</span></span><br><span class="line">        <span class="comment">#1. 先找左中位数</span></span><br><span class="line">        <span class="comment">#2. 将后半部分反转（包括右中位数），然后再把左位数为的next置为None，否则会报错</span></span><br><span class="line">        <span class="comment">#3. 将前后办部分一次插入</span></span><br><span class="line">        mid = self.findMid(head)</span><br><span class="line">        secondHead = self.reverse(mid.next)</span><br><span class="line">        mid.next = <span class="keyword">None</span><span class="comment">#把左位数为的next置为None，否则会报错</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">#前半部分比后半部分多1</span></span><br><span class="line">        <span class="keyword">while</span> secondHead:</span><br><span class="line">            tmp1 = head.next</span><br><span class="line">            tmp2 = secondHead.next</span><br><span class="line"></span><br><span class="line">            secondHead.next = tmp1</span><br><span class="line">            head.next = secondHead</span><br><span class="line"></span><br><span class="line">            head = tmp1</span><br><span class="line">            secondHead = tmp2  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverse</span><span class="params">(self,head)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        反转链表，将2-&gt;3-&gt;4变成4-&gt;3-&gt;2，并返回新的头结点4</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        pre,cur = <span class="keyword">None</span>,head</span><br><span class="line">        <span class="keyword">while</span> cur:</span><br><span class="line">            tmp = cur.next</span><br><span class="line">            cur.next = pre</span><br><span class="line">            pre = cur</span><br><span class="line">            cur = tmp</span><br><span class="line">        <span class="keyword">return</span> pre</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findMid</span><span class="params">(self,head)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        找左中位数，并返回</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        low,fast = head,head</span><br><span class="line">        <span class="keyword">while</span> fast.next <span class="keyword">and</span> fast.next.next:</span><br><span class="line">            low = low.next</span><br><span class="line">            fast = fast.next.next</span><br><span class="line">        <span class="keyword">return</span> low</span><br></pre></td></tr></table></figure><h1><span id="9-总结">9. 总结</span></h1><ol><li>使用快慢指针<br>链表中间节点，链表倒数K个元素，环形链表</li><li>添加新的头结点<br>当在链表中删除元素时，一般需要添加一个新的头节点，next指向原来的头结点，注意返回的时候返回原先的头结点，而不是新建的。</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;链表遍历数据时，需要从头遍历。链表只需要给出头指针就可以&lt;/p&gt;
    
    </summary>
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
      <category term="链表" scheme="http://yoursite.com/tags/%E9%93%BE%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode之排序</title>
    <link href="http://yoursite.com/2020/03/30/Leetcode%E4%B9%8B%E6%8E%92%E5%BA%8F/"/>
    <id>http://yoursite.com/2020/03/30/Leetcode之排序/</id>
    <published>2020-03-30T02:38:24.000Z</published>
    <updated>2020-07-15T01:54:39.414Z</updated>
    
    <content type="html"><![CDATA[<p>开始刷题了，首先整理并实现经典的排序算法并对其优化，使用Python实现。所有的排序默认从小到大排序</p><a id="more"></a><!-- TOC --><ul><li><a href="#1-术语说明">1. 术语说明</a></li><li><a href="#2-冒泡排序">2. 冒泡排序</a><ul><li><a href="#21-冒泡排序">2.1. 冒泡排序</a></li><li><a href="#22-优化1">2.2. 优化1</a></li><li><a href="#23-优化2">2.3. 优化2</a></li></ul></li><li><a href="#3-选择排序">3. 选择排序</a></li><li><a href="#4-插入排序">4. 插入排序</a></li><li><a href="#5-快速排序">5. 快速排序</a><ul><li><a href="#51-快速排序">5.1. 快速排序</a></li><li><a href="#52-优化1">5.2. 优化1</a></li><li><a href="#53-三路快排">5.3. 三路快排</a></li></ul></li><li><a href="#6-归并排序">6. 归并排序</a></li><li><a href="#7-堆排序">7. 堆排序</a><ul><li><a href="#71-堆排序">7.1. 堆排序</a></li><li><a href="#72-应用topk问题">7.2. 应用：topK问题</a></li></ul></li><li><a href="#8-nb三人组小结">8. NB三人组小结</a></li><li><a href="#9-希尔排序插入排序的改良版">9. 希尔排序(插入排序的改良版)</a></li><li><a href="#10-计数排序">10. 计数排序</a></li><li><a href="#11-桶排序">11. 桶排序</a></li><li><a href="#12-基数排序">12. 基数排序</a></li><li><a href="#13-leetcode题">13. LeetCode题</a><ul><li><a href="#131-合并两个有序数组">13.1. 合并两个有序数组</a></li><li><a href="#132-数组中的第k个最大元素">13.2. 数组中的第K个最大元素</a><ul><li><a href="#1321-总结">13.2.1. 总结</a></li></ul></li><li><a href="#133-前-k-个高频元素">13.3. 前 K 个高频元素</a></li><li><a href="#134-面试题39-数组中出现次数超过一半的数字">13.4. 面试题39. 数组中出现次数超过一半的数字</a></li><li><a href="#135-颜色分类">13.5. 颜色分类</a></li><li><a href="#136-两个数组的交集-ii">13.6. 两个数组的交集 II</a></li><li><a href="#137-摆动排序-ii">13.7. 摆动排序 II</a></li></ul></li><li><a href="#14-数据流的中位数">14. 数据流的中位数</a></li><li><a href="#15-总结">15. 总结</a></li></ul><!-- /TOC --><p>一共有10种排序算法，先给出排序算法的性能<br><img src="/2020/03/30/Leetcode之排序/conclusion.png" alt=""></p><ul><li>low B 三人组：冒泡，选择，插入</li><li>NB 三人组：快排，归并，堆排序</li><li>其他排序：计数排序，基数，希尔排序，桶排序</li></ul><h1><span id="1-术语说明">1. 术语说明</span></h1><ul><li>稳定：原始数据中a=b，并且a在b的前面，排序后a仍然在b的前面</li><li>不稳定：原始数据中a=b，并且a在b的前面，排序后a可能会出现在b的后面</li><li>内排序：所有排序操作都在内存中完成</li><li>外排序：由于数据太大，需要把数据放在磁盘中，而排序通过磁盘和内存的数据传输才能进行</li><li>比较排序：每个数必须和其他数进行比较，才能确定自己的位置。比较排序的优势：适用于各种规模的数据，不管数据分布什么样，都可以进行排序。可以说比较排序适用于一切需要排序的情况</li><li>非比较排序：通过确定每个元素之前，应该有多少元素来排序，针对arr[i]，计算arr[i]之前有多少个元素，则唯一确定了arr[i]在排序后数组中的位置，一次遍历即可解决，算法时间复杂度$O(N)$。非比较排序时间复杂度低，但由于需要占用空间来确定唯一位置，所以对数据规模和数据分布有一定要求</li></ul><p><strong>【交换函数】</strong><br>在比较排序中，需要用到交换函数，先在此定义下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">swap</span><span class="params">(nums,i,j)</span>:</span></span><br><span class="line">    tmp = nums[i]</span><br><span class="line">    nums[i] = nums[j]</span><br><span class="line">    nums[j] = tmp</span><br></pre></td></tr></table></figure><h1><span id="2-冒泡排序">2. 冒泡排序</span></h1><p>最简单的排序之一</p><h2><span id="21-冒泡排序">2.1. 冒泡排序</span></h2><p><strong>基本思想：</strong><br>每个数和它后面的数比较，小的数放在前面，大的数放在后面，最终越小的元素经过交换慢慢浮到数组的顶端，类似于水泡上升一样。<br><strong>步骤：</strong></p><ol><li>2重循环，第一次循环控制比较的次数，假设有n个数，第一次需要比较n-1次，选出n个数中最大的数；第二次需要比较n-2次，选出n-1个数中最大的数，…，剩下2个数，需要比较1次，选出最大的数</li><li>外层循环一共需要比较i=n-1,n-2,…1次，range(n-1,0,-1)</li><li>内存循环j=0,1,2,…i-1，range(0,i)</li><li>将数组分为有序和无序，每一次外循环，都将无序数组的最大值放在后面。首先整个数组都是无序的，经过一次外循环，有序数组个数加1，无序数组减1。然后再经过一次外循环，有序数组个数再加1，无序数组减1，直到所有数据全变成有序。</li></ol><p><img src="/2020/03/30/Leetcode之排序/bubble.gif" alt=""><br><strong>实现：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bubble_sort</span><span class="params">(nums)</span>:</span></span><br><span class="line">    n = len(nums)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(n<span class="number">-1</span>,<span class="number">0</span>,<span class="number">-1</span>):<span class="comment">#排序的趟数，一共n-1趟</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">0</span>,i):<span class="comment">#对0~i-1个数进行排序</span></span><br><span class="line">            <span class="comment">#每个数和后面比较，只有当前面数&gt;后面数才交换，相等不会交换，体现稳定性</span></span><br><span class="line">            <span class="keyword">if</span> nums[j] &gt; nums[j+<span class="number">1</span>]:</span><br><span class="line">                swap(nums,j,j+<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> nums</span><br></pre></td></tr></table></figure><ul><li>空间复杂性：$O(1)$</li><li>时间复杂性：$0(n^2)$</li><li>使用场景：适合小数据的排序，因为算法复杂度高，在数据量大不适用</li></ul><h2><span id="22-优化1">2.2. 优化1</span></h2><p>冒泡排序的关键是与后面的元素进行比较，然后交换，但是当我们发现某次排序过程中没有发生过交换行为，便可以认为，剩下的元素都是有序的，所以也不用比较了。例如：1,2,3,4,5，进行第一次排序时我们就发现后面的2大于1，3大于2…5大于4，此时便可以认为数据有序，不必再进行后面的排序和比较。<br>每次进入内部循环前，设置flag来标记前面0~i-1个数中是否发生交换，没有发生交换，说明前面的数已经是有序的，不用再排序了。<br>在数据完全有序的时候，最好时间复杂度$O(n)$,其他情况总是$O(n^2)$，因此算法在数据基本有序的情况下，性能最好。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bubble_sort1</span><span class="params">(nums)</span>:</span></span><br><span class="line">    n = len(nums)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(n<span class="number">-1</span>,<span class="number">0</span>,<span class="number">-1</span>):</span><br><span class="line">        flag = <span class="keyword">False</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">0</span>,i):</span><br><span class="line">            <span class="keyword">if</span> nums[j] &gt; nums[j+<span class="number">1</span>]:</span><br><span class="line">                swap(nums,j,j+<span class="number">1</span>)</span><br><span class="line">                flag = <span class="keyword">True</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> flag:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">return</span> nums</span><br></pre></td></tr></table></figure><h2><span id="23-优化2">2.3. 优化2</span></h2><p>在交换时，记录最后一次交换的位置，下次内循环时，只用遍历到这个位置就可以了，因为这个位置后的元素已经有序了</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bubble_sort2</span><span class="params">(nums)</span>:</span></span><br><span class="line">    n = len(nums)</span><br><span class="line">    k = n - <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(n<span class="number">-1</span>,<span class="number">0</span>,<span class="number">-1</span>):</span><br><span class="line">        flag = <span class="keyword">False</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">0</span>,k):</span><br><span class="line">            <span class="keyword">if</span> nums[j] &gt; nums[j+<span class="number">1</span>]:</span><br><span class="line">                swap(nums,j,j+<span class="number">1</span>)</span><br><span class="line">                flag = <span class="keyword">True</span></span><br><span class="line">                k = j</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> flag:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">return</span> nums</span><br></pre></td></tr></table></figure><h1><span id="3-选择排序">3. 选择排序</span></h1><p>表现最稳定的排序算法之一，无论什么数据，都是$O(n^2)$的时间复杂度，数据规模越小越好。<br>选择排序和冒泡排序的区别是：选择排序只有在确定了最小值的前提下，才进行交换，大大减少交换的次数。<br><strong>基本思想：</strong></p><ul><li>首先在未排序的数组中找到最小/大元素，放在数组的第一个位置，</li><li>然后再从剩下未排序数组中找最小/大元素，放在第二个位置</li><li>此次类推，直到所有的元素排序完成。</li></ul><p><img src="/2020/03/30/Leetcode之排序/select.gif" alt=""></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">select_sort</span><span class="params">(nums)</span>:</span></span><br><span class="line">    n = len(nums)</span><br><span class="line">    <span class="comment">#每一趟选出无序中最小的数</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">        min_idx = i</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(i+<span class="number">1</span>,n):</span><br><span class="line">            <span class="keyword">if</span> nums[j] &lt; nums[min_idx]:</span><br><span class="line">                min_idx = j</span><br><span class="line">        <span class="keyword">if</span> min_idx != i:<span class="comment">#下标不同才交换</span></span><br><span class="line">            swap(nums,i,min_idx)</span><br><span class="line">    <span class="keyword">return</span> nums</span><br></pre></td></tr></table></figure><ul><li>不稳定</li><li>在各种情况下，复杂度波动小，因此一般优于冒泡排序，在所有的完全交换排序中，选择排序是不错的算法</li><li>时间复杂度$O(n^2)$，使用于简单数据</li></ul><h1><span id="4-插入排序">4. 插入排序</span></h1><p><strong>基本思想：</strong><br>将数组分成2部分：有序数组和无序数组，给无序数组中的一个数，从后向前遍历有序数组，放在特定的位置上，然后再遍历下一个无序数据，再插入到有序数组中。</p><p><strong>步骤：</strong></p><ol><li>从第一个元素开始，该元素认为已经排好序</li><li>取下一个元素，在有序数组中从后向前扫描</li><li>如果该元素(已排序)大于新元素，将该元素(已排序)后移一位</li><li>重复步骤3，直到找到有序数组中 &lt;= 新元素</li><li>将新元素插入到该元素后面</li></ol><p><img src="/2020/03/30/Leetcode之排序/insert.gif" alt=""></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">insert_sort</span><span class="params">(nums)</span>:</span></span><br><span class="line">    n = len(nums)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,n):</span><br><span class="line">        <span class="comment">#只有当nums[i]&lt;有序数据时，才将有序数组中的元素后移</span></span><br><span class="line">        <span class="keyword">if</span> nums[i] &lt; nums[i<span class="number">-1</span>]:</span><br><span class="line">            tmp = nums[i]</span><br><span class="line">            insert_idx = i</span><br><span class="line">            <span class="comment">#遍历nums[i-1,...0]找出nums[i]插入位置</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(i<span class="number">-1</span>,<span class="number">-1</span>,<span class="number">-1</span>):</span><br><span class="line">                <span class="comment">#只有有序数据&gt;无序数据时，才将有序数据后移，</span></span><br><span class="line">                <span class="comment">#有序&lt;=无序，有序数组不用后移，所以插入排序是稳定的</span></span><br><span class="line">                <span class="keyword">if</span> nums[j] &gt; tmp:</span><br><span class="line">                    nums[j+<span class="number">1</span>] = nums[j]</span><br><span class="line">                    insert_idx = j</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">            nums[insert_idx] = tmp</span><br><span class="line">    <span class="keyword">return</span> nums</span><br></pre></td></tr></table></figure><ul><li>在有序数组中找到&lt;=无序数据，不交换位置，所以插入排序是稳定的</li><li>时间复杂度：$O(n^2)$，如果数据已经有序，那么比较次数为$O(n)$，不需要移动。</li><li>适用场景：在数组较大时不适用，但是在数据比较少时，一般作为快排的扩充，例如在JDK 7 java.util.Arrays所用的sort方法的实现中，当待排数组长度小于47时，会使用插入排序。</li></ul><h1><span id="5-快速排序">5. 快速排序</span></h1><h2><span id="51-快速排序">5.1. 快速排序</span></h2><p>在实际运用中冒泡排序很少使用，因为每次排序都要经过大量的交换，费时。快速排序通常比同为$nlog(n)$算法快，在实际应用中是表现最好的算法，因此常被采用，快排采用了分治思想。<br>快排虽然高端，但其思想来自于冒泡排序，冒泡排序通过相邻元素的比较和交换，把最小的元素冒泡在顶端，而快排是比较和交换大数和小数，不仅把小数冒泡到上面，同时把大数沉到下面。<br><strong>基本思想：</strong><br>找出一个基准，通过一趟排序，将待排序数据分割成独立的2部分，一部分基准大，一部分比基准小。快排使用分治法将一串分为2个子串</p><p><strong>步骤：</strong></p><ol><li>从数组中找出一个元素，作为基准（通常选择待排序数组中的第一个或最后一个元素）</li><li>在分区过程中，右指针找比基准小的，左指针找比基准大的，将这2个数交换，即比基准大的放在右边，小于或等于基准的放在左边</li><li>再对左右区间递归执行第二步，直到区间中只有一个数</li></ol><p>举例：5,4,1,8,10,7,9,2,4,3（刚开始）<br>基准值选：5</p><ul><li>首先lp指向5，rp指向3，这时右边的3比基准元素5小，说明该数需要交换。然后在左边找大于5的数，一直到lp指向8，交换8和3，变成[5,4,1,3,10,7,9,2,4,8]</li><li>此时rp指向8，lp指向3。然后rp左移在右边找小于5的数，rp指向4，左边lp指向10，交换4和10变成[5,4,1,3,4,7,9,2,10,8]</li><li>此时rp指向10，lp指向4，在右边找小于5的数，rp指向2，lp指向7，交换2和7，变成[5,4,1,3,4,2,9,7,10,8]</li><li>此时rp指向7，lp指向2，在右边找小于5的数，rp指向2，此时lp也指向2，2个指针相遇，rp==lp，跳出while循环</li><li>交换基准元素5和相遇位置的2，变成[2,4,1,3,4,5,9,7,10,8]，此时5左边的数全小于5，右边的数全大于5，然后递归对[2,4,1,3,4]和[9,7,10,8]进行排序</li></ul><p>注意以下几个点：</p><ul><li>右指针先扫描，首先这也不是绝对的，这取决于基准数的位置，因为在最后两个指针相遇的时候，要交换基准数到相遇的位置。一般选取第一个数作为基准数，那么就是在左边，所以最后相遇的数要和基准数交换，那么相遇的数一定要比基准数小。所以j指针先移动才能先找到比基准数小的数。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">quick_sort</span><span class="params">(nums)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> qsort(nums,<span class="number">0</span>,len(nums)<span class="number">-1</span>)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">qsort</span><span class="params">(nums,left,right)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> left &gt;= right:<span class="comment">#结束条件</span></span><br><span class="line">        <span class="keyword">return</span> nums</span><br><span class="line">    key = nums[left]<span class="comment">#最左边为基准数</span></span><br><span class="line">    lp = left <span class="comment">#左指针</span></span><br><span class="line">    rp = right <span class="comment">#右指针</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> lp &lt; rp:<span class="comment">#退出循环时，lp=rp</span></span><br><span class="line">        <span class="comment">#先移动右指针，直到右边的数&lt;key，说明这个数需要交换</span></span><br><span class="line">        <span class="keyword">while</span> lp &lt; rp <span class="keyword">and</span> nums[rp] &gt;= key:</span><br><span class="line">            rp -= <span class="number">1</span></span><br><span class="line">        <span class="comment">#再移动左指针，直到左边的数&gt;key，说明这个数需要交换</span></span><br><span class="line">        <span class="keyword">while</span> lp &lt; rp <span class="keyword">and</span> nums[lp] &lt;= key:</span><br><span class="line">            lp += <span class="number">1</span></span><br><span class="line">        swap(nums,lp,rp)</span><br><span class="line">    <span class="comment">#当lp==rp时跳出while循环，此时lp和rp指向的数&lt;key，交换相遇位置和基准数，此时key的位置就在lp上</span></span><br><span class="line">    swap(nums,left,lp)</span><br><span class="line">    <span class="comment">#此时lp==rp，此位置存储key，下面对key左和右递归排序</span></span><br><span class="line">    qsort(nums,left,lp<span class="number">-1</span>)</span><br><span class="line">    qsort(nums,rp+<span class="number">1</span>,right)</span><br><span class="line">    <span class="keyword">return</span> nums</span><br></pre></td></tr></table></figure><ul><li>快排不稳定</li><li>时间复杂度：$O(nlog(n))$</li><li>使用场景：在大多情况下都适用，尤其在数据量大时优越性更明显，但是在必要时，需要考虑下优化以提高在最坏情况下的性能</li></ul><h2><span id="52-优化1">5.2. 优化1</span></h2><p>时间复杂度：$O(nlog(n))$，但是当基准选择不当时，会变成$O(n^2)$。当基准恰好为当前序列中最小数，意味着每次排序时都是对1和n-1个数进行排序，则效率大大降低。</p><ul><li>假设数组[1,7,8,9,4,2,5,3]，当选择1作为基准时，右边没有比1小的，则需要比较n-1次，则对n个数排序需要$O(n^2)$。</li><li>当原始数组本身有序时</li></ul><p>优化快排的这种情况，主要有2个方法：</p><ul><li>随机选择基准数</li><li>三数中取中法（将序列中的第一个，中间那个，最后一个比较大小，选择中间的数作为基准数）</li></ul><p>下面针对随机选择基准数进行说明，每次快排使用随机数作为基准数，大大降低了基准数选择不当，以为数据本身有序的情况</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_rand</span><span class="params">(i,j)</span>:</span></span><br><span class="line">    <span class="comment">#产生[i,j]的随机整数</span></span><br><span class="line">    <span class="keyword">import</span> random</span><br><span class="line">    <span class="keyword">return</span> random.randint(i, j)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">quick_sort1</span><span class="params">(nums)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> qsort(nums,<span class="number">0</span>,len(nums)<span class="number">-1</span>)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">qsort1</span><span class="params">(nums,left,right)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> left &gt;= right:<span class="comment">#结束条件</span></span><br><span class="line">        <span class="keyword">return</span> nums</span><br><span class="line"></span><br><span class="line">    lp = left <span class="comment">#左指针</span></span><br><span class="line">    rp = right <span class="comment">#右指针</span></span><br><span class="line">    pos = get_rand(lp,rp)<span class="comment">#随机生成基准下标</span></span><br><span class="line">    swap(nums,lp,pos)</span><br><span class="line">    key = nums[lp]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> lp &lt; rp:</span><br><span class="line">        <span class="comment">#直到遇到右边的数&lt;key，说明这个数需要交换</span></span><br><span class="line">        <span class="keyword">while</span> lp &lt; rp <span class="keyword">and</span> nums[rp] &gt;= key:</span><br><span class="line">            rp -= <span class="number">1</span></span><br><span class="line">        <span class="comment">#直到遇到左边的数&gt;key，说明这个数需要交换</span></span><br><span class="line">        <span class="keyword">while</span> lp &lt; rp <span class="keyword">and</span> nums[lp] &lt;= key:</span><br><span class="line">            lp += <span class="number">1</span></span><br><span class="line">        swap(nums,lp,rp)</span><br><span class="line">    <span class="comment">#当lp==rp时跳出while循环，此时lp和rp指向的数&lt;key</span></span><br><span class="line">    swap(nums,left,lp)</span><br><span class="line">    <span class="comment">#此时lp==rp，此位置存储key，下面对key左和右递归排序</span></span><br><span class="line">    qsort1(nums,left,lp<span class="number">-1</span>)</span><br><span class="line">    qsort1(nums,rp+<span class="number">1</span>,right)</span><br><span class="line">    <span class="keyword">return</span> nums</span><br></pre></td></tr></table></figure><h2><span id="53-三路快排">5.3. 三路快排</span></h2><p>二路快排对nums中数据有很多相等的元素不友好，三路排序是将nums分为3部分，小于pivot，等于pivot，大于pivot。<br>Java中的快排使用的就是三路</p><p>分成3个区间</p><ul><li>[left,lt]小于v</li><li>[lt+1,i]等于v</li><li>[rt,right]大于v</li></ul><p>在刚开始怎么给lt、gt、i初始化？<br>刚开始初始化，就是让以上3个区间全为空。<br>即lt=left-1，rt=right+1，i=left<br><img src="/2020/03/30/Leetcode之排序/3-quick-sort1.png" alt=""></p><p>遍历每一个i，</p><ul><li>当nums[i]==v时，则nums[i]不需要移动，直接移动i，遍历下一个元素，i+=1</li><li>当nums[i]&lt;v时，需要归到小于v的左边行列中。即nums[i]和等于v的第一个元素交换，即nums[i]和nums[lt+1]交换，然后lt需要扩大一位，包住刚刚挪过来的那个小于v的数，lt+=1，i右移到下一个未遍历的元素i+=1</li><li>当nums[i]&gt;v时，需要归到大于v的右边行列中。即nums[i]和nums[gt-1]交换，然后gt需要左移一位，包住挪过来的这个数，然后被交换的这个值在i这个位置，因为这个数还没有被检测，所有i不需要右移，还是当前的位置。</li></ul><p><img src="/2020/03/30/Leetcode之排序/3-quick-sort2.png" alt=""></p><p>当指针i和gt相等时，说明的元素都被检测完毕，这时退出while循环。<br>然后再把nums[left]的v值放在正确的位置，使得左边都是小于v的，即将nums[lt]和nums[left]交换，这样v所在的位置就是lt。</p><ul><li>[left,lt-1]都是小于v的</li><li>[lt,gt-1]都是等于v的</li><li>[gt,right]都是大于v的</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_rand</span><span class="params">(i,j)</span>:</span></span><br><span class="line">    <span class="comment">#产生[i,j]的随机整数</span></span><br><span class="line">    <span class="keyword">import</span> random</span><br><span class="line">    <span class="keyword">return</span> random.randint(i, j)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">quick_sort1</span><span class="params">(nums)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> qsort(nums,<span class="number">0</span>,len(nums)<span class="number">-1</span>)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">qsort1</span><span class="params">(nums,left,right)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> left &gt;= right:<span class="comment">#结束条件</span></span><br><span class="line">        <span class="keyword">return</span> nums</span><br><span class="line">    </span><br><span class="line">    pos = get_rand(left,right)</span><br><span class="line">    swap(nums,left,pos)</span><br><span class="line">    key = nums[left]</span><br><span class="line">    lp = left<span class="number">-1</span></span><br><span class="line">    rp = right+<span class="number">1</span></span><br><span class="line">    i = left<span class="comment">#指向未被遍历的数</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> i &lt; rp:</span><br><span class="line">        <span class="comment">#当前值小于key</span></span><br><span class="line">        <span class="keyword">if</span> nums[i]&lt;key:</span><br><span class="line">            <span class="comment">#和等于key的元素互换，并且将lp加1，将刚刚那个元素合并到小于key的行列</span></span><br><span class="line">            swap(nums,i,lp+<span class="number">1</span>)</span><br><span class="line">            lp+=<span class="number">1</span></span><br><span class="line">            i+=<span class="number">1</span></span><br><span class="line">        <span class="keyword">elif</span> nums[i]&gt;key:</span><br><span class="line">            <span class="comment">#将nums[i]和rp的前一个元素互换</span></span><br><span class="line">            swap(nums,i,rp<span class="number">-1</span>)</span><br><span class="line">            rp-=<span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>: </span><br><span class="line">            i+=<span class="number">1</span></span><br><span class="line">    <span class="comment">#现在lp指向小于key的最后一个元素</span></span><br><span class="line">    <span class="comment">#i==rp，指向第一个大于key的元素</span></span><br><span class="line">    swap(nums,left,lp)</span><br><span class="line">    <span class="comment">#现在key的位置就是lp</span></span><br><span class="line">    <span class="comment">#[left....lp-1] &lt; key</span></span><br><span class="line">    <span class="comment">#[lp....rp-1] == key</span></span><br><span class="line">    <span class="comment">#[rp....right] &gt; key</span></span><br><span class="line"></span><br><span class="line">    qsort1(nums,left,lp<span class="number">-1</span>)</span><br><span class="line">    qsort1(nums,rp,right)</span><br><span class="line">    <span class="keyword">return</span> nums</span><br></pre></td></tr></table></figure><h1><span id="6-归并排序">6. 归并排序</span></h1><p>归并排序采用递归分治。和选择排序一样，归并排序的性能不受输入数据的影响，时间复杂度始终是$O(nlogn)$，代价是需要额外的内存空间<br><strong>基本思想：</strong><br>归并排序就是将待排序序列分为前后两个子序列，然后分别对两个子序列继续调用归并排序，待两个子序列都排完序后，再将两个子序列合并，又称为2-路归并，可见归并排序是一个递归的过程。<br><strong>步骤：</strong></p><ol><li>将长度为n的输入序列划分为2个长度为n/2的子序列</li><li>对这2个子序列分别采用归并排序</li><li>将2个排序好的子序列合并成一个最终的排序序列</li><li>合并2个有序数组时，比较2个数组最前面的数，谁小先取谁，然后相应的指针向后移一位，然后再比较，直到一个数组为空，最后把另一个数组的剩余部分复制过来即可</li></ol><p><img src="/2020/03/30/Leetcode之排序/merge.gif" alt=""></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">merge_sort</span><span class="params">(nums)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> len(nums) &lt;= <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> nums</span><br><span class="line">    mid = int(len(nums) / <span class="number">2</span>)</span><br><span class="line">    left = merge_sort(nums[:mid])</span><br><span class="line">    right = merge_sort(nums[mid:])</span><br><span class="line">    <span class="keyword">return</span> merge(left,right)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">merge</span><span class="params">(left,right)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    将2个有序数组合并成1个大的有序数据</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    lp,rp = <span class="number">0</span>,<span class="number">0</span></span><br><span class="line">    result = []</span><br><span class="line">    <span class="keyword">while</span> lp &lt; len(left) <span class="keyword">and</span> rp &lt; len(right):</span><br><span class="line">        <span class="keyword">if</span> left[lp] &lt; right[rp]:</span><br><span class="line">            result.append(left[lp])</span><br><span class="line">            lp += <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            result.append(right[rp])</span><br><span class="line">            rp += <span class="number">1</span></span><br><span class="line">    result += left[lp:]</span><br><span class="line">    result += right[rp:]</span><br><span class="line">    <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure><ul><li>稳定，因为我们在遇到相等的数据时必然是按顺序抄写到大数组中，没有改变顺序</li><li>时间复杂度：$O(nlogn)$</li><li>空间复杂度：$O(n)$</li><li>适用场景：在数据量比较大时表现出色，但是因为空间复杂度$O(n)$在数据量特别大时（如1千万）也不可以接受，因此使用归并排序时一定要注意。</li></ul><h1><span id="7-堆排序">7. 堆排序</span></h1><h2><span id="71-堆排序">7.1. 堆排序</span></h2><p>堆排序是借助二叉树来实现，如果升序排列使用最大堆（根节点最大），反之使用最小堆（根节点最小）。以下以最大堆为例。<br><strong>堆排序在topK问题中使用频繁</strong>。<br>二叉堆具有以下性质：</p><ol><li>父节点的值总是大于或等于(小于或等于)子节点</li><li>每个节点的左右子树都是一个二叉堆</li></ol><p>堆是一个特殊的完全二叉树，除了最底层之外，每一层都是满的，这使得堆可以利用数组来表示（普通的二叉树通常用链表表示，有left和right指针），如下所示，堆和数组的相互关系</p><p><img src="/2020/03/30/Leetcode之排序/heap-sort.png" alt=""></p><p>给定某个节点，它在数组中的下标i，可以计算出它的父节点，左/右子节点的下标：<br>父节点下标：floor((i-1)/2)<br>左子节点：2i+1<br>右子节点：2(i+1)=2i+2</p><p>在堆排序中，我们首先就是找最后一个非叶子节点，例如上面的树，最后一个非叶子节点是7，其实就是最后一个叶子节点1的父节点。已知最后一个叶子节点的下标是n-1，其父节点下标就是floor(n/2-1)</p><p><strong>基本思想：</strong><br>堆排序就是把最大堆的堆顶的最大数取出来，将剩下的堆继续调整为最大堆，再次将堆顶的最大数取出来，一直到只剩下一个节点结束。</p><p>对于堆排序我们只关心2个问题：</p><ol><li>给定一个无序数组，如何建立堆？</li><li>删除堆顶元素后，如何调整数组称为新队</li></ol><p>第一个问题，可以先使用数组来表示堆。下标为0~n-1，首先找到最后一个非叶子节点，下标为floor(n/2-1)，作为需要调整的堆的根节点，将其调整为最大堆，然后根节点向前移，再调整前一个堆，直到nums[0]作为根节点，调整为最大堆。这样，一个完整的最大堆就建立起来了。堆顶就是最大的元素</p><p>第二个问题，假设我们已经有一个现成的最大堆，现在删除根元素，但并没有移动别的元素，则根元素空了，其他元素还保留着堆的性质，可以把最后一个元素(代号A)移动到根元素的位置，则堆的性质被破坏，A小于其某个左右子节点，于是，我们可以把A和它的子节点调换位置，如果A大于所有的子节点，则堆调整结束，否则，重复上述过程，A元素在树形结构中不断下沉，直到合适的位置，数组重新恢复堆的性质，上述过程一般称为“筛选”，自上而下。</p><p><strong>步骤：</strong></p><ol><li>建立最大堆，题目给定一个无序的数组，将其构建成最大堆。首先找到最后一个非叶子节点，即下标为int(n/2-1)。然后使用<code>heap_shift</code>函数这个堆调整为最大堆，然后下标i向前移动1位，再把这个树调整为最大堆。当i=0时，说明到了最上面的根节点，将这个树调整为最大堆。整个原始数组就变成了最大堆的数组。这个由原始数组变成最大堆的过程是从下往上。先把下面的子树调整为最大堆，然后一步步向上调整。</li><li>挨个输出：将最后一个节点和堆顶交换，重新调整堆为最大堆</li></ol><p><img src="/2020/03/30/Leetcode之排序/heap.gif" alt=""></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">heap_sort</span><span class="params">(nums)</span>:</span></span><br><span class="line">    n = len(nums)</span><br><span class="line">    first = int(n/<span class="number">2</span><span class="number">-1</span>)<span class="comment">#找到最后一个非叶子节点下标</span></span><br><span class="line">    <span class="comment">#建立堆,从最后一个非叶子节点开始调整</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(first,<span class="number">-1</span>,<span class="number">-1</span>):</span><br><span class="line">        <span class="comment">#这里的high始终为n-1，high本身应该是以nums[i]为根节点的最后一个节点，</span></span><br><span class="line">        <span class="comment">#但是这个堆最后一个节点不好求，所以就直接用n-1作为high，对这个堆的调整没有任何影响，</span></span><br><span class="line">        <span class="comment">#high本身的作用是防止数组越界</span></span><br><span class="line">        heap_shift(nums,i,n<span class="number">-1</span>)</span><br><span class="line">    <span class="comment">#经过上面的代码，nums已经是最大堆。此时nums[0]就是堆顶，即最大的元素。</span></span><br><span class="line">    <span class="comment">#倒序遍历堆，将最后一个元素和堆顶交换位置，</span></span><br><span class="line">    <span class="comment">#首先i=n-1，和堆顶交换位置，即最大的元素放在n-1的位置，</span></span><br><span class="line">    <span class="comment">#这时nums[0:i-1]的位置就不一定是最大堆了，需要再次调整nums[0:i-1]为最大堆。</span></span><br><span class="line">    <span class="comment">#此时堆顶的元素就是第二大的元素。然后再次进入到for循环中，i=n-2，再将第二大的元素放在n-2的位置上。</span></span><br><span class="line">    <span class="comment">#这样一直交换位置，一直调整，最后nums就会变成从小到大排序的数组。</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(n<span class="number">-1</span>,<span class="number">-1</span>,<span class="number">-1</span>):</span><br><span class="line">        <span class="comment">#i始终是堆的最后一个元素，将堆顶的最大值放在数组的后面</span></span><br><span class="line">        swap(nums,<span class="number">0</span>,i)</span><br><span class="line">        heap_shift(nums,<span class="number">0</span>,i<span class="number">-1</span>)</span><br><span class="line">    <span class="keyword">return</span> nums</span><br><span class="line"></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">例如</span></span><br><span class="line"><span class="string">          i--&gt;   4    </span></span><br><span class="line"><span class="string">               /   \</span></span><br><span class="line"><span class="string">      j--&gt;  10      3</span></span><br><span class="line"><span class="string">           /  \    / </span></span><br><span class="line"><span class="string">          5    1  2</span></span><br><span class="line"><span class="string">nums=[4,10,3,5,1,2]，对这个数组进行调整为最大堆。</span></span><br><span class="line"><span class="string">当前low=0，因为4的2个子树已经是最大堆了。</span></span><br><span class="line"><span class="string">首先找到2个孩子中较大的那个节点，即10，然后和根节点交换，变成</span></span><br><span class="line"><span class="string">                 10</span></span><br><span class="line"><span class="string">               /   \</span></span><br><span class="line"><span class="string">    i--&gt;     4      3</span></span><br><span class="line"><span class="string">           /  \    / </span></span><br><span class="line"><span class="string"> j--&gt;     5    1  2</span></span><br><span class="line"><span class="string">这时候发现，4这个树仍然不是最大堆，所以还需要继续调整。此时i指向下一层，即i=j，j指向左孩子，j=2*i+1，然后再交换孩子和根节点，变成下面这种</span></span><br><span class="line"><span class="string">                 10</span></span><br><span class="line"><span class="string">               /   \</span></span><br><span class="line"><span class="string">             5      3</span></span><br><span class="line"><span class="string">           /  \    / </span></span><br><span class="line"><span class="string">    i--&gt;  4    1  2</span></span><br><span class="line"><span class="string">    j--&gt;</span></span><br><span class="line"><span class="string">此时i指向最后一层，j已经大于high了，就退出while循环，此时输入的nums已经完全转换成最大堆了。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">heap_shift</span><span class="params">(nums,low,high)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    对某个子树进行调整，使其变成最大堆。这个子树的左右子树已经是最大堆。</span></span><br><span class="line"><span class="string">    其中被调整的数在nums中起始位置为low，</span></span><br><span class="line"><span class="string">    终止位置为high，即[low,high]</span></span><br><span class="line"><span class="string">    即调整以low为根节点的那棵树</span></span><br><span class="line"><span class="string">    nums:待调整的nums</span></span><br><span class="line"><span class="string">    low:堆的第一个元素</span></span><br><span class="line"><span class="string">    high:堆的最后一个元素</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    i = low<span class="comment">#堆顶</span></span><br><span class="line">    j = <span class="number">2</span>*i+<span class="number">1</span><span class="comment">#左孩子</span></span><br><span class="line">    tmp = nums[low]<span class="comment">#当前堆顶</span></span><br><span class="line">    <span class="keyword">while</span> j &lt;= high:</span><br><span class="line">        <span class="comment">#找出左右孩子中较大的那个元素</span></span><br><span class="line">        <span class="comment">#j为左孩子，j+1为右孩子</span></span><br><span class="line">        <span class="keyword">if</span> j+<span class="number">1</span>&lt;=high <span class="keyword">and</span> nums[j+<span class="number">1</span>]&gt;nums[j]:</span><br><span class="line">            j += <span class="number">1</span><span class="comment">#j指向右孩子</span></span><br><span class="line">        <span class="keyword">if</span> nums[j] &gt; tmp:<span class="comment">#孩子&gt;父节点</span></span><br><span class="line">            nums[i] = nums[j]<span class="comment">#将孩子放在根节点</span></span><br><span class="line">            i = j<span class="comment">#向下移动一层</span></span><br><span class="line">            j = <span class="number">2</span>*i+<span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:<span class="comment">#tmp比2个孩子都大,因为孩子已经是最大堆</span></span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    nums[i] = tmp</span><br></pre></td></tr></table></figure><ul><li>时间复杂度：$O(nlog(n))$</li></ul><h2><span id="72-应用topk问题">7.2. 应用：topK问题</span></h2><p>堆排序通常用来解决topK问题：有n个数，得到前k大的数</p><p>解决思路：</p><ul><li>排序后切片：$O(nlog(n))$</li><li>排序Low B三人组：$O(kn)$</li><li>堆排序：$O(nlog(k))$</li></ul><p>下面介绍使用堆排序</p><ul><li>取列表前k个元素建立一个最小堆，堆中只有k个元素，堆顶是最小的元素，下面的值都大于或等于堆顶。遍历完整个数组后，下面的值肯定是最大值，倒数第2大的值，…，堆顶就是倒数第k大的值。首先取列表前k个元素建立一个最小堆</li><li>然后再看剩下的n-k个数，如果这个数比堆顶小，则堆顶保持不变，如果这个数比堆顶大，用这个数把堆顶换掉，然后再调整一下这个堆把它变成最小堆</li><li>然后再看后面的数，如果这个数比堆顶小，则堆顶保持不变，如果这个数比堆顶大，用这个数把堆顶换掉，然后再调整一下这个堆把它变成最小堆</li><li>重复以上步骤，直到列表遍历完，则这k个数组成的最小堆就是前k个最大的数</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">heap_shift</span><span class="params">(nums,low,high)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    调整为最小堆</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    i = low<span class="comment">#堆顶</span></span><br><span class="line">    j = <span class="number">2</span>*i+<span class="number">1</span><span class="comment">#左孩子</span></span><br><span class="line">    tmp = nums[low]</span><br><span class="line">    <span class="keyword">while</span> j &lt;= high:</span><br><span class="line">        <span class="keyword">if</span> j+<span class="number">1</span>&lt;=high <span class="keyword">and</span> nums[j+<span class="number">1</span>]&lt;nums[j]:</span><br><span class="line">            j += <span class="number">1</span><span class="comment">#j指向右孩子</span></span><br><span class="line">        <span class="keyword">if</span> nums[j] &lt; tmp:</span><br><span class="line">            nums[i] = nums[j]</span><br><span class="line">            i = j</span><br><span class="line">            j = <span class="number">2</span>*i+<span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    nums[i] = tmp</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">topk</span><span class="params">(nums,k)</span>:</span></span><br><span class="line">    n = len(nums)</span><br><span class="line">    heap = nums[:k]<span class="comment">#先使用nums中的前k个元素构建小顶堆</span></span><br><span class="line">    first = int(k/<span class="number">2</span><span class="number">-1</span>)</span><br><span class="line">    <span class="comment">#将前k个元素建立堆</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(first,<span class="number">-1</span>,<span class="number">-1</span>):</span><br><span class="line">        heap_shift(heap,i,k<span class="number">-1</span>)</span><br><span class="line">    <span class="comment">#遍历nums中剩下的元素，加入到最小堆中</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(k,n<span class="number">-1</span>):</span><br><span class="line">        <span class="keyword">if</span> nums[i] &gt; heap[<span class="number">0</span>]:<span class="comment">#当前值比堆顶大，替换堆顶，然后调整堆</span></span><br><span class="line">            heap[<span class="number">0</span>] = nums[i]</span><br><span class="line">            heap_shift(heap,<span class="number">0</span>,k<span class="number">-1</span>)</span><br><span class="line">    <span class="comment">#现在最小堆中已经是前k大的数，只不过是从小到大排序</span></span><br><span class="line">    <span class="comment">#但是返回的数是从大到小</span></span><br><span class="line">    <span class="keyword">return</span> heap[::<span class="number">-1</span>]</span><br></pre></td></tr></table></figure><h1><span id="8-nb三人组小结">8. NB三人组小结</span></h1><ul><li>三种排序时间复杂度都是$O(nlog(n))$</li><li>一般情况下，运行时间：<ul><li>快排 &lt; 归并 &lt; 堆排序</li></ul></li><li>三种排序的缺点：<ul><li>快排：极端情况下效率低</li><li>归并排序：需要额外的内存开销</li><li>堆排序：在快的排序算法中相对较慢</li></ul></li></ul><h1><span id="9-希尔排序插入排序的改良版">9. 希尔排序(插入排序的改良版)</span></h1><p>与插入排序的不同在于：它会优先比较距离较远的元素，又叫做“缩小增量排序”<br><strong>基本思想：</strong><br>将记录按照一定的增量分组，对每组使用插入排序进行排序，随着增量的变小，每组包含的数字越来越多，当增量变成1时，所有的数字恰好被分为1组，算法终止。<br>在此我们选择增量gap=length/2，缩小增量继续以gap = gap/2的方式，这种增量选择我们可以用一个序列来表示，{n/2,(n/2)/2…1}，称为增量序列。希尔排序的增量序列的选择与证明是个数学难题，我们选择的这个增量序列是比较常用的，也是希尔建议的增量，称为希尔增量，但其实这个增量序列不是最优的。此处我们做示例使用希尔增量。<br><strong>步骤：</strong></p><ol><li>选择一个增量序列${t_1,t_2,…1}$</li><li>先选第一个增量$t_1$，将数据划分为$t_1$组，对每组进行插入排序</li><li>再选择增量$t_2$，将数据划分为$t_2$组，对每组进行插入排序</li><li>直到增量为1</li></ol><p><strong>【注意】</strong> 增量序列最后一个必须为1</p><p><img src="/2020/03/30/Leetcode之排序/shell.png" alt=""></p><p>当gap=2时，数组为[3,5,1,6,0,8,9,4,7,2],其中[3,1,0,9,7]为一组，[5,6,8,4,2]为一组，for循环i分为等于2,3,4,…9</p><ul><li>当i=2时，对第一个子数组排序，即当前待插入的值是1,和3比较，放在3前面，顺序变成[1,3,0,9,7]</li><li>当i=3时，对第二个子数组排序，当前待插入的值是6，大于5，顺序不变，依旧为[5,6,8,4,2]</li><li>当i=4时，对第一个子数组排序，当前待插入的值是0，前面已经排好序的是[1,3],分别和1,3比较，只要比0大，顺序就往后移，顺序变为[0,1,3,9,7]</li><li>当i=5时，对第二个子数组排序，待插入的值为8，前面已经排好序的是[5,6],和5,6比较，顺序不变，依旧为[5,6,8]</li><li>……</li></ul><p>由上可以看出，给定一个待排序的数字，和同组的数进行比较，然后交换，待排序的数字不是一步一步向前挪，而是跳跃式地往前挪。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">shell_sort</span><span class="params">(nums)</span>:</span></span><br><span class="line">    n = len(nums)</span><br><span class="line">    gap = round(n/<span class="number">2</span>)</span><br><span class="line">    <span class="keyword">while</span> gap &gt; <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(gap,n):</span><br><span class="line">            tmp = nums[i]</span><br><span class="line">            j = i</span><br><span class="line">            <span class="keyword">while</span>(j &gt;= gap <span class="keyword">and</span> nums[j-gap] &gt; tmp):</span><br><span class="line">                nums[j] = nums[j-gap]</span><br><span class="line">                j -= gap</span><br><span class="line">            nums[j] = tmp</span><br><span class="line">        gap = round(gap/<span class="number">2</span>)</span><br><span class="line">    <span class="keyword">return</span> nums</span><br></pre></td></tr></table></figure><ul><li>时间复杂度：很难分析，因为比较次数和移动次数和增量序列有关</li><li>空间复杂度：$O(1)$</li></ul><h1><span id="10-计数排序">10. 计数排序</span></h1><p>计数排序的核心在于将输入的数据值转化为键存储在额外开辟的数组空间中。 作为一种线性时间复杂度的排序，<strong>计数排序要求输入的数据必须是有确定范围的整数</strong>。</p><p>计数排序(Counting sort)是一种稳定的排序算法。计数排序使用一个额外的数组C，其中第i个元素是待排序数组A中值等于i的元素的个数。然后根据数组C来将A中的元素排到正确的位置。它只能对整数进行排序。</p><p><img src="/2020/03/30/Leetcode之排序/count.gif" alt=""></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">count_sort</span><span class="params">(nums)</span>:</span></span><br><span class="line">    max_value = max(nums)</span><br><span class="line">    count = [<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> range(max_value+<span class="number">1</span>)]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> nums:</span><br><span class="line">        count[i]+=<span class="number">1</span></span><br><span class="line">    nums.clear()</span><br><span class="line">    <span class="keyword">for</span> idx,value <span class="keyword">in</span> enumerate(count):</span><br><span class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> range(value):</span><br><span class="line">            nums.append(idx)</span><br><span class="line">    <span class="keyword">return</span> nums</span><br></pre></td></tr></table></figure><p>当输入的元素是n个0到k之间的整数时，它的运行时间是 O(n + k)。计数排序不是比较排序，排序的速度快于任何比较排序算法。由于用来计数的数组C的长度取决于待排序数组中数据的范围（等于待排序数组的最大值与最小值的差加上1），这使得计数排序对于数据范围很大的数组，需要大量时间和内存。</p><h1><span id="11-桶排序">11. 桶排序</span></h1><p>桶排序是计数排序的升级版。它利用了函数的映射关系，高效与否的关键就在于这个映射函数的确定。<br>桶排序 (Bucket sort)的工作的原理：假设输入数据服从均匀分布，将数据分到有限数量的桶里，每个桶再分别排序.</p><p><img src="/2020/03/30/Leetcode之排序/bucket.jpg" alt=""></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bucket_sort</span><span class="params">(nums,bucker_nums)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    nums:待排序数组</span></span><br><span class="line"><span class="string">    bucker_nums:一共有多少个桶</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="comment">#创建桶</span></span><br><span class="line">    min_value = min(nums)</span><br><span class="line">    max_value = max(nums)</span><br><span class="line">    buckets = [[] <span class="keyword">for</span> _ <span class="keyword">in</span> range(bucker_nums)]</span><br><span class="line">    <span class="comment">#每个桶放多少个数</span></span><br><span class="line">    bucker_size = int((max_value-min_value)/bucker_nums+<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> nums:</span><br><span class="line">        <span class="comment">#判断i放在哪个桶里</span></span><br><span class="line">        cur_id = int((i - <span class="number">1</span>) / bucker_size)</span><br><span class="line">        buckets[cur_id].append(i)</span><br><span class="line">        <span class="comment">#使用插入方法排序</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(len(buckets[cur_id])<span class="number">-1</span>,<span class="number">0</span>,<span class="number">-1</span>):</span><br><span class="line">            <span class="comment">#如果当前的值 &lt; 桶中的元素，和大的值交换</span></span><br><span class="line">            <span class="keyword">if</span> buckets[cur_id][j] &lt; buckets[cur_id][j<span class="number">-1</span>]:</span><br><span class="line">                swap(buckets[cur_id],j,j<span class="number">-1</span>)</span><br><span class="line">            <span class="comment">#当前值 &gt;= 桶中的元素，不用交换</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">    sorted_nums = []</span><br><span class="line">    <span class="comment">#每个桶已经排好序，遍历每个桶，放在sorted_nums中</span></span><br><span class="line">    <span class="keyword">for</span> bucket <span class="keyword">in</span> buckets:</span><br><span class="line">        sorted_nums.extend(bucket)</span><br><span class="line">    <span class="keyword">return</span> sorted_nums</span><br></pre></td></tr></table></figure><ul><li>桶排序的表现取决于数据的分布，也就是需要对不同数据排序时采取不同的分桶策略</li><li>空间复杂度：平均$O(nk)$，最坏$O(n^2k)$</li><li>时间复杂度：$O(n+k)$</li></ul><h1><span id="12-基数排序">12. 基数排序</span></h1><p>基数排序是按照低位先排序，然后收集，再按照高位排序，然后再收集，依次类推，直到最高位。</p><p><img src="/2020/03/30/Leetcode之排序/radix.gif" alt=""></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">radix_sort</span><span class="params">(nums)</span>:</span></span><br><span class="line">    max_value = max(nums)</span><br><span class="line">    max_digit = len(str(max_value))<span class="comment">#最大数的位数</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(max_digit):</span><br><span class="line">        buckets = [[] <span class="keyword">for</span> _ <span class="keyword">in</span> range(<span class="number">10</span>)]</span><br><span class="line">        <span class="comment">#假设最大数为786，i = 0,1,2</span></span><br><span class="line">        <span class="keyword">for</span> val <span class="keyword">in</span> nums:</span><br><span class="line">            <span class="comment">#取出个位数，十位数，百位数</span></span><br><span class="line">            <span class="comment">#958,</span></span><br><span class="line">            <span class="comment">#i = 0,8=958//1 %10,</span></span><br><span class="line">            <span class="comment">#i = 1,5=958//10 %10</span></span><br><span class="line">            <span class="comment">#i = 2,9=958//100 %10</span></span><br><span class="line">            digit = (val // <span class="number">10</span>**i) % <span class="number">10</span></span><br><span class="line">            buckets[digit].append(val)</span><br><span class="line">        <span class="comment">#分桶完成，再放回到nums中</span></span><br><span class="line">        nums.clear()</span><br><span class="line">        <span class="keyword">for</span> bucket <span class="keyword">in</span> buckets:</span><br><span class="line">            nums.extend(bucket)</span><br><span class="line">    <span class="keyword">return</span> nums</span><br></pre></td></tr></table></figure><ul><li>时间复杂度：$O(nk)$,k是最大数的位数</li><li>空间复杂度：$O(k+n)$</li></ul><h1><span id="13-leetcode题">13. LeetCode题</span></h1><h2><span id="131-合并两个有序数组">13.1. 合并两个有序数组</span></h2><p>给你两个有序整数数组 nums1 和 nums2，请你将 nums2 合并到 nums1 中，使 num1 成为一个有序数组。</p><p>说明:<br>初始化 nums1 和 nums2 的元素数量分别为 m 和 n 。<br>你可以假设 nums1 有足够的空间（空间大小大于或等于 m + n）来保存 nums2 中的元素。</p><p>合并2个有序数组是归并排序的子过程。</p><p><strong>【解法1】</strong><br>开辟一个新的数据nums3，将nums1和nums2排序到nums3中</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">merge</span><span class="params">(self, nums1, m, nums2, n)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums1: List[int]</span></span><br><span class="line"><span class="string">        :type m: int</span></span><br><span class="line"><span class="string">        :type nums2: List[int]</span></span><br><span class="line"><span class="string">        :type n: int</span></span><br><span class="line"><span class="string">        :rtype: None Do not return anything, modify nums1 in-place instead.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        nums3 = []</span><br><span class="line">        p1=<span class="number">0</span></span><br><span class="line">        p2=<span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> p1 &lt; m <span class="keyword">and</span> p2 &lt; n:</span><br><span class="line">            <span class="keyword">if</span> nums1[p1] &lt; nums2[p2]:</span><br><span class="line">                nums3.append(nums1[p1])</span><br><span class="line">                p1+=<span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                nums3.append(nums2[p2])</span><br><span class="line">                p2+=<span class="number">1</span></span><br><span class="line"></span><br><span class="line">        nums3 += nums1[p1:m]</span><br><span class="line">        nums3 += nums2[p2:n]</span><br><span class="line">        nums1[:]=nums3[:]</span><br><span class="line">        <span class="keyword">return</span> nums1</span><br></pre></td></tr></table></figure><p><strong>【解法2】</strong><br>题目中说nums1中的空间大小为m+n，就是说我们可以不用新的数组nums3，使用nums1就可以了。从后往前遍历，哪个数大就存到nums1的后面，直到有个数组遍历完。如果遍历完的数组是nums2，这是nums1已经是有序了，直接返回即可。如果nums1遍历完了，就要把nums2未遍历的数都复制到nums1中</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">merge</span><span class="params">(self, nums1, m, nums2, n)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums1: List[int]</span></span><br><span class="line"><span class="string">        :type m: int</span></span><br><span class="line"><span class="string">        :type nums2: List[int]</span></span><br><span class="line"><span class="string">        :type n: int</span></span><br><span class="line"><span class="string">        :rtype: None Do not return anything, modify nums1 in-place instead.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> m==<span class="number">0</span>:</span><br><span class="line">            nums1[:]=nums2[:]</span><br><span class="line">            <span class="keyword">return</span> nums1</span><br><span class="line">        cur_idx=m+n<span class="number">-1</span></span><br><span class="line">        p1 = m<span class="number">-1</span></span><br><span class="line">        p2 = n<span class="number">-1</span></span><br><span class="line">        <span class="keyword">while</span> p1&gt;=<span class="number">0</span> <span class="keyword">and</span> p2&gt;=<span class="number">0</span>:</span><br><span class="line">            <span class="keyword">if</span> nums1[p1]&gt;nums2[p2]:</span><br><span class="line">                nums1[cur_idx]=nums1[p1]</span><br><span class="line">                cur_idx -=<span class="number">1</span></span><br><span class="line">                p1-=<span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                nums1[cur_idx]=nums2[p2]</span><br><span class="line">                cur_idx-=<span class="number">1</span></span><br><span class="line">                p2-=<span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> p2 &lt; <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> nums1</span><br><span class="line">        <span class="keyword">if</span> p1 &lt; <span class="number">0</span>:</span><br><span class="line">            nums1[:cur_idx+<span class="number">1</span>] = nums2[:p2+<span class="number">1</span>]</span><br><span class="line">            <span class="keyword">return</span> nums1</span><br></pre></td></tr></table></figure><h2><span id="132-数组中的第k个最大元素">13.2. 数组中的第K个最大元素</span></h2><p>在未排序的数组中找到第 k 个最大的元素。请注意，你需要找的是数组排序后的第 k 个最大的元素，而不是第 k 个不同的元素。</p><p>示例 1:</p><p>输入: [3,2,1,5,6,4] 和 k = 2<br>输出: 5<br>示例 2:</p><p>输入: [3,2,3,1,2,4,5,5,6] 和 k = 4<br>输出: 4</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/kth-largest-element-in-an-array" target="_blank" rel="noopener">https://leetcode-cn.com/problems/kth-largest-element-in-an-array</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p><p><strong>【解法1】</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findKthLargest</span><span class="params">(self, nums, k)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :type k: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="comment">#对nums进行排序，从大到小，第4个元素</span></span><br><span class="line">        nums.sort(reverse=<span class="keyword">True</span>)</span><br><span class="line">        <span class="keyword">return</span> nums[k<span class="number">-1</span>]</span><br></pre></td></tr></table></figure><ul><li>时间复杂度：$O(nlogn)$</li><li>空间复杂度：O(1)</li></ul><p><strong>【解法2】</strong><br>使用小顶堆，堆中只有k个元素，小顶堆的堆顶是k个元素中的最小值，下面的值都比它大，即堆顶就是第k大的数</p><ul><li>时间复杂度：O(nlogk)，调整堆的时间复杂度为O(logk)，遍历整个数组一共有n个元素。</li><li>空间复杂度：O(k)</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findKthLargest</span><span class="params">(self, nums, k)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :type k: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        n = len(nums)</span><br><span class="line">        heap=nums[:k]<span class="comment">#前k个元素</span></span><br><span class="line">        first=int(k/<span class="number">2</span><span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(first,<span class="number">-1</span>,<span class="number">-1</span>):</span><br><span class="line">            self.heap_shift(heap,i,k<span class="number">-1</span>)</span><br><span class="line">        <span class="comment">#遍历k之后的所有元素</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(k,n):</span><br><span class="line">            <span class="keyword">if</span> nums[i]&gt;heap[<span class="number">0</span>]:</span><br><span class="line">                heap[<span class="number">0</span>]=nums[i]</span><br><span class="line">                self.heap_shift(heap,<span class="number">0</span>,k<span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">return</span> heap[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">heap_shift</span><span class="params">(self,nums,low,high)</span>:</span></span><br><span class="line">        <span class="comment">#只进行调整,把最小的数调整到上面</span></span><br><span class="line">        <span class="comment">#时间复杂度：O(logk)</span></span><br><span class="line">        tmp = nums[low]</span><br><span class="line">        i= low</span><br><span class="line">        j = <span class="number">2</span>*i+<span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> j &lt;= high:</span><br><span class="line">            <span class="keyword">if</span> j+<span class="number">1</span>&lt;=high <span class="keyword">and</span> nums[j+<span class="number">1</span>]&lt;nums[j]:</span><br><span class="line">                j+=<span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> nums[j]&lt;tmp:</span><br><span class="line">                nums[i]=nums[j]</span><br><span class="line">                i=j</span><br><span class="line">                j=<span class="number">2</span>*i+<span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        nums[i]=tmp</span><br></pre></td></tr></table></figure><p><strong>【解法3】</strong><br>第k大的元素，假设对nums按照从小到大排序，第k大的元素的下标为n-k<br>[1,2,2,3,5,6,6]，n=7，第2大的元素下标为5，第3大的元素下标为4。<br>即给定nums，我们要找的就是对nums从小到大排序后，下标为n-k的元素就是第k大的元素。</p><p>使用快速排序，快速排序是先给定一个pivot，然后将这个pivot放在nums中正确的位置，所谓正确的位置就是：左边的元素都小于pivot，右边的元素都大于等于pivot。经过一次排序，将pivot放在下标为i的位置，判断下标i和n-k的关系，如果i等于n-k，则返回。如果i小于n-k,说明第k大的元素在pivot的右边，更新left=i+1，否则更新right=i-1</p><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(1)，但是这种解法修改了原始数组，如果题目要求不能修改原始数组，这种方法不适用</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findKthLargest</span><span class="params">(self, nums, k)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :type k: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        n = len(nums)</span><br><span class="line">        left=<span class="number">0</span></span><br><span class="line">        right=n<span class="number">-1</span></span><br><span class="line">        target=n-k<span class="comment">#需要寻找元素的下标</span></span><br><span class="line">        <span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">            idx = self.quick_sort(nums,left,right)</span><br><span class="line">            <span class="keyword">if</span> idx==target:</span><br><span class="line">                <span class="keyword">return</span> nums[target]</span><br><span class="line">            <span class="keyword">if</span> idx &lt; target:<span class="comment">#说明target在右边</span></span><br><span class="line">                left=idx+<span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:<span class="comment">#说明target在左边</span></span><br><span class="line">                right=idx<span class="number">-1</span></span><br><span class="line">        <span class="keyword">return</span> nums[left]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">quick_sort</span><span class="params">(self,nums,left,right)</span>:</span></span><br><span class="line">        <span class="comment">#在nums中找一个pivot，使得左边都小于pivot，右边都大于等于pivot</span></span><br><span class="line">        <span class="comment">#返回pivot的位置下标</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">#随机选择一个数作为pivot</span></span><br><span class="line">        <span class="keyword">import</span> random</span><br><span class="line">        random_index = random.randint(left, right)</span><br><span class="line">        nums[random_index], nums[left] = nums[left], nums[random_index]</span><br><span class="line">        pivot = nums[left]</span><br><span class="line">        lp = left</span><br><span class="line">        rp = right</span><br><span class="line">        <span class="keyword">while</span> lp&lt;rp:</span><br><span class="line">            <span class="keyword">while</span> lp &lt; rp <span class="keyword">and</span> nums[rp]&gt;=pivot:</span><br><span class="line">                rp-=<span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> lp &lt; rp <span class="keyword">and</span> nums[lp]&lt;=pivot:</span><br><span class="line">                lp+=<span class="number">1</span></span><br><span class="line">            nums[lp],nums[rp] = nums[rp],nums[lp]</span><br><span class="line">        <span class="comment">#跳出循环时，lp==rp，指向的元素小于pivot</span></span><br><span class="line">        nums[left],nums[lp]=nums[lp],nums[left]</span><br><span class="line">        <span class="keyword">return</span> lp</span><br></pre></td></tr></table></figure><p><strong>【扩展】</strong></p><p>返回最大的k个数，<br>例如[1,2,3],k=2,则输出[3,2]<br>[1,1,1],k=2,则输出[1,1]</p><p>使用快速排序，第k个最大的数下标为n-k，使用快速排序，当返回的值为n-k时，说明找到第k个最大的数，且这个数的右边全是需要找的值，则返回的是一个数组。如果返回的值比n-k小，说明需要找的n-k在右边，更新left，否则更新right。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getLeastNumbers</span><span class="params">(self, arr, k)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type arr: List[int]</span></span><br><span class="line"><span class="string">        :type k: int</span></span><br><span class="line"><span class="string">        :rtype: List[int]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> k==<span class="number">0</span>:<span class="keyword">return</span> []</span><br><span class="line">        <span class="keyword">if</span> k&gt;=len(arr):<span class="keyword">return</span> arr</span><br><span class="line"></span><br><span class="line">        left = <span class="number">0</span></span><br><span class="line">        right = len(arr)<span class="number">-1</span></span><br><span class="line">        target = n-k<span class="comment">#先找到最大的第k个数</span></span><br><span class="line">        <span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">            idx = self.quick_sort(arr,left,right)</span><br><span class="line">            <span class="keyword">if</span> idx == target:<span class="comment">#说明左侧的数都比target小</span></span><br><span class="line">                <span class="keyword">return</span> arr[target:]</span><br><span class="line">            <span class="keyword">elif</span> idx &lt; target:</span><br><span class="line">                left = idx+<span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                right = idx<span class="number">-1</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">quick_sort</span><span class="params">(self,nums,left,right)</span>:</span></span><br><span class="line">        <span class="keyword">import</span> random</span><br><span class="line">        idx = random.randint(left,right)</span><br><span class="line">        nums[left],nums[idx] = nums[idx],nums[left]</span><br><span class="line">        pivot = nums[left]</span><br><span class="line">        lp,rp = left,right</span><br><span class="line">        <span class="keyword">while</span> lp &lt; rp:</span><br><span class="line">            <span class="keyword">while</span> lp&lt;rp <span class="keyword">and</span> nums[rp]&gt;=pivot:</span><br><span class="line">                rp-=<span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> lp&lt;rp <span class="keyword">and</span> nums[lp]&lt;=pivot:</span><br><span class="line">                lp+=<span class="number">1</span></span><br><span class="line">            nums[lp],nums[rp]=nums[rp],nums[lp]</span><br><span class="line">        nums[left],nums[lp] = nums[lp],nums[left]</span><br><span class="line">        <span class="keyword">return</span> lp</span><br></pre></td></tr></table></figure><h3><span id="1321-总结">13.2.1. 总结</span></h3><p>解决topK问题最常用的方法有2种</p><ol><li>使用快速排序，分治思想</li><li>使用最大(小)堆</li></ol><p><img src="/2020/03/30/Leetcode之排序/topk.png" alt=""></p><p>这2种方法各有优缺点，适用于不同的场合。做题之前，需要明确以下几个要求</p><ul><li>输入的数据量有多大，堆适用于海量数据</li><li>能否一次性载入内存</li><li>是否可以修改原数组</li></ul><h2><span id="133-前-k-个高频元素">13.3. 前 K 个高频元素</span></h2><p>给定一个非空的整数数组，返回其中出现频率前 k 高的元素。</p><p>示例 1:</p><p>输入: nums = [1,1,1,2,2,3], k = 2<br>输出: [1,2]</p><p><strong>【我的解法】</strong><br>使用字典保存每个元素和其出现的次数，</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">topKFrequent</span><span class="params">(self, nums, k)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :type k: int</span></span><br><span class="line"><span class="string">        :rtype: List[int]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        count_dict = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> nums:</span><br><span class="line">            <span class="keyword">if</span> i <span class="keyword">not</span> <span class="keyword">in</span> count_dict:</span><br><span class="line">                count_dict[i]=<span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                count_dict[i]+=<span class="number">1</span></span><br><span class="line">        <span class="comment">#对count_dict进行排序</span></span><br><span class="line">        count_dict=sorted(count_dict.items(),key=<span class="keyword">lambda</span> x:x[<span class="number">1</span>],reverse=<span class="keyword">True</span>)</span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">for</span> value,count <span class="keyword">in</span> count_dict[:k]:</span><br><span class="line">            res.append(value)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><p><strong>【解法2】</strong><br>使用大顶堆。首先使用字典count_dict记录每个数字及出现的次数，然后构造堆，堆中的值也可以是元组，(freq,value)分别是出现的次数和数字。然后使用nlargest从中取出前k的的值，取出的值也是(freq,value)的元组形式，最后返回所有的value值 </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="keyword">import</span> heapq</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">topKFrequent</span><span class="params">(self, nums, k)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :type k: int</span></span><br><span class="line"><span class="string">        :rtype: List[int]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        count_dict = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> nums:</span><br><span class="line">            <span class="keyword">if</span> i <span class="keyword">not</span> <span class="keyword">in</span> count_dict:</span><br><span class="line">                count_dict[i]=<span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                count_dict[i]+=<span class="number">1</span></span><br><span class="line">        h = []</span><br><span class="line">        <span class="keyword">for</span> value,freq <span class="keyword">in</span> count_dict.items():</span><br><span class="line">            <span class="comment">#heapq插入的值可以是元组，按照元组的第一个元素排序</span></span><br><span class="line">            heapq.heappush(h, (freq, value))</span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">for</span> freq,value <span class="keyword">in</span> heapq.nlargest(k, h):</span><br><span class="line">            res.append(value)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h2><span id="134-面试题39-数组中出现次数超过一半的数字">13.4. 面试题39. 数组中出现次数超过一半的数字</span></h2><p>数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。</p><p>你可以假设数组是非空的，并且给定的数组总是存在多数元素。</p><p>示例 1:</p><p>输入: [1, 2, 3, 2, 2, 2, 5, 4, 2]<br>输出: 2</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/shu-zu-zhong-chu-xian-ci-shu-chao-guo-yi-ban-de-shu-zi-lcof" target="_blank" rel="noopener">https://leetcode-cn.com/problems/shu-zu-zhong-chu-xian-ci-shu-chao-guo-yi-ban-de-shu-zi-lcof</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p><p><strong>【解法1】</strong><br>使用count存储数字及出现的频率，因为题目中说肯定存储多数元素，所以直接返回出现次数最多的数字。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">majorityElement</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="comment">#用count记录每个数出现的次数</span></span><br><span class="line">        count=&#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> nums:</span><br><span class="line">            <span class="keyword">if</span> i <span class="keyword">not</span> <span class="keyword">in</span> count:</span><br><span class="line">                count[i]=<span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                count[i]+=<span class="number">1</span></span><br><span class="line">            </span><br><span class="line">        count=sorted(count.items(),key=<span class="keyword">lambda</span> x:x[<span class="number">1</span>],reverse=<span class="keyword">True</span>)</span><br><span class="line">        print(count)</span><br><span class="line">        <span class="keyword">return</span> count[<span class="number">0</span>][<span class="number">0</span>]</span><br></pre></td></tr></table></figure><p><strong>【解法2】</strong><br>将nums进行排序，多数元素肯定出现在中位数的位置</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">majorityElement</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        n=len(nums)</span><br><span class="line">        nums.sort()</span><br><span class="line">        <span class="keyword">return</span> nums[n/<span class="number">2</span>]</span><br></pre></td></tr></table></figure><p><strong>【解法3】</strong><br>使用摩尔投票，首先记nums[0]为众数，如果vote=0，则将当前值i设置为众数，然后再遍历下一个数，如果下一个数等于候选众数，vote则加1，否则减1.最终的vote肯定大于0，而mode也就是最终的众数。<br>超过一半的众数，和任何数抵消，最终的vote都&gt;0</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">majorityElement</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        vote=<span class="number">0</span></span><br><span class="line">        mode=nums[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> nums:</span><br><span class="line">            <span class="keyword">if</span> vote==<span class="number">0</span>:</span><br><span class="line">                mode=i</span><br><span class="line">            <span class="keyword">if</span> mode==i:</span><br><span class="line">                vote+=<span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                vote-=<span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> mode</span><br></pre></td></tr></table></figure><h2><span id="135-颜色分类">13.5. 颜色分类</span></h2><p>给定一个包含红色、白色和蓝色，一共 n 个元素的数组，原地对它们进行排序，使得相同颜色的元素相邻，并按照红色、白色、蓝色顺序排列。</p><p>此题中，我们使用整数 0、 1 和 2 分别表示红色、白色和蓝色。</p><p>注意:<br>不能使用代码库中的排序函数来解决这道题。</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/sort-colors" target="_blank" rel="noopener">https://leetcode-cn.com/problems/sort-colors</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p><blockquote><p>输入: [2,0,2,1,1,0]<br>输出: [0,0,1,1,2,2]</p></blockquote><p><strong>【我的解法】</strong><br>参考三路快排，这里比三路快排要简单，因为这里只有3个数，将pivot选为1，将小于1的放在左边，等于1的放在中间，大于1的放在右边。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sortColors</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: None Do not return anything, modify nums in-place instead.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        n = len(nums)</span><br><span class="line">        <span class="keyword">if</span> n &lt; <span class="number">2</span>:</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        lp = <span class="number">-1</span> </span><br><span class="line">        rp = n</span><br><span class="line">        i = <span class="number">0</span> <span class="comment">#指向未被遍历的数</span></span><br><span class="line">        <span class="keyword">while</span> i &lt; rp:</span><br><span class="line">            <span class="keyword">if</span> nums[i]&lt;<span class="number">1</span>:</span><br><span class="line">                self.swap(nums,i,lp+<span class="number">1</span>)</span><br><span class="line">                lp+=<span class="number">1</span></span><br><span class="line">                i+=<span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> nums[i]&gt;<span class="number">1</span>:</span><br><span class="line">                self.swap(nums,i,rp<span class="number">-1</span>)</span><br><span class="line">                rp-=<span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>: </span><br><span class="line">                i+=<span class="number">1</span></span><br><span class="line">        print(nums)  </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">swap</span><span class="params">(self,nums,i,j)</span>:</span></span><br><span class="line">        tmp=nums[i]</span><br><span class="line">        nums[i]=nums[j]</span><br><span class="line">        nums[j]=tmp</span><br></pre></td></tr></table></figure><h2><span id="136-两个数组的交集-ii">13.6. 两个数组的交集 II</span></h2><p>给定两个数组，编写一个函数来计算它们的交集。</p><p>示例 1:</p><p>输入: nums1 = [1,2,2,1], nums2 = [2,2]<br>输出: [2,2]</p><p>【我的解法】<br>首先将nums1中的值和出现的次数存储在count字典中，然后遍历nums2，从中找出交集。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">intersect</span><span class="params">(self, nums1, nums2)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums1: List[int]</span></span><br><span class="line"><span class="string">        :type nums2: List[int]</span></span><br><span class="line"><span class="string">        :rtype: List[int]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        count = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> nums1:</span><br><span class="line">            <span class="keyword">if</span> i <span class="keyword">not</span> <span class="keyword">in</span> count:</span><br><span class="line">                count[i]=<span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                count[i]+=<span class="number">1</span></span><br><span class="line">        res=[]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> nums2:</span><br><span class="line">            <span class="keyword">if</span> i <span class="keyword">in</span> count <span class="keyword">and</span> count[i]&gt;<span class="number">0</span>:</span><br><span class="line">                res.append(i)</span><br><span class="line">                count[i]-=<span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><p><strong>【解法2】</strong><br>使用双指针，如果2个元素相等,将相等元素加入到res中，然后将2个元素同时向前移一位,如果2个元素不等，将小的元素指针向前移一位。<br>还可以对这个算法改进一下，这里我们使用额外数据res保存最终的结果，其实可以不用额外空间，我们在nums1[p1]==nums2[p2]时，将相同的元素放在nums1[k]中，然后k+=1，因为nums1前面的元素已经遍历过了，就没用了，可以覆盖。返回nums1[:k]</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">intersect</span><span class="params">(self, nums1, nums2)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums1: List[int]</span></span><br><span class="line"><span class="string">        :type nums2: List[int]</span></span><br><span class="line"><span class="string">        :rtype: List[int]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="comment">#分别对nums1和nums2排序</span></span><br><span class="line">        nums1.sort()</span><br><span class="line">        nums2.sort()</span><br><span class="line">        p1=<span class="number">0</span></span><br><span class="line">        p2=<span class="number">0</span></span><br><span class="line">        res=[]</span><br><span class="line">        <span class="keyword">while</span> p1&lt;len(nums1) <span class="keyword">and</span> p2&lt;len(nums2):</span><br><span class="line">            print(p1,p2)</span><br><span class="line">            <span class="keyword">if</span> nums1[p1] == nums2[p2]:</span><br><span class="line">                res.append(nums1[p1])</span><br><span class="line">                p1+=<span class="number">1</span></span><br><span class="line">                p2+=<span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> nums1[p1]&lt;nums2[p2]:</span><br><span class="line">                p1+=<span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                p2+=<span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h2><span id="137-摆动排序-ii">13.7. 摆动排序 II</span></h2><p>给定一个无序的数组 nums，将它重新排列成 nums[0] &lt; nums[1] &gt; nums[2] &lt; nums[3]… 的顺序。</p><p>示例 1:</p><p>输入: nums = [1, 5, 1, 1, 6, 4]<br>输出: 一个可能的答案是 [1, 4, 1, 5, 1, 6]</p><p>说明:<br>你可以假设所有输入都会得到有效的结果。</p><p>进阶:<br>你能用 O(n) 时间复杂度和 / 或原地 O(1) 额外空间来实现吗？</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/wiggle-sort-ii" target="_blank" rel="noopener">https://leetcode-cn.com/problems/wiggle-sort-ii</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wiggleSort</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: None Do not return anything, modify nums in-place instead.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="comment">#先找到nums的中位数，即下标为</span></span><br><span class="line">        n = len(nums)</span><br><span class="line">        left,right=<span class="number">0</span>,n<span class="number">-1</span></span><br><span class="line">        mid_idx=(left+right)//<span class="number">2</span></span><br><span class="line">        nums.sort()</span><br><span class="line">        mid=nums[mid_idx]<span class="comment">#中位数</span></span><br><span class="line">        <span class="comment"># 交叉合并，划分为2部分[0...mid_idx],[]</span></span><br><span class="line">        small,big ,_nums = mid_idx,n<span class="number">-1</span>,nums[:]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">            <span class="keyword">if</span> i%<span class="number">2</span> == <span class="number">0</span>:</span><br><span class="line">                nums[i] = _nums[small]</span><br><span class="line">                small -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:<span class="comment">#big</span></span><br><span class="line">                nums[i] = _nums[big]</span><br><span class="line">                big -= <span class="number">1</span></span><br></pre></td></tr></table></figure><p><strong>【解法2】</strong></p><ul><li>先寻找nums中的中位数，即寻找第k大的数，k=n/2，</li><li>找到中位数后，然后对nums进行三路快排，小于mid放在左边，大于mid放在右边</li><li>然后把nums划分为small和big列表，倒序排列</li></ul><h1><span id="14-数据流的中位数">14. 数据流的中位数</span></h1><p>中位数是有序列表中间的数。如果列表长度是偶数，中位数则是中间两个数的平均值。</p><p>例如，</p><p>[2,3,4] 的中位数是 3</p><p>[2,3] 的中位数是 (2 + 3) / 2 = 2.5</p><p>设计一个支持以下两种操作的数据结构：</p><p>void addNum(int num) - 从数据流中添加一个整数到数据结构中。<br>double findMedian() - 返回目前所有元素的中位数。</p><p>链接：<a href="https://leetcode-cn.com/problems/find-median-from-data-stream" target="_blank" rel="noopener">https://leetcode-cn.com/problems/find-median-from-data-stream</a></p><p><strong>【分析一】</strong></p><p>我们只关心中位数，其他的数没必要有序。可以利用大顶堆和小顶堆，每次从堆中取出最值，其他元素无序排序。这样就可以在O(logN)复杂度从堆中取出最值。</p><p><img src="/2020/03/30/Leetcode之排序/heap.png" alt=""></p><p>当读入的数据为奇数个时，中位数在前面的有序数组。当读入的数据为偶数个时，中位数在前有序数组的最后一个和后有序数组的第一个。因为需要找出中位数，即从前有序数组中找出最大的，在后有序数组中找出最小的。因为前有序数据用大顶堆存储，后有序数组用小顶堆存储。</p><ul><li>大顶堆：存储前有序数组，个数&gt;=小顶堆</li><li><p>小顶堆：存储后有序数组，个数&lt;=大顶堆<br>当2个堆中个数为偶数时，2个堆中个数平分<br>当2个堆中个数为奇数时，大顶堆的个数比小顶堆个数多1<br>因此不管当前堆中个数为奇数还是偶数，当进来一个数时，都要先进入到大顶堆中，才能保证大顶堆个数&gt;=小顶堆个数。</p></li><li><p>当进来一个数后，堆中总数为偶数，比如原先大顶堆中为[3,4,7,9],小顶堆中为[11,13,16],进来一个数为8，说明进来的数本来需要进入到小顶堆中,才能使大小顶堆个数相等。但是这个数不能直接进入到小顶堆中，需要进行以下操作：先把这个数放入大顶堆中，大顶堆变成[3,4,7,8,9],在大顶堆中找出最大的数，然后把这个数给小顶堆,大顶堆变成[3,4,7,8],小顶堆变成[9,11,13,16],这样才能保证大顶堆和小顶堆个数相等。</p></li><li>当进来一个数后，堆中总数为奇数，比如原先大顶堆中为[3,4,7,9],小顶堆中为[11,13,16,17],进来一个数为20，先把这个数放入大顶堆中，大顶堆变成[3,4,7,9,20],此时大顶堆的最大值比小顶堆大，需要把20交换到小顶堆中，把20这个数给小顶堆,大顶堆变成[3,4,7,9],小顶堆变成[11,13,16,17,20]，但是此时小顶堆的个数又比大顶堆多1个，这是不允许的，所以需要把对顶堆的数移到大顶堆中，大顶堆变成[3,4,7,9,11]，小顶堆变成[13,16,17,20]，这样才正确。</li><li>总结如下：当堆中总数为偶数时，数据流向为：大顶堆—&gt;小顶堆。当堆中总数为奇数时，数据流向为：大顶堆—&gt;小顶堆—&gt;大顶堆。2者的共同之处都是大顶堆—&gt;小顶堆。所以进来一个数，先进大顶堆，然后再从大顶堆中弹出最大值到小顶堆。然后判断堆中总数为奇数还是偶数，如果为奇数，再从小顶堆中弹出最小值到大顶堆中。</li></ul><p>python中自带的堆是小顶堆，在push时根据item的第一个元素进行比较大小，将item小的元素放在栈顶。为了让小顶堆实现大顶堆(将最大值放在栈顶)的功能，item的第一个元素为其相反数，即最大值的相反数最小，按照相反数进行排序，这样最大数就放在了栈顶。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MedianFinder</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="comment"># 当前大顶堆和小顶堆的元素个数之和</span></span><br><span class="line">        self.count = <span class="number">0</span></span><br><span class="line">        self.max_heap = []</span><br><span class="line">        self.min_heap = []</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">addNum</span><span class="params">(self, num: int)</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        self.count += <span class="number">1</span></span><br><span class="line">        <span class="comment"># 因为 Python 中的堆默认是小顶堆，所以要传入一个 tuple，用于比较的元素需是相反数，</span></span><br><span class="line">        <span class="comment"># 才能模拟出大顶堆的效果</span></span><br><span class="line">        heapq.heappush(self.max_heap, -num)</span><br><span class="line">        max_heap_top = heapq.heappop(self.max_heap)</span><br><span class="line">        heapq.heappush(self.min_heap, -max_heap_top)</span><br><span class="line">        <span class="keyword">if</span> self.count &amp; <span class="number">1</span>:</span><br><span class="line">            min_heap_top = heapq.heappop(self.min_heap)</span><br><span class="line">            heapq.heappush(self.max_heap, -min_heap_top)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findMedian</span><span class="params">(self)</span> -&gt; float:</span></span><br><span class="line">        <span class="keyword">if</span> self.count &amp; <span class="number">1</span>:</span><br><span class="line">            <span class="comment"># 如果两个堆合起来的元素个数是奇数，数据流的中位数大顶堆的堆顶元素</span></span><br><span class="line">            <span class="keyword">return</span> -self.max_heap[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment"># 如果两个堆合起来的元素个数是偶数，数据流的中位数就是各自堆顶元素的平均值</span></span><br><span class="line">            <span class="keyword">return</span> (self.min_heap[<span class="number">0</span>] - self.max_heap[<span class="number">0</span>]) / <span class="number">2</span></span><br></pre></td></tr></table></figure><h1><span id="15-总结">15. 总结</span></h1><ol><li>选数组中的第k大或第k小的元素，使用堆排序或快速排序<ul><li>堆排序：使用小顶堆(第k大)和大顶堆(第k小)</li><li>快速排序：因为每一轮快速排序，都会确定pivot的位置，比较pivot的位置是否等于k或n-k，然后调整left或right的位置。</li></ul></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;开始刷题了，首先整理并实现经典的排序算法并对其优化，使用Python实现。所有的排序默认从小到大排序&lt;/p&gt;
    
    </summary>
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
      <category term="排序" scheme="http://yoursite.com/tags/%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>图神经网络研讨会</title>
    <link href="http://yoursite.com/2020/03/29/%E5%9B%BE%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E7%A0%94%E8%AE%A8%E4%BC%9A/"/>
    <id>http://yoursite.com/2020/03/29/图神经网络研讨会/</id>
    <published>2020-03-29T05:40:52.000Z</published>
    <updated>2020-03-31T15:15:44.158Z</updated>
    
    <content type="html"><![CDATA[<p>在线图神经网络研讨会<br><a id="more"></a><br><img src="/2020/03/29/图神经网络研讨会/intro.png" alt=""></p><h1><span id="网络表示学习">网络表示学习</span></h1><ul><li>网络表示的关键问题：<br>如何定义图中节点的相似性</li></ul><h1><span id="图神经网络及认知推理">图神经网络及认知推理</span></h1><p><strong>网络上的学习任务：</strong></p><ul><li>节点分类：给定一个点，预测其类别</li><li>链接预测：给2个点，预测这2个点是否相连</li><li>community detection：找子图</li><li>网络相似度：2个网络或子网络的相似度</li></ul><h2><span id="回顾网络表示学习">回顾网络表示学习</span></h2><p>给定一个网络，学习节点的低维表示，如果2个节点距离很近，那这2个节点的表示也要相似。<br><strong>挑战：</strong></p><ol><li>CNN只适用于网格(二维)，但是网络是一个拓扑机构</li><li>RNN适用于文本/序列，这种都有先后关系，但是网络没有先后关系</li><li>网络是动态的，节点有属性，并且网络还有结构属性</li></ol><p><strong>网络表示学习发展：</strong></p><ol><li>使用word2vec来做网络表示学习，即DeepWalk</li><li>根据DeepWalk进行扩展：<ul><li>LINE：一阶和二阶相似性</li><li>PTE：异构网络</li><li>Node2vec：biased random walk</li></ul></li></ol><p><strong>网络表示学习的本质：</strong><br>都是在做矩阵分解，SVD分解，只是分解的形式不一样。<br>图表示学习结合的是context信息，用上下文信息来做网络表示学习。</p><p><img src="/2020/03/29/图神经网络研讨会/1.png" alt=""></p><p><strong>问题：</strong></p><h2><span id="gnn">GNN</span></h2><p><img src="/2020/03/29/图神经网络研讨会/2.png" alt=""></p><p><img src="/2020/03/29/图神经网络研讨会/3.png" alt=""></p><h2><span id="异质图">异质图</span></h2><p>同质网络：网络中只有一种类型的节点或边<br>异质网络：网络中有多类节点或边</p><p>首先分解出网络中的对象，以及对象之间的关系。<br>例如：作者-论文-会议，一个网络中有3类节点。<br>其中对象之间的关系（Meta path）有：</p><ul><li>作者1-论文-作者2（2个作者共同合作一篇论文）</li><li>作者1-论文-引用论文1，作者1写论文，引用了其他论文</li><li>……</li></ul><h3><span id="模型">模型</span></h3><ol><li>Metapath2Vec<br>基于meta path的随机游走，</li><li>HERec<br>解决异质图中节点的表示，将异质图变成同质图，在同质图中用DeepWalk或LINE学习节点表示</li><li>HIN2Vec<br>随机游走抽取出点边序列</li><li>MCRec</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在线图神经网络研讨会&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Deep Learning" scheme="http://yoursite.com/categories/Deep-Learning/"/>
    
    
      <category term="Graph" scheme="http://yoursite.com/tags/Graph/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode之二分法</title>
    <link href="http://yoursite.com/2020/03/27/Leetcode%E4%B9%8B%E4%BA%8C%E5%88%86%E6%B3%95/"/>
    <id>http://yoursite.com/2020/03/27/Leetcode之二分法/</id>
    <published>2020-03-27T14:34:31.000Z</published>
    <updated>2020-07-13T04:26:45.224Z</updated>
    
    <content type="html"><![CDATA[<p>列表查找：从列表中查找指定元素</p><ul><li>输出：列表</li><li>输出：元素下标，找不到返回None或-1</li></ul><a id="more"></a><!-- TOC --><ul><li><a href="#1-顺序查找">1. 顺序查找</a></li><li><a href="#2-二分查找">2. 二分查找</a><ul><li><a href="#21-二分查找拓展问题">2.1. 二分查找拓展问题</a></li></ul></li><li><a href="#3-leetcode例题">3. LeetCode例题</a><ul><li><a href="#31-查找target的索引">3.1. 查找target的索引</a><ul><li><a href="#311-二分查找">3.1.1. 二分查找</a></li><li><a href="#312-搜索旋转排序数组">3.1.2. 搜索旋转排序数组</a></li><li><a href="#313-搜索旋转排序数组-ii">3.1.3. 搜索旋转排序数组 II</a></li><li><a href="#314-寻找旋转排序数组中的最小值">3.1.4. 寻找旋转排序数组中的最小值</a></li><li><a href="#315-寻找旋转排序数组中的最小值-ii">3.1.5. 寻找旋转排序数组中的最小值 II</a></li><li><a href="#316-h指数-ii">3.1.6. H指数 II</a></li><li><a href="#317-最长上升子序列">3.1.7. 最长上升子序列</a></li><li><a href="#318-山脉数组中查找目标值">3.1.8. 山脉数组中查找目标值</a></li><li><a href="#319-寻找两个有序数组的中位数">3.1.9. 寻找两个有序数组的中位数</a></li></ul></li><li><a href="#32-在一个有上下界的区间中搜索一个整数">3.2. 在一个有上下界的区间中搜索一个整数</a><ul><li><a href="#321-x-的平方根">3.2.1. x 的平方根</a></li><li><a href="#322-寻找重复数">3.2.2. 寻找重复数</a></li></ul></li><li><a href="#33-判断条件是一个函数">3.3. 判断条件是一个函数</a><ul><li><a href="#331-第一个错误的版本">3.3.1. 第一个错误的版本</a></li><li><a href="#332-分割数组的最大值">3.3.2. 分割数组的最大值</a></li><li><a href="#333-爱吃香蕉的珂珂">3.3.3. 爱吃香蕉的珂珂</a></li><li><a href="#334-找到-k-个最接近的元素">3.3.4. 找到 K 个最接近的元素</a></li><li><a href="#335-转变数组后最接近目标值的数组和">3.3.5. 转变数组后最接近目标值的数组和</a></li></ul></li></ul></li><li><a href="#排序矩阵查找">排序矩阵查找</a></li><li><a href="#4-总结">4. 总结</a></li></ul><!-- /TOC --><p>python中内置列表查找函数：index(),用的是线性查找，因为二分查找要求列表是有序的。</p><h1><span id="1-顺序查找">1. 顺序查找</span></h1><p>也叫做线性查找，从一个元素开始，依次遍历，直到找到指定元素或到最后一个元素</p><ul><li>时间复杂度：$O(n)$</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">linear_search</span><span class="params">(nums,val)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> idx,v <span class="keyword">in</span> enumerate(nums):</span><br><span class="line">        <span class="keyword">if</span> v == val:</span><br><span class="line">            <span class="keyword">return</span> idx</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span></span><br></pre></td></tr></table></figure><h1><span id="2-二分查找">2. 二分查找</span></h1><p>从有序列表中，比较列表中间的数和val比较，然后向左或向右查找。<br>对于有序数组或者部分有序数组，基本都是使用二分法</p><ul><li>时间复杂度：$O(logn)$</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">binary_search</span><span class="params">(nums,val)</span>:</span></span><br><span class="line">    left = <span class="number">0</span></span><br><span class="line">    right = len(nums)<span class="number">-1</span></span><br><span class="line">    <span class="keyword">while</span> left &lt;= right:<span class="comment">#说明候选区有值</span></span><br><span class="line">        mid = (left+right)//<span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> nums[mid] == val:</span><br><span class="line">            <span class="keyword">return</span> mid</span><br><span class="line">        <span class="keyword">elif</span> nums[mid] &gt; val:</span><br><span class="line">            right = mid - <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            left = mid + <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span></span><br></pre></td></tr></table></figure><p>参考资料</p><p><a href="https://www.liwei.party/2019/06/19/leetcode-solution-new/search-insert-position/" target="_blank" rel="noopener">特别好用的二分查找法模板（Python 代码、Java 代码）</a></p><p><a href="https://leetcode-cn.com/problems/search-insert-position/solution/te-bie-hao-yong-de-er-fen-cha-fa-fa-mo-ban-python-/" target="_blank" rel="noopener">二分查找模板</a></p><p><a href="https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/solution/er-fen-cha-zhao-suan-fa-xi-jie-xiang-jie-by-labula/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/solution/er-fen-cha-zhao-suan-fa-xi-jie-xiang-jie-by-labula/</a><br>用<strong>排除法</strong>来写二分查找，将nums分为2个区间</p><ul><li>循环继续的条件是<code>while (left &lt; right):</code>，这样写的好处是：退出循环时，一定是<code>left=right</code>,不用纠结返回是left还是right。退出训练后可能还需要对<code>nums[left]</code>和<code>target</code>做一下判断。</li><li><p>在写if和else语句是，使用排除法，在if语句中写当nums[mid]满足什么性质时，nums[mid]肯定不是目标元素，则真正的目标元素肯定在mid的左边或右边，分别在if和else中更新left或right。根据以下2种情况，考虑怎么更新left和right</p><ul><li>如果mid分到左区间，则更新left=mid+1，更新right=mid</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (check(mid)) &#123;</span><br><span class="line">  <span class="comment">#下一轮搜索区间是 [mid + 1, right]，因此把左边界设置到 mid + 1 位置</span></span><br><span class="line">      left = mid + <span class="number">1</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="comment">#上面对了以后，不加思考，剩下的区间一定是 [left, mid]，因此左边界向右收缩到 mid 位置</span></span><br><span class="line">      right = mid;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>如果mid分到右区间，则更新left=mid，更新right=mid-1</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (check(mid)) &#123;</span><br><span class="line">    right = mid - <span class="number">1</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    left = mid;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p><strong>【注意】</strong><code>check(mid)</code>通常是一个表达式，但在一些复杂情况下，需要单独写成一个函数</p><ul><li><p>更新mid（重难点）</p><ul><li><code>mid = (left+mid)//2</code>,最常用，但是在left和right较大时，会发生整形溢出</li><li><code>mid = left+(right-left)//2</code>,推荐写法</li><li><code>/</code>是整除，如果是小数，向下取整，当left和rigth相邻时，即rigth-left=1时，使用mid = left+(right-left)//2，得到的mid始终等于left，永远取不到right，可能会出现死循环。<br>例如nums=[1,2]，target=2，刚开始left=0，right=1，mid=0，<code>if(nums[mid]&lt;target)</code>，说明target在mid后面，更新left=mid，此时left还是等于0，然后就出现死循环，left一直都是0。</li><li><p>解决死循环的方案是：将mid划分到左边区间中，在更新时left=mid+1，right=mid，就不会出现left一直等于mid死循环。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(left &lt; right):</span><br><span class="line">    mid = left+(right-left)//<span class="number">2</span></span><br><span class="line">    <span class="keyword">if</span>(nums[mid] &lt; target):</span><br><span class="line">        left=mid+<span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        right=mid</span><br></pre></td></tr></table></figure><p>或者将mid划分到右区间，这时出现left=mid，将mid的取值从左中位数，改为右中位数，即<code>mid = left+(right-left+1)/2</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(left &lt; right):</span><br><span class="line">    mid = left+(right-left+<span class="number">1</span>)//<span class="number">2</span></span><br><span class="line">    <span class="keyword">if</span>(nums[mid] &lt; target):</span><br><span class="line">        left=mid</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        right=mid<span class="number">-1</span></span><br></pre></td></tr></table></figure><p><strong>记住if else代码只要出现<code>left=mid</code>时，就需要改成<code>mid=left+(right-left+1)/2</code></strong></p></li></ul></li><li><p>退出while时，一定是left=right，需要判断下<code>if(nums[left])==target</code>。</p><ul><li>如果题目中说了target一定存在于nums中，则不必执行上述操作，因为在while中已经把不是target的元素排除了，退出while时的left==right，一定是target元素，直接返回left就行。</li><li>如果题目中没有说target一定存在于nums，即要找的target在nums中可能不存在，我们需要执行<code>if(nums[left]==target)</code>，如果满足返回left，不满足说明target在nums中不存在，返回-1</li></ul></li></ul><p><strong>【总结】</strong></p><ul><li>如果把mid分到左区间，<code>mid=left+(right-left)//2</code></li><li>如果把mid分到右区间，<code>mid=left+(right-left+1)//2</code></li><li>在nums中找第一个出现target的下标，需要把mid分到左边，不符合条件写成<code>if nums[mid] &lt; target</code></li><li>在nums中找最后一个出现target的下标，需要把mid分到右边，不符合条件写成<code>if nums[mid] &gt; target</code></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#在有序nums中找第一个出现target的下标</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">find_first</span><span class="params">(nums,target)</span>:</span></span><br><span class="line">    left = <span class="number">0</span></span><br><span class="line">    right = len(nums)<span class="number">-1</span></span><br><span class="line">    <span class="keyword">while</span> left &lt; right:</span><br><span class="line">        mid = left+(right-left)//<span class="number">2</span><span class="comment">#取左中位数</span></span><br><span class="line">        <span class="comment">#小于target肯定不是解</span></span><br><span class="line">        <span class="keyword">if</span> nums[mid] &lt; target:</span><br><span class="line">            <span class="comment">#下一轮搜索空间为[mid+1,right]</span></span><br><span class="line">            left = mid+<span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            right = mid</span><br><span class="line">    <span class="keyword">if</span> nums[left] == target:</span><br><span class="line">        <span class="keyword">return</span> left</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#在有序nums中找最后一个出现target的下标</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">find_last</span><span class="params">(nums,target)</span>:</span></span><br><span class="line">    left = <span class="number">0</span></span><br><span class="line">    right = len(nums)<span class="number">-1</span></span><br><span class="line">    <span class="keyword">while</span> left &lt; right:</span><br><span class="line">        mid = left+(right-left+<span class="number">1</span>)//<span class="number">2</span><span class="comment">#取右中位数</span></span><br><span class="line">        <span class="keyword">if</span> nums[mid] &gt; target:</span><br><span class="line">            right = mid - <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            left = mid</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">if</span> nums[left] == target:</span><br><span class="line">        <span class="keyword">return</span> left</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span></span><br></pre></td></tr></table></figure><h2><span id="21-二分查找拓展问题">2.1. 二分查找拓展问题</span></h2><ol><li>在有序数组中查找等于目标元素的第1个或最后1个下标</li><li>在有序数组中查找第1个大于(等于)目标元素的下标</li><li>在有序数组中查找第1个小于(等于)目标元素的下标</li><li>在有序数组中查找最后1个大于(等于)目标元素的下标</li><li>在有序数组中查找最后1个小于(等于)目标元素的下标</li></ol><p>Leetcode上的二分问题主要分为以下三类</p><h1><span id="3-leetcode例题">3. LeetCode例题</span></h1><h2><span id="31-查找target的索引">3.1. 查找target的索引</span></h2><p>一般而言，这个数组是有序的，也可能是半有序，但不大可能是无序的</p><h3><span id="311-二分查找">3.1.1. 二分查找</span></h3><p>给定一个 n 个元素有序的（升序）整型数组 nums 和一个目标值 target  ，写一个函数搜索 nums 中的 target，如果目标值存在返回下标，否则返回 -1。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">search</span><span class="params">(self, nums, target)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :type target: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        left = <span class="number">0</span></span><br><span class="line">        right = len(nums)<span class="number">-1</span></span><br><span class="line">        <span class="keyword">while</span> left &lt; right:</span><br><span class="line">            mid = left+(right-left)//<span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> nums[mid] &lt; target:</span><br><span class="line">                left = mid+<span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                right=mid</span><br><span class="line">        <span class="keyword">if</span> nums[left]==target:</span><br><span class="line">            <span class="keyword">return</span> left</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span></span><br></pre></td></tr></table></figure><h3><span id="312-搜索旋转排序数组">3.1.2. 搜索旋转排序数组</span></h3><p>假设按照升序排序的数组在预先未知的某个点上进行了旋转。</p><p>( 例如，数组 [0,1,2,4,5,6,7] 可能变为 [4,5,6,7,0,1,2] )。</p><p>搜索一个给定的目标值，如果数组中存在这个目标值，则返回它的索引，否则返回 -1 。</p><p>你可以假设数组中不存在重复的元素。</p><p>你的算法时间复杂度必须是 O(log n) 级别。</p><p>这道题有多种解法：</p><ol><li>中间元素和右边界比较，使用右中位数</li><li>中间元素和右边界比较，使用左中位数</li><li>中间元素和左边界比较，使用右中位数</li><li>中间元素和左边界比较，使用左中位数</li><li>分三个区间</li></ol><p>下面只给出前2种的解法：<br>讨论mid元素和右边界的关系，因为nums不存在重复元素，所以要么大于，要么小于</p><ul><li><p><code>nums[mid] &lt; nums[right]</code><br>例如[7,8,2,3,4,5,6],nums[mid]=3,nums[right]=6,此时[mid,right]一定是有序的，那么target要不在有序区间[mid,right]中，要么在不一定有序的[left,mid-1]中。</p><ul><li>假设target在[mid,right]中，即<code>nums[mid] &lt;= target and target &lt;= nums[right]</code>，因为该区间已经有序，比较简单，更新<code>left=mid</code></li><li>假设target落在[left,mid-1]中，就是上一个情况的反面，即<code>right=mid-1</code></li><li>因为这里出现了<code>left=mid</code>的情况，所有需要使用<code>mid=left+(right-left+1)//2</code>的方式来计算mid</li></ul></li><li><p><code>nums[mid] &gt; nums[right]</code><br>例如[5,6,7,8,9,2,3,4],nums[mid]=8,nums[right]=4,此时[left,mid]一定是有序的，那么target要不在有序区间[left,mid]中，要么在不一定有序的[mid+1,left]中。</p><ul><li>假设target在[left,mid]中，即<code>nums[left] &lt;= target and target &lt;= nums[mid]</code>，因为该区间已经有序，比较简单，更新<code>right=mid</code></li><li>假设target落在[mid+1,right]中，就是上一个情况的反面，即<code>left=mid+1</code></li><li>为了和上一种情况，在计算<code>mid=left+(right-left+1)//2</code>的方式保持一致，这里，我们认为target在[left,mid-1]中有序，这样更新right=mid-1,更新left=mid，并且放区间中只有2个元素时，mid始终等于right，此时在更新right=mid-1时也不会越界</li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">search</span><span class="params">(self, nums, target)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :type target: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="comment">#方式1：中间元素和右边界比较，使用右中位数</span></span><br><span class="line">        <span class="keyword">if</span> len(nums) == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">        left= <span class="number">0</span></span><br><span class="line">        right = len(nums)<span class="number">-1</span></span><br><span class="line">        <span class="keyword">while</span> left &lt; right:</span><br><span class="line">            mid = left+(right-left+<span class="number">1</span>)//<span class="number">2</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> nums[mid] &lt; nums[right]:</span><br><span class="line">                <span class="keyword">if</span> nums[mid] &lt;= target <span class="keyword">and</span> target &lt;= nums[right]:</span><br><span class="line">                    <span class="comment">#[mid,right]一定是有序的</span></span><br><span class="line">                    left = mid</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    right = mid - <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">if</span> nums[left] &lt;= target <span class="keyword">and</span> target &lt;= nums[mid<span class="number">-1</span>]:</span><br><span class="line">                    <span class="comment">#[left,mid-1]一定是有序的</span></span><br><span class="line">                    right = mid - <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    left = mid </span><br><span class="line">        <span class="keyword">if</span> nums[left] == target:</span><br><span class="line">            <span class="keyword">return</span> left</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">#方法2：中间元素和右边界比较，使用左中位数</span></span><br><span class="line">        <span class="keyword">if</span> len(nums) == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">        left= <span class="number">0</span></span><br><span class="line">        right = len(nums)<span class="number">-1</span></span><br><span class="line">        <span class="keyword">while</span> left &lt; right:</span><br><span class="line">            mid = left+(right-left)//<span class="number">2</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> nums[mid] &lt; nums[right]:</span><br><span class="line">                <span class="keyword">if</span> nums[mid+<span class="number">1</span>] &lt;= target <span class="keyword">and</span> target &lt;= nums[right]:</span><br><span class="line">                    left = mid + <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    right = mid</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">if</span> nums[left] &lt;= target <span class="keyword">and</span> target &lt;= nums[mid]:</span><br><span class="line">                    right = mid</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    left = mid + <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> nums[left] == target:</span><br><span class="line">            <span class="keyword">return</span> left</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">#方法5：三段区间</span></span><br><span class="line">        left = <span class="number">0</span></span><br><span class="line">        right = len(nums)<span class="number">-1</span></span><br><span class="line">        <span class="keyword">while</span> left &lt;= right:<span class="comment">#注意</span></span><br><span class="line">            mid = left + (right-left)//<span class="number">2</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> nums[mid] == target:</span><br><span class="line">                <span class="keyword">return</span> mid</span><br><span class="line">            <span class="keyword">if</span> nums[left] &lt;= nums[mid]:<span class="comment">#注意是&lt;=</span></span><br><span class="line">                <span class="comment">#因为上面已经判断nums[mid]==target，这里就不用=</span></span><br><span class="line">                <span class="keyword">if</span> nums[left] &lt;= target <span class="keyword">and</span> target &lt; nums[mid]:</span><br><span class="line">                    right = mid - <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    left = mid+<span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">if</span> nums[mid] &lt; target <span class="keyword">and</span> target &lt;= nums[right]:</span><br><span class="line">                    left = mid+<span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    right = mid<span class="number">-1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span></span><br></pre></td></tr></table></figure><h3><span id="313-搜索旋转排序数组-ii">3.1.3. 搜索旋转排序数组 II</span></h3><p>假设按照升序排序的数组在预先未知的某个点上进行了旋转。</p><p>( 例如，数组 [0,0,1,2,2,5,6] 可能变为 [2,5,6,0,0,1,2] )。</p><p>编写一个函数来判断给定的目标值是否存在于数组中。若存在返回 true，否则返回 false。</p><p>进阶:<br>这是 搜索旋转排序数组 的延伸题目，本题中的 nums  可能包含重复元素。<br>这会影响到程序的时间复杂度吗？会有怎样的影响，为什么？</p><p>这道题和上一题的区别是nums中存在重复元素。那nums[mid]和右边界比较来举例，上一题只考虑了2种情况，if nums[mid] &lt; nums[right]和nums[mid] &gt; nums[right]，但在这一题中，因为有重复元素，所以就需要考虑相等的情况。当nums[mid] == nums[right]，先判断是否等于target，如果等于返回True，否则当前的right被排除，right向前移一位。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">search</span><span class="params">(self, nums, target)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :type target: int</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="comment">#中间元素和右边界比较，使用右中位数</span></span><br><span class="line">        <span class="keyword">if</span> len(nums) == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">        left= <span class="number">0</span> </span><br><span class="line">        right = len(nums)<span class="number">-1</span></span><br><span class="line">        <span class="keyword">while</span> left &lt; right:</span><br><span class="line">            mid = left+(right-left+<span class="number">1</span>)//<span class="number">2</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> nums[mid] &lt; nums[right]:</span><br><span class="line">                <span class="keyword">if</span> nums[mid] &lt;= target <span class="keyword">and</span> target &lt;= nums[right]:</span><br><span class="line">                    <span class="comment">#[mid,right]一定是有序的</span></span><br><span class="line">                    left = mid</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    right = mid - <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> nums[mid] &gt; nums[right]:</span><br><span class="line">                <span class="keyword">if</span> nums[left] &lt;= target <span class="keyword">and</span> target &lt;= nums[mid<span class="number">-1</span>]:</span><br><span class="line">                    <span class="comment">#[left,mid-1]一定是有序的</span></span><br><span class="line">                    right = mid - <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    left = mid</span><br><span class="line">            <span class="keyword">else</span>:<span class="comment">#nums[mid] == nums[right]</span></span><br><span class="line">                <span class="keyword">if</span> nums[mid] == target:</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    right -= <span class="number">1</span> </span><br><span class="line">        <span class="keyword">if</span> nums[left] == target:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">False</span></span><br></pre></td></tr></table></figure><h3><span id="314-寻找旋转排序数组中的最小值">3.1.4. 寻找旋转排序数组中的最小值</span></h3><p>假设按照升序排序的数组在预先未知的某个点上进行了旋转。</p><p>( 例如，数组 [0,1,2,4,5,6,7] 可能变为 [4,5,6,7,0,1,2] )。</p><p>请找出其中最小的元素。</p><p><strong>你可以假设数组中不存在重复元素。</strong></p><p>虽然是要找最小数，但是数据部分有序，可以使用二分法。有2种情况，nums[mid]和左边界比较，nums[mid]和右边界比较</p><ul><li>nums[mid]和左边界比较<ul><li>例如[1,2,3,4,5]，中间数nums[mid]=3,比左边界大，最小值存在于左区间</li><li>[2,3,4,5,6,1],中间数nums[mid]=4比左边界大，说明左边界有序，最小值一定存在于右区间</li></ul></li></ul><p>根据上面2种情况，可以看出当nums[mid]大于左边界时，不知道最小值一定存在于哪个区间，所以不能用mid和左边界比较。</p><ul><li><p>nums[mid]和右边界比较</p><ul><li>当nums[mid] &lt; nums[right],说明最小值一定在左边</li><li>当nums[mid] &gt; nums[right],说明最小值一定在右边</li><li>当nums[mid] = nums[right],因为题目中说不存在重复元素，所以不会出现相等的情况</li></ul></li><li><p>时间复杂度：O(logN)</p></li><li>空间复杂度：O(1)</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findMin</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="comment">#中间元素和右边元素比较</span></span><br><span class="line">        left = <span class="number">0</span></span><br><span class="line">        right = len(nums)<span class="number">-1</span></span><br><span class="line">        <span class="keyword">while</span> left &lt; right:</span><br><span class="line">            mid = left+(right-left)//<span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> nums[mid] &lt; nums[right]:<span class="comment">#说明右边有序，右边递增</span></span><br><span class="line">                <span class="comment">#说明最小值肯定在左区间</span></span><br><span class="line">                right = mid</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment">#mid大于右边，说明左边有序，左边递增，那左边的值比mid小，右边的值也比mid小，到底哪边的值更小呢？</span></span><br><span class="line">            <span class="comment">#答案是：右边的值更小，因为如果左边的值更小的话，那说明右边的值比左边的最小值大，比mid小，那这个值肯定在min和mid之间，</span></span><br><span class="line">            <span class="comment">#但现在这个值在右边，推翻前面的假设，即右边的值更小</span></span><br><span class="line">                left = mid+<span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> nums[left]</span><br><span class="line"></span><br><span class="line">        <span class="comment">#尝试使用nums[mid]和左边界比较，失败</span></span><br><span class="line">        <span class="comment"># left = 0</span></span><br><span class="line">        <span class="comment"># right = len(nums)-1</span></span><br><span class="line">        <span class="comment"># while left &lt; right:</span></span><br><span class="line">        <span class="comment">#     mid = left+(right-left)//2</span></span><br><span class="line">        <span class="comment">#     if nums[mid] &lt; nums[left]:#说明右边有序,右边递增，最小值一定在做区间</span></span><br><span class="line">        <span class="comment">#         right = mid</span></span><br><span class="line">        <span class="comment">#     else:#mid比左边大，说明左边有序，左边递增，但是最小值不一定在左边</span></span><br><span class="line">        <span class="comment">#     #[1,2,3,4,5,6,7]最小值在左区间，</span></span><br><span class="line">        <span class="comment">#     #[8,9,10,11,1,2]最小值在右区间</span></span><br><span class="line">        <span class="comment">#     #不确定该缩小到哪个区间，该方法不可行</span></span><br></pre></td></tr></table></figure><h3><span id="315-寻找旋转排序数组中的最小值-ii">3.1.5. 寻找旋转排序数组中的最小值 II</span></h3><p>假设按照升序排序的数组在预先未知的某个点上进行了旋转。</p><p>( 例如，数组 [0,1,2,4,5,6,7] 可能变为 [4,5,6,7,0,1,2] )。</p><p>请找出其中最小的元素。</p><p><strong>注意数组中可能存在重复的元素</strong>。</p><ul><li>时间复杂度：O(logN),但在最坏情况下，即nums[mid]==nums[right]，需要逐个遍历数组，复杂度为O(N)</li><li>空间复杂度：O(1)<br>上个问题是这个问题的特例，只是上个问题永远不会进入到nums[mid]==nums[right]的分支。</li></ul><p>在本题中如果nums[mid]==nums[right]，会将right减1，那是否可以变成left+1呢？答案是：不可以，例如[1,3,3]，left=1，mid=3，right=3，如果变成left+1，就会跳过最小值。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findMin</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        left = <span class="number">0</span></span><br><span class="line">        right = len(nums)<span class="number">-1</span></span><br><span class="line">        <span class="keyword">while</span> left &lt; right:</span><br><span class="line">            mid = left+(right-left)//<span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> nums[mid] &lt; nums[right]:<span class="comment">#说明右边有序，最小值一定在左区间</span></span><br><span class="line">                right = mid</span><br><span class="line">            <span class="keyword">elif</span> nums[mid] &gt; nums[right]:<span class="comment">#说明左边有序，最小值一定在右区间</span></span><br><span class="line">                left = mid + <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:<span class="comment">#nums[mid] == nums[right]</span></span><br><span class="line">                right -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> nums[left]</span><br></pre></td></tr></table></figure><h3><span id="316-h指数-ii">3.1.6. H指数 II</span></h3><p>给定一位研究者论文被引用次数的数组（被引用次数是非负整数），数组已经按照升序排列。编写一个方法，计算出研究者的 h 指数。</p><p>h 指数的定义: “h 代表“高引用次数”（high citations），一名科研人员的 h 指数是指他（她）的 （N 篇论文中）有 h 篇论文分别被引用了至少 h 次。（其余的 N - h 篇论文每篇被引用次数不多于 h 次。）”</p><p>我们先举一个例子，<br>[1,2,3,7,9]，假设一个文章下标为i，则需要满足<code>citation[i] &gt;= n - i</code>,有h个文章的引用次数大于等于h，即当前的引用次数为citation[i]，引用次数大于等于它的文章有n-i个。h的值就是n-i<br>该问题可以简化为：给定一个长度为n的升序数组，找到满足<code>citation[i]&gt;=n-i</code>的citation[i]<br>用二分法来解决这个问题<br>我们要找i，先找到不符合citation[i] &gt;= n-i的情况，就是citation[i] &lt; n -i，即i太小了，需要变大到右区间找，更新left=mid+1，否则去左区间right=mid。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hIndex</span><span class="params">(self, citations)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type citations: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        n = len(citations)</span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">0</span> <span class="keyword">or</span> citations[n<span class="number">-1</span>] == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        left = <span class="number">0</span></span><br><span class="line">        right = n<span class="number">-1</span></span><br><span class="line">        <span class="comment">#要找citation[i] &gt;= n -i</span></span><br><span class="line">        <span class="keyword">while</span> left &lt; right:</span><br><span class="line">            mid = left+(right-left)//<span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> citations[mid] &lt; n - mid:<span class="comment">#说明mid小了，需要移到右区间</span></span><br><span class="line">                left = mid+<span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                right = mid</span><br><span class="line">        <span class="keyword">return</span> n-left</span><br></pre></td></tr></table></figure><h3><span id="317-最长上升子序列">3.1.7. 最长上升子序列</span></h3><p>动态规划+二分，以后再看</p><h3><span id="318-山脉数组中查找目标值">3.1.8. 山脉数组中查找目标值</span></h3><p>给你一个 山脉数组 mountainArr，请你返回能够使得 mountainArr.get(index) 等于 target 最小 的下标 index 值。</p><p>如果不存在这样的下标 index，就请返回 -1。</p><p>山脉数组：[1,2,4,7,4,2,1]先上升后下降的数组<br>使用3次二分</p><ul><li>使用二分，找出最大元素的下标</li><li>使用二分，找出左边升序数组中第一个等于target的下标</li><li>使用二分，找出右边降序数组中第一个等于target的下标</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findInMountainArray</span><span class="params">(self, target, mountain_arr)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type target: integer</span></span><br><span class="line"><span class="string">        :type mountain_arr: MountainArray</span></span><br><span class="line"><span class="string">        :rtype: integer</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        n = mountain_arr.length()<span class="number">-1</span></span><br><span class="line">        max_idx = self.findTop(mountain_arr,<span class="number">0</span>,n)</span><br><span class="line">        <span class="comment">#[0,max_idx+1]升序，[max_idx+1,n]降序</span></span><br><span class="line">        first_idx = self.sorted_first(mountain_arr,<span class="number">0</span>,max_idx,target)</span><br><span class="line">        <span class="keyword">if</span> first_idx != <span class="number">-1</span>:</span><br><span class="line">            <span class="keyword">return</span> first_idx</span><br><span class="line">        first_idx = self.reverse_first(mountain_arr,max_idx+<span class="number">1</span>,n,target)</span><br><span class="line">        <span class="keyword">return</span> first_idx</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findTop</span><span class="params">(self,mountain_arr,left,right)</span>:</span></span><br><span class="line">        <span class="comment">#找到mountain_arr中最大值的下标</span></span><br><span class="line">        <span class="keyword">while</span> left &lt; right:</span><br><span class="line">            mid = left+(right-left)//<span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> mountain_arr.get(mid) &lt; mountain_arr.get(mid+<span class="number">1</span>):<span class="comment">#说明最大值在右边</span></span><br><span class="line">                left = mid+<span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                right = mid</span><br><span class="line">        <span class="keyword">return</span> left</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sorted_first</span><span class="params">(self,mountain_arr,left,right,target)</span>:</span></span><br><span class="line">        <span class="comment">#nums升序，从nums中找到第一个等于target的下标，找不到返回-1</span></span><br><span class="line">     </span><br><span class="line">        <span class="keyword">while</span> left &lt; right:</span><br><span class="line">            mid=left+(right-left)//<span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> mountain_arr.get(mid) &lt; target:</span><br><span class="line">                left = mid+<span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                right = mid</span><br><span class="line">        <span class="keyword">if</span> mountain_arr.get(left)==target:</span><br><span class="line">            <span class="keyword">return</span> left</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverse_first</span><span class="params">(self,mountain_arr,left,right,target)</span>:</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> left &lt; right:</span><br><span class="line">            mid = left+(right-left+<span class="number">1</span>)//<span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> mountain_arr.get(mid) &lt; target:<span class="comment">#说明target在左边</span></span><br><span class="line">                right = mid<span class="number">-1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                left = mid</span><br><span class="line">        <span class="keyword">if</span> mountain_arr.get(left) == target:</span><br><span class="line">            <span class="keyword">return</span> left</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span></span><br></pre></td></tr></table></figure><h3><span id="319-寻找两个有序数组的中位数">3.1.9. 寻找两个有序数组的中位数</span></h3><p>给定两个大小为 m 和 n 的有序数组 nums1 和 nums2。</p><p>请你找出这两个有序数组的中位数，并且要求算法的时间复杂度为 O(log(m + n))。</p><p>你可以假设 nums1 和 nums2 不会同时为空</p><p><strong>【解法1】</strong><br>最简单的方法是：将2个数组拼接，重排序。这种方法很常规，但是不符合题目要求。<strong>这个方法的优点是：2个数组不需要有序</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findMedianSortedArrays</span><span class="params">(self, nums1, nums2)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums1: List[int]</span></span><br><span class="line"><span class="string">        :type nums2: List[int]</span></span><br><span class="line"><span class="string">        :rtype: float</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        m = len(nums1)</span><br><span class="line">        n = len(nums2)</span><br><span class="line">        nums1.extend(nums2)</span><br><span class="line">        nums1.sort()</span><br><span class="line">        <span class="keyword">if</span> (m+n)%<span class="number">2</span>==<span class="number">0</span>:</span><br><span class="line">            mid = (m+n)//<span class="number">2</span></span><br><span class="line">            <span class="keyword">return</span> (nums1[mid]+nums1[mid<span class="number">-1</span>])/<span class="number">2.0</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            mid = (m+n)//<span class="number">2</span></span><br><span class="line">            <span class="keyword">return</span> nums1[mid]</span><br></pre></td></tr></table></figure><ul><li>时间复杂度：$O((m+n)log(m+n))$</li><li>空间复杂度：$O(m+n)$</li></ul><p><strong>【解法2】</strong><br>不用把2个数组排序放在一起，直到遍历2个数组，找到中位数就可以了。</p><ul><li>当m+n为奇数时，[1,2,5,7],[3,6,8],一共7个数，中位数的下标为3，即7//2</li><li>当m+n为偶数时，[1,2,5,7],[3,6,8,9],一共8个数，中位数的下标为3,4，即8//2-1,8//2<br>即不管总数是奇数还是偶数，都要遍历到(m+n)//2这个下标，如果是偶数的话，还需要记录<code>(m+n)//2-1</code>的值，即需要同时记录2个值</li><li><p>使用2个变量left和right来标记遍历到的2个数，right表示当前循环遍历的数，left为上一个循环遍历的数。在每次循环开始的时候，将上个循环遍历的<code>right</code>赋值给<code>left</code>进行保存，此时再把当前循环遍历的数赋值给<code>right</code>。等到遍历结束的时候，如果数字个数为偶数的话，需要返回<code>right</code>和<code>left</code>的均值，如果是奇数，直接返回<code>right</code></p></li><li><p>使用2个指针p1和p2来标记nums1和nums2遍历到的位置。当nums1没有完，且当前nums1的值小于nums2的值，移动p1，或者nums1没有完，但是nums2遍历完了，移动p1， 其余情况都是移动p2。在<code>if p1 &lt; m and (p2 &gt;= n or nums1[p1] &lt; nums2[p2])</code>中需要先判断<code>p2</code>是否越界大于等于n，如果越界了，就不用执行后面的<code>nums1[p1] &lt; nums2[p2]</code></p></li><li>在最后返回值的时候判断一下当前m+n奇偶情况。</li></ul><p>这种方法不是二分法，而是一个个的遍历，因为我们知道中位数肯定会出现在<code>(m+n)//2</code>的下标处，所以就开始遍历下标，从<code>0~(m+n)//2</code>，这个下标可能出现在数组1中，也可能出现在数组2中，所以需要2个指针<code>p1,p2</code>来分别指向数组1和数组2，每次只移动小的那个数对应的指针，看当遍历到下标为<code>(m+n)//2</code>时，<code>right，left</code>指向哪个数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findMedianSortedArrays</span><span class="params">(self, nums1, nums2)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums1: List[int]</span></span><br><span class="line"><span class="string">        :type nums2: List[int]</span></span><br><span class="line"><span class="string">        :rtype: float</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="comment">#不管m+n是奇数还是偶数，都遍历到下标为(m+n)//2的位置</span></span><br><span class="line">        m,n=len(nums1),len(nums2)</span><br><span class="line">        mid_idx = (m+n)//<span class="number">2</span></span><br><span class="line"></span><br><span class="line">        left_val,right_val = <span class="number">-1</span>,<span class="number">-1</span></span><br><span class="line">        p1,p2=<span class="number">0</span>,<span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>,mid_idx+<span class="number">1</span>):</span><br><span class="line">            left_val = right_val</span><br><span class="line">            <span class="keyword">if</span> p1 &lt; m <span class="keyword">and</span> (p2 &gt;= n <span class="keyword">or</span> nums1[p1] &lt; nums2[p2]):</span><br><span class="line">                right_val = nums1[p1]</span><br><span class="line">                p1 += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                right_val = nums2[p2]</span><br><span class="line">                p2+=<span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> (m+n)%<span class="number">2</span>==<span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> (left_val+right_val)/<span class="number">2.0</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> right_val</span><br></pre></td></tr></table></figure><ul><li>时间复杂度：$O(m+n)$<br>还是没有达到log的时间复杂度</li></ul><h2><span id="32-在一个有上下界的区间中搜索一个整数">3.2. 在一个有上下界的区间中搜索一个整数</span></h2><h3><span id="321-x-的平方根">3.2.1. x 的平方根</span></h3><p>实现 int sqrt(int x) 函数。</p><p>计算并返回 x 的平方根，其中 x 是非负整数。</p><p>由于返回类型是整数，结果只保留整数的部分，小数部分将被舍去。</p><p>【我的解法】<br>首先找到不符合条件的值，即mid*mid&gt;x，一定不符合条件。在更新left会出现left=mid，这时就需要把mid取右中位数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">mySqrt</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type x: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> x==<span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        left,right = <span class="number">1</span>,x//<span class="number">2</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># while left &lt; right:</span></span><br><span class="line">        <span class="comment">#     mid = left+(right-left)//2</span></span><br><span class="line">        <span class="comment">#     if mid*mid &lt; x:#mid的平方&lt;x,也是符合条件的，例如8的结果为2,2*2=4&lt;8</span></span><br><span class="line">        <span class="comment">#         left = mid+1</span></span><br><span class="line">        <span class="comment">#     else:</span></span><br><span class="line">        <span class="comment">#         right=mid</span></span><br><span class="line">        <span class="keyword">while</span> left &lt; right:</span><br><span class="line">            mid = left+(right-left+<span class="number">1</span>)//<span class="number">2</span><span class="comment">#取右中位数</span></span><br><span class="line">            <span class="keyword">if</span> mid*mid &gt; x:</span><br><span class="line">                right = mid <span class="number">-1</span><span class="comment">#有边界不包括中位数</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                left = mid<span class="comment">#左边界可以是中位数，</span></span><br><span class="line">        <span class="keyword">return</span> left</span><br></pre></td></tr></table></figure><h3><span id="322-寻找重复数">3.2.2. 寻找重复数</span></h3><p>给定一个包含 n + 1 个整数的数组 nums，其数字都在 1 到 n 之间（包括 1 和 n），可知至少存在一个重复的整数。假设只有一个重复的整数，找出这个重复的数。</p><p>说明：</p><ol><li>不能更改原数组（假设数组是只读的）。</li><li>只能使用额外的 O(1) 的空间。</li><li>时间复杂度小于 O(n2) 。</li><li>数组中只有一个重复的数字，但它可能不止重复出现一次。</li></ol><p>先不管上面这些限制条件，看有什么解法</p><p>【解法1】<br>先对nums排序，然后判断每个数和它后面的数是否相同，若相同则说明重复，直接返回</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findDuplicate</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        nums.sort()</span><br><span class="line">        n = len(nums)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n<span class="number">-1</span>):</span><br><span class="line">            <span class="keyword">if</span> nums[i] == nums[i+<span class="number">1</span>]:</span><br><span class="line">                <span class="keyword">return</span> nums[i]</span><br></pre></td></tr></table></figure><ul><li>时间复杂度：$O(nlogn)$</li><li>改变原数组，不符合题目要求</li></ul><p>【解法2】<br>使用字典保存每个数字出现的次数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findDuplicate</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        count = dict()</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> nums:</span><br><span class="line">            <span class="keyword">if</span> i <span class="keyword">not</span> <span class="keyword">in</span> count:</span><br><span class="line">                count[i] = <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                count[i]+=<span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> count[i] &gt; <span class="number">1</span>:</span><br><span class="line">                <span class="keyword">return</span> i</span><br></pre></td></tr></table></figure><ul><li>时间复杂度：$O(n)$,只遍历一次数组</li><li>空间复杂度：$O(n)$,不符合题目要求</li></ul><p>【解法3】<br>使用二分法，[1,3,3,2,4,5],例如有6个数，范围在1~5之间，其中小于等于3的有4个数，说明重复的数肯定在3的左边，要么是3,2,1中的1个数，更新right到左区间。<br>这里的mid表示当前重复的数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findDuplicate</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        n = len(nums)</span><br><span class="line">        left = <span class="number">0</span></span><br><span class="line">        right = n <span class="number">-1</span></span><br><span class="line">        <span class="keyword">while</span> left &lt; right:</span><br><span class="line">            mid = left + (right-left) // <span class="number">2</span></span><br><span class="line">            count=<span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> nums:</span><br><span class="line">                <span class="keyword">if</span> i&lt;=mid:</span><br><span class="line">                    count+=<span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> count &gt; mid:<span class="comment">#说明小于等于mid的元素有重复的，转到左区间</span></span><br><span class="line">                right = mid</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                left = mid + <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> left</span><br></pre></td></tr></table></figure><ul><li>时间复杂度：$O(nlogn)$，因为二分的复杂度为logn，在内部又遍历一次数组</li><li>空间复杂度：$O(1)$</li></ul><h2><span id="33-判断条件是一个函数">3.3. 判断条件是一个函数</span></h2><p>在二分法中if语句中，判断条件是一个函数</p><h3><span id="331-第一个错误的版本">3.3.1. 第一个错误的版本</span></h3><p>你是产品经理，目前正在带领一个团队开发新的产品。不幸的是，你的产品的最新版本没有通过质量检测。由于每个版本都是基于之前的版本开发的，所以错误的版本之后的所有版本都是错的。</p><p>假设你有 n 个版本 [1, 2, …, n]，你想找出导致之后所有版本出错的第一个错误的版本。</p><p>你可以通过调用 bool isBadVersion(version) 接口来判断版本号 version 是否在单元测试中出错。实现一个函数来查找第一个错误的版本。你应该尽量减少对调用 API 的次数。</p><p><strong>【我的解法】</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># The isBadVersion API is already defined for you.</span></span><br><span class="line"><span class="comment"># @param version, an integer</span></span><br><span class="line"><span class="comment"># @return a bool</span></span><br><span class="line"><span class="comment"># def isBadVersion(version):</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">firstBadVersion</span><span class="params">(self, n)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type n: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        left=<span class="number">1</span></span><br><span class="line">        right=n</span><br><span class="line">        <span class="keyword">while</span> left &lt; right:</span><br><span class="line">            mid=left+(right-left)//<span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> isBadVersion(mid):</span><br><span class="line">                left=mid+<span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                right=mid</span><br><span class="line">        <span class="keyword">return</span> left</span><br></pre></td></tr></table></figure><h3><span id="332-分割数组的最大值">3.3.2. 分割数组的最大值</span></h3><p>给定一个非负整数数组和一个整数 m，你需要将这个数组分成 m 个非空的连续子数组。设计一个算法使得这 m 个子数组各自和的最大值最小。</p><p>注意:<br>数组长度 n 满足以下条件:</p><p>1 ≤ n ≤ 1000<br>1 ≤ m ≤ min(50, n)</p><p><strong>【题解】</strong><br>本题中给定完整数组和子数组个数m，让这m个子数组和的最大值最小。<br>首先定义left，right和mid分别表示什么意思。这里的mid表示子数组和的最大值。子数组和的最大值是有范围的。<br>如果让数组中每个数组都单独组成一个子数组，那子数组和的最大值就是<code>nums</code>的最大值。<br>如果对这个数组不分组，子数组和的最大值就是<code>nums</code>所有元素的和。</p><p>令<code>left=max(nums)</code>，<code>right=sum(nums)</code>，<code>mid=left+(right-left)//2</code>。</p><p>我们写一个函数，假设给定<code>mid</code>，即子数组和最大值为mid，看看能分成多少组，假设能分成<code>cnt</code>组，然后和要求的<code>m</code>组比较。显然如果给的mid越大，分的组数越小</p><ul><li>如果子数组个数cnt &gt; m，说明mid给小了，导致子数组划分多了，那应该让mid值变大，left=mid+1</li><li>否则，cnt &lt;= m，说明mid给大了，导致子数组划分少了，那应该让mid变小，right=mid</li></ul><p>下面的关键问题是给定<code>mid</code>，怎么算出划分的子数组个数<code>cnt</code>呢？<br>思路是：我们设置2个变量<code>cnt</code>和<code>sums</code>，表示目前的组数、目前的和。</p><ul><li>初始化<code>cnt=1,sums=0</code></li><li>然后遍历数组<code>nums</code><ul><li>让<code>sums</code>加上当前遍历的数</li><li>如果<code>sums+nums[i]</code>比给定的<code>mid</code>小，就需要遍历下一个</li><li>如果<code>sums+nums[i]</code>比给定的<code>mid</code>大，说明就需要分组了</li><li>那么<code>cnt+=1</code>，同时<code>sums=nums[i]</code>作为下一个分组的和</li><li>最终返回当子数组和最大为<code>mid</code>，所能得到的分组个数<code>cnt</code></li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">splitArray</span><span class="params">(self, nums, m)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :type m: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="comment">#获取nums的最大值和总和</span></span><br><span class="line">        left,right=nums[<span class="number">0</span>],<span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> nums:</span><br><span class="line">            right+=i</span><br><span class="line">            <span class="keyword">if</span> i&gt;left:</span><br><span class="line">                left=i</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> left&lt;right:</span><br><span class="line">            mid = left+(right-left)//<span class="number">2</span></span><br><span class="line">            cnt = self.getArrayCount(nums,mid)</span><br><span class="line">            <span class="keyword">if</span> cnt &gt; m:<span class="comment">#说明cnt分多了，说明mid给小了，应该让mid变得更大</span></span><br><span class="line">                left = mid+<span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                right = mid</span><br><span class="line">        <span class="keyword">return</span> left</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getArrayCount</span><span class="params">(self,nums,mid)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        划分nums，使得子数组和的最大值不能超过mid，看可以分多少组</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        cnt = <span class="number">1</span><span class="comment">#划分子数组个数</span></span><br><span class="line">        sums = <span class="number">0</span><span class="comment">#子数组和</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums)):</span><br><span class="line">            <span class="keyword">if</span> sums+nums[i]&gt;mid:</span><br><span class="line">                cnt += <span class="number">1</span></span><br><span class="line">                sums = nums[i]</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                sums += nums[i]</span><br><span class="line">        <span class="keyword">return</span> cnt</span><br></pre></td></tr></table></figure><p>这里的if语句中不是一个简单的表达式，而是一个复杂的运算，所有单独写成一些函数</p><h3><span id="333-爱吃香蕉的珂珂">3.3.3. 爱吃香蕉的珂珂</span></h3><p>珂珂喜欢吃香蕉。这里有 N 堆香蕉，第 i 堆中有 piles[i] 根香蕉。警卫已经离开了，将在 H 小时后回来。</p><p>珂珂可以决定她吃香蕉的速度 K （单位：根/小时）。每个小时，她将会选择一堆香蕉，从中吃掉 K 根。如果这堆香蕉少于 K 根，她将吃掉这堆的所有香蕉，然后这一小时内不会再吃更多的香蕉。  </p><p>珂珂喜欢慢慢吃，但仍然想在警卫回来前吃掉所有的香蕉。</p><p>返回她可以在 H 小时内吃掉所有香蕉的最小速度 K（K 为整数）。</p><p><strong>【我的解法】</strong><br>这一题和上一题<a href="https://leetcode-cn.com/problems/split-array-largest-sum/" target="_blank" rel="noopener">410. 分割数组的最大值</a>很像。首先明确left，right，mid代表什么意思。这里的mid表示吃的速度。根据当前mid来吃香蕉，看看需要多少小时，如果hours&gt;H,说明吃慢了，mid要变大，更新left，否则更新right</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minEatingSpeed</span><span class="params">(self, piles, H)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type piles: List[int]</span></span><br><span class="line"><span class="string">        :type H: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">import</span> math</span><br><span class="line">        <span class="comment">#最小速度的范围是1,max</span></span><br><span class="line">        left=<span class="number">1</span></span><br><span class="line">        right=piles[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> piles:</span><br><span class="line">            <span class="keyword">if</span> i&gt;right:</span><br><span class="line">                right=i</span><br><span class="line">        <span class="keyword">while</span> left&lt;right:</span><br><span class="line">            mid=left+(right-left)//<span class="number">2</span><span class="comment">#表示当前吃的速度</span></span><br><span class="line">            <span class="comment">#计算以当前的速度，需要吃几个小时</span></span><br><span class="line">            hours=<span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> piles:</span><br><span class="line">                hours+=math.ceil(i*<span class="number">1.0</span>/mid)</span><br><span class="line">            <span class="keyword">if</span> hours &gt; H:<span class="comment">#说明吃的太慢了，mid需要向右移</span></span><br><span class="line">                left=mid+<span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                right=mid</span><br><span class="line">        <span class="keyword">return</span> left</span><br></pre></td></tr></table></figure><h3><span id="334-找到-k-个最接近的元素">3.3.4. 找到 K 个最接近的元素</span></h3><p>给定一个排序好的数组，两个整数 k 和 x，从数组中找到最靠近 x（两数之差最小）的 k 个数。返回的结果必须要是按升序排好的。如果有两个数与 x 的差值一样，优先选择数值较小的那个数。</p><p><strong>【解法1】</strong><br>遍历整个数组，记录每个数和x的差值，然后取出前k小的差值，范湖其原始值。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findClosestElements</span><span class="params">(self, arr, k, x)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type arr: List[int]</span></span><br><span class="line"><span class="string">        :type k: int</span></span><br><span class="line"><span class="string">        :type x: int</span></span><br><span class="line"><span class="string">        :rtype: List[int]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        delta = &#123;&#125;<span class="comment">#存储每个数和x的差值</span></span><br><span class="line">        <span class="keyword">for</span> idx,val <span class="keyword">in</span> enumerate(arr):</span><br><span class="line">            delta[idx]=abs(val-x)</span><br><span class="line">        <span class="comment">#按照差值排序</span></span><br><span class="line">        delta1 = sorted(delta.items(),key=<span class="keyword">lambda</span> x:x[<span class="number">1</span>])</span><br><span class="line">        k_res = delta1[:k]<span class="comment">#取出差值在前k个的数据</span></span><br><span class="line">        k_res.sort(key= operator.itemgetter(<span class="number">0</span>))<span class="comment">#对这k个数按照下标排序</span></span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">for</span> idx,delta <span class="keyword">in</span> k_res:</span><br><span class="line">            res.append(arr[idx])</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><p><strong>【解法2】</strong><br>在arr中找到离x最近的k个数，因为arr已经是升序，所有删除的数一定在边界。使用2个指针，一个指向left，一个指向right。一共要保留k个数，即要删除n-k个数，while循环的条件是<code>while del_cnt &lt; n-k</code>,保证在退出循环时，<code>del_cnt=n-k</code>。如果左边数的差值&gt;右边数的差值，移动left，否则移动right。在else中其中有2种情况：</p><ul><li>右边数的差值&gt;左边的差值，移动right</li><li>右边数的差值=左边的差值，因为题目中说了，差值一样时，优先选择数值较小的那个数，即保留left，移动right</li></ul><p>退出循环时，left和right就是我们要保留的数，因为列表切片时，左闭右开，所以右边要写成right+1</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findClosestElements</span><span class="params">(self, arr, k, x)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type arr: List[int]</span></span><br><span class="line"><span class="string">        :type k: int</span></span><br><span class="line"><span class="string">        :type x: int</span></span><br><span class="line"><span class="string">        :rtype: List[int]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="comment">#使用双指针</span></span><br><span class="line">        n = len(arr)</span><br><span class="line">        left = <span class="number">0</span></span><br><span class="line">        right = n<span class="number">-1</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">#要保留k个数，即要删除n-k个数</span></span><br><span class="line">        del_cnt=<span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> del_cnt &lt; n-k:</span><br><span class="line">            <span class="keyword">if</span> abs(arr[left]-x) &gt; abs(arr[right]-x):</span><br><span class="line">               <span class="comment">#左边元素差值更大时，删除左边的元素</span></span><br><span class="line">                left+=<span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                right-=<span class="number">1</span></span><br><span class="line">            del_cnt+=<span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> arr[left:right+<span class="number">1</span>]</span><br></pre></td></tr></table></figure><p><strong>【题解3】</strong><br>利用二分法来找到长度为k的区间，这里我们只要确定左边界就可以了，因为知道区间长度为k，右边界为left+k-1。<br>首先确定左边界的范围[0,n-k]，比如[0,1,2,3,4,5,6]，一共7个数，n=7，假设k=3，那么左区间最大为4，如果更大的话，就不够3个数了。<br>所以现在要做的是在[0,n-k]这个区间中，找到一个合适的左边界。这就类似在一个有序数组中，查找一个数，可以使用二分法。<br>设定2个指针，一个left=0，指向左边界的最小值，right=n-k，指向左边界的最大值。<code>mid=left+(right-left)//2</code></p><p>解读以下代码：<br>在if语句中<code>abs(arr[mid]-x) &gt; abs(arr[mid+k]-x)</code>,如果左边界是mid，那整个区间是[mid,mid+k-1],下一个左区间范围是[mid+1,mid+k]，这2个区间除了arr[mid]和nums[mid+k]这2个数不一样，其余都一样，那就比较这2个数哪个数离x更远，假设nums[mid]离x更远，就要把left往右移，即left=mid+1，否则right=mid</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findClosestElements</span><span class="params">(self, arr, k, x)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type arr: List[int]</span></span><br><span class="line"><span class="string">        :type k: int</span></span><br><span class="line"><span class="string">        :type x: int</span></span><br><span class="line"><span class="string">        :rtype: List[int]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        n=len(arr)</span><br><span class="line">        left=<span class="number">0</span></span><br><span class="line">        right=n-k</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> left&lt;right:</span><br><span class="line">            mid=left+(right-left)//<span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> abs(arr[mid]-x) &gt; abs(arr[mid+k]-x):<span class="comment">#说明右边的元素离x更近，向右移</span></span><br><span class="line">                left=mid+<span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                right=mid</span><br><span class="line">        <span class="keyword">return</span> arr[left:left+k]</span><br></pre></td></tr></table></figure><h3><span id="335-转变数组后最接近目标值的数组和">3.3.5. 转变数组后最接近目标值的数组和</span></h3><p>给你一个整数数组 arr 和一个目标值 target ，请你返回一个整数 value ，使得将数组中所有大于 value 的值变成 value 后，数组的和最接近  target （最接近表示两者之差的绝对值最小）。</p><p>如果有多种使得和最接近 target 的方案，请你返回这些整数中的最小值。</p><p>请注意，答案不一定是 arr 中的数字。</p><p><strong>【我的解法】</strong><br>首先确定left，right，value表示什么。这里mid表示需要求的value。然后找到left和right的范围。value的范围最小为0，最大为arr中的最大值。然后开始写二分，给定mid，然后我们计算替换后的sum和target的差值。<br>在if语句中，需要有一个比较条件，但是我们不知道和谁比较，受下面2个题的启发<br><a href="https://leetcode-cn.com/problems/find-in-mountain-array/" target="_blank" rel="noopener">1095山脉数组中查找目标值</a>和<a href="https://leetcode-cn.com/problems/find-k-closest-elements/" target="_blank" rel="noopener">658. 找到 K 个最接近的元素</a>：不知道和谁比较时，一般和mid+1比较。如果mid的差值比mid+1的差值大，说明mid小了，应该变大，更新left=mid+1，否则更新right</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findBestValue</span><span class="params">(self, arr, target)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type arr: List[int]</span></span><br><span class="line"><span class="string">        :type target: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="comment">#mid表示要找的这个数value</span></span><br><span class="line">        <span class="comment">#它的范围是：0~arr中的最大值</span></span><br><span class="line">        left=<span class="number">0</span></span><br><span class="line">        right=arr[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> arr:</span><br><span class="line">            <span class="keyword">if</span> i&gt;right:</span><br><span class="line">                right=i</span><br><span class="line">        <span class="keyword">while</span> left&lt;right:</span><br><span class="line">            mid=left+(right-left)//<span class="number">2</span></span><br><span class="line">            <span class="comment">#计算当value=mid时，所有数据的和</span></span><br><span class="line">            mid_sum = self.get_sum(arr,mid)</span><br><span class="line">            mid_plus_sum = self.get_sum(arr,mid+<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">if</span> abs(mid_sum-target) &gt; abs(mid_plus_sum-target):</span><br><span class="line">                <span class="comment">#说明mid小了，向右移</span></span><br><span class="line">                left = mid+<span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                right=mid</span><br><span class="line">        <span class="keyword">return</span> left</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_sum</span><span class="params">(self,arr,value)</span>:</span></span><br><span class="line">        all_sum = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> arr:</span><br><span class="line">            <span class="keyword">if</span> i &gt; value:</span><br><span class="line">                all_sum+=value</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                all_sum+=i</span><br><span class="line">        <span class="keyword">return</span> all_sum</span><br></pre></td></tr></table></figure><h1><span id="排序矩阵查找">排序矩阵查找</span></h1><p>给定M×N矩阵，每一行、每一列都按升序排列，请编写代码找出某元素。</p><blockquote><p>示例:<br>现有矩阵 matrix 如下：<br>[<br>  [1,   4,  7, 11, 15],<br>  [2,   5,  8, 12, 19],<br>  [3,   6,  9, 16, 22],<br>  [10, 13, 14, 17, 24],<br>  [18, 21, 23, 26, 30]<br>]<br>给定 target = 5，返回 true。<br>给定 target = 20，返回 false。</p></blockquote><p>链接：<a href="https://leetcode-cn.com/problems/sorted-matrix-search-lcci" target="_blank" rel="noopener">https://leetcode-cn.com/problems/sorted-matrix-search-lcci</a></p><p><strong>【分析一】</strong></p><p>这里没有用到二分法，只是简单的查找。<br>让<code>target</code>和<code>matrix</code>的右上角元素比较</p><ul><li>如果target比右上角的元素小，说明target在左边的列，列下标需要减1</li><li>如果target比右上角元素大，说明target在下面的行，行下标加1</li><li>如果target等于右上角元素，则返回True</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">searchMatrix</span><span class="params">(self, matrix, target)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type matrix: List[List[int]]</span></span><br><span class="line"><span class="string">        :type target: int</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> matrix:<span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">        <span class="comment">#使用target和右上角元素比较</span></span><br><span class="line">        m,n = len(matrix),len(matrix[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line">        i,j=<span class="number">0</span>,n<span class="number">-1</span></span><br><span class="line">        <span class="keyword">while</span> i &lt; m <span class="keyword">and</span> j &gt;=<span class="number">0</span>:</span><br><span class="line">            <span class="keyword">if</span> matrix[i][j] &gt; target:</span><br><span class="line">                <span class="comment">#说明target在左边的列</span></span><br><span class="line">                j-=<span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> matrix[i][j] &lt; target:</span><br><span class="line">                <span class="comment">#说明target在下面的行</span></span><br><span class="line">                i+=<span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">False</span></span><br></pre></td></tr></table></figure><h1><span id="4-总结">4. 总结</span></h1><ol><li>首先明确left，right，mid表示什么意思，确定了表示含义后，才可以确定left和right的范围</li><li>一般来说mid的含义要么是题目中要求的值，要么是下标。</li><li>在if语句中的条件时，mid的值或mid对应的函数值，需要和一个值进行比较，如果很容易发现和谁比较，就和谁比较，如果找不到就和mid+1的函数值比较</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;列表查找：从列表中查找指定元素&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;输出：列表&lt;/li&gt;
&lt;li&gt;输出：元素下标，找不到返回None或-1&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode之Array</title>
    <link href="http://yoursite.com/2020/03/13/Leetcode%E4%B9%8BArray/"/>
    <id>http://yoursite.com/2020/03/13/Leetcode之Array/</id>
    <published>2020-03-13T07:02:20.000Z</published>
    <updated>2020-07-14T06:43:29.394Z</updated>
    
    <content type="html"><![CDATA[<p>最近要开始准备刷Leetcode了，在这里记录下刷题的心得</p><a id="more"></a><!-- TOC --><ul><li><a href="#1-双指针">1. 双指针</a><ul><li><a href="#11-删除排序数组中的重复项">1.1. 删除排序数组中的重复项</a></li><li><a href="#12-移除元素">1.2. 移除元素</a></li><li><a href="#13-删除排序数组中的重复项-ii">1.3. 删除排序数组中的重复项 II</a></li><li><a href="#14-缺失的第一个正数">1.4. 缺失的第一个正数</a></li></ul></li><li><a href="#2-其他">2. 其他</a><ul><li><a href="#21-find-the-celebrity">2.1. Find the Celebrity</a></li><li><a href="#22-旋转数组">2.2. 旋转数组</a></li><li><a href="#23-猜数字游戏">2.3. 猜数字游戏</a></li><li><a href="#24-加油站">2.4. 加油站</a></li><li><a href="#25-多数元素">2.5. 多数元素</a></li><li><a href="#26-求众数-ii">2.6. 求众数 II</a></li><li><a href="#27-h指数">2.7. H指数</a></li><li><a href="#28-最短单词距离">2.8. 最短单词距离</a></li><li><a href="#29-最短单词距离-ii">2.9. 最短单词距离 II</a></li><li><a href="#210-最短单词距离之iii">2.10. 最短单词距离之III</a></li><li><a href="#211-存在重复元素">2.11. 存在重复元素</a></li><li><a href="#212-存在重复元素-ii">2.12. 存在重复元素 II</a></li><li><a href="#213-存在重复元素-iii">2.13. 存在重复元素 III</a></li><li><a href="#214-跳跃游戏">2.14. 跳跃游戏</a></li></ul></li><li><a href="#k数之和">K数之和</a><ul><li><a href="#两数之和">两数之和</a></li><li><a href="#三数之和">三数之和</a></li><li><a href="#四数之和">四数之和</a></li><li><a href="#k-sum">K sum</a></li></ul></li></ul><!-- /TOC --><h1><span id="1-双指针">1. 双指针</span></h1><h2><span id="11-删除排序数组中的重复项">1.1. 删除排序数组中的重复项</span></h2><p>给定一个<strong>排序数组</strong>，你需要在 原地 删除重复出现的元素，使得每个元素只出现一次，返回移除后数组的新长度。</p><p>不要使用额外的数组空间，你必须在 原地 修改输入数组 并在使用 <strong>O(1) 额外空间</strong>的条件下完成。</p><p><strong>【我的解法】</strong><br>用一个变量<code>i_first</code>表示待验证是否重复的值，因为该数据已经排好序，所以已经验证不重复的元素后面不会再次出现。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">removeDuplicates</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        delete_num = <span class="number">0</span></span><br><span class="line">        len_nums = len(nums)</span><br><span class="line">        i_first = <span class="keyword">None</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len_nums):</span><br><span class="line">            i-=delete_num</span><br><span class="line">            <span class="keyword">if</span> i == <span class="number">0</span>: </span><br><span class="line">                i_first = nums[i]</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">if</span> nums[i] == i_first:</span><br><span class="line">                nums.pop(i)</span><br><span class="line">                delete_num += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                i_first = nums[i]</span><br><span class="line">        <span class="keyword">return</span> len(nums)</span><br></pre></td></tr></table></figure><p><strong>【改进1】</strong><br>如果数组长度为1，可以直接返回。其余情况使用快慢双指针，快指针用来遍历数据，注意快指针从下标1开始遍历，慢指针指向非重复的值，如果快指针和慢指针不相等，快指针后移，如果相等，将快指针的值拷贝到慢指针+1的位置</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">removeDuplicates</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> len(nums) == <span class="number">1</span>:<span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        slow = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> fast <span class="keyword">in</span> range(<span class="number">1</span>,len(nums)):</span><br><span class="line">            <span class="keyword">if</span> nums[fast] != nums[slow]:</span><br><span class="line">                slow+=<span class="number">1</span></span><br><span class="line">                nums[slow] = nums[fast]</span><br><span class="line">        <span class="keyword">return</span> slow+<span class="number">1</span></span><br></pre></td></tr></table></figure><h2><span id="12-移除元素">1.2. 移除元素</span></h2><p>给你一个数组 nums 和一个值 val，你需要 原地 移除所有数值等于 val 的元素，并返回移除后数组的新长度。</p><p>不要使用额外的数组空间，你必须仅使用 <strong>O(1) 额外空间</strong>并 原地 修改输入数组。</p><p><strong>元素的顺序可以改变</strong>。你不需要考虑数组中超出新长度后面的元素。</p><p><strong>【我的解法】</strong>:<br>使用remove函数从原始数组中删除元素，但是每调用一次remove函数，数组的中元素会向前移，时间复杂度大</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">removeElement</span><span class="params">(self, nums, val)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :type val: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        delete_count = <span class="number">0</span></span><br><span class="line">        nums_len = len(nums)</span><br><span class="line">        <span class="keyword">for</span> idx <span class="keyword">in</span> range(nums_len):</span><br><span class="line">            idx -= delete_count</span><br><span class="line">            <span class="keyword">if</span> nums[idx] == val:</span><br><span class="line">                nums.remove(nums[idx])</span><br><span class="line">                delete_count +=<span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> len(nums)</span><br></pre></td></tr></table></figure><p><strong>【改进1】</strong>：<br>使用快慢双指针，拷贝覆盖，快指针依次遍历nums数组，慢指针指向不等于val的元素，如果fast的元素不等于val，则拷贝到nums[slow]位置，否则fast++</p><ul><li>这种思路在移除元素较多时更适合使用，最极端的情况是全部元素都需要移除，遍历一遍结束即可</li><li>时间复杂度：O(n)，空间复杂度：O(1)</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">removeElement</span><span class="params">(self, nums, val)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :type val: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        slow = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> fast <span class="keyword">in</span> range(len(nums)):</span><br><span class="line">            <span class="keyword">if</span> nums[fast] != val:</span><br><span class="line">                nums[slow] = nums[fast]</span><br><span class="line">                slow +=<span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> slow</span><br></pre></td></tr></table></figure><h2><span id="13-删除排序数组中的重复项-ii">1.3. 删除排序数组中的重复项 II</span></h2><p>给定一个排序数组，你需要在原地删除重复出现的元素，使得每个元素最多出现两次，返回移除后数组的新长度。</p><p>不要使用额外的数组空间，你必须在原地修改输入数组并在使用 O(1) 额外空间的条件下完成。</p><p><strong>【我的解法】</strong></p><p>经过上面2道题，本题也使用快慢双指针。fast用来遍历数组，slow用来表示当前需要验证的值，如果fast=slow，则slow的count+1，如果不相等，则更新slow并将fast的值拷贝到slow中。但是这种方案总是在一些边界时出现问题，例如[1,1,1,2,2,3,3]其中后两个值相等，但是在处理最后一个3时，if条件判断fast和slow相等，count+1，然后就直接return，这样输出的结果将是[1,1,2,2,3],为了解决这个问题，加了对边界条件的处理，如下，但是这样[1,1,1]会出错，返回[1]，调了很久都没有想出来怎么满足所有的条件。。。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">removeDuplicates</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        slow,count = <span class="number">0</span>,<span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> fast <span class="keyword">in</span> range(<span class="number">1</span>,len(nums)):</span><br><span class="line">            <span class="keyword">if</span> nums[fast] == nums[slow]:</span><br><span class="line">                count+=<span class="number">1</span></span><br><span class="line">                <span class="comment">#处理边界</span></span><br><span class="line">                <span class="keyword">if</span> fast == len(nums) - <span class="number">1</span> <span class="keyword">and</span> count ==<span class="number">2</span>:</span><br><span class="line">                    slow += <span class="number">1</span></span><br><span class="line">                    nums[slow] = nums[fast]</span><br><span class="line">                    count = <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                slow += <span class="number">2</span> <span class="keyword">if</span> count&gt;<span class="number">2</span> <span class="keyword">else</span> count</span><br><span class="line">                nums[slow] = nums[fast]</span><br><span class="line">                count = <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> slow+<span class="number">1</span></span><br></pre></td></tr></table></figure><p><strong>【改进1】</strong><br>思路：</p><ul><li>快指针：遍历整个数组；</li><li>慢指针：记录可以覆写数据的位置；</li><li>题目中规定每个元素最多出现两次，因此，应检查快指针指向的元素和慢指针前一个元素是否相等。相等只更新快指针；不相等时，先将慢指针后移一位，再将快指针指向的元素覆写入慢指针指向的单元，最后更新快指针。</li></ul><p>边界：</p><ul><li>当数组的长度小于等于 2 时，不需要操作，直接返回原数组即可。</li></ul><p>初始化：</p><ul><li>快指针用于遍历数组，但算法不可能操作序号小于 2 的元素，因此快指针初始值为 2；</li><li>初始状态下，慢指针应紧随快指针之后，因此初始值为 1；</li></ul><p>结束条件：</p><ul><li>快指针达到数组结尾。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">removeDuplicates</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> len(nums) == <span class="number">2</span>:<span class="keyword">return</span> <span class="number">2</span></span><br><span class="line">        slow = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> fast <span class="keyword">in</span> range(<span class="number">2</span>,len(nums)):</span><br><span class="line">            <span class="keyword">if</span> nums[fast] != nums[slow<span class="number">-1</span>]:</span><br><span class="line">                slow+=<span class="number">1</span></span><br><span class="line">                nums[slow] = nums[fast]</span><br><span class="line">        <span class="keyword">return</span> slow+<span class="number">1</span></span><br></pre></td></tr></table></figure><p><strong>【改进2】</strong></p><ul><li>使用count来记录每一个元素出现的次数，初始值为1</li><li>当fast和slow相等时，说明fast出现了多次，count+1，否则说明fast是新出现的，count重置为1</li><li>如果count小于等于2，满足条件，slow+1,把fast的值拷贝到slow中，如果 count大于2，fast的值舍弃，不要拷贝到slow中</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">removeDuplicates</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> len(nums) == <span class="number">2</span>:<span class="keyword">return</span> <span class="number">2</span></span><br><span class="line">        slow,count = <span class="number">0</span>,<span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> fast <span class="keyword">in</span> range(<span class="number">1</span>,len(nums)):</span><br><span class="line">            <span class="keyword">if</span> nums[fast] == nums[slow]:</span><br><span class="line">                count+=<span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                count = <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> count &lt;= <span class="number">2</span>:</span><br><span class="line">                slow += <span class="number">1</span></span><br><span class="line">                nums[slow] = nums[fast]</span><br><span class="line">        <span class="keyword">return</span> slow+<span class="number">1</span></span><br></pre></td></tr></table></figure><h2><span id="14-缺失的第一个正数">1.4. 缺失的第一个正数</span></h2><p>给定一个未排序的整数数组，找出其中没有出现的最小的正整数。<br><strong>【我的解法】</strong><br>首先找到nums中的最大值和最小值，然后遍历min和max之间的所有数，判断是否在数组中。但是这样会出现内存溢出的问题</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">firstMissingPositive</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> len(nums) == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        <span class="comment">#先遍历数组找max和min</span></span><br><span class="line">        nums_min,nums_max = min(nums),max(nums)</span><br><span class="line">        <span class="keyword">if</span> nums_max &lt; <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        <span class="keyword">elif</span> nums_min &lt; <span class="number">0</span>:</span><br><span class="line">            nums_min = <span class="number">1</span></span><br><span class="line">        <span class="keyword">elif</span> nums_min &gt; <span class="number">0</span> <span class="keyword">and</span> nums_min != <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span> </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(nums_min,nums_max):</span><br><span class="line">            <span class="keyword">if</span> i <span class="keyword">not</span> <span class="keyword">in</span> nums:</span><br><span class="line">                <span class="keyword">return</span> i</span><br><span class="line">        <span class="keyword">return</span> nums_max+<span class="number">1</span></span><br></pre></td></tr></table></figure><p><strong>【改进1】</strong><br>使用快慢指针。</p><ul><li>先对nums排序</li><li>对特征情况处理：nums为空或最小值大于1，返回1</li><li>快指针遍历数组，慢指针表示最小的正整数，初始化为1</li><li>遍历数组，如果fast小于等于0，继续；如果fast和slow相等，说明slow在数组中，slow加1。遍历完之后返回slow，即最小的正整数。</li><li>不能在for循环的else中返回slow，如果list中有重复元素会报错，例如[0,1,1,2,2]</li><li>为了解决nums中有重复元素问题，使用set(sorted(nums))，但是这样也报错，因为set会让原先已经排好序的数组又变得乱序，改成sorted(set(nums))就可以了</li><li>但是排序的时间复杂度不符合题目要求</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">firstMissingPositive</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        nums = sorted(nums)</span><br><span class="line">        <span class="keyword">if</span> len(nums) ==<span class="number">0</span> <span class="keyword">or</span> nums[<span class="number">0</span>] &gt; <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        slow = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> fast <span class="keyword">in</span> nums:</span><br><span class="line">            <span class="keyword">if</span> fast &lt;= <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">if</span> fast == slow:</span><br><span class="line">                slow+=<span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> slow</span><br></pre></td></tr></table></figure><p><strong>【改进2】</strong><br>要返回丢失的最小正整数，该正整数一定在[1,n+1]之间。题目要求常数空间，所以将原始数组当做哈希表使用。</p><ul><li>最终返回的数在[1,n+1]之间，当[1,n]都在数组中，才会返回n+1</li><li>对[1,n]之间的数重新找位置。<br>数字1放在下标为0的位置<br>数字2放在下标为1的位置<br>…<br>数字n放在下标为n-1的位置<br>如果遇到的数不在[1,n]之间，不用换位置</li><li>在遍历一次数组，遇到第一个数字不等于下标+1的值，就是丢失的正整数，返回即可。如果遍历完整个数组，都没有return，说明[1,n]的所有数都在数组中，返回n+1</li><li>空间复杂度$O(1)$</li><li>时间复杂度$O(n)$</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">firstMissingPositive</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        n = len(nums)<span class="comment">#一共有n个数</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">            <span class="keyword">while</span> (nums[i] &gt;= <span class="number">1</span> <span class="keyword">and</span> nums[i] &lt;= n <span class="keyword">and</span> nums[i] != nums[nums[i] - <span class="number">1</span>]):</span><br><span class="line">                self.swap(nums,i,nums[i]<span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">            <span class="keyword">if</span> nums[i] != i + <span class="number">1</span>:</span><br><span class="line">                <span class="keyword">return</span> i+<span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> n+<span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">swap</span><span class="params">(self,nums,src,des)</span>:</span></span><br><span class="line">        temp = nums[des]</span><br><span class="line">        nums[des] = nums[src]</span><br><span class="line">        nums[src] = temp</span><br></pre></td></tr></table></figure><h1><span id="2-其他">2. 其他</span></h1><h2><span id="21-find-the-celebrity">2.1. Find the Celebrity</span></h2><p>在n个人中寻找名人，所谓名人就是每个人都认识他，他却不认识任何人，限定了只有1个或0个名人，给定了一个 API 函数，输入a和b，<code>bool know(a,b)</code>用来判断a是否认识b，让我们尽可能少的调用这个函数，来找出人群中的名人,能找到名人返回名人的下标，否则返回-1</p><p><strong>【解法1】</strong><br>遍历所有的人，判断i是否是名人，就要看i是否满足名人的条件，如果剩下的n-1个人中有i认识的人，或者有人不认识i，则i不是名人，使用break跳出内循环，继续遍历下一个i。如果剩下的n-1个人中i都不认识并且n-1个人都认识i，则返回i，否则返回-1。找出一种解法最可能少的调用<code>know</code>函数<br>时间复杂度$O(n^2)$</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">findCelebrity</span><span class="params">(n)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(n):</span><br><span class="line">            <span class="keyword">if</span>(i!=j <span class="keyword">and</span> (know(i,j) <span class="keyword">or</span> <span class="keyword">not</span> know(j,i))):</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">if</span>(j==n):</span><br><span class="line">            <span class="keyword">return</span> i</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span></span><br></pre></td></tr></table></figure><p><strong>【解法2】</strong><br>先找出名人的candidate，然后再验证这个candidate是否合理。</p><ul><li>第一步：找candidate,先初始化candidate为0，然后遍历所有人，如果candidate认识i，则candidate不符合，将candidate换成i。遍历完所有的人，最终选出一个candidate，这个candidate不认识它后面所有的人</li><li>第二步：验证candidate。先验证candicate前面的人，如果前面的人中不认识candicate，或candicate认识某人，则candicate不是名人，返回-1。再验证candidate后面的人，因为在选择candidate时已经知道candidate不认识后面的人，所以这里只需要验证后面的人是否认识candidate就可以了</li><li>时间复杂度$O(n)$</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">findCelebrity</span><span class="params">(n)</span>:</span></span><br><span class="line">    candidate = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">        <span class="keyword">if</span>(i != candicate <span class="keyword">and</span> know(candidate,i)):</span><br><span class="line">            candicate = i</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(candicate):</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">not</span> know(i,candidate) <span class="keyword">or</span> know(candidate,i)):</span><br><span class="line">            retur</span><br><span class="line">            n <span class="number">-1</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(candicate+<span class="number">1</span>,n):</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">not</span> know(i,candidate)):</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">    <span class="keyword">return</span> candidate</span><br></pre></td></tr></table></figure><h2><span id="22-旋转数组">2.2. 旋转数组</span></h2><p>给定一个数组，将数组中的元素向右移动 k 个位置，其中 k 是非负数。</p><p><strong>【我的解法】</strong><br>当时使用找规律的方法，旋转k步，原先下标为i的元素，旋转之后下标变成多少，然后赋值。但是有个问题赋值完后数组原先的值就丢失了，所以一直在纠结这个问题，下面的解法没有实现</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">rotate</span><span class="params">(self, nums, k)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :type k: int</span></span><br><span class="line"><span class="string">        :rtype: None Do not return anything, modify nums in-place instead.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        n = len(nums)</span><br><span class="line">        k = k % n</span><br><span class="line">        nums_0 = nums[<span class="number">0</span>] <span class="comment">#将来放在(0+k)%n的位置</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>,k):</span><br><span class="line">            <span class="keyword">if</span> i == <span class="number">0</span>:</span><br><span class="line">                nums[i] = nums[(n+i-k)%n]</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                tmp = nums[i]</span><br><span class="line">                nums[i] = nums[(n+i-k)%n]</span><br><span class="line">                nums[(n+i-k)%k] = tmp</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(k+<span class="number">1</span>,n):</span><br><span class="line">            nums[i] = 。。。</span><br><span class="line">        nums[k] = nums_0</span><br><span class="line">        <span class="keyword">return</span> nums</span><br></pre></td></tr></table></figure><p><strong>【改进1】</strong><br>利用python中数组的特性，pop()每次弹出最后一个元素，然后使用insert将其插入到开头</p><ul><li>空间复杂度：$O(1)$</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">rotate</span><span class="params">(self, nums, k)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :type k: int</span></span><br><span class="line"><span class="string">        :rtype: None Do not return anything, modify nums in-place instead.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        k %= len(nums)</span><br><span class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> range(k):</span><br><span class="line">            nums.insert(<span class="number">0</span>,nums.pop())</span><br><span class="line">        <span class="keyword">return</span> nums</span><br></pre></td></tr></table></figure><p><strong>【改进2】</strong><br>例如<code>1,2,3,4,5,6,7</code>，当k=3时，旋转后的数组为<code>5,6,7,1,2,3,4</code>，就是将原先数据中[-k:]的元素前移，将[:-k]的元素后移</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">rotate</span><span class="params">(self, nums, k)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :type k: int</span></span><br><span class="line"><span class="string">        :rtype: None Do not return anything, modify nums in-place instead.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        k %= len(nums)</span><br><span class="line">        nums[:] = nums[-k:]+nums[:-k]</span><br><span class="line">        <span class="keyword">return</span> nums</span><br></pre></td></tr></table></figure><p>【优秀题解3】<br>使用3次翻转，先翻转所有数据，再翻转前k个，再翻转后n-k个。</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">k = <span class="number">3</span></span><br><span class="line">原始数据：<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span></span><br><span class="line">翻转全部：<span class="number">7</span>,<span class="number">6</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span></span><br><span class="line">翻转前k个：<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span></span><br><span class="line">翻转后n-k个：<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">rotate</span><span class="params">(self, nums, k)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :type k: int</span></span><br><span class="line"><span class="string">        :rtype: None Do not return anything, modify nums in-place instead.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        k %= len(nums)</span><br><span class="line">        nums[:] = nums[-k:]+nums[:-k]</span><br><span class="line">        <span class="keyword">return</span> nums</span><br></pre></td></tr></table></figure><p>【总结】以上3种解法都是利用Python的特征，非常简单！人生苦短，我用Python！</p><h2><span id="23-猜数字游戏">2.3. 猜数字游戏</span></h2><p>你正在和你的朋友玩 猜数字（Bulls and Cows）游戏：你写下一个数字让你的朋友猜。每次他猜测后，你给他一个提示，告诉他有多少位数字和确切位置都猜对了（称为“Bulls”, 公牛），有多少位数字猜对了但是位置不对（称为“Cows”, 奶牛）。你的朋友将会根据提示继续猜，直到猜出秘密数字。</p><p>请写出一个根据秘密数字和朋友的猜测数返回提示的函数，用 A 表示公牛，用 B 表示奶牛。</p><p>请注意秘密数字和朋友的猜测数都可能含有重复数字。</p><blockquote><p>输入: secret = “1807”, guess = “7810”<br>输出: “1A3B”<br>解释: 1 公牛和 3 奶牛。公牛是 8，奶牛是 0, 1 和 7。</p></blockquote><p><strong>【我的解法】</strong><br>首先找出A的个数，然后找出B的个数。</p><ul><li>先找到A的个数，并记录这些数字的下标</li><li>除去A的数字，记录剩下的secret中每个数字及下标。</li><li>找B的个数。遍历guess中的数字，如果该数字在secret中，并且该数字验证的个数小于secret中该数字的个数，B的个数加一</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getHint</span><span class="params">(self, secret, guess)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type secret: str</span></span><br><span class="line"><span class="string">        :type guess: str</span></span><br><span class="line"><span class="string">        :rtype: str</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="comment">#先找到A</span></span><br><span class="line">        A = <span class="number">0</span></span><br><span class="line">        A_index = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(secr  et)):</span><br><span class="line">            <span class="keyword">if</span> secret[i] == guess[i]:</span><br><span class="line">                A +=<span class="number">1</span></span><br><span class="line">                A_index.append(i)</span><br><span class="line">        <span class="comment">#记录secret中剩下的数字及下标</span></span><br><span class="line">        other_index = [i <span class="keyword">for</span> i <span class="keyword">in</span> list(range(len(secret))) <span class="keyword">if</span> i <span class="keyword">not</span> <span class="keyword">in</span> A_index]</span><br><span class="line">        secret_dict = &#123;&#125;</span><br><span class="line">        secret_verify = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> other_index:</span><br><span class="line">            <span class="keyword">if</span> secret[i] <span class="keyword">not</span> <span class="keyword">in</span> secret_dict:</span><br><span class="line">                secret_dict[secret[i]] = [i]</span><br><span class="line">                secret_verify[secret[i]] = <span class="number">0</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                secret_dict[secret[i]].append(i)</span><br><span class="line">        <span class="comment">#找B的个数</span></span><br><span class="line">        B = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> other_index:</span><br><span class="line">            current = guess[i]</span><br><span class="line">            <span class="keyword">if</span> (current <span class="keyword">in</span> secret_dict) <span class="keyword">and</span> secret_verify[current] &lt; len(secret_dict[current]):</span><br><span class="line">                B += <span class="number">1</span></span><br><span class="line">                secret_verify[current] += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> str(A)+<span class="string">'A'</span>+str(B)+<span class="string">'B'</span></span><br></pre></td></tr></table></figure><h2><span id="24-加油站">2.4. 加油站</span></h2><p>在一条环路上有 N 个加油站，其中第 i 个加油站有汽油 gas[i] 升。</p><p>你有一辆油箱容量无限的的汽车，从第 i 个加油站开往第 i+1 个加油站需要消耗汽油 cost[i] 升。你从其中的一个加油站出发，开始时油箱为空。</p><p>如果你可以绕环路行驶一周，则返回出发时加油站的编号，否则返回 -1。</p><p>说明: </p><p>如果题目有解，该答案即为唯一答案。<br>输入数组均为非空数组，且长度相同。<br>输入数组中的元素均为非负数。</p><p><strong>【我的解法】</strong><br>暴力搜索</p><ul><li>先找出能够作为起始点的加油站，作为候选集。即gas[i] &gt;= cost[i]，从当前加油站出发能够走到下一个加油站</li><li><p>遍历所有的候选集。对于某一个候选加油站。终止的条件是：</p><ul><li>if cur_idx != start的前一个加油站，cur_gas-cost[cur_idx]+gas[next_idx] &lt; cost[next_idx]，即当前加油站出发走到下一个加油站加上油，不够走到下下一个加油站。则当前候选加油站失效，遍历下一个候选集</li><li>if cur_idx == start的前一个加油站，cur_gas &lt; cost[cur_idx],当前的油不够走到下一个加油站。则当前候选加油站失效，遍历下一个候选集</li></ul></li><li>空间复杂度$O(1)$</li><li>时间复杂度$O(N^2)$</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">canCompleteCircuit</span><span class="params">(self, gas, cost)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type gas: List[int]</span></span><br><span class="line"><span class="string">        :type cost: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        n = len(gas)</span><br><span class="line">        candidate = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">            <span class="keyword">if</span> gas[i] &gt;= cost[i]:</span><br><span class="line">                candidate.append(i)</span><br><span class="line">        <span class="keyword">for</span> start <span class="keyword">in</span> candidate:</span><br><span class="line">            cur_index = start</span><br><span class="line">            cur_gas = gas[cur_index]</span><br><span class="line">            next_index = (cur_index+<span class="number">1</span>)%n</span><br><span class="line">            tmp = n<span class="number">-1</span> <span class="keyword">if</span> start==<span class="number">0</span> <span class="keyword">else</span> start<span class="number">-1</span></span><br><span class="line">            <span class="keyword">while</span> cur_index != tmp:</span><br><span class="line">                <span class="keyword">if</span> cur_gas - cost[cur_index] + gas[next_index] &gt;= cost[next_index]:</span><br><span class="line">                    cur_gas = cur_gas - cost[cur_index] + gas[next_index]</span><br><span class="line">                    cur_index = next_index</span><br><span class="line">                    next_index = (cur_index+<span class="number">1</span>)%n</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">if</span> cur_index == tmp <span class="keyword">and</span> cur_gas &gt;= cost[cur_index]:</span><br><span class="line">                <span class="keyword">return</span> start</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span></span><br></pre></td></tr></table></figure><p>【改进1】</p><ul><li>时间复杂度$O(N)$</li><li>空间复杂度$O(1)$<br>这个题解还没有看懂，以后再看</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">canCompleteCircuit</span><span class="params">(self, gas, cost)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type gas: List[int]</span></span><br><span class="line"><span class="string">        :type cost: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        cur_gas = <span class="number">0</span><span class="comment">#当前剩余油量</span></span><br><span class="line">        delta_gas = <span class="number">0</span><span class="comment">#整个过程中油量和消耗的delta</span></span><br><span class="line">        start = <span class="number">0</span><span class="comment">#起始位置</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(gas)):</span><br><span class="line">            cur_gas += gas[i] - cost[i]</span><br><span class="line">            delta_gas += gas[i] - cost[i]</span><br><span class="line">            <span class="keyword">if</span> cur_gas &lt; <span class="number">0</span>:</span><br><span class="line">                <span class="comment">#当前i不满足时，start为什么跳到i+1，而不是start+1?</span></span><br><span class="line">                start = i+<span class="number">1</span></span><br><span class="line">                cur_gas = <span class="number">0</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span> <span class="keyword">if</span> delta_gas &lt; <span class="number">0</span> <span class="keyword">else</span> start</span><br></pre></td></tr></table></figure><h2><span id="25-多数元素">2.5. 多数元素</span></h2><p>给定一个大小为 n 的数组，找到其中的多数元素。多数元素是指在数组中出现次数大于 ⌊ n/2 ⌋ 的元素。</p><p>你可以假设数组是非空的，并且给定的数组总是存在多数元素。</p><p><strong>【我的解法】</strong><br>使用字典保存每个数字出现的个数，然后按照出现排序，找到出现次数最多的key</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">majorityElement</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        count = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> nums:</span><br><span class="line">            <span class="keyword">if</span> i <span class="keyword">not</span> <span class="keyword">in</span> count:</span><br><span class="line">                count[i] = <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                count[i]+=<span class="number">1</span></span><br><span class="line">        count = sorted(count.items(),key=<span class="keyword">lambda</span> x:x[<span class="number">1</span>],reverse=<span class="keyword">True</span>)</span><br><span class="line">        <span class="keyword">return</span> count[<span class="number">0</span>][<span class="number">0</span>]</span><br></pre></td></tr></table></figure><p><strong>【改进1】</strong><br>摩尔投票法的详细步骤：</p><ul><li>我们维护一个候选众数 major 和它出现的次数 count。初始时 major 可以为任意值，count 为 0；</li><li><p>遍历数组 nums 中的所有元素，对于每个元素 x，在判断 x 之前，如果 count 的值为 0，我们先将 x 的值赋予major，随后我们判断 x：</p><ul><li>如果 x 与 major 相等，那么计数器 count 的值增加 1；</li><li>如果 x 与 major 不等，那么计数器 count 的值减少 1。</li></ul></li><li><p>在遍历完成后，major 即为整个数组的众数。</p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">majorityElement</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="comment">#摩尔投票法</span></span><br><span class="line">        major = <span class="number">0</span></span><br><span class="line">        count = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> nums:</span><br><span class="line">            <span class="keyword">if</span> count == <span class="number">0</span>:</span><br><span class="line">                major = i</span><br><span class="line">            <span class="keyword">if</span> i == major:</span><br><span class="line">                count += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                count -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> major</span><br></pre></td></tr></table></figure><h2><span id="26-求众数-ii">2.6. 求众数 II</span></h2><p>给定一个大小为 n 的数组，找出其中所有出现超过 ⌊ n/3 ⌋ 次的元素。</p><p>说明: 要求算法的时间复杂度为 O(n)，空间复杂度为 O(1)。</p><p>同样使用摩尔投票法，参考<br><a href="https://leetcode-cn.com/problems/majority-element-ii/solution/liang-fu-dong-hua-yan-shi-mo-er-tou-piao-fa-zui-zh/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/majority-element-ii/solution/liang-fu-dong-hua-yan-shi-mo-er-tou-piao-fa-zui-zh/</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">majorityElement</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: List[int]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        cand1,count1 = <span class="number">0</span>,<span class="number">0</span></span><br><span class="line">        cand2,count2 = <span class="number">0</span>,<span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> nums:</span><br><span class="line">            <span class="keyword">if</span> i == cand1:</span><br><span class="line">                count1 +=<span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> i == cand2:</span><br><span class="line">                count2 += <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> count1 == <span class="number">0</span>:</span><br><span class="line">                cand1 = i</span><br><span class="line">                count1 +=<span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> count2 == <span class="number">0</span>:</span><br><span class="line">                cand2 = i</span><br><span class="line">                count2 += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                count1 -= <span class="number">1</span></span><br><span class="line">                count2 -= <span class="number">1</span></span><br><span class="line">        count1,count2 = <span class="number">0</span>,<span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> nums:</span><br><span class="line">            <span class="keyword">if</span> i == cand1:</span><br><span class="line">                count1 += <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> i == cand2:</span><br><span class="line">                count2 += <span class="number">1</span></span><br><span class="line">        result = []</span><br><span class="line">        <span class="keyword">if</span> count1 &gt; int(len(nums)/<span class="number">3</span>):</span><br><span class="line">            result.append(cand1)</span><br><span class="line">        <span class="keyword">if</span> count2 &gt; int(len(nums)/<span class="number">3</span>):</span><br><span class="line">            result.append(cand2)</span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure><h2><span id="27-h指数">2.7. H指数</span></h2><p>给定一位研究者论文被引用次数的数组（被引用次数是非负整数）。编写一个方法，计算出研究者的 h 指数。</p><p>h 指数的定义: “h 代表“高引用次数”（high citations），一名科研人员的 h 指数是指他（她）的 （N 篇论文中）有 h 篇论文分别被引用了至少 h 次。（其余的 N - h 篇论文每篇被引用次数不多于 h 次。）”</p><p><strong>【题解】</strong><br>先将数组从大到小排序，使用直方图表示，直方图上最大正方形的变长h就是最终的答案。<code>citations[i]&gt;i</code></p><ul><li>时间复杂度:$nlog(n)$，排序的下限</li></ul><p><a href="https://leetcode-cn.com/problems/h-index/solution/hzhi-shu-by-leetcode/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/h-index/solution/hzhi-shu-by-leetcode/</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hIndex</span><span class="params">(self, citations)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type citations: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> len(citations) == <span class="number">0</span> <span class="keyword">or</span> (len(citations)==<span class="number">1</span> <span class="keyword">and</span> citations[<span class="number">0</span>]==<span class="number">0</span>):</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> len(citations) == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        citations = sorted(citations,reverse=<span class="keyword">True</span>)</span><br><span class="line">        j = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(citations)):</span><br><span class="line">            <span class="keyword">if</span> citations[i] &gt; j:</span><br><span class="line">                j+=<span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> j</span><br></pre></td></tr></table></figure><h2><span id="28-最短单词距离">2.8. 最短单词距离</span></h2><p>Given a list of words and two words word1 and word2, return the shortest distance between these two words in the list.</p><p>Example:<br>Assume that words = [“practice”, “makes”, “perfect”, “coding”, “makes”].</p><p>Input: word1 = “coding”, word2 = “practice”<br>Output: 3<br>Input: word1 = “makes”, word2 = “coding”<br>Output: 1<br>Note:<br>You may assume that word1 does not equal to word2, and word1 and word2 are both in the list.<br>2个词不相同，并且都在list中</p><p><strong>【我的解法】</strong><br>首先遍历words数据，分别记录word1和word2的位置，然后遍历这些位置数组，找出最短的距离</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">shortestDistance</span><span class="params">(words,word1,word2)</span>:</span></span><br><span class="line">    idx1,idx2 = [],[]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(words)):</span><br><span class="line">        <span class="keyword">if</span> words[i] == word1:</span><br><span class="line">            idx1.append(i)</span><br><span class="line">        <span class="keyword">if</span> words[i] == word2:</span><br><span class="line">            idx2.append(i)</span><br><span class="line">    result = float(<span class="string">"inf"</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> idx1:</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> idx2:</span><br><span class="line">            result = min(result,abs(i-j))</span><br><span class="line">    <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure><p><strong>【改进1】</strong><br>不再使用数组来保存2个词的位置，只遍历一遍数组。用2个变量idx1和idx2来记录word1和word2的位置。如果idx1和idx2都不为-1时，更新result</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">shortestDistance</span><span class="params">(words,word1,word2)</span>:</span></span><br><span class="line">    idx1,idx2 = <span class="number">-1</span>,<span class="number">-1</span></span><br><span class="line">    result = float(<span class="string">"inf"</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(words)):</span><br><span class="line">        <span class="keyword">if</span> words[i] == word1:</span><br><span class="line">            idx1 = i</span><br><span class="line">        <span class="keyword">if</span> words[i] == word2:</span><br><span class="line">            idx2 = i</span><br><span class="line">        <span class="keyword">if</span> idx1 != <span class="number">-1</span> <span class="keyword">and</span> idx2 != <span class="number">-1</span>:</span><br><span class="line">            result = min(result,abs(idx1-idx2))</span><br><span class="line">    <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure><h2><span id="29-最短单词距离-ii">2.9. 最短单词距离 II</span></h2><p>This is a follow up of Shortest Word Distance. The only difference is now you are given the list of words and your method will be called repeatedly many times with different parameters. How would you optimize it?</p><p>Design a class which receives a list of words in the constructor, and implements a method that takes two words word1 and word2 and return the shortest distance between these two words in the list.</p><p>For example,<br>Assume that words = [“practice”, “makes”, “perfect”, “coding”, “makes”].</p><p>Given word1 = “coding”, word2 = “practice”, return 3.<br>Given word1 = “makes”, word2 = “coding”, return 1.</p><p>Note:<br>You may assume that word1 does not equal to word2, and word1 and word2 are both in the list.<br>这道题和上一道的区别：给定一个words列表，求最短距离函数会被调用很多次，算是对上一题的优化</p><p><strong>【解法1】</strong><br>因为最短距离函数会被调用很多次，所以我们可以提前讲words中每个单词的位置记录在dict中，在计算距离时，取出这2个单词的位置计算最短距离。</p><ul><li>时间复杂度：$O(M*N)$，其中M和N是2个单词的个数</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WordDistance</span><span class="params">(object)</span>:</span></span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, words)</span>:</span></span><br><span class="line">        <span class="keyword">from</span> collections <span class="keyword">import</span> defaultdict</span><br><span class="line">        self.words = words</span><br><span class="line">        self.dict= defaultdict(list)</span><br><span class="line">        <span class="keyword">for</span> i, word <span class="keyword">in</span> enumerate(words):</span><br><span class="line">            self.dict[word].append(i)</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">shortest</span><span class="params">(self, word1, word2)</span>:</span></span><br><span class="line">        res = float(<span class="string">'inf'</span>)</span><br><span class="line">        <span class="keyword">for</span> l1 <span class="keyword">in</span> self.dict[word1]:</span><br><span class="line">            <span class="keyword">for</span> l2 <span class="keyword">in</span> self.dict[word2]:</span><br><span class="line">                res = min(res, abs(l1 - l2))</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><p><strong>【解法2】</strong><br>将上述的时间复杂度$O(M*N)$变成$O(M+N)$<br>使用2个指针记录word1和word2的位置，每次让位置较小的指针加1</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WordDistance</span><span class="params">(object)</span>:</span></span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, words)</span>:</span></span><br><span class="line">        <span class="keyword">from</span> collections <span class="keyword">import</span> defaultdict</span><br><span class="line">        self.words = words</span><br><span class="line">        self.dict= defaultdict(list)</span><br><span class="line">        <span class="keyword">for</span> i, word <span class="keyword">in</span> enumerate(words):</span><br><span class="line">            self.dict[word].append(i)</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">shortest</span><span class="params">(self, word1, word2)</span>:</span></span><br><span class="line">        res = float(<span class="string">'inf'</span>)</span><br><span class="line">        p1,p2 = <span class="number">0</span>,<span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> p1 &lt; len(self.dict[word1]) <span class="keyword">and</span> p2 &lt; len(self.dict[word2]):</span><br><span class="line">            result = min(result,abs(self.dict[word1][p1] - self.dict[word2][p2]))</span><br><span class="line">            <span class="keyword">if</span> self.dict[word1][p1] &lt; self.dict[word2][p2]:</span><br><span class="line">                p1 += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                p2 += <span class="number">2</span></span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure><h2><span id="210-最短单词距离之iii">2.10. 最短单词距离之III</span></h2><p>Given a list of words and two words word1 and word2, return the shortest distance between these two words in the list.</p><p>word1 and word2 may be the same and they represent two individual words in the list.</p><p>Example:<br>Assume that words = [“practice”, “makes”, “perfect”, “coding”, “makes”].</p><p>Input: word1 = “makes”, word2 = “coding”<br>Output: 1<br>Input: word1 = “makes”, word2 = “makes”<br>Output: 3<br>Note:<br>You may assume word1 and word2 are both in the list.<br>对第一道题的区别：word1和word2可能相同</p><p><strong>【解法1】</strong><br>word1和word2可能相等，使用pre_idx1记录上一个idx1的位置。接下来分为2种情况，word1和word2相等时，根据pre_idx1和idx1来更新result，不相等时，根据idx1和idx2来更新result</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">shortestDistance</span><span class="params">(words,word1,word2)</span>:</span></span><br><span class="line">    idx1,idx2 = <span class="number">-1</span>,<span class="number">-1</span></span><br><span class="line">    result = float(<span class="string">"inf"</span>)</span><br><span class="line">    pre_idx1 = <span class="number">-1</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(words)):</span><br><span class="line">        <span class="keyword">if</span> words[i] == word1:</span><br><span class="line">            idx1 = i</span><br><span class="line">        <span class="keyword">if</span> words[i] == word2:</span><br><span class="line">            idx2 = i</span><br><span class="line">        <span class="keyword">if</span> idx1 != <span class="number">-1</span> <span class="keyword">and</span> idx2 != <span class="number">-1</span>:</span><br><span class="line">            <span class="keyword">if</span> word1 == word2:</span><br><span class="line">                <span class="keyword">if</span> pre_idx1 == <span class="number">-1</span> <span class="keyword">or</span> pre_idx1 == idx1:</span><br><span class="line">                    pre_idx1 = idx1</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="comment">#如果pre_idx1和idx1不相等，更新result</span></span><br><span class="line">                    result = min(result,abs(pre_idx1-idx1))</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                result = min(result,abs(idx1-idx2))</span><br><span class="line">    <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">shortestDistance</span><span class="params">(words,word1,word2)</span>:</span></span><br><span class="line">    idx1,idx2 = <span class="number">-1</span>,<span class="number">-1</span></span><br><span class="line">    result = float(<span class="string">"inf"</span>)</span><br><span class="line">    <span class="keyword">if</span> word1 != word2:</span><br><span class="line">        <span class="keyword">if</span> words[i] == word1:</span><br><span class="line">            idx1 = i</span><br><span class="line">        <span class="keyword">if</span> words[i] == word2:</span><br><span class="line">            idx2 = i</span><br><span class="line">        <span class="keyword">if</span> idx1 != <span class="number">-1</span> <span class="keyword">and</span> idx2 != <span class="number">-1</span>:</span><br><span class="line">            result = min(result,abs(idx1-idx2))</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        pre_idx1 = <span class="number">-1</span></span><br><span class="line">        <span class="keyword">for</span> i,word <span class="keyword">in</span> enumerate(words):</span><br><span class="line">            <span class="keyword">if</span> word == word1:</span><br><span class="line">                <span class="keyword">if</span> pre_idx1 != <span class="number">-1</span>:</span><br><span class="line">                    result = min(result,abs(i-pre_idx1))</span><br><span class="line">                pre_idx1 = i</span><br><span class="line">    <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure><h2><span id="211-存在重复元素">2.11. 存在重复元素</span></h2><p>给定一个整数数组，判断是否存在重复元素。</p><p>如果任何值在数组中出现至少两次，函数返回 true。如果数组中每个元素都不相同，则返回 false。</p><blockquote><p>示例 1:<br>输入: [1,2,3,1]<br>输出: true</p></blockquote><p>【我的解法】<br>使用字典</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">containsDuplicate</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        counts = dict()</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> nums:</span><br><span class="line">            <span class="keyword">if</span> i <span class="keyword">not</span> <span class="keyword">in</span> counts:</span><br><span class="line">                counts[i] = <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">False</span></span><br></pre></td></tr></table></figure><h2><span id="212-存在重复元素-ii">2.12. 存在重复元素 II</span></h2><p>给定一个整数数组和一个整数 k，判断数组中是否存在两个不同的索引 i 和 j，使得 nums [i] = nums [j]，并且 i 和 j 的差的 绝对值 至多为 k。</p><blockquote><p>示例 1:<br>输入: nums = [1,2,3,1], k = 3<br>输出: true</p></blockquote><p><strong>【我的解法】</strong><br>首先找到重复的元素，然后再遍历重复元素的下标，其差值是否&lt;=k，时间复杂度高</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">containsNearbyDuplicate</span><span class="params">(self, nums, k)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :type k: int</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="comment">#首先找出重复的元素</span></span><br><span class="line">        counts = collections.defaultdict(list)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums)):</span><br><span class="line">            counts[nums[i]].append(i)</span><br><span class="line">        <span class="keyword">for</span> value <span class="keyword">in</span> list(counts.values()):</span><br><span class="line">            <span class="keyword">if</span> len(value) &gt;= <span class="number">2</span>:</span><br><span class="line">                <span class="comment">#找出下标差最大的值</span></span><br><span class="line">                <span class="keyword">for</span> i <span class="keyword">in</span> range(len(value)):</span><br><span class="line">                    <span class="keyword">for</span> j <span class="keyword">in</span> range(len(value)):</span><br><span class="line">                        <span class="keyword">if</span> i!=j <span class="keyword">and</span> abs(value[i]-value[j]) &lt;= k:</span><br><span class="line">                            <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">False</span></span><br></pre></td></tr></table></figure><p><strong>【改进1】</strong><br>使用集合，集合的长度始终是k，如果集合中的k个元素存在相同元素，则说明这2个元素的距离&lt;=k,返回True。如果集合中没有当前元素，将其加入到set中，判断set中长度是否&gt;k,如果超过k，则将set中的第一个元素删掉。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">containsNearbyDuplicate</span><span class="params">(self, nums, k)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :type k: int</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="comment">#使用一个长度为k的set</span></span><br><span class="line">        k_set = set()</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums)):</span><br><span class="line">            <span class="keyword">if</span> nums[i] <span class="keyword">in</span> k_set:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line"></span><br><span class="line">            k_set.add(nums[i])</span><br><span class="line">            <span class="keyword">if</span> len(k_set) &gt; k:</span><br><span class="line">                k_set.remove(nums[i-k])</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">False</span></span><br></pre></td></tr></table></figure><h2><span id="213-存在重复元素-iii">2.13. 存在重复元素 III</span></h2><p>给定一个整数数组，判断数组中是否有两个不同的索引 i 和 j，使得 nums [i] 和 nums [j] 的差的绝对值最大为 t，并且 i 和 j 之间的差的绝对值最大为 ķ。</p><blockquote><p>示例 1:<br>输入: nums = [1,2,3,1], k = 3, t = 0<br>输出: true</p></blockquote><p><strong>【题解1】</strong><br>找出2个数，其下标之差&lt;=k,数之差&lt;=t<br>将数据放在桶中，每个桶放t+1个数，假设t=2<br>桶编号-1: [-3,-2,-1]<br>桶编号0：[0,1,2]<br>桶编号1：[3,4,5]<br>桶编号2：[6,7,8]<br>桶编号i：[i<em>(t+1),i</em>(t+1)+1,i*(t+1)+2]<br>首先编写一个分配桶的函数，根据数字i，计算被分配到哪个桶中。<br>dict中最多有k+1个元素，看做滑动窗口，保证元素下标之差&lt;=k。如果i&gt;k，说明当前滑动窗口中已经有k+1个元素了，装不下了，则将第一个元素nums[i-k-1]所在的桶清空，腾出一个位置。<br>dict[key]=value，其中key是桶id，value是nums中的值。</p><ul><li>如果2个元素的桶id一样，说明这2个值之差&lt;=t，返回True</li><li>如果该元素所在的桶没有其他值，那就看和它左右邻近的桶，看差值是否&lt;=t,如果是返回True</li><li>如果自己的桶和邻居桶都没有符合条件，则将该元素放在自己的桶内</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">containsNearbyAlmostDuplicate</span><span class="params">(self, nums, k, t)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :type k: int</span></span><br><span class="line"><span class="string">        :type t: int</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> t &lt; <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">        <span class="comment">#滑动窗口中有k+1个元素</span></span><br><span class="line">        <span class="comment">#每个桶中有t+1个元素</span></span><br><span class="line">        buckets = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums)):</span><br><span class="line">            <span class="keyword">if</span> i &gt; k:</span><br><span class="line">                buckets.pop(self.getBucket(nums[i-k<span class="number">-1</span>],t+<span class="number">1</span>))</span><br><span class="line"></span><br><span class="line">            cur_id = self.getBucket(nums[i],t+<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> cur_id <span class="keyword">in</span> buckets:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">            <span class="keyword">elif</span> cur_id+<span class="number">1</span> <span class="keyword">in</span> buckets <span class="keyword">and</span> abs(buckets[cur_id+<span class="number">1</span>] - nums[i]) &lt;= t:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">            <span class="keyword">elif</span> cur_id<span class="number">-1</span> <span class="keyword">in</span> buckets <span class="keyword">and</span> abs(buckets[cur_id<span class="number">-1</span>] - nums[i]) &lt;= t:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                buckets[cur_id] = nums[i]</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getBucket</span><span class="params">(self,x,w)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        一个桶中有w个数</span></span><br><span class="line"><span class="string">        返回数字x被分配的桶编号</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> x &gt; <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> int(x/w)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> (x+<span class="number">1</span>)/w<span class="number">-1</span></span><br></pre></td></tr></table></figure><h2><span id="214-跳跃游戏">2.14. 跳跃游戏</span></h2><p>给定一个非负整数数组，你最初位于数组的第一个位置。<br>数组中的每个元素代表你在该位置可以跳跃的最大长度。<br>判断你是否能够到达最后一个位置。</p><blockquote><p>示例 1:<br>输入: [2,3,1,1,4]<br>输出: true<br>解释: 我们可以先跳 1 步，从位置 0 到达 位置 1, 然后再从位置 1 跳 3 步到达最后一个位置</p><p>示例 2:<br>输入: [3,2,1,0,4]<br>输出: false<br>解释: 无论怎样，你总会到达索引为 3 的位置。但该位置的最大跳跃长度是 0 ， 所以你永远不可能到达最后一个位置。</p></blockquote><p>【题解1】<br>i表示当前节点，k表示当前节点的前面所有节点能达到的最远节点。<br>例如[3,2,1,0,4]</p><ul><li>k=0，i=0：当前节点i=0，前面能到达的最远节点下标为0</li><li>k=3，i=1：当前节点i=1，前面能到达的最远节点下标为3</li><li>k=3，i=2：当前节点i=2，前面能到达的最远节点下标为3</li><li>k=3，i=3：当前节点i=3，前面能到达的最远节点下标为3</li><li>k=3，i=4：当前节点i=4，前面能到达的最远节点下标为3</li><li>当前节点为4，但是前面的节点最远只能到达下标为3的位置，说明i=4达不到，即返回false</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">canJump</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        k = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums)):</span><br><span class="line">            <span class="keyword">if</span> i &gt; k:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">            k = max(k,i+nums[i])<span class="comment">#更新节点[0,i]能到达的最远节点</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">True</span></span><br></pre></td></tr></table></figure><h1><span id="k数之和">K数之和</span></h1><h2><span id="两数之和">两数之和</span></h2><p>给定一个整数数组nums和一个目标值target，在数组中找到和为target的两个整数，并返回数组下标。<br>你可以假设每种输入都会对应一个答案，数组中同一个元素不能使用两遍。</p><p>nums中可能有重复元素。</p><blockquote><p>示例:<br>给定 nums = [2, 7, 11, 15], target = 9<br>因为 nums[0] + nums[1] = 2 + 7 = 9<br>所以返回 [0, 1]</p></blockquote><p>链接：<a href="https://leetcode-cn.com/problems/two-sum" target="_blank" rel="noopener">https://leetcode-cn.com/problems/two-sum</a></p><p><strong>【分析一】</strong></p><p>暴力求解，使用2层for循环，找到2个数的和为target即返回下标。题目要求每个输入都会对应一个答案，所以只要找到一个答案就可以返回。</p><p><strong>【分析二】</strong></p><p>二次遍历数组<br>第一次遍历时使用字典记录nums中的数字和下标<br>第二次遍历时，给定nums[i]，在字典中找是否存在other这个数，如果存储在返回这个数的下标，如果不存在返回None，然后判断这个下标，如果是None说明没有other这个数，如果有other这个数，但是和nums[i]是同一个数，导致数组重复使用，也不符合要求。如果以上两个条件都不满足，则返回对应的下标。</p><p>就相当于在一个大会中相亲</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">twoSum</span><span class="params">(self, nums, target)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :type target: int</span></span><br><span class="line"><span class="string">        :rtype: List[int]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="comment">#使用字典记录</span></span><br><span class="line">        nums_dict = dict()</span><br><span class="line">        <span class="comment">#我来了，我在主持人记录一下我自己的信息</span></span><br><span class="line">        <span class="keyword">for</span> idx,num <span class="keyword">in</span> enumerate(nums):</span><br><span class="line">            nums_dict[num] = idx</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums)):<span class="comment">#对于每一个人</span></span><br><span class="line">            <span class="comment">#看一下我钟意的人有没有来过</span></span><br><span class="line">            other_idx = nums_dict.get(target-nums[i])<span class="comment">#另外一个数的下标</span></span><br><span class="line">            <span class="comment">#来过并且不是我自己，那就返回找到了对象啦</span></span><br><span class="line">            <span class="keyword">if</span> other_idx <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span> <span class="keyword">and</span> other_idx!=i:</span><br><span class="line">                <span class="keyword">return</span> [i,other_idx]</span><br></pre></td></tr></table></figure><p><strong>【分析】</strong></p><p>对上面进行优化，使用一层循环。<br>来一个人先问主持人，我钟意的人在不在，如果在的话，牵手成功，如果不再的话，把自己登记下来，等着他来找我</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">twoSum</span><span class="params">(self, nums, target)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :type target: int</span></span><br><span class="line"><span class="string">        :rtype: List[int]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="comment">#使用字典记录,一次遍历</span></span><br><span class="line">        nums_dict = dict()</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums)):</span><br><span class="line">            <span class="comment">#对于当前nums[i]，先问一下nums_dict，你这有没有我需要的人</span></span><br><span class="line">            <span class="keyword">if</span> target-nums[i] <span class="keyword">in</span> nums_dict:</span><br><span class="line">                <span class="keyword">return</span> [i,nums_dict[target-nums[i]]]</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                nums_dict[nums[i]] = i</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">None</span></span><br></pre></td></tr></table></figure><h2><span id="三数之和">三数之和</span></h2><p>给定一个包含n个整数的数组nums，判断是否存在三个元素a，b，c，使得这3个数之和为0，找出所有满足的条件的这3个数，答案中不能有重复三元组。<br>nums中可以有重复元素，</p><blockquote><p>示例：<br>给定数组 nums = [-1, 0, 1, 2, -1, -4]，<br>满足要求的三元组集合为：<br>[<br>  [-1, 0, 1],<br>  [-1, -1, 2]<br>]</p></blockquote><p>链接：<a href="https://leetcode-cn.com/problems/3sum" target="_blank" rel="noopener">https://leetcode-cn.com/problems/3sum</a></p><p><strong>【分析一】</strong></p><p>排序+双指针</p><ul><li><strong>排序</strong>：先给<code>nums</code>排序，时间复杂度为O(NlogN)</li><li><strong>双指针</strong>：固定三个指针中最左边的指针<code>k</code>，将指针<code>i</code>指向<code>k+1</code>，指针<code>j</code>指向<code>len(nums)-1</code>，<code>i</code>和<code>j</code>向中间移动，记录<code>nums[k]+nums[i]+nums[j]</code>的和<ul><li>当<code>nums[k]&gt;0</code>时，因为是排序数组，k右边的数肯定也大于0，不存在三数之和为0，直接break，返回结果</li><li>当<code>k&gt;=1且nums[k]==nums[k-1]</code>时，这时<code>nums[k]</code>所能组成的组合，<code>nums[k-1]</code>都已经遍历过了，所以continue，接着遍历下一个k</li><li>while循环遍历不同的i和j，<code>while i&lt;j</code>时，判断<code>s=nums[k]+nums[i]+nums[j]</code>的和<ol><li>如果<code>s&gt;0</code>，说明此时和太大了，<code>j</code>指针需要向左移动，让<code>nums[j]</code>变小一点。并且在向左移动的过程中，需要跳过那些和<code>nums[j]</code>相等的值</li><li>如果<code>s&lt;0</code>，说明此时和太小了，i指针需要向右移动，让<code>nums[i]</code>变大一点，并且在移动的过程中跳过那些和<code>nums[i]</code>相等的值</li><li>如果<code>s==0</code>，说明此时的<code>nums[k],nums[i],nums[j]</code>满足要求，将三元组加入到结果集中。然后同时移动<code>i和j</code>，并跳过那些重复的值</li></ol></li></ul></li></ul><p>有很多细节：</p><ol><li>K的取值，K右边必须要有2个元素，所以K的取值最大为n-3</li><li>在判断<code>nums[k]==nums[k-1]</code>时，需要k&gt;=1，才不会出现越界</li><li>每次判断当前元素是否和前一个或后一个相同时，需要加上<code>i&lt;j</code>的条件</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">threeSum</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: List[List[int]]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> nums:<span class="keyword">return</span> []</span><br><span class="line">        <span class="comment">#排序+双指针</span></span><br><span class="line">        nums.sort()</span><br><span class="line">        n = len(nums)</span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">for</span> k <span class="keyword">in</span> range(n<span class="number">-2</span>):<span class="comment">#k的右边必须有2个元素</span></span><br><span class="line">            <span class="keyword">if</span> nums[k] &gt; <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">if</span> k&gt;=<span class="number">1</span> <span class="keyword">and</span> nums[k] == nums[k<span class="number">-1</span>]:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">            i,j = k+<span class="number">1</span>,n<span class="number">-1</span></span><br><span class="line">            <span class="keyword">while</span> i &lt; j:</span><br><span class="line">                s = nums[k]+nums[i]+nums[j]</span><br><span class="line">                <span class="keyword">if</span> s &lt; <span class="number">0</span>:</span><br><span class="line">                    i += <span class="number">1</span></span><br><span class="line">                    <span class="keyword">while</span> i &lt; j <span class="keyword">and</span> nums[i] == nums[i<span class="number">-1</span>]:</span><br><span class="line">                        i+=<span class="number">1</span></span><br><span class="line">                <span class="keyword">elif</span> s &gt; <span class="number">0</span>:</span><br><span class="line">                    j -= <span class="number">1</span></span><br><span class="line">                    <span class="keyword">while</span> i &lt; j <span class="keyword">and</span> nums[j] == nums[j+<span class="number">1</span>]:</span><br><span class="line">                        j -= <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    res.append([nums[k],nums[i],nums[j]])</span><br><span class="line">                    i += <span class="number">1</span></span><br><span class="line">                    j -= <span class="number">1</span></span><br><span class="line">                    <span class="keyword">while</span> i &lt; j <span class="keyword">and</span> nums[i] == nums[i<span class="number">-1</span>]:i += <span class="number">1</span></span><br><span class="line">                    <span class="keyword">while</span> i &lt; j <span class="keyword">and</span> nums[j] == nums[j+<span class="number">1</span>]:j -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h2><span id="四数之和">四数之和</span></h2><p>给定一个包含 n 个整数的数组 nums 和一个目标值 target，判断 nums 中是否存在四个元素 a，b，c 和 d ，使得 a + b + c + d 的值与 target 相等？找出所有满足条件且不重复的四元组。<br>注意：<br>答案中不可以包含重复的四元组。</p><blockquote><p>示例：<br>给定数组 nums = [1, 0, -1, 0, -2, 2]，和 target = 0。<br>满足要求的四元组集合为：<br>[<br>  [-1,  0, 0, 1],<br>  [-2, -1, 1, 2],<br>  [-2,  0, 0, 2]<br>]</p></blockquote><p>链接：<a href="https://leetcode-cn.com/problems/4sum" target="_blank" rel="noopener">https://leetcode-cn.com/problems/4sum</a></p><p><strong>【分析一】</strong></p><p>参照三数之和，这里使用四个指针，固定前2个指针，然后移动后2个指针</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">fourSum</span><span class="params">(self, nums, target)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :type target: int</span></span><br><span class="line"><span class="string">        :rtype: List[List[int]]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> nums:<span class="keyword">return</span> []</span><br><span class="line">        <span class="comment">#固定2个指针，移动2个指针</span></span><br><span class="line">        nums.sort()</span><br><span class="line">        n = len(nums)</span><br><span class="line">        res = []</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> a <span class="keyword">in</span> range(n<span class="number">-3</span>):<span class="comment">#a的后面要有3个元素</span></span><br><span class="line">            <span class="comment">#注意这里不用和target比较，提前break</span></span><br><span class="line">            <span class="keyword">if</span> a&gt;=<span class="number">1</span> <span class="keyword">and</span> nums[a] == nums[a<span class="number">-1</span>]:<span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">for</span> b <span class="keyword">in</span> range(a+<span class="number">1</span>,n<span class="number">-2</span>):</span><br><span class="line">                <span class="keyword">if</span> b&gt;a+<span class="number">1</span> <span class="keyword">and</span> nums[b] == nums[b<span class="number">-1</span>]:<span class="keyword">continue</span></span><br><span class="line">                </span><br><span class="line">                c,d = b+<span class="number">1</span>,n<span class="number">-1</span></span><br><span class="line">                <span class="keyword">while</span> c &lt; d:</span><br><span class="line">                    s = nums[a]+nums[b]+nums[c]+nums[d]</span><br><span class="line">                    <span class="keyword">if</span> s &lt; target:</span><br><span class="line">                        c += <span class="number">1</span></span><br><span class="line">                        <span class="keyword">while</span> c &lt; d <span class="keyword">and</span> nums[c] == nums[c<span class="number">-1</span>]:c+=<span class="number">1</span></span><br><span class="line">                    <span class="keyword">elif</span> s &gt; target:</span><br><span class="line">                        d -= <span class="number">1</span></span><br><span class="line">                        <span class="keyword">while</span> c &lt; d <span class="keyword">and</span> nums[d] == nums[d+<span class="number">1</span>]:d-=<span class="number">1</span></span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        res.append([nums[a],nums[b],nums[c],nums[d]])</span><br><span class="line">                        c+=<span class="number">1</span></span><br><span class="line">                        d-=<span class="number">1</span></span><br><span class="line">                        <span class="keyword">while</span> c &lt; d <span class="keyword">and</span> nums[c] == nums[c<span class="number">-1</span>]:c+=<span class="number">1</span> </span><br><span class="line">                        <span class="keyword">while</span> c &lt; d <span class="keyword">and</span> nums[d] == nums[d+<span class="number">1</span>]:d-=<span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h2><span id="k-sum">K sum</span></h2><p>给定一个包含 n 个整数的数组 nums 和一个目标值 target，判断 nums 中是否存在K个元素，使得这K个元素之和与 target 相等？找出所有满足条件且不重复的K元组。<br>注意：<br>答案中不可以包含重复的K元组。</p><p><strong>【分析】</strong></p><p>经过上面的分析，我们发现任何K个数的和最后都可以转化为2 sum。在求3sum时，先固定一个指针，然后使用2sum对另外2个指针进行遍历。在求4sum时，先固定2个指针，然后使用2sum对另外2个指针进行遍历。在求Ksum问题时，使用递归操作</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">NSum</span><span class="params">(self, nums, target)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :type target: int</span></span><br><span class="line"><span class="string">        :rtype: List[List[int]]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> nums:<span class="keyword">return</span> []</span><br><span class="line">        nums.sort()</span><br><span class="line">        <span class="keyword">return</span> self.kSum(nums,target,N,<span class="number">0</span>)</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">kSum</span><span class="params">(self,nums,target,k,start)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        在nums[start:]中找k个元素，使得和为target</span></span><br><span class="line"><span class="string">        返回值List[List[int]]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        n = len(nums)</span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">if</span> k == <span class="number">2</span>:</span><br><span class="line">            res = self.twoSum(nums,target,start)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment">#固定一个元素，然后递归求k-1个元素和为target-nums[i]</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(start,n-k+<span class="number">1</span>):<span class="comment">#要保证后面有k-1个元素</span></span><br><span class="line">                <span class="keyword">if</span> i &gt; start <span class="keyword">and</span> nums[i] == nums[i<span class="number">-1</span>]:</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                res_k_1 = self.kSum(nums,target-nums[i],k<span class="number">-1</span>,i+<span class="number">1</span>)</span><br><span class="line">                <span class="keyword">if</span> res_k_1:</span><br><span class="line">                    <span class="comment">#将nums[i]加入到每个path中</span></span><br><span class="line">                    <span class="keyword">for</span> path <span class="keyword">in</span> res_k_1:</span><br><span class="line">                        path.insert(<span class="number">0</span>,nums[i])</span><br><span class="line">                    <span class="comment">#把当前结果加入到最终res中</span></span><br><span class="line">                    res.extend(res_k_1)</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line">                </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">twoSum</span><span class="params">(self,nums,target,start)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        在nums[start:]中找2个元素，使得和为target</span></span><br><span class="line"><span class="string">        返回List[List[int]]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        n = len(nums)</span><br><span class="line">        left,right = start,n<span class="number">-1</span></span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">while</span> left&lt;right:</span><br><span class="line">            s = nums[left] + nums[right]</span><br><span class="line">            <span class="keyword">if</span> s &lt; target:<span class="comment">#说明s小了，需要让left变大</span></span><br><span class="line">                left+=<span class="number">1</span></span><br><span class="line">                <span class="keyword">while</span> left &lt; right <span class="keyword">and</span> nums[left] == nums[left<span class="number">-1</span>]:</span><br><span class="line">                    left+=<span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> s &gt; target:<span class="comment">#说明s大了，需要让j变小</span></span><br><span class="line">                right -= <span class="number">1</span></span><br><span class="line">                <span class="keyword">while</span> left &lt; right <span class="keyword">and</span> nums[right] == nums[right+<span class="number">1</span>]:</span><br><span class="line">                    right -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                res.append([nums[left],nums[right]])</span><br><span class="line">                left += <span class="number">1</span></span><br><span class="line">                right -= <span class="number">1</span></span><br><span class="line">                <span class="keyword">while</span> left &lt; right <span class="keyword">and</span> nums[left] == nums[left<span class="number">-1</span>]:</span><br><span class="line">                    left+=<span class="number">1</span></span><br><span class="line">                <span class="keyword">while</span> left &lt; right <span class="keyword">and</span> nums[right] == nums[right+<span class="number">1</span>]:</span><br><span class="line">                    right -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近要开始准备刷Leetcode了，在这里记录下刷题的心得&lt;/p&gt;
    
    </summary>
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title>argparse不支持bool类型</title>
    <link href="http://yoursite.com/2020/03/09/argparse%E4%B8%8D%E6%94%AF%E6%8C%81bool%E7%B1%BB%E5%9E%8B/"/>
    <id>http://yoursite.com/2020/03/09/argparse不支持bool类型/</id>
    <published>2020-03-09T08:28:29.000Z</published>
    <updated>2020-03-09T08:57:46.605Z</updated>
    
    <content type="html"><![CDATA[<p>在Python中通过下列方式向程序传递bool参数时，其中<code>neg</code>参数指定类型为bool，但是无论传入的值是什么，<code>neg</code>始终为<code>True</code></p><p>解决方法：<br><a href="https://blog.csdn.net/yaokai_assultmaster/article/details/77928629" target="_blank" rel="noopener">使用Python中的argparse从命令行接收boolean类型的参数</a><br><a id="more"></a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">parser = argparse.ArgumentParser()</span><br><span class="line">parser.add_argument(<span class="string">"--config"</span>, type=str, help=<span class="string">'configuration file'</span>)</span><br><span class="line">parser.add_argument(<span class="string">"--gpus"</span>, type=str,help=<span class="string">"test program"</span>)<span class="comment">#如果</span></span><br><span class="line">parser.add_argument(<span class="string">"--neg"</span>, type=bool, help=<span class="string">"test program"</span>)</span><br><span class="line">parser.add_argument(<span class="string">"--test"</span>, action=<span class="string">"store_true"</span>, help=<span class="string">"test program"</span>)</span><br></pre></td></tr></table></figure><p>【注意】类似于上文中<code>gpus</code>这种参数，指定也可以，不指定也可以</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在Python中通过下列方式向程序传递bool参数时，其中&lt;code&gt;neg&lt;/code&gt;参数指定类型为bool，但是无论传入的值是什么，&lt;code&gt;neg&lt;/code&gt;始终为&lt;code&gt;True&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;解决方法：&lt;br&gt;&lt;a href=&quot;https://blog.csdn.net/yaokai_assultmaster/article/details/77928629&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;使用Python中的argparse从命令行接收boolean类型的参数&lt;/a&gt;&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Python" scheme="http://yoursite.com/categories/Python/"/>
    
    
      <category term="Python" scheme="http://yoursite.com/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>深度学习优秀代码示例</title>
    <link href="http://yoursite.com/2020/03/03/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E4%BC%98%E7%A7%80%E4%BB%A3%E7%A0%81%E7%A4%BA%E4%BE%8B/"/>
    <id>http://yoursite.com/2020/03/03/深度学习优秀代码示例/</id>
    <published>2020-03-03T03:30:18.000Z</published>
    <updated>2020-03-07T05:14:24.731Z</updated>
    
    <content type="html"><![CDATA[<p>&ensp;&ensp;&ensp;&ensp;曾经一段时间很苦恼，对于深度学习算法不知道怎么上手，看了很多深度学习教程，依然不会写。后来就看论文公开的源代码，对照着论文模型，一点点看，多看几篇代码，逐渐有种开窍的感觉。其次是看Mxnet和Pytorch的源代码(我主要用这2个框架)，Mxnet和Pytorch的Github上给了很多示例代码，写的非常规范，从中可以学到用法，从而也可以规范自己的代码。<br>&ensp;&ensp;&ensp;&ensp;下面整理一下，在我学习过程中，对我帮助很大的教程和代码。</p><a id="more"></a><ol><li><a href="http://zh.gluon.ai/" target="_blank" rel="noopener">《动手学深度学习》Mxnet版</a><br>Mxnet的入门教程，沐神写的，来来回回看了2~3遍，每次看都有新的收货</li><li><a href="https://tangshusen.me/Dive-into-DL-PyTorch/#/" target="_blank" rel="noopener">《动手学深度学习》Pytorch版</a><br>将Mxnet改写为Pytorch版本，非常好的Pytorch入门教程</li><li><a href="https://github.com/Davidham3/ASTGCN" target="_blank" rel="noopener">ASTGCN</a><br>AAAI2019论文公开代码，用Mxnet写的</li><li><a href="https://yjucho1.github.io/spatio-temporal%20data/deep%20learning%20paper/ST-resnet/" target="_blank" rel="noopener">ST-ResNet</a><br>AAAI2017论文公开代码，用Keras，看这篇代码主要是学习模型架构，然后自己用mxnet复现了一下</li><li><a href="https://github.com/panzheyi/ST-MetaNet" target="_blank" rel="noopener">ST-MetaNet</a><br>KDD2019论文公开代码，用Mxnet写的，学到了很多高级用法，例如EarlyStopping，Encoder和Decoder，getattr，DGL</li><li><p><a href="https://github.com/pytorch/examples/tree/master/word_language_model" target="_blank" rel="noopener">Pytorch Transformer</a><br>学习怎么使用Transformer，Dropout和BN在训练和测试的不同，PositionEmbedding，getattr等用法。学习Transformer最好去看Pytorch关于Tranformer的源代码。</p></li><li><p><a href="https://github.com/pytorch/examples" target="_blank" rel="noopener">Pytorch示例代码</a><br>Pytorch Github中的示例代码</p></li><li><a href="https://github.com/apache/incubator-mxnet/tree/master/example" target="_blank" rel="noopener">Mxnet示例代码</a><br>Mxnet Github中的示例代码</li></ol><p>觉得自己最大的变化是喜欢去读源代码了，遇到问题去官网看教程，读源码，帮助很大。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;ensp;&amp;ensp;&amp;ensp;&amp;ensp;曾经一段时间很苦恼，对于深度学习算法不知道怎么上手，看了很多深度学习教程，依然不会写。后来就看论文公开的源代码，对照着论文模型，一点点看，多看几篇代码，逐渐有种开窍的感觉。其次是看Mxnet和Pytorch的源代码(我主要用这2个框架)，Mxnet和Pytorch的Github上给了很多示例代码，写的非常规范，从中可以学到用法，从而也可以规范自己的代码。&lt;br&gt;&amp;ensp;&amp;ensp;&amp;ensp;&amp;ensp;下面整理一下，在我学习过程中，对我帮助很大的教程和代码。&lt;/p&gt;
    
    </summary>
    
      <category term="Deep Learning" scheme="http://yoursite.com/categories/Deep-Learning/"/>
    
    
      <category term="Mxnet" scheme="http://yoursite.com/tags/Mxnet/"/>
    
      <category term="Pyotrch" scheme="http://yoursite.com/tags/Pyotrch/"/>
    
  </entry>
  
  <entry>
    <title>时空论文阅读笔记</title>
    <link href="http://yoursite.com/2020/02/27/%E6%97%B6%E7%A9%BA%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/2020/02/27/时空论文阅读笔记/</id>
    <published>2020-02-27T12:03:53.000Z</published>
    <updated>2020-06-18T02:36:57.665Z</updated>
    
    <content type="html"><![CDATA[<p>因为疫情推迟开学，在家把以前看的论文又看了一遍，每重新看一次都有新的收获，在此整理下。</p><a id="more"></a><!-- TOC --><ul><li><a href="#1-流量速度预测">1. 流量/速度预测</a><ul><li><a href="#11-deep-spatio-temporal-residual-networks-for-citywide-crowd-flows-predictionaaai2017">1.1. Deep Spatio-Temporal Residual Networks for Citywide Crowd Flows Prediction(AAAI2017)</a></li><li><a href="#12-deepstn-context-aware-spatial-temporal-neural-network-for-crowd-flow-prediction-in-metropolisaaai2019">1.2. DeepSTN+: Context-aware Spatial-Temporal Neural Network for Crowd Flow Prediction in Metropolis(AAAI2019)</a></li><li><a href="#13-urbanfm-inferring-fine-grained-urban-flowskdd2019">1.3. UrbanFM: Inferring Fine-Grained Urban Flows(KDD2019)</a></li><li><a href="#14-attention-based-spatial-temporal-graph-convolutional-networks-for-traffic-flow-forecastingaaai2019">1.4. Attention Based Spatial-Temporal Graph Convolutional Networks for Traffic Flow Forecasting(AAAI2019)</a></li><li><a href="#15-spatial-temporal-synchronous-graph-convolutional-networks-a-new-framework-for-spatial-temporal-network-data-forecastingaaai2020">1.5. Spatial-Temporal Synchronous Graph Convolutional Networks: A New Framework for Spatial-Temporal Network Data Forecasting(AAAI2020)</a></li><li><a href="#16-hyperst-net-hypernetworks-for-spatio-temporal-forecasting2019aaai">1.6. HyperST-Net: Hypernetworks for Spatio-Temporal Forecasting(2019AAAI)</a></li><li><a href="#17-urban-traffic-prediction-from-spatio-temporal-data-using-deep-meta-learning2019kdd">1.7. Urban Traffic Prediction from Spatio-Temporal Data Using Deep Meta Learning(2019KDD)</a></li><li><a href="#18-stepdeep-a-novel-spatial-temporal-mobility-event-prediction-framework-based-on-deep-neural-networkkdd2018">1.8. StepDeep: A Novel Spatial-temporal Mobility Event Prediction Framework based on Deep Neural Network(KDD2018)</a></li><li><a href="#19-stgrat-a-spatio-temporal-graph-attention-network-for-traffic-forecastingaaai2020">1.9. STGRAT: A Spatio-Temporal Graph Attention Network for Traffic Forecasting(AAAI2020)</a></li><li><a href="#110-connecting-the-dots-multivariate-time-series-forecasting-with-graph-neural-networks">1.10. Connecting the Dots: Multivariate Time Series Forecasting with Graph Neural Networks</a></li></ul></li><li><a href="#2-eta预测">2. ETA预测</a><ul><li><a href="#21-when-will-you-arrive-estimating-travel-time-based-on-deep-neural-networksaaai20">2.1. When Will You Arrive? Estimating Travel Time Based on Deep Neural Networks(AAAI20)</a></li></ul></li><li><a href="#3-出租车需求预测">3. 出租车需求预测</a><ul><li><a href="#31-deep-multi-view-spatial-temporal-network-for-taxi-demand-predictionaaai2018">3.1. Deep Multi-View Spatial-Temporal Network for Taxi Demand Prediction(AAAI2018)</a></li><li><a href="#32-revisiting-spatial-temporal-similarity-a-deep-learning-framework-for-traffic-predictionaaai2019">3.2. Revisiting Spatial-Temporal Similarity: A Deep Learning Framework for Traffic Prediction(AAAI2019)</a></li><li><a href="#33-spatiotemporal-multi-graph-convolution-network-for-ride-hailing-demand-forecastingaaai2019">3.3. Spatiotemporal Multi-Graph Convolution Network for Ride-hailing Demand Forecasting(AAAI2019)</a></li><li><a href="#34-passenger-demand-forecasting-with-multi-task-convolutional-recurrent-neural-networkspakdd2019">3.4. Passenger Demand Forecasting with Multi-Task Convolutional Recurrent Neural Networks(PAKDD2019)</a></li><li><a href="#35-stg2seq-spatial-temporal-graph-to-sequence-model-for-multi-step-passenger-demand-forecasting2019ijcai">3.5. STG2Seq: Spatial-temporal Graph to Sequence Model for Multi-step Passenger Demand Forecasting(2019IJCAI)</a></li></ul></li><li><a href="#4-时间序列预测">4. 时间序列预测</a><ul><li><a href="#41-restful-resolution-aware-forecasting-of-behavioral-time-series-data2018cikm">4.1. RESTFul: Resolution-Aware Forecasting of Behavioral Time Series Data(2018CIKM)</a></li><li><a href="#42-multi-horizon-time-series-forecasting-with-temporal-attention-learningkdd2019">4.2. Multi-Horizon Time Series Forecasting with Temporal Attention Learning(KDD2019)</a></li></ul></li><li><a href="#5-总结">5. 总结</a><ul><li><a href="#51-网格--图">5.1. 网格—&gt;图</a></li><li><a href="#52-动态图">5.2. 动态图</a></li><li><a href="#53-计算2个区域的相似性">5.3. 计算2个区域的相似性</a></li><li><a href="#54-poi">5.4. POI</a></li><li><a href="#55-时间相关性">5.5. 时间相关性</a></li><li><a href="#56-lstm共t个隐藏状态整合">5.6. LSTM共T个隐藏状态整合</a></li><li><a href="#57-外部因素嵌入">5.7. 外部因素嵌入</a></li><li><a href="#58-mask">5.8. mask</a></li><li><a href="#59-max-min归一化">5.9. Max-min归一化</a></li></ul></li></ul><!-- /TOC --><h1><span id="1-流量速度预测">1. 流量/速度预测</span></h1><h2><span id="11-deep-spatio-temporal-residual-networks-for-citywide-crowd-flows-predictionaaai2017">1.1. Deep Spatio-Temporal Residual Networks for Citywide Crowd Flows Prediction(AAAI2017)</span></h2><blockquote><p>张钧波(京东)<br>郑宇(京东)<br><a href="https://github.com/lucktroy/DeepST" target="_blank" rel="noopener">https://github.com/lucktroy/DeepST</a> Keras</p></blockquote><ul><li>给定所有区域历史T个时间段的inflow和outflow，预测下一个时间段所有区域的inflow和outflow</li></ul><p><img src="/2020/02/27/时空论文阅读笔记/ST-ResNet.png" alt=""></p><ul><li>每个时间段所有区域的输入是$I<em>J</em>2$,将输入分为recent，daily，weekly周期，预测第t个时间段的infow和outflow：<ul><li>recent：当天前r个时间段</li><li>daily：前d天该时间段</li><li>weekly：前w周该天该时间段</li></ul></li><li>外部特征包括：天气，节假日，dayOfWeek。用2层FCN对外部特征进行嵌入，第一层FCN作为嵌入层，第二层FCN转换维度和$X_{Res}$一致。</li><li>在融合阶段，先将3个时间周期的输出融合，再和外部因素拼接。</li><li>数据集：北京出租车和NYC自行车流量</li><li>将flow使用Max-Min归一化到[-1,1]，FCN最后一层使用tanh激活函数</li></ul><h2><span id="12-deepstn-context-aware-spatial-temporal-neural-network-for-crowd-flow-prediction-in-metropolisaaai2019">1.2. DeepSTN+: Context-aware Spatial-Temporal Neural Network for Crowd Flow Prediction in Metropolis(AAAI2019)</span></h2><blockquote><p>Ziqian Lin(清华大学)<br>Jie Feng(清华大学)<br>Ziyang Lu(清华大学)<br>Yong Li(清华大学)<br>Depeng Jin(清华大学)<br><a href="https://github.com/FIBLAB/DeepSTN" target="_blank" rel="noopener">https://github.com/FIBLAB/DeepSTN</a>  Keras</p></blockquote><ul><li>crowd flow预测是给定历史T个时间段，预测区域的inflow和outflow</li><li>现有研究的缺点：<ul><li>不能捕获长距离空间依赖</li><li>忽略区域功能对人流的影响(POI)</li></ul></li><li>提出DeeoSTN+，有3个组件<ul><li>ConvPlus：解决长距离区域的空间依赖</li><li>SemanticPlus：解决区域POI对人流的影响</li><li>early-fusuion模块</li></ul></li></ul><p><img src="/2020/02/27/时空论文阅读笔记/DeepSTN+.png" alt=""></p><ul><li><p>假设预测周四第5个时间段的flow，输入的数据有：</p><ul><li>recent：周四2,3,4个时间段</li><li>day：周一，周二，周三第5个时间段</li><li>week：上上上周四，上上周四，上周四第5个时间段</li><li>time：周四第5个时间段的时间向量</li><li>poi：(C,W,H)所有区域的poi信息</li></ul></li><li>【<strong>ConvPlus</strong>】传统的Conv中kernel的大小远小于网格大小，通常是$3 \times 3$,然后在人流量预测中通常有一些长距离的依赖，例如人们去很远的地方上班。在ConvPlus中，假设原始输入维度是(C,W,H),其中plus维用来捕获长距离依赖<ul><li>正常Conv2D：将原始输入(C,W,H)输入到正常Conv2D中,卷积核有C-plus个，输出维度(C-plus,W,H)，</li><li>ConvPlus：再将原始(C,W,H)输入到ConvPlus中，卷积核有plus<em>W\</em>H个，卷积大小为W*H,则输出维度(plus*W*H,1,1),reshape为(plus,W,H)</li><li>将上面2个卷积的输出拼接成(C,W,H)</li></ul></li><li><strong>计算POI在时间上的分布权重</strong><ul><li>POI维度$C \times W \times H$,表示每个网格有C类POI</li><li>时间维度$T \times W \times H$，T=24+7, 首先对时间进行嵌入，通过2D卷积，将31个数变成一个数$1 \times W \times H$，然后将时间repeat成$C \times W \times H$</li><li>时间和POI逐元素相乘，得到$C \times W \times H$</li><li>如果需要，还可以再通过K个2D卷积，变成$K \times W \times H$</li><li>将该张量和3个周期的输出在通道维上拼接。</li></ul></li><li>crowd flow使用Max-Min归一化到[-1,1]，最后一层使用Tanh，范围[-1,1]</li><li>POI使用Max-Min归一化到[0,1]</li></ul><h2><span id="13-urbanfm-inferring-fine-grained-urban-flowskdd2019">1.3. UrbanFM: Inferring Fine-Grained Urban Flows(KDD2019)</span></h2><blockquote><p>Yuxuan Liang(XiDian)<br>Kun Ouyang(新加坡国立)<br>张钧波(京东)<br>郑宇(京东)<br><a href="https://github.com/yoshall/UrbanFM" target="_blank" rel="noopener">https://github.com/yoshall/UrbanFM</a></p></blockquote><ul><li>基于粗粒度级的flow，实时推测整个城市细粒度级的flow，提出模型<strong>Urban</strong> <strong>F</strong>low <strong>M</strong>agnifier (<strong>UrbanFM</strong>)</li><li>有2个挑战：粗粒度和细粒度的flow在空间上的相关性、复杂的外部因素。</li></ul><p><img src="/2020/02/27/时空论文阅读笔记/UrbanFM1.png" alt=""></p><p><img src="/2020/02/27/时空论文阅读笔记/UrbanFM.png" alt=""></p><h2><span id="14-attention-based-spatial-temporal-graph-convolutional-networks-for-traffic-flow-forecastingaaai2019">1.4. Attention Based Spatial-Temporal Graph Convolutional Networks for Traffic Flow Forecasting(AAAI2019)</span></h2><blockquote><p>郭晟楠(北京交通大学)<br>冯宁(北京交通大学)<br>宋超(北京交通大学)<br>万怀宇(北京交通大学)<br><a href="https://github.com/Davidham3/ASTGCN" target="_blank" rel="noopener">https://github.com/Davidham3/ASTGCN</a> Mxnet</p></blockquote><p>根据所有节点历史T个时间段traffic flow，occupy，speed，预测所有节点未来T_p个时间段的traffic flow。</p><p><img src="/2020/02/27/时空论文阅读笔记/ASTGCN.png" alt=""></p><ul><li>三个独立的组件，分别对recent，daily，weekly周期进行建模</li><li>比如说预测6.14 8:00-8:55的flow，传入的样本是<br>时：6.14号6:00~7:55（前2个小时）的数据，<br>天：6.13和6.12（前2天）的8:00-8:55，<br>周：上周6.17，上上周5.31（前2周）的8:00-8:55</li></ul><h2><span id="15-spatial-temporal-synchronous-graph-convolutional-networks-a-new-framework-for-spatial-temporal-network-data-forecastingaaai2020">1.5. Spatial-Temporal Synchronous Graph Convolutional Networks: A New Framework for Spatial-Temporal Network Data Forecasting(AAAI2020)</span></h2><blockquote><p>宋超(北京交通大学)<br>郭晟楠(北京交通大学)<br>万怀宇(北京交通大学)<br><a href="https://github.com/Davidham3/STSGCN" target="_blank" rel="noopener">https://github.com/Davidham3/STSGCN</a> Mxnet</p></blockquote><ul><li>给定所有节点历史T个时间段的车流量，预测所有节点未来$T’$个时间段的车流量，</li><li>原先的研究通常使用分开的组件捕获时间和空间的相关性，并且忽略了时空数据的异构性。</li><li>提出<strong>S</strong>patial-<strong>T</strong>emporal <strong>S</strong>ynchronous <strong>G</strong>raph <strong>C</strong>onvolutional <strong>N</strong>etworks (<strong>STSGCN</strong>)</li><li><strong>对于图中的每个节点，它的影响范围有3种</strong>，这是该文章提出的一个新观点，以前的研究中通常只考虑前2种。</li></ul><p><img src="/2020/02/27/时空论文阅读笔记/STSGCN1.png" alt=""></p><ul><li>本文强调的内容有2点：<ul><li>局部的时空关系，称作localized spatial-temporal correlations</li><li>时空数据的异质性，居住区和商业区，早上和晚上</li></ul></li><li><strong>使用连续3个时间步的图数据来构建localized spatial-temporal graph，local指的是在时间上局部</strong><br>假设原先一个图中有N个节点，图信号矩阵为$N \times C$,邻接矩阵为$N \times N$，现在3个图来构建一个局部时空图，图信号矩阵为$3N \times C$,邻接矩阵为$3N \times 3N$,邻接矩阵中非0即1</li></ul><p><img src="/2020/02/27/时空论文阅读笔记/STSGCN2.png" alt=""></p><ul><li>但是把3个图构成1个图失去了图之间的时间关系，模型可能会认为这是一个有3N个节点在一个时间步的信息，为了区域这3个图的时间关系，受ConvS2S启发，为时空网络序列$N \times C \times T$添加位置嵌入，增加时间嵌入矩阵$C \times T$,空间嵌入矩阵$N \times C$,这2个矩阵是通过模型学习的，当模型训练好之后，这2个矩阵可以包含图的时间和空间信息。然后把这2个嵌入矩阵和原始的图信号矩阵相加，这样图中就包含了时间和位置信息。</li></ul><p><img src="/2020/02/27/时空论文阅读笔记/STSGCN.png" alt=""></p><ul><li>图中模型框架：多个STSGCM构成STSGCL，多个STSGCL构成STSGCN。STSGCN就是多层图卷积，从局部时空图中捕获邻居信息。STSGCL一层中有多个STSGCM，一个样本中每个时间段的局部时空图都用一个STSGCM来建模。</li><li><strong>第一个FCN成将输入转换到高维空间，提高模型的表示能力</strong></li><li>【<strong>STSGCM</strong>】中包含多层图卷积，使用GLU作为激活函数，其中sigmoid作为门控机制，控制哪个节点的信息可以流入到下一层。<strong>图卷积计算定义在顶点域，意味着不需要计算图的拉普拉斯矩阵</strong><br><img src="/2020/02/27/时空论文阅读笔记/STSGCN3.png" alt=""><br>STSGCM的架构如下：参考JK-net，一共有L个图卷积层，每一层的输出都输入到AGG层中，AGG层将接收到的L个输出进行max聚合，最终得到一个输出$3N \times C_{out}$,然后进行裁剪，将前中后3个时间步的数据只保留中间时间步，即$N \times C_out$<br><img src="/2020/02/27/时空论文阅读笔记/STSGCN4.png" alt=""></li><li>【<strong>STSGCL</strong>】多个STSGCM组成一个STSGCL层，其输入维度$T \times N \times C$,使用滑动窗口每次取3个时间段段的图构成$3N \times C$,一共构成$T-2$个局部时空图，然后需要$T-2$个STSGCM，最终输出$T-2个N \times C_{out}$，将其拼接为$(T-2) \times N \times C_{out}$，再输入到下一个STSGCL中。<strong>【注意】每个局部时空图是通过滑动窗口获得，每个时空局部图的邻接矩阵是不变的，而不是提前处理好局部图输入到模型中，这样会省空间</strong></li><li>上面使用的邻接矩阵$3N \times 3N$中的值非0即1，每个邻居聚合的权重相等，聚合能力会受到限制，这里对此做出改进，将邻接矩阵乘上一个Mask矩阵，对每个邻居赋予不同的权重，其中Mask矩阵是可学习参数，维度$3N \times 3N$<script type="math/tex; mode=display">A_{\text {adjusted}}^{\prime}=W_{\text {mask}} \otimes A^{\prime} \in \mathbb{R}^{3 N \times 3 N}</script></li><li>最后的FCN将STSGCL的输出转换成预测的格式。STSGCL的输出格式为$T \times N \times C$,reshape成$N \times TC$,然后使用$T’$个2层全连接，每个全连接输出维度为$(N,1)$,然后将$T’$个全连接的输出拼接成$N \times T’$</li><li><strong>损失函数使用Huber Loss，对异常值不敏感</strong><script type="math/tex; mode=display">L(Y, \hat{Y})=\left\{\begin{array}{ll}\frac{1}{2}(Y-\hat{Y})^{2} & |Y-\hat{Y}| \leq \delta \\\delta|Y-\hat{Y}|-\frac{1}{2} \delta^{2} & \text { otherwise }\end{array}\right.</script></li><li>使用mean-std归一化，训练集:验证集:测试集=6:2:2，模型包含4个STSGCL，每个STSGCM包含3个图卷积</li></ul><h2><span id="16-hyperst-net-hypernetworks-for-spatio-temporal-forecasting2019aaai">1.6. HyperST-Net: Hypernetworks for Spatio-Temporal Forecasting(2019AAAI)</span></h2><blockquote><p>潘哲逸(上海交通大学)<br>梁宇轩(西安电子科技大学)<br>张钧波(京东)<br>易修文(京东)<br>郑宇(京东)</p></blockquote><p>论文声称第一个考虑<strong>空间和时间内在因果关系</strong>的深度框架。</p><p><img src="/2020/02/27/时空论文阅读笔记/HyperST_Net.png" alt=""></p><ul><li>该论文提出的只是一个HyperNetwork框架，并不是一个具体的模型。</li><li><strong>HyperNetwork</strong>：和以往不同，以前都是一个网络的输出，输入到下一个网络中，<strong>超网络是一个网络的输出作为另一个网络的参数</strong>。</li><li>该模型有3个模块：空间模块，时间模块，推理模块。将空间模块的输出经过推理模块，得到的输出作为时间模块的权重参数，以此捕获时间和空间的内在因果关系。</li><li>这只是一个框架，可以变换成多种模型。在空间模块中如果使用全连接就是HyperST-Dense，使用卷积就是HyperST-Conv。</li></ul><h2><span id="17-urban-traffic-prediction-from-spatio-temporal-data-using-deep-meta-learning2019kdd">1.7. Urban Traffic Prediction from Spatio-Temporal Data Using Deep Meta Learning(2019KDD)</span></h2><blockquote><p>潘哲逸(上海交通大学)<br>梁宇轩(西安电子科技大学)<br>张钧波(京东)<br>郑宇(京东)<br><a href="https://github.com/panzheyi/ST-MetaNet" target="_blank" rel="noopener">https://github.com/panzheyi/ST-MetaNet</a> Mxnet</p></blockquote><ul><li>使用图中所有节点历史T个时间段的flow或speed，预测所有节点未来</li></ul><p><img src="/2020/02/27/时空论文阅读笔记/ST-MetaNet.png" alt=""></p><p><img src="/2020/02/27/时空论文阅读笔记/ST-MetaNet1.png" alt=""></p><p><img src="/2020/02/27/时空论文阅读笔记/ST-MetaNet2.png" alt=""></p><ul><li>本论文用的图，但是实验中有一个$I \times J$的网格数据，将网格数据构建成图</li><li>本论文来表示1张图有2个矩阵：图信号矩阵(N,D)和边特征矩阵(N,N,C)。对于网格数据来说，图信号矩阵表示每个网格POI个数，道路个数。边特征表示2个两个网格的道路个数。这都是静态数据，不随着时间变化。</li></ul><p>【总结】发现上面这2个论文都是一个网络生成另一个网络的参数，查阅资料发现这叫做<code>meta-learning</code>，先记录一下以后再自己看<br><img src="/2020/02/27/时空论文阅读笔记/Meta-learning.png" alt=""></p><h2><span id="18-stepdeep-a-novel-spatial-temporal-mobility-event-prediction-framework-based-on-deep-neural-networkkdd2018">1.8. StepDeep: A Novel Spatial-temporal Mobility Event Prediction Framework based on Deep Neural Network(KDD2018)</span></h2><blockquote><p>Bilong Shen(清华大学)<br>梁晓丹(卡耐基梅隆)</p></blockquote><ul><li><strong>S</strong>patial-<strong>T</strong>emporal mobility <strong>E</strong>vent <strong>P</strong>rediction framework based on <strong>Deep</strong> neural network (<strong>StepDeep</strong>)同时考虑时间和空间模式，给定所有区域历史T个时间段的出租车流量和外部因素，预测所有区域在下一个时间段出租车的inflow和outflow。</li><li>网格区域中的flow随时间变化，可以看做一个视频(T,C,W,H)，进而看做是视频预测任务</li><li>数据集NYC出租车轨迹数据，将NYC网格划分，计算每个区域的inflow和outflow，</li></ul><p><img src="/2020/02/27/时空论文阅读笔记/StepDeep.png" alt=""></p><p><img src="/2020/02/27/时空论文阅读笔记/StepDeep1.png" alt=""></p><ul><li>提出3种卷积：时间卷积，空间卷积，时空卷积。将输入(T,C,H,W)输入到以上7层卷积中，最终输出(C,H,W)表示下一个时间段所有区域的inflow和outflow，</li></ul><h2><span id="19-stgrat-a-spatio-temporal-graph-attention-network-for-traffic-forecastingaaai2020">1.9. STGRAT: A Spatio-Temporal Graph Attention Network for Traffic Forecasting(AAAI2020)</span></h2><blockquote><p>Cheonbok Park(韩国大学)<br>Chunggi Lee(韩国大学)<br>Hyojin Bahng(韩国大学)</p></blockquote><ul><li>根据所有节点历史T个时间段的交通速度，预测所有节点未来T个时间段的交通速度(T=12)，时间多预测多，Seq2Seq架构</li></ul><p><img src="/2020/02/27/时空论文阅读笔记/STGRAT.png" alt=""></p><ul><li>Encoder layer中有3个sublayer：空间Attention层，时间Attention层和point-wise FCN。<ul><li>空间Attention：关注每个时间步上空间邻近的节点</li><li>时间Attention：关注单个节点，输入时间序列的不同时间步</li></ul></li><li>整个Encoder = 1个嵌入层 + 4个Encoder layer，使用LINE对图节点进行嵌入</li></ul><p><img src="/2020/02/27/时空论文阅读笔记/STGRAT1.png" alt=""></p><ul><li>空间Attention层：参考Transformer，中心结点作为query，其邻居作为key和value，计算每个节点新的表示。</li><li>时间Attention==Transformer，输入维度(batch_size,T,N,D),计算时间步之间的attention分数，输出维度(batch_size,T,N,D)</li><li>Point-wise FFN和Transformer中一样，使用2层FCN，中间使用GELU激活函数，Transformer使用的是ReLU激活函数。</li><li>Decoder layer有4个sublayer：空间Attention层，mask时间Attention层，Encoder-Decoder Attention层，point-wise FFN层。整个Decoder层=1个嵌入层+4个Decoder层。</li><li><strong>本模型比Transformer多了一个空间Attention层，其余都一样，因为时间Attention层、FFN和Transformer的一样</strong></li></ul><h2><span id="110-connecting-the-dots-multivariate-time-series-forecasting-with-graph-neural-networks">1.10. Connecting the Dots: Multivariate Time Series Forecasting with Graph Neural Networks</span></h2><p>该模型使用图网络模型捕获交通数据或其他领域数据中的时间和空间相关性。</p><p><img src="/2020/02/27/时空论文阅读笔记/论文总结/MTGNN-1.png" alt=""></p><p>该模型有2个模块，图卷积模块和时间模块。其中图卷积模块主要解决4个问题：</p><ol><li>节点间的空间相关性</li><li>如何构造图</li><li>如何解决图卷积过度平滑问题</li><li>大图如何训练问题</li></ol><p><img src="/2020/02/27/时空论文阅读笔记/论文总结/MTGNN-2.png" alt=""></p><p>首先图信号矩阵，输入到图结构学习模块，构造图的邻接矩阵。注意这里的邻接矩阵不是预先定义好的，而是根据网络模块学习得到，据此构建图，然后输入到GCN中捕获时间相关性，然后输入到时间卷积捕获时间相关性，最后预测结果。</p><p><img src="/2020/02/27/时空论文阅读笔记/论文总结/MTGNN-3.png" alt=""></p><p>在构造图时，通过模型学习节点的嵌入矩阵，然后根据嵌入矩阵计算节点的相似性，为每个节点选取相似性前k的节点作为其一阶邻居。邻接矩阵不随着时间变化。</p><script type="math/tex; mode=display">\begin{array}{l}\mathbf{M}_{1}=\tanh \left(\alpha \mathrm{E}_{1} \Theta_{1}\right) \\ \mathbf{M}_{2}=\tanh \left(\alpha \mathrm{E}_{2} \mathbf{\Theta}_{2}\right) \\ \mathbf{A}=\operatorname{ReL} U\left(\tanh \left(\alpha\left(\mathbf{M}_{1} \mathbf{M}_{2}^{T}-\mathbf{M}_{2} \mathbf{M}_{1}^{T}\right)\right)\right) \\ \text { for } i=1,2, \cdots, N \\ \text { idx }=\operatorname{argtop} k(\mathrm{A}[i,:]) \\ \quad \mathrm{A}[i,-\mathrm{idx}]=0\end{array}</script><p>在图卷积模块，参考Min-hop架构，每个GCN层的输入会加上原始的图信号矩阵，避免图过度平滑问题，然后再将所有GCN层的输出加起来，进行融合。为了解决大图训练的问题，在进行GCN时，每次随机选取几个节点进行GCN运算，而不是使用所有的节点。</p><script type="math/tex; mode=display">\mathbf{H}^{(k)}=\beta \mathbf{H}_{i n}+(1-\beta) \tilde{\mathbf{A}} \mathbf{H}^{(k-1)}</script><script type="math/tex; mode=display">\mathbf{H}_{o u t}=\sum_{i=0}^{K} \mathbf{H}^{(k)} \mathbf{W}^{(k)}</script><p><img src="/2020/02/27/时空论文阅读笔记/论文总结/MTGNN-4.png" alt=""></p><p>在时间模块，使用一维空洞卷积，捕获长期的时间依赖，同时参照Inception结构，设置不同的卷积核，来捕获不同力度的周期性，例如小时周期，天周期，周周期。</p><p>总结：</p><ol><li>根据模型学习节点嵌入，由此构建邻接矩阵，构建相似性图</li><li>使用一维空洞卷积捕获时间相似性，使用不同的卷积核捕获不同粒度的周期性。</li></ol><h1><span id="2-eta预测">2. ETA预测</span></h1><h2><span id="21-when-will-you-arrive-estimating-travel-time-based-on-deep-neural-networksaaai20">2.1. When Will You Arrive? Estimating Travel Time Based on Deep Neural Networks(AAAI20)</span></h2><blockquote><p>王东(杜克大学)<br>张钧波(京东)<br>郑宇(京东)<br><a href="https://github.com/UrbComp/DeepTTE" target="_blank" rel="noopener">https://github.com/UrbComp/DeepTTE</a> Pytorch</p><ul><li>端到端<strong>Deep</strong> learning framework for <strong>T</strong>ravel <strong>T</strong>ime <strong>E</strong>stimation(<strong>DeepTTE</strong>)，给定路径P和外部因素(weather，day of week，开始时间)预测整个path的时间</li><li>原先的工作都是预测travel中单个路段的耗时，然后再把每个路段的时间加起来，缺点是没有考虑到道路交叉口，红绿灯等影响，错误累积</li></ul></blockquote><p><img src="/2020/02/27/时空论文阅读笔记/DeepTTE.png" alt=""></p><ul><li>DeepTTE提出geo-convolution，将地理信息加入到传统Conv中，捕获空间相关性</li><li>多任务学习，同时预测local path和entir path的时间，在loss中限制2者的权重</li><li><strong>在生成测试数据时，将历史轨迹点中的时间戳都去掉</strong>(因为要预测出行时间，所以测试数据不能带有事件信息)，从轨迹中抽样等距离的点组成路径P</li><li><p>DeepTTE一共有3个组件</p><ul><li>Attribute组件：外部因素：天气(one-hot)，司机ID(one-hot)，weekID和timeID(one-hot)，都是类别值，不能直接输入到网络中，需要先嵌入层低维向量，参考<a href="https://arxiv.org/abs/1512.05287" target="_blank" rel="noopener">(2016NIPS)A Theoretically Grounded Application of Dropout in Recurrent Neural Networks</a>,然后再和整个path的距离拼接作为该组件的输出</li><li>Geo-Conv层，历史轨迹是一个GPS序列，为了捕获空间依赖使用1D卷积，将历史轨迹序列先经过FCN变成一个矩阵$T \times V$,T个轨迹点，每个轨迹点有V个特征，然后使用C个k*V的1D卷积，卷积输出的时间维度变成$T-k+1$,将C个卷积核输出的结果拼接，然后再拼接上local path的距离,输出结果为$T-k+1 \times D$</li></ul><p><img src="/2020/02/27/时空论文阅读笔记/DeepTTE2.png" alt=""></p><ul><li>然后将$T-k+1 \times D$的序列拼接外部因素输入到LSTM中，每个时间步表示一个local path，将<strong>隐藏状态用来预测每个local path的时间作为辅助任务</strong></li><li>LTSM输出$T-k+1$个时间步，将其整合成1个向量，通过和外部因素做Attention，对每个local path赋予不同的权重，然后再和外部因素拼接，用来预测entir path的时间</li></ul></li><li><p><strong>训练阶段预测local path和entir path的时间，在测试阶段只预测entir path的时间</strong></p></li><li><p>在训练时，使用MAPE作为loss，包含辅助任务和主任务的loss<br><img src="/2020/02/27/时空论文阅读笔记/DeepTTE-loss.png" alt=""></p></li><li><p>这篇文章也是经典的CNN+LSTM的架构，只是这里的CNN是1D卷积。在融合外部因素上也是CNN的输出和外部因素拼接，送入到LSTM中。</p></li></ul><h1><span id="3-出租车需求预测">3. 出租车需求预测</span></h1><h2><span id="31-deep-multi-view-spatial-temporal-network-for-taxi-demand-predictionaaai2018">3.1. Deep Multi-View Spatial-Temporal Network for Taxi Demand Prediction(AAAI2018)</span></h2><blockquote><p>姚骅修(Pennsylvania State University)<br>吴飞(Pennsylvania State University)<br>柯金涛(香港科技大学)<br>Xianfeng Tang(Pennsylvania State University)<br>叶杰平(滴滴出行)<br><a href="https://github.com/huaxiuyao/DMVST-Net" target="_blank" rel="noopener">https://github.com/huaxiuyao/DMVST-Net</a> Keras</p></blockquote><ul><li><strong>出租车需求预测</strong>，根据S<em>S的小区域，历史T个时间段的出租车订单数据，预测下一个时间段中心区域的订单。<em>*空间和时间都是多预测一</em></em></li></ul><p><img src="/2020/02/27/时空论文阅读笔记/DMVST_Net.png" alt=""></p><ul><li>现有的研究都是使用CNN对空间建模，LSTM对时间建模，时间和空间分开建模，本文的模型是对时间和空间同时建模</li><li>本文提出DMVST-Net，有3个view：<strong>时间view</strong>（通过LSTM建模时间关系），<strong>空间view</strong>（使用local CNN建模邻近空间关系），<strong>语义view</strong>（建模功能相似的区域）</li><li>local CNN只考虑空间邻近的区域，但是不能考虑离得较远，但出租车需求模型相似的区域，所以又加了语义view</li><li><img src="/2020/02/27/时空论文阅读笔记/DMVST_Net-1.jpg" alt=""></li><li><strong>输入是S*S的邻居区域，如果是边界区域，其邻居用0填充</strong></li><li>在LSTM每个时间步的特征中拼接天气等外部因素</li><li>local CNN和LSTM对时间和空间建模，然后再构建图，表示区域之间需求相似性(功能相似性)。求出2个区域每周的需求量，形成一个时间序列，使用DTW计算2个序列的相似性，即<strong>2个区域的相似性，作为图中的边，创建一个全连接图(任意2个区域都相连)</strong>,使用LINE对图中节点进行嵌入。</li><li><img src="/2020/02/27/时空论文阅读笔记/DMVST_Net-2.png" alt=""><br>损失函数由MSE和MAPE组成，MSE更关注大值，为了避免模型偏向大值的方向训练，又添加了MAPE，但是使用MAPE时，真实值中不能有0</li><li>Max-Min激活，最终输出值在[0,1]之间，反归一化</li><li>最后一层FCN用sigmoid激活，其余的FCN用ReLU激活</li></ul><h2><span id="32-revisiting-spatial-temporal-similarity-a-deep-learning-framework-for-traffic-predictionaaai2019">3.2. Revisiting Spatial-Temporal Similarity: A Deep Learning Framework for Traffic Prediction(AAAI2019)</span></h2><blockquote><p>姚骅修(Pennsylvania State University)<br>Xianfeng Tang(Pennsylvania State University)<br><a href="https://github.com/tangxianfeng/STDN" target="_blank" rel="noopener">https://github.com/tangxianfeng/STDN</a> Keras</p></blockquote><ul><li>主要问题是：原先研究中的空间相关性都是静态的，本次建模<strong>动态的空间相关性</strong>。<strong>时间有天和周周期，且有时间偏移</strong>。</li><li>提出模型<strong>S</strong>patial-<strong>T</strong>emporal <strong>D</strong>ynamic <strong>N</strong>etwork(<strong>STDN</strong>)来traffic prediction</li><li>根据S<em>S小区域历史T个时间段的volume和flow，预测下一个时间段中心区域的volume，<em>*空间和时间都是多预测一</em></em></li></ul><p><img src="/2020/02/27/时空论文阅读笔记/STDN.png" alt=""></p><ul><li>将交通量分为2种<ul><li>traffic volume：无方向，一个区域进来和出去的流量。</li><li>traffic flow：有方向，从区域i到区域j的流量</li></ul></li><li>flow-gated local CNN每次输入S*S区域的volume和flow，其中flow起到门控作用，值在[0,1]之间，如果2个区域之间flow大，即门控的值大，2个区域的相关性强。每个时间段经过local CNN输出的值，再拼接上该时间段的天气等外部因素送入LSTM中</li><li><strong>时间偏移Attention</strong>：比如预测第t+1个时间段的volume，用到当天前t=7个时间段的数据(短期依赖)，前P=3天(长期依赖)，每天Q=3个时间段(解决时间偏移问题)。</li><li>先将短期的t个时间段数据输入LSTM中，得到隐藏状态h做Attention。前P天，每天Q个时间段输入到LSTM中，每天得到Q个隐藏状态，和h做attention，将Q个整合成1个，最终生成P个隐藏状态，再输入到LSTM，得到长期依赖的隐藏状态，然后再和短期的隐藏状态h拼接，输入到FCN中。</li><li><strong>短期的隐藏状态和长期的隐藏状态做Attention</strong></li><li><strong>短期的隐藏状态和长期的隐藏状态拼接</strong></li><li>数据集：出租车流量和自行车流量</li></ul><blockquote><ul><li>STDN和DMVST-Net是同一作者发的</li><li>两者都是：空间和时间<strong>多预测一</strong></li><li><strong>STDN</strong>：local CNN + LSTM</li><li><strong>DMVST-Net</strong>：flow-gated local CNN + Periodically Shifted Attention LSTM</li></ul></blockquote><h2><span id="33-spatiotemporal-multi-graph-convolution-network-for-ride-hailing-demand-forecastingaaai2019">3.3. Spatiotemporal Multi-Graph Convolution Network for Ride-hailing Demand Forecasting(AAAI2019)</span></h2><blockquote><p>Xu Geng(香港大学)<br>Yaguang Li(南加利福尼亚)<br>Lingyu Zhang(滴滴AI)<br>杨强(香港大学)<br>叶杰平(滴滴)</p></blockquote><p><img src="/2020/02/27/时空论文阅读笔记/ST_MGCN.png" alt=""></p><ul><li>问题：根据所有区域历史T个时间段的订单数，预测所有区域下一个时间段的订单数</li><li>将研究区域划分为网格，根据网格构建3个图，这3个图的图信号矩阵一样，只是邻接矩阵不一样。分别<ul><li><strong>邻居图</strong>（3*3网格，每个区域有8个邻居，2个区域是邻居，邻接矩阵为1，否则为0）；</li><li><strong>区域功能相似图</strong>（根据每个区域的POI，计算相似性，值在0&lt;=sim&lt;=1）；</li><li><strong>交通连通图</strong>（看2个区域是否在高速公路，公共交通等方式相连，相连为1，否则为0）</li></ul></li><li><strong>Channel-wise attention</strong>参考CV领域，图像输入$X \in \mathbb{R}^{W\times H \times C}$，计算每一个通道的权重$s$,然后再把输入和通道权重相乘$\tilde{\boldsymbol{X}}_{:,:,c}=\boldsymbol{X}_{:,:, c} \circ s_{c} \quad for \quad c=1,2, \cdots C$</li><li>一共有3类图，每类图的邻接矩阵不一样，图信号矩阵一样，表示该区域的订单数，图信号矩阵是动态的，每个时间段的图信号矩阵都不一样，一共有T个时间段。拿一个图距离，输入为(T,V,P),根据通道维的attention，<strong>这里将时间维作为通道维，对T个时间段做Attention</strong>，最终得到attention后的输入(T,V,P),然后输入到RNN中，因为RNN一次只能输入一个节点T个时间段的数据，但是这里有V个节点，这里V个节点共享一个RNN，最终得到隐藏状态，然后在把3个图的输出融合，得到最终的预测结果(所有区域下一个时间段的订单数)</li><li>T为5，根据ST_ResNet，其中3个邻近，1个天周期，1个周周期。</li></ul><h2><span id="34-passenger-demand-forecasting-with-multi-task-convolutional-recurrent-neural-networkspakdd2019">3.4. Passenger Demand Forecasting with Multi-Task Convolutional Recurrent Neural Networks(PAKDD2019)</span></h2><blockquote><p>Lei Bai1(University of New South Wales)<br>Lina Yao(University of New South Wales)<br>Salil S. Kanhere(University of New South Wales)</p></blockquote><ul><li>根据历史T个时间段<strong>相似区域</strong>出租车demand和人流量，预测下一个时间段中心区域的出租车demand。<strong>时间和空间都是多预测一</strong></li></ul><p><img src="/2020/02/27/时空论文阅读笔记/MT-CRNN.png" alt=""></p><ul><li>根据路网来划分区域</li><li>多任务预测：<ul><li><strong>主任务(回归)</strong>：预测中心区域的订单需求数</li><li><strong>辅助任务(分类)</strong>：预测中心区域的订单需求等级(高、中、低)</li></ul></li><li>主任务输入的是相似区域的订单数据和人流量数据，其中<strong>根据POI和taxi demand来计算2个区域的相似性</strong>，为中心区域选择m=3个最相似区域</li><li>使用外部信息(天气等)来预测订单需求等级(辅助任务)</li></ul><h2><span id="35-stg2seq-spatial-temporal-graph-to-sequence-model-for-multi-step-passenger-demand-forecasting2019ijcai">3.5. STG2Seq: Spatial-temporal Graph to Sequence Model for Multi-step Passenger Demand Forecasting(2019IJCAI)</span></h2><blockquote><p>Lei Bai1(University of New South Wales)<br>Lina Yao(University of New South Wales)<br>Salil S. Kanhere(University of New South Wales)</p></blockquote><ul><li>基于GCN，提出<strong>Seq2Seq的模型</strong>，来进行<strong>多步预测</strong>。本文说这是第一篇使用GCN来进行多步预测</li><li><p>大部分的研究只预测下一个时间段，本文预测多个时间段。以前的研究预测多个时间段使用seq2seq架构，里面是RNN或者其变体(ConvLSTM)，有个问题是：在decoder中，将前一个时间步的预测结果作为输入，会出现错误累积</p></li><li><p>将城市划分为N个小区域，基于网格或道路划分都可以</p></li><li><p>给定历史h个时间段的D(需求量，维度$N \times D_{in}$)和所有时间段的时间信息E，预测未来$\tau$个时间段的需求量<br><img src="/2020/02/27/时空论文阅读笔记/STG2Seq1.png" alt=""></p></li><li><p>图中每个节点表示一个小区域，图的邻接矩阵A中非0即1，根据区域demand的模式，计算2个区域的皮尔森相似度，如果相似度大于某个阈值，邻接矩阵为1，否则设置为0</p></li><li><p>模型主要有3个模块，假设预测时间段为$t+1,t+1,…,t+\tau$</p><ul><li>长期encoder：历史长期h个时间段，(h,N,D)</li><li>短期encoder：最近的q个时间段，(q,N,D)</li><li>Attention模块：在历史时间段中，找出对预测时间段的重要性</li></ul></li><li><p>长期encoder和短期encoder都是由GGCM组成，一个GGCM中有多个GCN。拿长期encoder举例，输入维度(h,N,D),每k个时间段(k,N,D)输入到GCN中，h个时间段一共有h-k+1个GCN，即经过一个GGCM，输入维度变成(h-k+1,N,D1)，每经过一个GGCM，时间维度都会变小，为了防止时间维度变小，会拼接上一个(k-1,N,D1)的全0padding，让其变成(h,N,D1)的维度，然后再输入到下一个GGCM中。<br>  <img src="/2020/02/27/时空论文阅读笔记/STG2Seq3.png" alt=""><br>  <img src="/2020/02/27/时空论文阅读笔记/STG2Seq4.png" alt=""></p></li><li>对于一个GCN中，输入维度是(k,N,D),reshape成(N,k*D),然后使用下面的公式。下面这个公式用到了残差连接，在经过GCN后，加上原来的$X^l$，同时和后面的sigmoid逐元素相乘，控制线性转换的哪部分可以通过门。<br><img src="/2020/02/27/时空论文阅读笔记/STG2Seq2.png" alt=""></li><li>在经过长期encoder和短期encoder后，将输出拼接，得到$(h+q,N,d_{out})$</li><li><strong>时间Attention</strong>：历史h+q个时间段对target时间段的影响不同，为了求出不同的影响程度，使用Attention机制。将$Y_{h+q}$reshape成$(h+q) \times (N \times d_{out})$<script type="math/tex; mode=display">\boldsymbol{\alpha}=\operatorname{softmax}\left(\tanh \left(Y_{h+q} W_{3}^{Y}+E_{T} W_{4}^{E}+b_{1}\right)\right)</script>其中$W_{3}^{Y} \in \mathbb{R}^{(h+q) \times\left(N \times d_{\text {out }}\right) \times 1}, W_{4}^{E} \in \mathbb{R}^{d_{e} \times(h+q)}$，$b_{1} \in \mathbb{R}^{(h+q)}$ 得到的Attention分数$\boldsymbol{\alpha} \in \mathbb{R}^{(h+q)}$<script type="math/tex; mode=display">Y_{\alpha}=\sum_{i=1}^{h+q} \alpha^{i} y_{i} \quad \in \mathbb{R}^{N \times d_{o u t}}</script></li><li><strong>通道Attention</strong>：经过上一步的时间Attention，得到的结果$Y_{\alpha}$维度为$N \times d_{out}$，然后再经过通道Attention，将$Y_{\alpha}$reshape成$N \times d_{out}$<script type="math/tex; mode=display">\boldsymbol{\beta}=\operatorname{softmax}\left(\tanh \left(Y_{\alpha} W_{5}^{Y}+E_{T} W_{6}^{E}+b_{2}\right)\right)</script>其中$W_{5}^{Y} \in \mathbb{R}^{d_{\text {out}} \times N \times 1}, W_{6}^{E} \in \mathbb{R}^{d_{e} \times d_{\text {out}}}, b_{2} \in \mathbb{R}^{d_{out}}$，$\boldsymbol{\beta} \in \mathbb{R}^{d_{\text {out }}}$<script type="math/tex; mode=display">Y_{\beta}=\sum_{i=1}^{d_{\text {out}}} \beta^{i} \mathscr{Y}_{i} \in \mathbb{R}^{N}</script></li><li>经过通道Attention，求得$Y_{\beta}$就是一个时间段的预测值</li></ul><p><strong>- 总结：</strong></p><ul><li>图的邻接矩阵非0即1，计算2个区域的相似度，大于阈值为1，否则为0</li><li>将历史时间段分为<strong>长期和短期</strong>，在历史时间段上设置一个<strong>长度为k的滑动窗口</strong>，每k个时间段都用不同的GCN来<strong>捕获空间关系</strong></li><li><strong>时间Attention</strong>：经过encoder后，将长期和短期的输出拼接，形成h+q个时间段，计算对target的时间段的时间Attention</li><li><strong>通道Attention</strong>：借鉴CV领域的思想《(CVPR2017)-Spatial and channel-wise attention in convolutional networks for image captioning》</li><li>使用GCN捕获空间相关性，然后分别使用时间Attention和通道Attention</li></ul><h1><span id="4-时间序列预测">4. 时间序列预测</span></h1><h2><span id="41-restful-resolution-aware-forecasting-of-behavioral-time-series-data2018cikm">4.1. RESTFul: Resolution-Aware Forecasting of Behavioral Time Series Data(2018CIKM)</span></h2><blockquote><p>吴宪(University of Notre Dame)<br>史宝旭(University of Notre Dame)<br>Yuxiao Dong(微软)<br>黄超(University of Notre Dame)</p></blockquote><p>本文使用<strong>多种时间粒度</strong>的<strong>时间序列数据</strong>来预测。<br>模型为<strong>RES</strong>olution-aware <strong>T</strong>ime <strong>S</strong>eries Forecasting (RESTFul)<br>第一个使用多种时间粒度来进行行为时间序列预测</p><p><img src="/2020/02/27/时空论文阅读笔记/RESTFul.png" alt=""></p><ul><li>有2个参数$\alpha和\beta$，取值{day,week}，限制α&gt;=β，<br>$\alpha$=1week,$\beta$=1day,表示1周测量1次，1次测1天。<br>$\alpha$=1week,$\beta$=1week,表示1周测量1次，1次测1周。<br>有一个完整的时间序列，要从中隔抽取不同时间粒度的时间序列。$X=\left[x_{1}, \ldots, x_{t}, \ldots, x_{T-1}, x_{T}\right]$，不同的$\alpha和\beta$就构成不同时间粒度的序列，序列长度为k，这里设置为5。</li><li>对于每一个时间序列都用GRU来捕获时间相关性，得到一个隐藏状态，那么n个时间序列就有n个隐藏状态</li><li>将所有的隐藏状态reshape成$\alpha <em> \beta </em> d$的张量，然后使用卷积融合不同粒度。</li><li>使用数据集：销售数据，311投诉数据</li></ul><h2><span id="42-multi-horizon-time-series-forecasting-with-temporal-attention-learningkdd2019">4.2. Multi-Horizon Time Series Forecasting with Temporal Attention Learning(KDD2019)</span></h2><blockquote><p>Chenyou Fan(京东金融)<br>Yuze Zhang(京东金融)<br>Yi Pan(京东金融)</p></blockquote><ul><li>使用前T个时间段的销售数据，预测未来<code>T&#39;</code>个时间段的销售数据</li><li>传统的encoder-decoder架构使用rnn,本文的一个改进是在decoder中使用BiLSTM</li></ul><p><img src="/2020/02/27/时空论文阅读笔记/BiLSTM-Enc-Dec.png" alt=""></p><p><img src="/2020/02/27/时空论文阅读笔记/BiLSTM-Enc-Dec1.png" alt=""></p><ul><li><strong>时间Attention</strong>:在decoder中第$t+1$个时间步生成的隐藏状态，对encoder中的隐藏状态进行attention，这里并不是对所有的历史时间段做attention，而是对历史$T_h$个时间段(可划分为M个period)做attention。例如上图中M=2，然后形成M个$c$向量，再经过FCN转换成$d$，然后再将M个$d$向量融合，这里使用attention融合，通过decoder的隐藏状态$h_{t+1}$对M个向量d做attention，将其融合成1个向量，然后再和$h_{t+1}$拼接，输入到FCN中预测第$t+1$个时间步的$y_{t+1}$，decoder中每个时间步都输出该时间步的预测值$y$。</li><li>本文的创新点就是：BILSTM和时间local Attention(只和局部时间段做Attention)</li></ul><h1><span id="5-总结">5. 总结</span></h1><h2><span id="51-网格gt图">5.1. 网格—&gt;图</span></h2><p>图用2个矩阵表示：图信号矩阵和邻接矩阵。由网格构建图时，节点表示区域，图信号矩阵就是区域的特征。重点是怎么构建邻接矩阵。</p><ul><li>《Spatiotemporal Multi-Graph Convolution Network for Ride-hailing Demand Forecasting》(AAAI2019)这篇文章构建了3个图：邻居图，POI功能相似图，交通连通图</li><li>《RiskOracle: A Minute-level Citywide Traffic Accident Forecasting Framework》(AAAI2020)有27*27个网格，但只有354个网格有道路，所以构建图中有354个节点。根据区域之间的道路静态信息和交通动态信息(flow和speed)来计算区域之间的相似性，构建邻接矩阵。由于动态交通信息随时间变化，所有每个时间段的相似性都不同，即每个时间段的邻接矩阵都不一样。<ul><li>图信号矩阵：区域的flow，speed、和前一个时间段的差值</li><li>邻接矩阵：区域之间的相似性，在[0,1]之间</li></ul></li></ul><p><strong>邻接矩阵的构造</strong></p><ul><li><p>邻接矩阵，非0即1，如果2个区域相邻，为1，否则为0<br>《Spatial-Temporal Synchronous Graph Convolutional Networks: A New Framework for Spatial-Temporal Network Data Forecasting》（AAAI2020）</p></li><li><p>计算2个区域的相似性，如果2个区域的相似度大于某个阈值，设置为1，否则为0<br>《STG2Seq: Spatial-temporal Graph to Sequence Model for Multi-step Passenger Demand Forecasting》（2019IJCAI）</p></li><li>计算2个区域的相似性，使用相似性作为邻接矩阵的值<br>《RiskOracle: A Minute-level Citywide Traffic Accident Forecasting Framework》（AAAI2020）</li><li>计算2个节点的相似性，为每个节点选取相似性前k的节点作为其一阶邻居，其余节点的相似性设置为0，例如《Connecting the Dots: Multivariate Time Series Forecasting with Graph Neural Networks》2020KDD</li></ul><h2><span id="52-动态图">5.2. 动态图</span></h2><p>一般的图卷积的输入维度是<code>(batch_size,N,C)</code>，即只有一个时间段，但如果输入的是动态图即<code>(batch_size,T,N,C)</code>，该怎么办？</p><script type="math/tex; mode=display">h^{(l)}=\left(\hat{A} h^{(l-1)} W_{1}+b_{1}\right)</script><ul><li><code>(batch_size,T,N,C)--&gt;(batch_size,T*N,C)--&gt;(T*N,batch_size,C)</code>,例如《Spatial-Temporal Synchronous Graph Convolutional Networks: A New Framework for Spatial-Temporal Network Data Forecasting》（AAAI2020）,将时间T乘到节点N上，需要对邻接矩阵进行变换成<code>(TN,TN)</code>的形式，才可以和h相乘。不常用，除非对邻接矩阵A进行变换</li><li><code>(batch_size,T,N,C)--&gt;(batch_size,N,T*C)</code>，可以先经过一个FCN，将其转换为<code>(batch_size,N,D)</code>,然后再输出到GCN中，也可以不经过FCN，直接输入到GCN中。较常用，例如：<br>《RiskOracle: A Minute-level Citywide Traffic Accident Forecasting Framework》（AAAI2020）<br>《STG2Seq: Spatial-temporal Graph to Sequence Model for Multi-step Passenger Demand Forecasting》（2019IJCAI）</li></ul><h2><span id="53-计算2个区域的相似性">5.3. 计算2个区域的相似性</span></h2><ul><li><p>用<strong>出租车需求量</strong>计算2个区域的<strong>相似性</strong>，用2个区域<strong>训练集</strong>中出租车需求量组成时间序列</p><ul><li>使用DTW计算2个序列的相似性，2个时间序列越相似，说明2个区域越相似。例如：《Deep Multi-View Spatial-Temporal Network for Taxi Demand Prediction》(AAAI2018)</li><li>使用皮尔森度量函数Pearson Correlation Coefficient，<br>《Passenger Demand Forecasting with Multi-Task Convolutional Recurrent Neural Networks》(2019PAKDD)<br>《STG2Seq: Spatial-temporal Graph to Sequence Model for Multi-step Passenger Demand Forecasting》（2019IJCAI）</li></ul></li><li><p>计算2个区域之间的<strong>相关性</strong>，使用<strong>区域间带有方向的traffic flow</strong>，如果2个区域之间的traffic flow越大，说明这2个区域越相关。但是《R evisiting Spatial-Temporal Similarity: A Deep Learning Framework for Traffic Prediction》(AAAI2019)说这种相关性也是相似性。我觉得有问题，例如工作区和住宅区，2个区域的traffic flow很大，有很强的相关性，但是相似性并不强。</p></li><li>根据<strong>POI</strong>计算2个区域的相似性<ul><li>例如《Passenger Demand Forecasting with Multi-Task Convolutional Recurrent Neural Networks》(2019PAKDD)</li><li>《Spatiotemporal Multi-Graph Convolution Network for Ride-hailing Demand Forecasting》(2019AAAI)但是这篇文章没有提到使用什么函数来计算相似度</li></ul></li><li>《RiskOracle: A Minute-level Citywide Traffic Accident Forecasting Framework》(AAAI2020)根据区域的道路静态信息和交通动态信息(flow和speed)计算2个区域的相似性。使用JS散度</li></ul><h2><span id="54-poi">5.4. POI</span></h2><p>很多论文中都习惯将POI成为Semantic</p><ul><li>《Deep Multi-View Spatial-Temporal Network for Taxi Demand Prediction》(AAAI2018)</li><li>《DeepSTN+: Context-aware Spatial-Temporal Neural Network for Crowd Flow Prediction in Metropolis》(AAAI2019)</li></ul><h2><span id="55-时间相关性">5.5. 时间相关性</span></h2><p>像dayOfWeek，monthOfYear等时间信息，在论文中称作<strong>time meta feature</strong></p><ul><li>使用RNN来捕获时间相关性</li><li>使用1D卷积来捕获时间相关性，或者使用1D空洞卷积，来捕获长期的时间相关性。或者参照Inception结构，使用不同大小的卷积核来捕获不同粒度的周期性，例如WaveNet，MTGNN</li><li>使用不同的模块捕获不同粒度的周期性，例如ST-ResNet，DeepSTN，ASTGCN</li></ul><h2><span id="56-lstm共t个隐藏状态整合">5.6. LSTM共T个隐藏状态整合</span></h2><p>LSTM一共有T个时间步，将输出T个隐藏状态，怎么将其整合成1个，有3种方法：</p><ul><li>只取最后一个时间步的隐藏状态，例如<br>《Deep Multi-View Spatial-Temporal Network for Taxi Demand Prediction》(AAAI2018)</li><li>将T个时间步的隐藏状态拼接或平均或加和</li><li>将T个时间步的隐藏状态和被预测时间步的某个向量(e.g.外部因素)做Attention，对每个时间步赋予不同的权重，整合成1个向量。例如<br>《Revisiting Spatial-Temporal Similarity: A Deep Learning Framework for Traffic Prediction》(AAAI2019)<br>《When Will You Arrive? Estimating Travel Time Based on Deep Neural Networks》(AAAI20)</li></ul><h2><span id="57-外部因素嵌入">5.7. 外部因素嵌入</span></h2><p>外部因素包括：天气，时间，holiday等信息，</p><ul><li>外部因素中<strong>类别值</strong>(dayOfWeek，weather等)用one-hot表示，<strong>连续值</strong>(温度，风速)等用float表示，将这些外部因素拼接在一起，送入FCN中做嵌入。<br>例如《 Deep Spatio-Temporal Residual Networks for Citywide Crowd Flows Prediction(AAAI2017)》</li><li>外部因素中<strong>类别值</strong>(dayOfWeek，weather等)直接用数字表示，例如周一用0表示，周日用6表示。<strong>连续值</strong>(温度，风速)等用float表示，然后将每个类别值用对应的Embedding嵌入，然后再把嵌入的结果拼接<br>例如《When Will You Arrive? Estimating Travel Time Based on Deep Neural Networks(AAAI20)》<br><code>Embedding</code>相关知识参考<a href="https://echohhhhhh.github.io/2020/02/24/Pytorch%E4%B9%8B%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB/#12-embedding" target="_blank" rel="noopener">Pytorhc之Embedding</a></li></ul><h2><span id="58-mask">5.8. mask</span></h2><p>有时候mask是舍弃一些不想关注的值，比如预测车流量时，真实车流量小于5的值则舍弃，即不关注那些车流量小的值预测结果，只关注大约5的值的预测结果。一般在评价指标中mask</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">mask_mae_np</span><span class="params">(y_true,y_pred,region_mask,null_val=None)</span>:</span></span><br><span class="line">    <span class="string">"""计算MAE</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    Arguments:</span></span><br><span class="line"><span class="string">        y_true &#123;np.ndarray&#125; -- 真实值,维度(samples,pre_len,W,H)</span></span><br><span class="line"><span class="string">        y_pred &#123;np.ndarray&#125; -- 预测值,维度(samples,pre_len,W,H)</span></span><br><span class="line"><span class="string">        region_mask &#123;np.ndarray&#125; -- mask矩阵,维度(W,H)</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    Returns:</span></span><br><span class="line"><span class="string">        np.float64 -- MAE值</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    y_true,y_pred = transfer_dtype(y_true,y_pred)</span><br><span class="line">    <span class="keyword">if</span> null_val <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span>:</span><br><span class="line">        label_mask = np.where(y_true &gt; <span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>).astype(<span class="string">'float32'</span>)</span><br><span class="line">        <span class="comment"># label_mask = np.not_equal(y_true, null_val).astype('float32')</span></span><br><span class="line">        mask = region_mask * label_mask</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        mask = region_mask</span><br><span class="line">    mask /= mask.mean()</span><br><span class="line">    <span class="keyword">return</span> np.mean(np.abs(y_true-y_pred)*mask)</span><br></pre></td></tr></table></figure><h2><span id="59-max-min归一化">5.9. Max-min归一化</span></h2><p>使用Max-Min将数据归一化到[0,1]，但是也有论文归一化成[-1,1]，如下所示：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MinMaxNormalization</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="string">'''MinMax Normalization --&gt; [-1, 1]</span></span><br><span class="line"><span class="string">       x = (x - min) / (max - min).</span></span><br><span class="line"><span class="string">       x = x * 2 - 1</span></span><br></pre></td></tr></table></figure><p>【注意】对特征和y归一化有2种方式：</p><ol><li><strong>只对特征进行归一化，y不进行归一化</strong>，模型预测的结果和真实y是同一量纲，模型的loss会偏大，计算评价指标时，不需要反归一化</li><li><strong>对特征和y都归一化</strong>，y归一化到[0,1]之间，在计算loss时，不需要反归一化，loss相对方法1会偏小，在计算评价指标时，需要对真实y和预测y进行反归一化，再计算MAE等指标</li><li><p>关于上面是否需要对y进行归一化。如果模型收敛(loss一直在下降)，可以不对y进行归一化。如果模型不收敛(数值过大)，则需要对y进行归一化。</p><p><img src="/2020/02/27/时空论文阅读笔记/神经网络踩坑/y-norm.png" alt=""><br>如果对y进行归一化，loss初始值很小，模型训练时很快就会收敛loss不再下降。不对y归一化，loss初始值很大，在训练过程中，训练很多轮loss才开始收敛，可能还会造成训练过程不稳定，loss上下震荡。</p></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;因为疫情推迟开学，在家把以前看的论文又看了一遍，每重新看一次都有新的收获，在此整理下。&lt;/p&gt;
    
    </summary>
    
      <category term="论文阅读笔记" scheme="http://yoursite.com/categories/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="时空领域" scheme="http://yoursite.com/tags/%E6%97%B6%E7%A9%BA%E9%A2%86%E5%9F%9F/"/>
    
  </entry>
  
  <entry>
    <title>VSCode连接服务器太慢</title>
    <link href="http://yoursite.com/2020/02/26/VSCode%E8%BF%9E%E6%8E%A5%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%A4%AA%E6%85%A2/"/>
    <id>http://yoursite.com/2020/02/26/VSCode连接服务器太慢/</id>
    <published>2020-02-26T09:59:55.000Z</published>
    <updated>2020-02-26T12:26:38.519Z</updated>
    
    <content type="html"><![CDATA[<p>使用VSCode远程连接服务器太慢，是因为需要远程下载vscode-server-linux-x64.tar.gz，下载太慢，下面是解决方案</p><a id="more"></a><p><img src="/2020/02/26/VSCode连接服务器太慢/vscode.png" alt=""></p><p><a href="https://blog.csdn.net/bcfd_yundou/article/details/96135456" target="_blank" rel="noopener">vscode搭建远程开发</a></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">先将vscode-server-linux-x64.tar.gz拷贝到/data/WangBeibei/.vscode-server/bin/xxx下面，并解压</span></span><br><span class="line">tar -xzvf vscode-server-linux-x64.tar.gz</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">删掉压缩包</span></span><br><span class="line">rm -r vscode-server-linux-x64.tar.gz</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">将vscode-server-linux-x64目录中所有内容移到/data/WangBeibei/.vscode-server/bin/xxx下面</span></span><br><span class="line">mv /data/WangBeibei/.vscode-server/bin/xxx/vscode-server-linux-x64/* /data/WangBeibei/.vscode-server/bin/xxx</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">删掉vscode-server-linux-x64</span></span><br><span class="line">rm -r vscode-server-linux-x64</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;使用VSCode远程连接服务器太慢，是因为需要远程下载vscode-server-linux-x64.tar.gz，下载太慢，下面是解决方案&lt;/p&gt;
    
    </summary>
    
      <category term="工具" scheme="http://yoursite.com/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="VSCode" scheme="http://yoursite.com/tags/VSCode/"/>
    
  </entry>
  
  <entry>
    <title>对loss进行mask</title>
    <link href="http://yoursite.com/2020/02/25/%E5%AF%B9loss%E8%BF%9B%E8%A1%8Cmask/"/>
    <id>http://yoursite.com/2020/02/25/对loss进行mask/</id>
    <published>2020-02-25T05:37:12.000Z</published>
    <updated>2020-03-06T16:32:42.950Z</updated>
    
    <content type="html"><![CDATA[<h1><span id="简介">简介</span></h1><p>在计算loss和评价指标时，对一些不关注的值进行mask。下面介绍mask的使用。</p><a id="more"></a><h1><span id="对loss进行mask">对loss进行mask</span></h1><p>在NLP中的Seq2Seq中经常会对loss进行mask，因为一个batch中句子的长度通常不一样，一个batch中不足长度的位置用0填充，最后生成句子计算loss时需要忽略掉原先那些padding的值，即只保留mask中值为1的位置，忽略值为0的位置。在计算loss时，将那些本不应该计算的mask掉，使其loss为0，这样就不会反向传播了。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">masked_predicts = torch.masked_select(predicts, mask)</span><br><span class="line">masked_targets = torch.masked_select(targets, mask)</span><br><span class="line">loss = my_criterion(masked_predicts, masked_targets)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">diff2 = (torch.flatten(input) - torch.flatten(target)) ** <span class="number">2.0</span> * torch.flatten(mask)</span><br><span class="line">loss = torch.sum(diff2) / torch.sum(mask)</span><br><span class="line">out.backward()</span><br></pre></td></tr></table></figure><p>有时候mask是舍弃一些不想关注的值，比如预测车流量时，真实车流量小于5的值则舍弃，即不关注那些车流量小的值预测结果，只关注大约5的值的预测结果。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">masked_mean_squared_error</span><span class="params">(y_true, y_pred)</span>:</span></span><br><span class="line">    idx = (y_true &gt; <span class="number">5</span>).nonzero()</span><br><span class="line">    <span class="keyword">return</span> K.mean(K.square(y_pred[idx] - y_true[idx]))</span><br></pre></td></tr></table></figure><h1><span id="pytorch的mask_select函数">Pytorch的mask_select函数</span></h1><p><code>torch.masked_select(input, mask, out=None) → Tensor</code><br>返回1-D的Tensor</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>x = torch.randn(<span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x</span><br><span class="line">tensor([[ <span class="number">0.3552</span>, <span class="number">-2.3825</span>, <span class="number">-0.8297</span>,  <span class="number">0.3477</span>],</span><br><span class="line">        [<span class="number">-1.2035</span>,  <span class="number">1.2252</span>,  <span class="number">0.5002</span>,  <span class="number">0.6248</span>],</span><br><span class="line">        [ <span class="number">0.1307</span>, <span class="number">-2.0608</span>,  <span class="number">0.1244</span>,  <span class="number">2.0139</span>]])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>mask = x.ge(<span class="number">0.5</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>mask</span><br><span class="line">tensor([[<span class="keyword">False</span>, <span class="keyword">False</span>, <span class="keyword">False</span>, <span class="keyword">False</span>],</span><br><span class="line">        [<span class="keyword">False</span>, <span class="keyword">True</span>, <span class="keyword">True</span>, <span class="keyword">True</span>],</span><br><span class="line">        [<span class="keyword">False</span>, <span class="keyword">False</span>, <span class="keyword">False</span>, <span class="keyword">True</span>]])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>torch.masked_select(x, mask)</span><br><span class="line">tensor([ <span class="number">1.2252</span>,  <span class="number">0.5002</span>,  <span class="number">0.6248</span>,  <span class="number">2.0139</span>])</span><br></pre></td></tr></table></figure><p>【参考资料】</p><p><a href="http://www.linzehui.me/2018/10/12/%E7%A2%8E%E7%89%87%E7%9F%A5%E8%AF%86/%E6%B5%85%E8%B0%88mask%E7%9F%A9%E9%98%B5/" target="_blank" rel="noopener">浅谈mask矩阵</a><br><a href="https://github.com/xlwang233/pytorch-DCRNN/blob/master/lib/metrics.py" target="_blank" rel="noopener">pytorch-DCRNN</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h1&gt;&lt;p&gt;在计算loss和评价指标时，对一些不关注的值进行mask。下面介绍mask的使用。&lt;/p&gt;
    
    </summary>
    
      <category term="Deep Learning" scheme="http://yoursite.com/categories/Deep-Learning/"/>
    
    
      <category term="Deep Learning" scheme="http://yoursite.com/tags/Deep-Learning/"/>
    
  </entry>
  
  <entry>
    <title>Pytorch之知识点汇总</title>
    <link href="http://yoursite.com/2020/02/24/Pytorch%E4%B9%8B%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB/"/>
    <id>http://yoursite.com/2020/02/24/Pytorch之知识点汇总/</id>
    <published>2020-02-24T09:08:12.000Z</published>
    <updated>2020-07-08T03:23:00.354Z</updated>
    
    <content type="html"><![CDATA[<h1><span id="1-简介">1. 简介</span></h1><p>汇总Pytorch的一些知识点</p><a id="more"></a><!-- TOC --><ul><li><a href="#1-简介">1. 简介</a></li><li><a href="#2-查看网络参数">2. 查看网络参数</a></li><li><a href="#3-分类问题">3. 分类问题</a></li><li><a href="#4-crossentropyloss和nllloss-区别">4. CrossEntropyLoss()和NLLLoss() 区别</a></li><li><a href="#5-模型训练示例">5. 模型训练示例</a></li><li><a href="#6-关闭梯度">6. 关闭梯度</a></li><li><a href="#7-gpu">7. GPU</a></li><li><a href="#8-多gpu运行程序">8. 多GPU运行程序</a></li><li><a href="#9-tensor">9. Tensor</a></li><li><a href="#10-bn和dropout在训练和测试的不同">10. BN和Dropout在训练和测试的不同</a></li><li><a href="#11-linear">11. Linear</a></li><li><a href="#12-embedding">12. Embedding</a></li><li><a href="#13-linear参数维度">13. Linear参数维度</a></li></ul><!-- /TOC --><h1><span id="2-查看网络参数">2. 查看网络参数</span></h1><ul><li><p>方法1</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> param <span class="keyword">in</span> network.parameters():</span><br><span class="line">  print(param.shape)</span><br></pre></td></tr></table></figure></li><li><p>方法2<br>可以查看参数的名称</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> name, param <span class="keyword">in</span> network.named_parameters():</span><br><span class="line">  print(name, <span class="string">'\t\t'</span>, param.shape)</span><br></pre></td></tr></table></figure></li></ul><h1><span id="3-分类问题">3. 分类问题</span></h1><p>例如Fashion-MNIST分类任务中，一共有10类。假设batch_size=16,每个batch的feature维度为(16,1,28,28)，label的维度(16,)，经过模型最终输出的预测结果维度(16,10)，然后我们使用<code>argmax()</code>来得出最终的预测类别。然后可以和真实label比较，看预测结果的正确性,计算预测正确的个数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&gt; preds.argmax(dim=<span class="number">1</span>)</span><br><span class="line">tensor([<span class="number">5</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">4</span>])</span><br><span class="line"></span><br><span class="line">&gt; labels</span><br><span class="line">tensor([<span class="number">9</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">3</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">7</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">5</span>])</span><br><span class="line"></span><br><span class="line">&gt; preds.argmax(dim=<span class="number">1</span>).eq(labels)</span><br><span class="line">tensor([<span class="keyword">False</span>, <span class="keyword">False</span>, <span class="keyword">False</span>, <span class="keyword">False</span>, <span class="keyword">False</span>, <span class="keyword">False</span>, <span class="keyword">False</span>, <span class="keyword">False</span>, <span class="keyword">True</span>, <span class="keyword">False</span>], dtype=torch.bool)</span><br><span class="line"></span><br><span class="line">&gt; preds.argmax(dim=<span class="number">1</span>).eq(labels).sum()</span><br><span class="line">tensor(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">&gt; preds.argmax(dim=<span class="number">1</span>).eq(labels).sum().item()</span><br><span class="line"><span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#得到每个batch预测正确的样本</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_num_correct</span><span class="params">(preds, labels)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> preds.argmax(dim=<span class="number">1</span>).eq(labels).sum().item()</span><br></pre></td></tr></table></figure><h1><span id="4-crossentropyloss和nllloss-区别">4. CrossEntropyLoss()和NLLLoss() 区别</span></h1><p><code>CrossEntropyLoss()=log_softmax() + NLLLoss()</code></p><p><a href="https://blog.csdn.net/zwqjoy/article/details/96282788" target="_blank" rel="noopener">Pytorch nn.CrossEntropyLoss()和nn.NLLLoss() 区别</a></p><p><a href="https://www.cnblogs.com/marsggbo/p/10401215.html" target="_blank" rel="noopener">Pytorch里的CrossEntropyLoss详解</a>  </p><p><a href="https://www.zhihu.com/question/66782101" target="_blank" rel="noopener">PyTorch 中，nn 与 nn.functional 有什么区别</a></p><h1><span id="5-模型训练示例">5. 模型训练示例</span></h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">network = Network()</span><br><span class="line"></span><br><span class="line">train_loader = torch.utils.data.DataLoader(train_set, batch_size=<span class="number">100</span>)</span><br><span class="line">optimizer = optim.Adam(network.parameters(), lr=<span class="number">0.01</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> epoch <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">    </span><br><span class="line">    total_loss = <span class="number">0</span></span><br><span class="line">    total_correct = <span class="number">0</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> batch <span class="keyword">in</span> train_loader: <span class="comment"># Get Batch</span></span><br><span class="line">        images, labels = batch </span><br><span class="line"></span><br><span class="line">        preds = network(images) <span class="comment"># Pass Batch</span></span><br><span class="line">        loss = F.cross_entropy(preds, labels) <span class="comment"># Calculate Loss</span></span><br><span class="line"></span><br><span class="line">        optimizer.zero_grad()</span><br><span class="line">        loss.backward() <span class="comment"># Calculate Gradients</span></span><br><span class="line">        optimizer.step() <span class="comment"># Update Weights</span></span><br><span class="line"></span><br><span class="line">        total_loss += loss.item()</span><br><span class="line">        total_correct += get_num_correct(preds, labels)</span><br><span class="line"></span><br><span class="line">    print(</span><br><span class="line">        <span class="string">"epoch"</span>, epoch, </span><br><span class="line">        <span class="string">"total_correct:"</span>, total_correct, </span><br><span class="line">        <span class="string">"loss:"</span>, total_loss</span><br><span class="line">    )</span><br></pre></td></tr></table></figure><h1><span id="6-关闭梯度">6. 关闭梯度</span></h1><p>关闭梯度有2种方法</p><ul><li><p>方法1：在模型训练的时候，需要计算梯度，但是在测试的时候不需要计算梯度，那我们就可以使用<code>@torch.no_grad()</code>。下面代码示例求所有的预测结果</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@torch.no_grad()</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_all_preds</span><span class="params">(model, loader)</span>:</span></span><br><span class="line">    all_preds = torch.tensor([])</span><br><span class="line">    <span class="keyword">for</span> batch <span class="keyword">in</span> loader:</span><br><span class="line">        images, labels = batch</span><br><span class="line">        preds = model(images)</span><br><span class="line">        all_preds = torch.cat(</span><br><span class="line">            (all_preds, preds),dim=<span class="number">0</span>)</span><br><span class="line">  <span class="keyword">return</span> all_preds</span><br></pre></td></tr></table></figure></li></ul><p>使用<code>@torch.no_grad()</code>就不用再记录梯度的轨迹(不用再保存动态图的计算轨迹)，省内存。</p><ul><li><p>方法2：<br>使用<code>with torch.no_grad()</code>在函数内部</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> torch.no_grad():</span><br><span class="line">  prediction_loader = torch.utils.data.DataLoader(train_set, batch_size=<span class="number">10000</span>)</span><br><span class="line">  train_preds = get_all_preds(network, prediction_loader)</span><br></pre></td></tr></table></figure></li></ul><h1><span id="7-gpu">7. GPU</span></h1><p>在这里原先一直有个误区，误认为<code>device = torch.device(&quot;cuda&quot;)</code>获取所有的GPU，<code>device = torch.device(&quot;cuda:0&quot;)</code>获取第一个GPU。下面是正解：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#程序只能看到1,2,3序号的GPU，然后重新给它们编号为：0,1,2</span></span><br><span class="line">&gt; os.environ[<span class="string">"CUDA_VISIBLE_DEVICES"</span>] = <span class="string">'1,2,3'</span></span><br><span class="line"></span><br><span class="line">&gt; device = torch.device(<span class="string">"cuda:0"</span>)<span class="comment">#获取下标为0的GPU</span></span><br><span class="line">device(type=<span class="string">'cuda'</span>, index=<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#如果不指定cuda编号，其实有一个默认编号，</span></span><br><span class="line"><span class="comment">#默认为torch.cuda.current_device()，该值默认为0</span></span><br><span class="line">&gt; device = torch.device(<span class="string">"cuda"</span>)</span><br><span class="line">device(type=<span class="string">'cuda'</span>)</span><br><span class="line"></span><br><span class="line">&gt; torch.cuda.current_device()</span><br><span class="line"><span class="number">0</span></span><br></pre></td></tr></table></figure><p>也就是说<code>device = torch.device(&quot;cuda&quot;)</code>还是1个GPU，等价于<code>device = torch.device(&quot;cuda:X&quot;)</code>,其中<code>X = torch.cuda.current_device()</code>  </p><p>【<strong>参考资料</strong>】</p><p><a href="https://pytorch.apachecn.org/docs/1.0/tensor_attributes.html" target="_blank" rel="noopener">torch.device</a></p><p><a href="https://pytorch.org/docs/stable/notes/cuda.html" target="_blank" rel="noopener">CUDA SEMANTICS</a></p><h1><span id="8-多gpu运行程序">8. 多GPU运行程序</span></h1><p><a href="https://echohhhhhh.github.io/2020/01/06/Pytorch%E4%B9%8BGPU%E7%A8%8B%E5%BA%8F/" target="_blank" rel="noopener">Pytorch之GPU程序</a></p><p><a href="https://echohhhhhh.github.io/2019/12/29/%E8%BF%90%E8%A1%8CGPU%E7%A8%8B%E5%BA%8F/" target="_blank" rel="noopener">运行GPU程序</a></p><h1><span id="9-tensor">9. Tensor</span></h1><p><a href="https://echohhhhhh.github.io/2020/02/17/Pytorch%E4%B9%8BTensor%E5%AD%A6%E4%B9%A0/" target="_blank" rel="noopener">Pytorch之Tensor学习</a></p><h1><span id="10-bn和dropout在训练和测试的不同">10. BN和Dropout在训练和测试的不同</span></h1><p><code>model.train()</code>:启用 BatchNormalization 和 Dropout<br><code>model.eval()</code>:不启用 BatchNormalization 和 Dropout<br>训练完train样本后，生成的模型model要用来测试样本。在model(test)之前，需要加上model.eval()，否则的话，有输入数据，即使不训练，它也会改变权值。这是model中含有batch normalization层所带来的的性质。</p><p>参考资料<br><a href="https://zhuanlan.zhihu.com/p/54986509" target="_blank" rel="noopener">Pytorch model.train 与 model.eval</a><br><a href="https://discuss.pytorch.org/t/model-eval-vs-with-torch-no-grad/19615/19" target="_blank" rel="noopener">‘model.eval()’ vs ‘with torch.no_grad()’</a><br><a href="https://github.com/pytorch/examples/blob/master/word_language_model/main.py" target="_blank" rel="noopener">https://github.com/pytorch/examples/word_language_model</a></p><h1><span id="11-linear">11. Linear</span></h1><p>原先误以为Pytorch中的Linear的输入只能接受二维数据，实际上Linear的输入数据可以是三维、四维等更多维。但是<strong>输入数据的最后一维一定要和<code>in_dim</code>一致，输出数据维度就是把<code>in_dim</code>换成了<code>out_dim</code>，前面所有的维度都不变</strong>。<br>例如定义一个全连接<code>nn.Linear(10,5)</code>，输入数据维度为(3,6,10),输出维度为(3,6,5)。即输入数据最后一个维度一定要和<code>in_dim</code>一致，也不用纠结到底3是batch_size,还是6是batch_size，因为最终输出的数据只有最后一个维度变化，前面维度都不变。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dense = nn.Linear(in_dim,out_dim)</span><br></pre></td></tr></table></figure><hr><p>2020.3.7更新</p><h1><span id="12-embedding">12. Embedding</span></h1><p><code>Embedding</code>层常用在词嵌入中，目的是将高维数据变成稠密的低维数据。例如：字典共9个字：[我,你,看,吃,吧,吗,饭,了,的]，例句：吃饭了吗，对这句话用向量表示有2种方式：</p><ul><li>one-hot表示<br>[0,0,0,1,0,0,0,0,0],<br>[0,0,0,0,0,0,1,0,0],<br>[0,0,0,0,0,0,0,1,0],<br>[0,0,0,0,0,1,0,0,0]<br>one-hot表示过于稀疏，如果字典中的层变大，维度会非常高</li><li><p>使用<code>Embedding</code>,字典中共有9个字，下标从0~8，例句被表示为[3,6,7,5],但是只用数字并不能表示字的含义和相似度，下面使用Embedding对其嵌入。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># example with padding_idx</span></span><br><span class="line">embedding = nn.Embedding(<span class="number">9</span>, <span class="number">3</span>)</span><br><span class="line">input = torch.LongTensor([[<span class="number">3</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">5</span>]])</span><br><span class="line">embedding(input)</span><br><span class="line">tensor([[[ <span class="number">0.0000</span>,  <span class="number">0.0000</span>,  <span class="number">0.0000</span>],</span><br><span class="line">       [ <span class="number">0.1535</span>, <span class="number">-2.0309</span>,  <span class="number">0.9315</span>],</span><br><span class="line">       [ <span class="number">0.0000</span>,  <span class="number">0.0000</span>,  <span class="number">0.0000</span>],</span><br><span class="line">       [<span class="number">-0.1655</span>,  <span class="number">0.9897</span>,  <span class="number">0.0635</span>]]])</span><br></pre></td></tr></table></figure><blockquote><p>CLASS torch.nn.Embedding(num_embeddings, embedding_dim, padding_idx=None, max_norm=None, norm_type=2.0, scale_grad_by_freq=False, sparse=False, _weight=None)</p></blockquote><p><strong>num_embeddings</strong>：原始数据维度，例如字典中有9个字，该值为9<br><strong>embedding_dim</strong>：嵌入维度，每个字用3维向量表示，该值为3<br><strong>输入维度</strong>：(<em>)任意维度<br><strong>输出维度</strong>：(\</em>,embedding_dim)，*表示输入维度<br>例如输入维度(16,100),输出为(16,100,3)，表示有16个句子，每个句子100个字，经过Embedding层后，有16个句子，每个句子100个字，每个字用3维特征表示。</p><p>在时空领域中，经常需要考虑外部因素，例如时间，天气，holiday等，需要对外部因素进行Embedding，例如<a href="https://github.com/UrbComp/DeepTTE" target="_blank" rel="noopener">https://github.com/UrbComp/DeepTTE</a></p></li></ul><hr><p>2020.7.8更新</p><h1><span id="13-linear参数维度">13. Linear参数维度</span></h1><p>做全连接时，我们平时看到的公式有以下形式：<br>$Y=XW+b$<br>$Y=XW^T+b$<br>$Y=W^TX+b$</p><p>因为不同的公式，此时的$W$形状也不同，假设$X\in\mathbb{R}^{100\times2}$表示100个样本，每个样本有2维，假设输出维度5<br>$y=XW+b$，$W\in\mathbb{R}^{2\times5}$<br>$y=XW^T+b$，$W\in\mathbb{R}^{5\times2}$<br>$y=W^TX+b$，对于这种情况，默认$X$中每个样本是列向量，即$X\in\mathbb{R}^{2\times100}$，$W\in\mathbb{R}^{5\times2}$</p><p>在Pytorch中的<code>Linear</code>中采用的是公式2，参数形状$W\in\mathbb{R}^{输出维度\times输入维度}$</p><p>但在实际使用中，为了方便，一般用公式1，此时$W\in\mathbb{R}^{输入维度\times输出维度}$</p><p>在写公式时，需要注意公式的大写还是小写</p><p>$Y=XW+b$这里的$X,Y$表示所有样本<br>$y=xW+b$这里的$x,y$表示一个样本<br>但这两种情况中，$W$始终是大写</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;1-简介&quot;&gt;&lt;a href=&quot;#1-简介&quot; class=&quot;headerlink&quot; title=&quot;1. 简介&quot;&gt;&lt;/a&gt;1. 简介&lt;/h1&gt;&lt;p&gt;汇总Pytorch的一些知识点&lt;/p&gt;
    
    </summary>
    
      <category term="Deep Learning" scheme="http://yoursite.com/categories/Deep-Learning/"/>
    
    
      <category term="Pytorch" scheme="http://yoursite.com/tags/Pytorch/"/>
    
  </entry>
  
</feed>
