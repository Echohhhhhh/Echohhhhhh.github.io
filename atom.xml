<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Echo&#39;s blog</title>
  
  <subtitle>远方到底有多远</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2020-06-21T09:47:14.170Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Echo</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>python输入怎么写</title>
    <link href="http://yoursite.com/2020/06/21/python%E8%BE%93%E5%85%A5%E6%80%8E%E4%B9%88%E5%86%99/"/>
    <id>http://yoursite.com/2020/06/21/python输入怎么写/</id>
    <published>2020-06-21T09:35:43.000Z</published>
    <updated>2020-06-21T09:47:14.170Z</updated>
    
    <content type="html"><![CDATA[<p>Leetcode刷多了不太记得python的输入怎么写了。在实际笔试或面试时，需要自己写输入和输出函数，所以在此记录下怎么使用Python读取数据。<br><a id="more"></a></p><p>在面试的时候，面试官只给你一个白板，最多给你定义好的函数名，其余都要自己写。给定的题目一般先读取数据，然后使用<code>print</code>输出最终的结果。</p><ul><li><code>print</code>可以写在<code>test</code>函数中</li><li>也可以将要输出的内容保存下来，作为<code>test</code>的<code>return</code>，然后在<code>main</code>中输出<br>下面是写程序的模板：</li><li><code>main</code>只关注输入和输出</li><li>其余的功能单独封装成函数，在<code>main</code>中调用</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test</span><span class="params">(param1,param2)</span>:</span></span><br><span class="line">    <span class="comment">#do something</span></span><br><span class="line"></span><br><span class="line">    print(<span class="string">"xx"</span>)</span><br><span class="line">    <span class="comment">#或者return</span></span><br><span class="line">    <span class="keyword">return</span> xx</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    <span class="comment">#使用input读取数据</span></span><br><span class="line">    m = input()</span><br><span class="line">    n = list(map(int,input.split()))</span><br><span class="line"></span><br><span class="line">    test(m,n)</span><br><span class="line"></span><br><span class="line">    print(<span class="string">"xx"</span>)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Leetcode刷多了不太记得python的输入怎么写了。在实际笔试或面试时，需要自己写输入和输出函数，所以在此记录下怎么使用Python读取数据。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="Python" scheme="http://yoursite.com/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>百面机器学习概述</title>
    <link href="http://yoursite.com/2020/06/19/%E7%99%BE%E9%9D%A2%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%A6%82%E8%BF%B0/"/>
    <id>http://yoursite.com/2020/06/19/百面机器学习概述/</id>
    <published>2020-06-19T15:12:34.000Z</published>
    <updated>2020-07-02T16:21:27.746Z</updated>
    
    <content type="html"><![CDATA[<p>总结《百面机器学习》有关知识点。</p><a id="more"></a><!-- TOC --><ul><li><a href="#1-特征工程">1. 特征工程</a><ul><li><a href="#11-特征归一化">1.1. 特征归一化</a></li><li><a href="#12-类别型特征">1.2. 类别型特征</a></li><li><a href="#13-文本表示模型">1.3. 文本表示模型</a></li><li><a href="#14-word2vec">1.4. Word2Vec</a></li><li><a href="#15-图像不足时处理方法">1.5. 图像不足时处理方法</a></li></ul></li><li><a href="#2-模型评估">2. 模型评估</a><ul><li><a href="#21-常见评估指标">2.1. 常见评估指标</a></li><li><a href="#22-p-r曲线和roc曲线">2.2. P-R曲线和ROC曲线</a></li><li><a href="#23-余弦距离">2.3. 余弦距离</a></li><li><a href="#24-ab测试">2.4. A/B测试</a></li><li><a href="#25-模型评估方法">2.5. 模型评估方法</a></li><li><a href="#26-过拟合和欠拟合">2.6. 过拟合和欠拟合</a></li><li><a href="#27-正则化">2.7. 正则化</a></li></ul></li><li><a href="#3-统计学">3. 统计学</a><ul><li><a href="#31-参数估计">3.1. 参数估计</a></li><li><a href="#32-散度">3.2. 散度</a></li><li><a href="#33-优化方法">3.3. 优化方法</a></li><li><a href="#34-贝叶斯">3.4. 贝叶斯</a></li></ul></li><li><a href="#4-经典算法">4. 经典算法</a><ul><li><a href="#41-回归模型">4.1. 回归模型</a><ul><li><a href="#411-单变量线性回归">4.1.1. 单变量线性回归</a></li><li><a href="#412-多变量线性回归">4.1.2. 多变量线性回归</a></li><li><a href="#413-l1正则和l2正则">4.1.3. L1正则和L2正则</a></li><li><a href="#414-面试问题">4.1.4. 面试问题</a></li></ul></li><li><a href="#42-逻辑回归">4.2. 逻辑回归</a><ul><li><a href="#421-逻辑回归推导">4.2.1. 逻辑回归推导</a></li><li><a href="#422-逻辑回归常见问题">4.2.2. 逻辑回归常见问题</a></li></ul></li><li><a href="#43-softmax回归">4.3. Softmax回归</a></li><li><a href="#44-数据不平衡问题">4.4. 数据不平衡问题</a></li><li><a href="#45-svm">4.5. SVM</a><ul><li><a href="#451-线性可分svm">4.5.1. 线性可分SVM</a></li><li><a href="#452-近似线性svm">4.5.2. 近似线性SVM</a></li><li><a href="#453-核函数">4.5.3. 核函数</a></li><li><a href="#454-面试问题">4.5.4. 面试问题</a></li></ul></li><li><a href="#46-决策树">4.6. 决策树</a><ul><li><a href="#461-基础树id3c45cart">4.6.1. 基础树(ID3/C4.5/CART)</a><ul><li><a href="#4611-id3">4.6.1.1. ID3</a></li><li><a href="#4612-c45">4.6.1.2. C4.5</a></li><li><a href="#4613-cart分类回归树">4.6.1.3. CART(分类回归树)</a></li><li><a href="#4614-总结">4.6.1.4. 总结</a></li></ul></li><li><a href="#462-树的剪枝">4.6.2. 树的剪枝</a></li></ul></li></ul></li><li><a href="#5-聚类">5. 聚类</a><ul><li><a href="#51-k-means聚类">5.1. K-Means聚类</a></li><li><a href="#52-k-means的优化">5.2. K-Means的优化</a></li><li><a href="#53-knn">5.3. KNN</a></li><li><a href="#54-聚类评价指标">5.4. 聚类评价指标</a></li></ul></li></ul><!-- /TOC --><h1><span id="1-特征工程">1. 特征工程</span></h1><h2><span id="11-特征归一化">1.1. 特征归一化</span></h2><ul><li>目的：消除特征之间量纲的影响，防止学习到的结果向数值大的特征倾斜。</li><li>Max-Min归一化：将数据归一化到[0,1]之间，等比缩放。</li><li>Z-Score归一化（零均值归一化）：将数据归一化到均值为0，标准差为1的分布上。</li><li>需要归一化：线性回归、逻辑回归、SVM、深度神经网络。不需要归一化：基于决策树模型。</li></ul><h2><span id="12-类别型特征">1.2. 类别型特征</span></h2><p>将类别特征—&gt;数值特征，有以下方法</p><ul><li>序号编码：有大小关系的，比如低中高，可以编码成1,2,3</li><li>one-hot编码：没有大小关系，问题：高维稀疏，需要将其嵌入成低维稠密向量</li><li>二进制编码：先编码再转换成二进制</li></ul><h2><span id="13-文本表示模型">1.3. 文本表示模型</span></h2><ul><li>词袋模型：将文章按照词分割，使用每个词的权重来表示文章</li><li>TF-IDF：用来计算一个词的权重，TF=一个词w在文章d中出现的频率，IDF：特属词的特征，逆文档频率</li><li>N-gram模型：将连续的n个词作为一个特征放在向量中。</li><li>词嵌入模型：将词映射成低维稠密向量(50~300维度)，Word2Vec是最常用的词嵌入模型。</li></ul><h2><span id="14-word2vec">1.4. Word2Vec</span></h2><p>Word2Vec有2种网络结构：CBOW，skip-gram</p><ul><li>CBOW：多预测一</li><li>skip-gram：一预测多</li></ul><h2><span id="15-图像不足时处理方法">1.5. 图像不足时处理方法</span></h2><p>图像不足易出现过拟合问题。解决图像不足有2种方法：</p><ul><li>基于模型：采用一些措施降低过拟合。例如简化模型，L1L2正则化、Dropout，集成学习。</li><li>基于数据：通过一些方法增加数据。平移、旋转、裁剪、修改图片亮度，锐度、添加噪声等方法。</li></ul><h1><span id="2-模型评估">2. 模型评估</span></h1><h2><span id="21-常见评估指标">2.1. 常见评估指标</span></h2><ul><li>准确率(Accuracy)</li><li>精确率(Precision)</li><li>召回率(Recall)</li></ul><p>其中这些指标都有一定的局限性。对于一个排序模型，怎么评估排序模型的好坏：</p><ul><li>设置不同的N，计算P@N,R@N</li><li>设置更综合的评价指标，PR曲线，ROC曲线，F1值</li></ul><p>RMSE：回归问题的评价指标。如果在一个问题上，RMSE非常高，但是观察预测值和真实值，发现90%的预测值都很接近真实值，为什么RMSE还是这么高。分析由于剩下的10%存在非常大的异常值，即使90%预测很准，但是这10%导致最终的RMSE差别很大。解决方案：</p><ul><li>如果10%是噪声数据，提前去除噪声</li><li>如果10%不是噪声数据，需要对异常数据进行建模</li><li>换一个对异常值不敏感的指标，例如MAPE</li></ul><h2><span id="22-p-r曲线和roc曲线">2.2. P-R曲线和ROC曲线</span></h2><ul><li>P-R曲线</li></ul><p>P-R曲线横坐标是召回率，纵坐标是准确率。<br>为什么要有P-R曲线？因为精确率precision和召回率recall指标都有一定的局限性，所以使用P-R曲线可以综合地评估一个模型的效果。<br>在P-R曲线中，通过改变正负样本间的阈值来改变precision和recall。当判定为正样本的阈值很大时，说明选出的正样本都是很有把握的，precision较大，recall较小。当判定为正样本的阈值很小时，即尽可能不漏掉正样本，导致precision降低，recall变大。</p><ul><li>ROC曲线<br>横坐标是假阳率FPR，纵坐标是真阳率TPR。</li></ul><script type="math/tex; mode=display">假阳率=\frac{负例被判为正例}{真正的负例}\quad真阳率=\frac{正例被判为正例}{真正的正例}</script><p>可以看出真阳率也就是召回率。<br>同P-R曲线类似，ROC曲线也是通过不断改变正负样本的阈值生成的。</p><ul><li>P-R曲线和ROC曲线有什么不同</li></ul><p>当测试集中的负样本数量增加10倍时，P-R曲线发生了明显的变化，ROC曲线几乎不变。ROC曲线能够尽量降低测试集带来的干扰，适用于正负样本不均衡的数据集中。ROC适用的场景更多，被广泛应用在排序，推荐，广告等领域。</p><p><img src="/2020/06/19/百面机器学习概述/PR曲线和ROC曲线.png" alt=""></p><h2><span id="23-余弦距离">2.3. 余弦距离</span></h2><p>余弦相似度：</p><script type="math/tex; mode=display">\cos (A, B)=\frac{A \cdot B}{\|A\|_{2}\|B\|_{2}}</script><p>余弦距离体现方向上的相对差异，欧式距离体现数值上的绝对差异。</p><h2><span id="24-ab测试">2.4. A/B测试</span></h2><p>划分实验组和对照组<br>实验组和对照组：选取样本时要求独立性和无偏性。</p><h2><span id="25-模型评估方法">2.5. 模型评估方法</span></h2><p>通常将数据划分为训练集和测试集，但在<strong>样本划分</strong>和<strong>模型验证</strong>的过程中，存在着不同的方法。</p><ol><li>Holdout验证<br>随机将数据划分为训练集和测试集，在测试集上进行模型验证。<br>缺点：模型的效果取决于样本划分，具有随机性</li><li>k折交叉验证<br>将样本划分为k个大小相等的子集，一个子集作为测试集，k-1个子集作为训练集。将k次评估结果平均作为该模型最终的结果。<br>优点：（1）解决当数据量较小时，模型评估不准确的问题（2）消除数据对评估结果的随机性影响（3）可以用来选择超参数<br>缺点：耗时，需要训练多个模型求评估结果的平均值</li><li>自助法<br>如果数据比较小，holdout和k折交叉验证都需要划分数据集，导致训练集变小。自助发采用随机抽样，在全部样本中进行n次有放回的抽样，得到大小为n的训练集。这n个样本中有的样本是重复的，有的样本没有被抽到，这些没有抽到的样本作为测试集。</li></ol><h2><span id="26-过拟合和欠拟合">2.6. 过拟合和欠拟合</span></h2><ul><li>过拟合<br>模型在训练数据上loss很小，在测试集上loss大</li><li>欠拟合<br>模型在训练集和测试集上loss都很大，效果都不好</li><li><p>降低过拟合的方法</p><ol><li>增加数据集，减少噪声的影响。如果没有这么多数据，可以生成一些数据。例如图像可以通过平移，旋转等生成数据</li><li>正则化，在loss中添加L1或L2正则，防止参数过大</li><li>集成学习，将多个模型集成在一起，降低单一模型的过拟合风险</li><li>降低模型复杂度，例如减少网络参数，神经元个数等。</li><li>早停，当模型在验证机上的loss连续N次没有提升时，停止训练</li><li>Dropout，在训练过程中按照给定的概率随机删除隐藏层的一些神经单元。由于模型训练的随机性，减轻了不同特征之间的协同效应。<strong>Dropout只能在训练时使用，在测试集上不能使用</strong></li></ol></li><li><p>降低欠拟合的方法</p><ol><li>添加新的特征，当特征少时容易出现欠拟合，模型对训练数据的拟合程度不好。</li><li>增加模型复杂度</li><li>减少正则化系数</li></ol></li></ul><h2><span id="27-正则化">2.7. 正则化</span></h2><p>正则化为了避免过拟合，即在损失函数后加上一个正则项（惩罚项），模型越复杂，正则化值就越大。</p><script type="math/tex; mode=display">\min _{f \in \mathcal{F}} \frac{1}{N} \sum_{i=1}^{N} L\left(y_{i}, f\left(x_{i}\right)\right)+\lambda J(f)</script><p>第一项是损失值，第二项是正则化项，$\lambda$调整两者的权重。下面拿回归问题举例，损失值为平方损失。</p><ul><li>L1正则<br>惩罚项为权重绝对值的和</li></ul><script type="math/tex; mode=display">L(w)=\frac{1}{N} \sum_{i=1}^{N}\left(f\left(x_{i} ; w\right)-y_{i}\right)^{2}+\lambda\|w\|_{1}</script><ul><li>L2正则</li></ul><p>惩罚项为权重的平方和</p><script type="math/tex; mode=display">L(w)=\frac{1}{N} \sum_{i=1}^{N}\left(f\left(x_{i} ; w\right)-y_{i}\right)^{2}+\frac{\lambda}{2}\|w\|^{2}</script><h1><span id="3-统计学">3. 统计学</span></h1><h2><span id="31-参数估计">3.1. 参数估计</span></h2><h2><span id="32-散度">3.2. 散度</span></h2><h2><span id="33-优化方法">3.3. 优化方法</span></h2><h2><span id="34-贝叶斯">3.4. 贝叶斯</span></h2><h1><span id="4-经典算法">4. 经典算法</span></h1><h2><span id="41-回归模型">4.1. 回归模型</span></h2><p>回归模型分为线性回归和非线性回归。</p><p>线性回归又分为单变量线性回归和多变量线性回归。</p><h3><span id="411-单变量线性回归">4.1.1. 单变量线性回归</span></h3><p>使用房子面积和房价举例。训练集中x表示房子面积，y表示房价。使用$(x,y)$表示一个训练样，其中$(x^{(i)},y^{(i)})$表示第$i$个训练样本。。</p><ul><li>$h(x)=w_0+w_1x$，通过训练集学习$w_0,w_1$，使得$x$可以得到对应的$y$。因为这里没有激活函数，$x和y$是线性关系，所以成为单变量线性回归模型，因为输入的特征$x$只有1个特征（房子面积）</li><li>损失函数：$Loss = \frac{1}{2m}\sum_{i=1}^{i=m}(h(x^{i})-y^{i})^2$<br>求得是平均损失，有m个样本，所以前面损失除以m，这里的1/2是为了求导简化添加的。</li></ul><p><img src="/2020/06/19/百面机器学习概述/百面机器学习/../百面机器学习概述/linear.jpg" alt=""></p><h3><span id="412-多变量线性回归">4.1.2. 多变量线性回归</span></h3><p>输入的x有多个特征，上面单变量回归问题中，x只表示房子面积，在多变量线性回归中，x1=房子面积，x2=卧室个数，x3=房子楼层，x4=房子年龄</p><ul><li>$h(x)=w_0+w_1x_1+w_2x_2+w_3x_3+w_4x_4$<br>令$x=[x_1,x_2,x_3,x_4]$为列向量，$w=[w_1,w_2,w_3,w_4]$为列向量，则$h(x)=w^Tx$</li></ul><p><img src="/2020/06/19/百面机器学习概述/百面机器学习/../百面机器学习概述/linear1.jpg" alt=""></p><h3><span id="413-l1正则和l2正则">4.1.3. L1正则和L2正则</span></h3><p>L1正则和L2正则都是为了避免过拟合设计的。使用L1正则化的叫做Lasso回归，使用L2正则化的叫做岭回归。<br>这两种回归为了<strong>解决线性回归出现过拟合</strong>的问题。通过<strong>在损失函数中引入正则化项</strong>来解决</p><ul><li><p>Lasso回归损失函数<br> 添加L1正则项</p><script type="math/tex; mode=display">J(w)=\frac{1}{2m}\sum_{i=1}^{i=m}(h(x^i)-y^i)^2+\lambda\sum_{j=1}^{j=n}|w_j|</script></li><li><p>岭回归损失函数<br> 添加L2正则项</p><script type="math/tex; mode=display">J(w)=\frac{1}{2m}\sum_{i=1}^{i=m}(h(x^i)-y^i)^2+\lambda\sum_{j=1}^{j=n}w_j^2</script></li></ul><p>我们从梯度下降的角度分析下为什么加入正则化可以避免过拟合。下面以L2正则化为例。L2正则化的梯度下降公式为</p><script type="math/tex; mode=display">w_j = w_j - \alpha * \frac{1}{m}\sum_{i=1}^{i=m}(h(x^i)-y^i)x^i_j-2\lambda w_j</script><p>当惩罚项越大，即$\lambda$越大时，更新后得到的$w_j$也就越小，模型复杂度变小，模型更简单。</p><p>下面以线性回归为例，模型只包含2个参数。下面等高线图表示$w_1,w_2$和损失的关系。当$w_1,w_2$取值为图像中最里面紫色圆圈上的点时，损失最小。</p><p><img src="/2020/06/19/百面机器学习概述/L1_1.png" alt=""></p><p>当加上L1正则化后，目标函数图像为</p><p><img src="/2020/06/19/百面机器学习概述/L1_2.png" alt=""></p><p>原先损失函数的第一项就是等高线，L1正则化损失函数的第二项就是菱形上的点。图中的菱形函数为$\sum_{j=1}^{j=2}w_j=F$。我们现在求解的目标是不仅要让第一项小，即$w_1,w_2$的值靠近紫色的圆圈，还要让第二项小，即$|w_1|+|w_2|=F$小，即$F$比较小。如下图所示，如果让菱形靠近紫色的圆圈，虽然损失函数第一项小了，但是第二项会变大。因此我们要取到一个恰好的值，让第一项的值+第二项的值最小。<br>我们发现对于同一个等高线来说，即损失函数的第一项相同，当菱形和等高线相切（只有一个交点）时，菱形的边长最小，即$w_1+w_2$最小，也就是相加得到的损失最小。</p><p>由上面的说明可以看出，L1正则化后的解一定是某个菱形和某个等高线的切点。经过观察发现，对于图中的每条等高线，与这个等高线相切的菱形的切点一般出现在坐标轴上(x轴或y轴)，例如上面的解为$(0,y)$，这也是说L1正则化更容易得到稀疏解(解向量中0比较多)的原因。</p><p><img src="/2020/06/19/百面机器学习概述/L1_3.png" alt=""></p><p>当加入L2正则化后，目标函数图像为</p><p><img src="/2020/06/19/百面机器学习概述/L2.png" alt=""></p><p>菱形变成了圆，同样求等高线和圆的切点作为最终的解。与L1正则化相比，切点不容易出现在坐标轴上，然后仍然比较靠近坐标轴。因此L2正则化得到的解比较小（靠近0），但是比较平滑（不等于0）。所以通过添加L2正则化向，模型不会得到特别大的权重，偏向于学习比较小的权重。因此L2正则化又叫做权重衰减。</p><p><strong>总结</strong></p><p>L1正则化使权重稀疏，L2正则化使权重平滑。即L1正则化趋向于使用更少的特征，没用的特征权重为0，而L2正则化趋向于使用更多的特征，但这些特征的权重都接近0。实际中最常用L2正则化。</p><h3><span id="414-面试问题">4.1.4. 面试问题</span></h3><ol><li><p>简单介绍以下线性回归</p><ul><li>线性：输入x和输出y的关系是线性的，即图像是直线</li><li>非线性：输入x和输出y的关系不是一次函数，图像不是直线</li><li>线性回归就是利用已有的样本，通过监督学习，学习由x到y的映射，然后利用学到的映射函数对未知的x进行预测。由于预测的值是连续值，所以是回归问题。</li></ul></li><li><p>线性回归的损失函数</p><script type="math/tex; mode=display">J(w)=\frac{1}{2m}\sum_{i=1}^{i=m}(h(x^i)-y^i)^2</script></li></ol><ol><li><p>简述岭回归和Lasso回归<br>这两种回归为了<strong>解决线性回归出现过拟合</strong>的问题。通过<strong>在损失函数中引入正则化项</strong>来解决</p><ul><li><p>岭回归损失函数<br>添加L2正则项</p><script type="math/tex; mode=display">J(w)=\frac{1}{2m}\sum_{i=1}^{i=m}(h(x^i)-y^i)^2+\lambda\sum_{j=1}^{j=n}w_j^2</script></li><li><p>Lasso回归损失函数<br>添加L1正则项</p><script type="math/tex; mode=display">J(w)=\frac{1}{2m}\sum_{i=1}^{i=m}(h(x^i)-y^i)^2+\lambda\sum_{j=1}^{j=n}|w_j|</script></li></ul></li><li><p>线性回归的假设<br>线性回归假设因变量y符合正太分布   </p></li></ol><h2><span id="42-逻辑回归">4.2. 逻辑回归</span></h2><p>逻辑回归是分类模型，虽然名字中有回归二字，但却是分类模型，用来二分类任务。<br>二分类的y有正负样本，即$y\in{(0,1)}$，$y$只有2个取值，一般将我们想要找的样本作为正样本。例如垃圾邮件分类中，想要找垃圾邮件，所以将垃圾邮件划分为正样本，非垃圾邮件为负样本。肿瘤良性判断中将恶性肿瘤设置为正样本，良性肿瘤设置为负样本。</p><ul><li><p>如何用连续的数组预测离散的y</p><p>线性回归输出的是连续值，而分类问题的标签y是离散值，属于{0,1}。怎么用回归模型预测离散的标签呢？<br>一个直观的办法是设定一个阈值，比如0，如果预测的值&gt;0，则属于正样本，否则属于负样本。<br>另一种方法是不去直接预测标签，而是预测样本属于正样本的概率。概率是连续值，并且在[0,1]之间。但是回归问题的输出值并不是在[0,1]之间，为了限制回归问题的值域，使用sigmoid函数，又成为logistic函数。因为sigmoid函数可以将输入$x\in[-\infty,\infty]$映射到$[0,1]$之间，输出的$h(x)$正好可以作为样本属于正例的概率。这种方法成为逻辑回归模型=logistic函数+回归模型</p></li></ul><h3><span id="421-逻辑回归推导">4.2.1. 逻辑回归推导</span></h3><p>sigmoid函数：</p><script type="math/tex; mode=display">g(x)=\frac{1}{1+e^{-x}}</script><p><img src="/2020/06/19/百面机器学习概述/sigmoid.png" alt=""></p><p>输出值在<code>0~1</code>之间。原先的回归问题的假设函数简化为$h(x)=w^Tx$，为了让$h(x)$的输出在0~1之间，在外面套上sigmoid函数。</p><script type="math/tex; mode=display">h(x)=\frac{1}{1+e^{-w^{T}x}}</script><p>求得的$h(x)$表示样本$x$被判为正样本的概率，例如$h(x)=0.7$表示邮件是垃圾邮件的概率是0.7。因为真实标签值$y$只能为0和1，所以需要将$h(x)$和$y$对应起来。<br>如果$h(x)&gt;=0.5$，也就是$w^Tx&gt;=0$，则预测$y=1$<br>如果$h(x)&lt;0.5$，也就是$w^Tx&lt;0$，则预测$y=0$</p><ul><li>逻辑回归损失函数</li></ul><p><img src="/2020/06/19/百面机器学习概述/logistic.png" alt=""></p><ol><li><p>求单个样本预测正确的概率<br>$h(x)$表示样本为正例$(y=1)$的概率$P(y=1|x,w)=h(x)$<br>则样本为负例的概率为$P(y=0|x,w)=1-h(x)$</p></li><li><p>将上述公式整合</p><script type="math/tex; mode=display">P(y \mid {x})=\left\{\begin{array}{r}h(x), y=1 \\1-h(x), y=0\end{array}\right.</script><p>将上述2种情况整合成一个公式为</p><script type="math/tex; mode=display">P(y^i|x^i)=h(x^i)^{y_i}*(1-h(x^i))^{1-y^i}</script><p>对于样本$(x^i,y^i)$，如果$y^i=1$，则概率为$h(x^i)$，如果$y^i=0$，则概率为$1-h(x^i)$</p></li><li><p>求$m$个样本的似然函数</p><blockquote><p>极大似然估计：利用已知的样本结果，反推最有可能（最大概率）导致这些样本结果出现的模型参数，即在模型已知的情况下，求参数。</p></blockquote><p>如果有$m$个样本，分别为$(x^1,y^1),(x^2,y^2),…,(x^m,y^m)$，这m个样本假设相互独立，组合概率为每个样本概率的乘积，即最大似然估计为：</p><script type="math/tex; mode=display">P_总=P(y^1|x^1)P(y^2|x^2)...P(y^m|x^m)\\=\prod_{i=1}^{i=m}h(x^i)^{y_i}*(1-h(x^i))^{1-y^i}</script><p>其中<script type="math/tex">h(x)=\frac{1}{1+e^{-w^Tx}}</script></p></li><li><p>求对数似然<br>模型需要做的就是该概率最大，即连乘的乘积最大，但是连乘很复杂，通过<strong>对两边取对数将连乘变成累加的形式</strong></p><script type="math/tex; mode=display">log(P_总)=log(\prod_{i=1}^{i=m}h(x^i)^{y_i}*(1-h(x^i))^{1-y^i})\\=\sum_{i=1}^{i=m}log(h(x^i)^{y_i}*(1-h(x^i))^{1-y^i})\\=\sum_{i=1}^{i=m}(y^ilog(h(x^i))+(1-y^i)log(1-h(x^i)))</script></li><li><p>求逻辑回归损失函数<br>上面的最大化$P_总$其实是我们的目标函数，但是如果在最大化目标函数时，对参数$w$进行求导时，非常复杂，所以就先取对数，将连乘换成累加。然后为了迎合一般都是最小化损失函数，所以加上一个符号。<br>模型最好的效果是让$log(P_总)$越大越好，但是损失函数却是越小越好，所以我们将其取负数作为损失函数，应为损失函数求的是平均误差，所以需要除以样本个数$m$,即逻辑回归的损失函数为交叉熵损失函数</p><script type="math/tex; mode=display">Loss(w)=-\frac{1}{m}\sum_{i=1}^{i=m}(y^ilog(h(x^i))+(1-y^i)log(1-h(x^i)))</script><ul><li><p>为什么可以用似然函数<br>因为逻辑回归的目标是让预测为正的概率最大，且预测为负的概率最大，即每个样本都要保证得到最大的概率，将所有样本预测后的概率相乘就最大，即得到似然函数。</p></li><li><p>为什么损失函数要取对数</p><ul><li>线性回归模型的平方损失函数对sigmoid函数求导无法保证是凸函数，在优化求$w$的过程中，求得的解有可能是局部最优，而不是全局最优</li><li>取对数后，方便后续的求导</li></ul></li></ul></li></ol><ul><li><p>梯度下降</p><p>首先先看sigmoid的导数</p><script type="math/tex; mode=display">g(x)=\frac{1}{1+e^{-x}}</script><p><img src="/2020/06/19/百面机器学习概述/sigmoid.jpg" alt=""></p><p><img src="/2020/06/19/百面机器学习概述/sigmoid1.jpg" alt=""></p><p>得到导数之后，更新参数$w_j$<br><img src="/2020/06/19/百面机器学习概述/sigmoid2.jpg" alt=""></p><ol><li>梯度下降公式中的$m$如果是样本总数，则每次更新参数时需要考虑所有的样本，称为批量梯度下降(BGD)。这种方法容易求得全局最优解，但是由于样本个数太多，训练过程非常慢。</li><li>如果$m=1$，即每次更新参数时只考虑一个样本，称为随机梯度下降(SGD)。这种方法训练速度快，但是准确率下降，并不是全局最优。</li><li>综上所述，当m为所有样本的一小部分时，比如m=32，即每次更新参数时只考虑一小部分样本，称为小批量梯度下降(MBGD)。它克服了上述两种方法的缺点又兼顾它们的优点，在实际中最常使用。</li></ol></li></ul><h3><span id="422-逻辑回归常见问题">4.2.2. 逻辑回归常见问题</span></h3><ol><li><p>用一句话概括逻辑回归<br>逻辑回归假设数据服从伯努利分布，通过极大化似然函数，使用梯度下降求解参数，达到二分类的目的。</p></li><li><p>逻辑回归的目的<br>进行二分类<br>逻辑回归作为回归，输出值是连续的，怎么应用在分类上呢？这里的y确实是一个连续的值，但是它的输出值在[0,1]之间，可以选定一个阈值来进行划分，如果输出值大于0.5，则判定为正样本，否则判定为负样本。</p></li><li><p>逻辑回归的基本假设</p><ul><li><p>逻辑回归假设数据服从伯努利分布。伯努利分布就是抛硬币，正面的概率为$p$，反面的概率为$1-p$<br>在逻辑回归中，样本被判定为正例的概率为$h(x)$，则被判为负例的概率为$1-h(x)$</p></li><li><p>第二个假设是样本为正的概率是</p></li></ul><script type="math/tex; mode=display">p=\frac{1}{1+e^{-w^Tx}}</script></li><li><p>逻辑回归的损失函数<br>逻辑回归的损失函数是它的极大对数似然函数的相反数</p><script type="math/tex; mode=display">Loss(w)=-\frac{1}{m}\sum_{i=1}^{i=m}(y^ilog(h(x^i))+(1-y^i)log(1-h(x^i)))</script></li><li><p>随机梯度下降、批量梯度下降、小批量梯度下降的优缺点</p><ul><li>梯度下降公式中的$m$如果是样本总数，则每次更新参数时需要考虑所有的样本，称为批量梯度下降(BGD)。这种方法容易求得全局最优解，但是由于样本个数太多，训练过程非常慢。</li><li>如果$m=1$，即每次更新参数时只考虑一个样本，称为随机梯度下降(SGD)。这种方法训练速度快，但是准确率下降，并不是全局最优。</li><li>综上所述，当m为所有样本的一小部分时，比如m=32，即每次更新参数时只考虑一小部分样本，称为小批量梯度下降(MBGD)。它克服了上述两种方法的缺点又兼顾它们的优点，在实际中最常使用。</li></ul></li><li><p>逻辑回归的优缺点<br>优点：</p><ul><li>形式简单，模型可解释性好。模型的权重$w$表示不同特征对最终结果的影响，如果$w_j$大，说明第$j$个特征的权重比较高，对最终的结果影响较大</li><li>模型效果不错。在工程上可以接受，如果特征工作做的好，效果不会太差。</li><li>训练速度快。在分类时，计算两仅仅和特征的数目有关</li><li>资源占用小，尤其是内存。因为只需要存储各个维度的特征值</li><li>方便输出结果。逻辑回归可以很方便的得到最后的分类结果，因为输出的结果表示每个样本属于正例的概率，可以很容易的对概率进行划分阈值。<br>缺点</li><li>准确率不是很高，因为形式简单</li><li>很难处理不平衡的数据。距离：如果正负样本比例1:1000，则将所有的样本都预测为负样本，模型的损失值就很小，但是这样的模型对于正样本的召回率并不高</li><li>处理非线性数据较麻烦。逻辑回归一般只处理线性可分的数据，一般用于二分类</li><li>无法筛选特征，需要提前做特征工程。</li></ul></li></ol><ul><li><p>逻辑回归的输出是真实概率吗<br>如果数据满足以上的2个假设，则输出的数据表示样本属于正例的概率。但是这2个假设并不是那么容易满足，所以很多情况下，逻辑回归的输出值无法作为真实的概率，只能看做置信度。</p></li><li><p>使用逻辑回归怎么进行多分类<br>可以将多分类问题转换成二分类问题</p></li><li><p>逻辑回归和线性回归的区别</p><ol><li>线性回归阈值$[-\infty,\infty]$,逻辑回归的阈值$[0,1]$</li><li>拟合函数不同，线性回归$h(x)=w^Tx$，逻辑回归$h(x)=\frac{1}{1+e^{-w^Tx}}$</li><li>损失函数形式不同。线性回归是最小二乘法（平方损失），逻辑回归是极大似然估计</li></ol></li></ul><h2><span id="43-softmax回归">4.3. Softmax回归</span></h2><p>逻辑回归用来解决二分类问题，softmax回归用来解决多分类问题。</p><p>假设对一个2*2的图像进行分类，判断图像是狗、猫、鸡的哪一种。即输入x有4个特征$x_1,x_2,x_3,x_4$，真实标签$y=1,2,3$。</p><p>softmax回归和线性回归一样，也是一个单层全连接层。输入有4个，输出有3个，所以参数有12个。</p><p><img src="/2020/06/19/百面机器学习概述/softmax.png" alt=""></p><p>像上面的线性回归，输出的y值是连续的，我们可以把输出的y值看做样本属于某一类值置信度。例如$o_1=o_3=10,o_2=1000$，则图片被预测为猫。但是由于输出的值不稳定，并且连续的预测值和真实的离散值误差难以衡量。<br>为了解决这个问题，这里用到softmax运算。softmax将原先输出的连续值$o$转换为概率。</p><p><img src="/2020/06/19/百面机器学习概述/softmax1.png" alt=""></p><p>最终softmax回归模型函数为</p><p>$o^i=W^Tx+b$<br>$y^i=softmax(o^i)$</p><p>逻辑回归和softmax回归的不同</p><ol><li>逻辑回归最后的输出层只有1个神经元，输出的结果表示样本属于正例的概率。softmax回归最后的输出层有n个神经元(n为类别数)，输出样本属于每个类别的概率。即sigmoid输出的是一个数，softmax输出的是一个向量。</li><li>逻辑回归最后输出用sigmoid将连续值转换为属于正例的概率。softmax回归最后输出用softmax将连续值转换为属于各类的概率。都是将连续值转换为概率。</li></ol><ul><li>softmax回归是逻辑回归在多分类的拓展</li></ul><p><img src="/2020/06/19/百面机器学习概述/softmax.jpg" alt=""></p><ul><li><p>逻辑回归怎么用来解决多分类问题<br>将多分类问题拆分成多个二分类问题。具体怎么拆分有3种方法：</p><ol><li>一对一。假设多分类中一共有k类，则将任意2类进行组合，一共形成k(k-1)/2个组合。将一个样本输入到这k(k-1)/2个分类器中，得到k(k-1)/2个分类结果，然后取个数最多的类别作为这个样本最终预测类别</li><li>一对多。假设多分类中共有k类，一共形成k个分类器，第一个分类器将k1作为正例，其余类作为负例。第二个分类器将k2作为正例，其余类作为负例，以此类推。一个样本输入到这k个分类器中，输出k个分类结果，如果只有一个正例，则该样本属于这个类，如果输出多个正例，则看置信度。</li><li>多对多。每次将多个类作为正例，多个类作为负例。</li></ol><p><img src="/2020/06/19/百面机器学习概述/多分类.png" alt=""></p></li><li><p>如果一个样本有多个类别标签，怎么办？</p><p>这就不是一个多分类问题了，而是多标签学习。假设一共有k类，训练k个分类器。第$i$个分类器判断每个样本是否归为第$i$类。训练分类器时，需要将标签重新整理为属于第$i$类和不属于第$i$类。</p></li></ul><h2><span id="44-数据不平衡问题">4.4. 数据不平衡问题</span></h2><p>在分类问题中可能会遇到类别不平衡问题。例如1000个样本中，2个正例，998个负例。这样模型在预测值偏向于将样本预测为负例，但是在实际中却没有价值，因为它检测不到正例。</p><p>解决正负样本不均衡问题，有以下3个方法</p><ol><li>欠采样<br>对负样本进行负采样，使得正负样本均衡。欠采样需要丢弃一些负样本，但也不能随意丢弃，否则会丢失一些重要信息。代表算法为EasyEnsemble利用集成学习，将负样本划分为若干个集合进行训练，这样每个模型的数据都进行了欠采样。</li><li>过采样<br>生成一些正样本，使得正负样本均衡。但是过采样不能将原先的正样本复制n份，这样会造成严重的过拟合。过采样代表算法为SMOTE通过对训练集中的正样本进行插值生成一些正样本。</li><li>调整阈值<br>在逻辑回归中，我们通常将$h(x)&gt;0.5$判定为正例，否则为负例。这说明正例和负例出现的可能性相同。但是如果正负样本不平衡，正样本出现非常小，可能阈值就需要变小。假设正样本:负样本=2:10，则将阈值变成0.2，例$h(x)&gt;0.2$我们就判定为正例，否则为负例。</li></ol><h2><span id="45-svm">4.5. SVM</span></h2><p>SVM用来做二分类，主要分为三部分</p><ol><li>数据线性可分：最优划分超平面/硬间隔SVM/线性可分SVM</li><li>数据近似线性可分：软间隔SVM/近似线性可分SVM</li><li>数据线性不可分：核方法</li></ol><h3><span id="451-线性可分svm">4.5.1. 线性可分SVM</span></h3><p>SVM就是解决二分类问题，分类学习最基本的想法就是找到一个划分超平面，将不同类别的数据集分开。目的就是找到一个最优的分割线将两类分开。</p><p>分类问题有线性可分和线性不可分。线性可分就是在二维空间中能找到一条直线将2类样本划分开。线性不可分就是不能找到一条直线。对于线性不可分的样本通常是通过高斯核函数将样本映射到高维空间，然后转换为高维空间线性可分的问题。<br>下图中的直线都可以将2类样本分开，但是哪个才是好的分割线呢？分类器的价值不在于它多么擅长分割训练样本，而是对于哪些未知的样本它的分类效果怎么样。下图中中间较粗的那条线，在正确划分训练样本的前提下，尽可能地同时远离两个聚类。而其他的线都是有些“倾斜”，一头远离一类，另一头靠近另一类。</p><p><img src="/2020/06/19/百面机器学习概述/SVM1.png" alt=""></p><p>假设划分超平面的公式为</p><script type="math/tex; mode=display">w^Tx+b=0</script><p>这就是我们初中学的直线公式$ax+b=0$</p><p>理想中超平面进行划分时，如果结果大于0就划分为正例，否则划分为负例。下面就是逻辑回归的划分方式：</p><script type="math/tex; mode=display">\left\{\begin{array}{ll}\omega^{T} x_{i}+b>0, & y_{i}=+1 \\\omega^{T} x_{i}+b<0, & y_{i}=-1\end{array}\right.</script><p>而SVM是逻辑回归的强化，SVM设置更严格的划分条件，变成：</p><script type="math/tex; mode=display">\left\{\begin{array}{l}w^{T} x+b \geq 1 \quad y=1 \\w^{T} x+b \leq-1 \quad y=-1\end{array}\right.</script><p>上面我们简单的介绍下SVM和逻辑回归的不同，下面我们将详细介绍SVM</p><p>假设SVM中的分割超平面为<script type="math/tex">w^Tx+b=0</script></p><p>$w=(w_1,w_2,…w_d)$是有个列向量，拆分开就是$w_1x_1+w_2x_2+…+w_dx_d+b=0$</p><p>超平面有以下几个性质</p><p><strong>性质1</strong>：等比例缩放$w,b$，超平面不变，仍然是同一条直线或超平面<br><strong>性质2</strong>：点$x=(x_1,x_2,…,x_d)$到超平面的距离为</p><script type="math/tex; mode=display">\frac{|w_1x_1+w_2x_2+...+w_dx_d+b|}{\sqrt{w_1^2+w_2^2+...+w_d^2}}=\frac{|w^Tx+b|}{||w||}</script><p>下面介绍2个概念：<strong>函数间隔、几何间隔</strong></p><blockquote><p>二维平面中点$(x,y)$到$AX+By+c=0$的距离为$\frac{|Ax+By+c|}{\sqrt{A^2+B^2}}$</p></blockquote><p>  <strong>超平面</strong>：$w^Tx+b=0$<br>  <strong>函数间隔</strong>：$\hat{\gamma}=y(w^Tx+b)=yf(x)=|f(x)|$<br>  函数间隔就是标签$y$乘上$f(x)$的值，函数间隔永远为正。但是由于SVM中$y$的取值只能为1和-1，所以函数间隔的值就是$|f(x)|$<br>  几何间隔表示点到超平面的距离，在SVM中点到超平面的距离为$\frac{|w^Tx+b|}{||w||}=\frac{|f(x)|}{||w||}=\frac{\hat{\gamma}}{||w||}$<br>  <strong>几何间隔</strong>：$\gamma=\frac{|w^Tx+b|}{||w||}=\frac{y(w^Tx+b)}{||w||}=\frac{\hat{\gamma}}{||w||}$</p><p>  函数间隔$y(w^Tx+b)$可以表示分类预测的准确性和置信度，值越大越好，说明模型将样本分正确的概率越大，但函数间隔并不表示点到超平面的距离，因为假如将$w,b$成比例变成$2w,2b$，超平面的位置没有变，但是$f(x)$却变成原来的2倍，即函数间隔变成原来的2倍。在实际中，定义点到直线的距离时，用的是几何间隔。$w,b$成倍数增加时，几何间隔不变。函数间隔是几何间隔没有除以$||w||$的表示，几何间隔是函数间隔归一化的结果。函数间隔是我们自己定义的，而几何间隔是客观存在的，无论$w,b$扩大几倍，对几何间隔没有影响。</p><p><strong>SVM的目标</strong></p><p>SVM的目标是找到一个最优的划分超平面。那怎么定义最优呢？在SVM中评价指标就是几何间隔。在下图中，我们直观的感觉图a的分类效果比b和c好，因为在图a中，与分割线最近的样本点相比b和c来说，这个样本点距离分割线最远。SVM正是遵循这一思想，在众多分割超平面中，找样本点（超平面附近的点）与分割超平面距离最大的那个超平面，即最小几何间隔中，最大的那个。</p><p><img src="/2020/06/19/百面机器学习概述/SVM3.png" alt=""></p><p>SVM的最佳划分超平面需要满足2个条件：（1）能够将所有的正负样本划分正确，即函数间隔大于0，（2）离超平面最近的样本点与超平面的几何距离最大</p><p>第一个条件公式为$\hat{\gamma}=y(w^Tx+b)&gt;0$<br>第二个条件为首先找到最近的样本点，即最小的函数间距，然后再最大化函数间距。</p><script type="math/tex; mode=display">\begin{array}{l}\min\tilde{\gamma}^{i}=\min \frac{y^{i}\left(w^{T} \mathbf{x}^{i}+b\right)}{\| w \mid}=\frac{1}{\|w\|} \min y^{i}\left(w^{T} \mathbf{x}^{i}+b\right), i=1,2, \ldots, m \\\max _{w, b} \frac{1}{\|w\|} \min y^{i}\left(w^{T} \mathbf{x}^{i}+b\right), i=1,2, \ldots, m\end{array}</script><p>结合上面的2个条件，求解最优划分超平面的公式为</p><script type="math/tex; mode=display">\begin{aligned}\max _{w, b} \frac{1}{\|w\|} \min y^{i}\left(w^{T} \mathbf{x}^{i}+b\right), i=1,2, \ldots, m \\\text { subject to } y^{i}\left(w^{T} \mathbf{x}^{i}+b\right)>0\end{aligned}</script><p>但是上面这个目标函数太复杂了，需要对其进行简化。这里就需要用到超平面的性质1：对$w,b$进行缩放，超平面不变。如果在求解的过程中，继续保持这个性质的话，就算上面的公式可以求得最优的划分超平面，但是$w,b$的取值却有无数个，即解不唯一。但是我们要求一个固定的超平面，对应的$w,b$是唯一的，就需要添加限制条件。限制条件可以有多种选择：</p><p>选择1：限制$||w||=1$，即超平面的法向量模长为1，这样就消除了等比缩放的影响。但是添加了这个限制对上面公式的简化没有什么帮助<br>选择2：$miny^i(w^Tx^i+b)=1$，限制最小的函数间隔等于1，这也是SVM所采取的方式。如果$\hat{\gamma}=1$，假设将$w,b$放大为$kw,kb$，理论上来说缩放后的函数间隔$\hat{\gamma}_{i+1}=k\hat{\gamma}$，但是我们限制了函数间隔只能为1，即$\hat{\gamma}_{i+1}=\hat{\gamma}=1$，那$k$也只能为1，即不存在等比缩放的问题。</p><blockquote><p>注意：SVM中将$miny^i(w^Tx^i+b)=1$，其实将值限制为2,3,4…，限制为多少都没关系，都可以消除等比缩放带来的影响，但是不可以不限制。</p></blockquote><p>有了这个限制条件，原先的目标就需要变了</p><p><strong>原先的目标函数</strong>：</p><script type="math/tex; mode=display">\begin{aligned}\max _{w, b} \frac{1}{\|w\|} \min y^{i}\left(w^{T} \mathbf{x}^{i}+b\right), i=1,2, \ldots, m \\\text { subject to } y^{i}\left(w^{T} \mathbf{x}^{i}+b\right)>0\end{aligned}</script><p>增加了$min y^i(w^Tx^i+b)=1$的限制，也就是说$y^i(w^Tx^i+b)&gt;=1$，第一个限制条件变成$\max _{w, b} \frac{1}{|w|}$，最大化$\frac{1}{||w||}$其实就是最小化$||w||$，也就是$min \frac{1}{2}||w||^2$，</p><p><strong>最终SVM的目标函数</strong></p><script type="math/tex; mode=display">\begin{aligned}\min _{w, b} \frac{1}{2}||w||^2 , i=1,2, \ldots, m \\\text { subject to } y^{i}\left(w^{T} \mathbf{x}^{i}+b\right)>=1\end{aligned}</script><p>于是我们得到了3个平面：最优划分超平面$w^Tx+b=0$，与划分超平面间隔平行的2个超平面$w^Tx+b=1$和$w^Tx+b=-1$</p><p><img src="/2020/06/19/百面机器学习概述/SVM2.png" alt=""></p><p>这是一个凸二次规划的问题，对于一个优化问题，通常可以从2个角度考虑：主问题和对偶问题。常常利用拉格朗日对偶性将主问题转换为对偶问题，通过求解对偶问题的解来得到原始问题的解，这是因为对偶问题的复杂度往往低于原始问题。</p><blockquote><p>拉格朗日乘子法知识点<br>拉格朗日乘子法将原问题转换为对偶问题进行求解，主问题有等式约束和不等式约束<br>主问题：</p><script type="math/tex; mode=display">\begin{array}{c}\min _{x} f(x)\\s . t . h_{i}(x)=0(i=1, \ldots, m)\\g_{j}(x) \leq 0(j=1, \ldots, n)\end{array}</script><p>拉格朗日函数为</p><script type="math/tex; mode=display">L(x, \lambda, \mu)=f(x)+\sum_{i=1}^{m} \lambda_{i} h_{i}(x)+\sum_{j=1}^{n} \mu_{j} g_{j}(x)</script><p>由不等式约束引入的KKT条件</p><script type="math/tex; mode=display">\left\{\begin{array}{l}g_{j}(x) \leq 0 \\\mu_{j} \geq 0 \\\mu_{j} g_{j}(x)=0\end{array}\right.</script><p>其中$\lambda=\left(\lambda_{1}, \lambda_{2}, \ldots, \lambda_{m}\right)^{T} \text { 和 } \mu=\left(\mu_{1}, \mu_{2}, \ldots, \mu_{n}\right)^{T}$是拉格朗日乘子</p></blockquote><p>根据上面的知识，我们得到<strong>SVM的拉格朗日函数</strong></p><p>[<br>L(\omega, b, \alpha)=\frac{1}{2}|\omega|^{2}+\sum_{i=1}^{m} \alpha_{i}\left(1-y_{i}\left(\omega^{T} x_{i}+b\right)\right)<br>]<br>其中 $\alpha=\left(\alpha_{1} ; \alpha_{2} ; \ldots ; \alpha_{m}\right)$,拉格朗日乘子 $\alpha_{i} \geq 0$</p><p>最终求得的$w,b$只和支持向量有关。因此SVM的一个重要性质是：SVM训练完之后，大部分的训练样本不需要保留，最终模型只和支持向量有关。</p><h3><span id="452-近似线性svm">4.5.2. 近似线性SVM</span></h3><p>在实际应用中，完全线性可分是很少的，例如下图中，没有一条直线可以将2类完全分开。</p><p><img src="/2020/06/19/百面机器学习概述/SVM4.png" alt=""></p><p>于是就有了软间隔，与线性可分的硬间隔相比，条件没有那么苛刻，我们允许个别样本点出现在隔离带里面，例如下图</p><p><img src="/2020/06/19/百面机器学习概述/SVM5.png" alt=""></p><p>硬间隔要求所有样本点都满足</p><script type="math/tex; mode=display">y^i(w^Tx^i+b)>=1</script><p>软间隔引入松弛变量，允许部分样本点满足</p><script type="math/tex; mode=display">y^i(w^Tx^i+b)+\xi_{i}>=1</script><p>当$\xi_{i}=0$时，样本分类正确<br>当0&lt;$\xi_{i}<1$时，样本分类正确 当$\xi_{i}="">=1$时，样本分类正确</1$时，样本分类正确></p><p>增加松弛变量后，SVM的目标变成：</p><script type="math/tex; mode=display">\begin{aligned}&\min _{w} \frac{1}{2}\|w\|^{2}+C \sum_{i=1}^{m} \xi_{i}\\&\text {s.t.} \quad g_{i}(w, b)=1-y_{i}\left(w^{T} x_{i}+b\right)-\xi_{i} \leq 0, \quad \xi_{i} \geq 0, \quad i=1,2, \ldots, n\end{aligned}</script><p>松弛变量通过学习得到，且要惩罚大的松弛变量。<br>$C$是一个大于0的数，表示错误样本的惩罚程度，当$C$无穷大时，表示对错误样本的惩罚无穷大，不允许分错样本，这样$\xi_i$就无穷小，就是线性可分SVM。当$C$为有限值时，才会允许部分样本分错。</p><p>注意：在间隔内的那部分样本点是不是支持向量？是</p><h3><span id="453-核函数">4.5.3. 核函数</span></h3><p>上面讨论的硬间隔和软间隔都是样本完全线性可分或者近似线性可分的，但是也会遇到样本不是线性可分的，例如下图：</p><p><img src="/2020/06/19/百面机器学习概述/SVM6.png" alt=""></p><p>解决方案：将样本使用核函数，向高维空间转化，使得在高维空间中线性可分。</p><p><img src="/2020/06/19/百面机器学习概述/SVM7.png" alt=""></p><p>核函数的好坏对SVM至关重要。若核函数选择不合适，将样本映射到一个不合适的特征空间，很有可能分类效果不佳。</p><p><img src="/2020/06/19/百面机器学习概述/SVM8.png" alt=""></p><h3><span id="454-面试问题">4.5.4. 面试问题</span></h3><ul><li><p><strong>介绍函数间隔和几何间隔</strong></p><blockquote><p>二维平面中点$(x,y)$到$AX+By+c=0$的距离为$\frac{|Ax+By+c|}{\sqrt{A^2+B^2}}$</p></blockquote><p><strong>超平面</strong>：$w^Tx+b=0$<br><strong>函数间隔</strong>：$\hat{\gamma}=y(w^Tx+b)=yf(x)=|f(x)|$<br>函数间隔就是标签$y$乘上$f(x)$的值，函数间隔永远为正。但是由于SVM中$y$的取值只能为1和-1，所以函数间隔的值就是$|f(x)|$<br>几何间隔表示点到超平面的距离，在SVM中点到超平面的距离为$\frac{|w^Tx+b|}{||w||}=\frac{|f(x)|}{||w||}=\frac{\hat{\gamma}}{||w||}$<br><strong>几何间隔</strong>：$\gamma=\frac{|w^Tx+b|}{||w||}=\frac{y(w^Tx+b)}{||w||}=\frac{\hat{\gamma}}{||w||}$</p><p>函数间隔$y(w^Tx+b)$可以表示分类预测的准确性和置信度，值越大越好，说明模型将样本分正确的概率越大，但函数间隔并不表示点到超平面的距离，因为假如将$w,b$成比例变成$2w,2b$，超平面的位置没有变，但是$f(x)$却变成原来的2倍，即函数间隔变成原来的2倍。在实际中，定义点到直线的距离时，用的是几何间隔。$w,b$成倍数增加时，几何间隔不变。函数间隔是几何间隔没有除以$||w||$的表示，几何间隔是函数间隔归一化的结果。函数间隔是我们自己定义的，而几何间隔是客观存在的，无论$w,b$扩大几倍，对几何间隔没有影响。</p></li><li><p><strong>SVM中$w^Tx+b&gt;1$，$w^Tx+b&lt;-1$设置为正负样本的阈值，为什么是正负1</strong><br>SVM最终学习到的是一个超平面，至于系数是$(w^T,b)$还是$(2w^T,2b)$都不重要，所以需要对$w,b$进行限制，这SVM对函数间隔进行限制为$y(w^Tx+b)=1$，这样在求得的解中$w,b$就是唯一的。当然$y(w^Tx+b)$也不一定为1，也可以为2，3或其他值</p></li><li><p><strong>SVM什么时候选择线性核函数，什么时候选择高斯核函数</strong><br>当样本量比较小，特征量比较大时使用线性核函数。因为此时特征空间已经很高维了，只是数据量不够，线性核函数足够了。如果用高斯核函数投影到高维容易出现过拟合。<br>当数据量比较大而特征量比较小时，使用高斯核函数，需要投影到高维特征空间。</p></li><li><p><strong>使用高斯核函数之前需要对数据进行处理吗</strong><br>需要对特征进行缩放，因为高斯核函数需要计算两个点之间的欧式距离，如果不特征缩放的话那些值特别大的特征将会对核函数的结果有决定性影响，而数据量小的特征将被忽略。</p></li><li><p><strong>SVM如何解决数据不均衡问题</strong><br>数据不均衡在SVM中导致的主要问题是数据量少的样本分布空间不如数据量多的样本。为了能够让分割超平面向数据量少的样本偏移，可以给样本少的分类更大的惩罚因为$C$,表示如果数据少的样本分错了将会有很大的惩罚，使模型更重视数量少的样本。</p></li><li><strong>SVM原始问题为什么要转化为对偶问题求解？</strong><ol><li>改变算法复杂度，对偶问题更容易求解。因为算法的复杂度与样本维度有关，在对偶问题下，算法复杂度和样本数量有关。如果是线性回归，样本维度小于样本数量，在原问题上求解就可以了。但如果是非线性回归，就涉及到升维，例如使用高斯核函数，将样本升到很高维，升维后的样本维度远远大于样本数量，这是显然在对偶问题下更好求解。</li><li>转化为对偶问题才能得到内积形式，引入核函数，进而推广到非线性分类问题中。</li></ol></li><li><strong>SVM为什么采用间隔最大化</strong><br>当数据线性可分时，有无穷多个超平面可以将样本划分开，利用间隔最大化可以求得最优的划分超平面。此时的划分超平面的分类结果是最鲁棒的，对未知数据的泛化能力最强。</li><li><strong>为什么SVM引入核函数</strong><br>当样本在原始空间中线性不可分时，通过核函数将样本映射到更高维的特征空间中，样本在这个特征空间中线性可分或近似线性可分。</li><li><strong>核函数也可以应用在别的分类模型中，为什么在逻辑回归中不用核函数呢？</strong><br>因为核函数将样本维度映射到很高维。在SVM中只有支持向量决定了划分超平面，只有少数样本参与核计算，在计算核函数时优势很大。但是逻辑回归是所有的样本都决定了划分超平面，如果采用核函数，那每个样本都参数核运算，则非常耗时。</li><li><strong>SVM为什么对缺失值敏感</strong><br>这里说的缺失数据是指缺失某些特征数据，向量数据不完整。SVM没有处理缺失值的策略（决策树有）。而SVM希望样本在特征空间中线性可分，所以特征空间的好坏对SVM的性能很重要。缺失特征数据将影响训练结果的好坏。</li><li><strong>SVM和逻辑回归的不同</strong><ol><li>SVM只有支持向量对模型有影响，即只有支持向量决定划分超平面。逻辑回归是所有点都影响划分超平面</li><li>损失函数不同。SVM采用hinge损失，逻辑回归采用对数损失<br>逻辑回归的目标函数 <script type="math/tex; mode=display">J(\theta)=-\frac{1}{m}\left[\sum_{i=1}^{m} y^{(i)} \log h_{\theta}\left(x^{(i)}\right)+\left(1-y^{(i)}\right) \log \left(1-h_{\theta}\left(x^{(i)}\right)\right)\right]</script>SVM的目标函数<script type="math/tex; mode=display">\mathcal{L}(w, b, \alpha)=\frac{1}{2}\|w\|^{2}-\sum_{i=1}^{n} \alpha_{i}\left(y_{i}\left(w^{T} x_{i}+b\right)-1\right)</script>逻辑回归是最大化似然，求得参数的值<br>SVM是最大化几何间隔，求得参数的值</li><li>输出不同。SVM输出0/1，逻辑回归输出样本属于正例的概率</li><li>处理非线性问题的能力不同。SVM通过核函数将非线性问题转化为线性问题。逻辑回归需要活动特征转换。</li><li>LR对异常值敏感；SVM相对不敏感，泛化能力好</li></ol></li><li><p>SVM的优缺点<br>优点：</p><ol><li>可以高效地解决高维特征的分类和回归</li><li>只依赖支持向量，无需全部样本</li><li>通过核函数可以处理线性不可分问题<br>缺点：</li><li>样本量巨大时，不适合用</li><li>SVM对缺失值敏感</li><li>对核函数没有选择的标准</li></ol></li></ul><h2><span id="46-决策树">4.6. 决策树</span></h2><p>决策树是一个非常常见的机器学习算法，易于理解，可解释强，可以作为分类算法和回归算法。</p><p>首先了解一个概念：信息熵</p><p>一个事情发生的概率越大，这个事情所携带的信息熵越小。<br>例如一个人告诉你明天太阳从东方升起，那这个人相当于说了句废话，这个话的信息熵为0。</p><h3><span id="461-基础树id3c45cart">4.6.1. 基础树(ID3/C4.5/CART)</span></h3><h4><span id="4611-id3">4.6.1.1. ID3</span></h4><p>ID3根据信息增益进行划分</p><p>信息增益是用来选择特征的一个指标，信息增益越大，说明这个特征带的信息越多，该特征越重要。</p><p>信息增益=信息熵-条件熵<br>表示在一个条件下，事情不确定性减少的程度。<br>例如相亲问题中，在南方会不会写代码这个条件下，女方见不见。<br>如果男方会写代码，女方就见。不会写代码，女方就不见。说明这个特征对结果很重要，信息增益很大。0&lt;=信息增益的取值&lt;=1</p><p>缺点：</p><ul><li>信息增益对取值数据较多的特征有多偏好。例如编号，每个人的编号都不一样，编号的取值很多，则编号的信息增益接近1，形成只有2层的决策树。虽然信息增益很大，但是对于数据集的分割却没有意义。</li><li>信息增益只能处理离散的特征，不能处理连续特征</li><li>只能处理分类问题，不能处理回归问题</li><li>对缺失值敏感</li></ul><h4><span id="4612-c45">4.6.1.2. C4.5</span></h4><p>C4.5根据信息增益比进行划分</p><p>为了解决ID3对取值多的特征偏好这一缺点，引入信息增益比。<br>信息增益比就是对取值很多的特征进行惩罚。举个例子，假设有100个样本，对这100个样本进行均分。如果特征1的取值有2个，则将样本分成50,50的子集。如果特征2的取值有4个，则将样本分成25,25,25,25的子集。可以看出特征的取值越多，就会生成越多的小子集。但是如果小子集越多的话，就会出现过拟合的问题。所以需要对这样的特征添加个惩罚项。这个特征的取值个数越多，惩罚越大。</p><script type="math/tex; mode=display">信息增益比=\frac{信息增益}{惩罚项}</script><p>ID3中如果特征取值个数很多，则信息增益越大，但是这个的惩罚项也就越大，就可以让信息增益比平衡。</p><p>缺点：<br>虽然解决了特征取值多的问题，但是仍然有以下问题</p><ul><li>只能处理离散的特征，不能处理连续特征</li><li>需要计算信息增益，计算量大</li><li>只能处理分类问题，不能处理回归问题</li><li>对缺失值有处理</li></ul><h4><span id="4613-cart分类回归树">4.6.1.3. CART(分类回归树)</span></h4><p>CART根据基尼指数(Gini)进行划分</p><p>基尼指数描述分类结果的不确定性，和信息熵类似。划分时选择基尼指数小的特征进行划分。0&lt;=基尼指数&lt;=1，</p><ul><li>CART划分的树是二叉树，因此CART每次分类时会将这个特征的特征值分成两堆，划分成左子树和右子树。然后在子树中还会用到这个特征计算基尼指数，因此CART中特征会被重复利用。但是在ID3和C4.5中，选中一个特征后，会划分为多个子树，例如这个特征有5个取值，就会划分成5个子树，在下一层中就不会计算这个特征的信息增益和信息增益比，因此特征只计算一次。</li><li>可以处理连续值，因此既可以分类，也可以回归。</li><li>对缺失值有处理</li></ul><h4><span id="4614-总结">4.6.1.4. 总结</span></h4><p>ID3：信息增益<br>C4.5：信息增益比<br>CART：最小基尼指数</p><p>以上3个指标都是描述特征的。</p><p>以上三种方法都是对数据划分的方法，通过选择特征将数据划分为更小的子集。</p><p>ID3选择信息增益大的特征来划分，但是会偏好特征取值多的特征，引入C4.5，使用信息增益比，对取值多的特征添加惩罚项。但是以上2种方法都只能处理分类问题，后来引入CART，计算基尼指数，选择基尼指数最小的特征进行划分。</p><h3><span id="462-树的剪枝">4.6.2. 树的剪枝</span></h3><p>一棵完全生长的决策树会出现过拟合的问题。例如如果按照“编号”进行划分树，则每个节点只包含1个样本，在测试集上的效果将会很差，出现过拟合现象。为了解决这个问题，对决策树进行剪枝，减掉一些枝叶。剪枝方法有2种方式：预剪枝、后剪枝</p><ul><li><p>预剪枝<br>在生成决策树的时候进行剪枝。在按照某个特征划分之前，先计算当前的划分是否能够带来模型泛化性能的提升，如果不能，则不再生成子树。此时该节点中包含的样本可能属于不同的类别，按照多数投票的原则，将该节点判为多数类别。怎么判断不再划分树：</p><ol><li>当树的深度达到一定深度</li><li>当节点样本个数小于某个阈值</li><li><p>计算每次分裂对测试集的准确率是否提升，当提升小于某个阈值时，停止划分</p><p>缺点：<br>可能会出现欠拟合的问题，应为当前划分可能造成准确率变小，但是可能后续会让准确率变大，但是树的划分已经止步于此了。</p></li></ol></li><li><p>后剪枝<br>先生成一个完整的决策树，然后自底向上的进行剪枝。通过在测试集上的准确率是否提升来判断是否剪枝该子树。<br>后剪枝的欠拟合风险很小，泛化能力优于预剪枝，但是开销比较大。</p></li></ul><h1><span id="5-聚类">5. 聚类</span></h1><p>聚类是无监督学习，即不知道样本的标签。</p><h2><span id="51-k-means聚类">5.1. K-Means聚类</span></h2><p>算法步骤:</p><ol><li>随机选k个点，作为聚类中心。这k个点不一定是样本点，可以是任意一点</li><li>计算每个点到k个聚类中心的距离，然后将这个点分到最近的类中</li><li>重新计算每个簇的中心（簇中心为所有点的均值）</li><li>重复2~4，直到聚类中心不再发生改变或达到迭代次数</li></ol><p>常见问题</p><ol><li><p><strong>K-Means常用的距离度量有哪些</strong></p><ul><li>曼哈顿距离<br>$d12=|x_1-x_2|+|y_1-y_2|$ </li><li>欧式距离<br>$d12=\sqrt{(x_1-x_2)^2+(y_1-y_2)^2}$<br>欧式距离体现2个向量距离上的绝对差异</li><li>余弦相似度<br>$con(A,B)=\frac{AB}{||A||*||B||}$<br>相比欧式距离，余弦距离更关注2个向量在方向上的相对差异。2个向量夹角越小，余弦距离越大</li></ul></li><li><p>K-Means中k如何选择</p><ul><li>根据场景选择</li><li>手肘法<br>计算指标SSE（误差平方和）<script type="math/tex; mode=display">SSE=\sum_{i=1}^{k}\sum_{p \in C_i}|p-m_i|^2</script>一共有k个簇，$C_i$为第$i$个簇，$p$是第$i$个簇的样本，$m_i$是第$i$第个簇的中心。$SSE$表示所有样本的误差平方和，表示聚类结果的好坏。核心思想：随着$k$的增大，每个簇中的样本越来越小，那每个簇越聚集，所有样本点的误差平方和$SSE$逐渐变小。假设理想情况下聚成$k’$类。我们从小到大遍历$k$，当$k&lt;k’$时，随着$k$的增加每个簇的聚合程度会迅速增加，那$SSE$会大幅度下降。当$k=k’$时，接下来再增加$k$，$SSE$下降的幅度会变小，此时不同的$k$和$SSE$的关系图就像手肘的形状。例如下图所示，手肘位置所对应的$k$就是最佳的$k$值。</li></ul><p><img src="/2020/06/19/百面机器学习概述/kmeans1.png" alt=""></p><ul><li>轮廓系数法<br>首先求一个样本点的轮廓系数，然后将所有点的轮廓系数求平均得到整个样本的轮廓系数。<br>怎么求一个样本的轮廓系数？<br>$S_i=\frac{b-a}{max(a,b)}$<br>$a$表示样本$x_i$与相同簇的样本的平均距离。$b$为样本$x_i$与最近簇中样本的平均距离。 因此$a$表示簇内的聚合程度，$b$表示簇间的分离程度。下图中显示了$x_i$的轮廓系数计算方法。平均轮廓系数范围[-1,1]，轮廓系数越大，聚类效果越好，说明簇内越紧密(a越小)，簇间越分离(b越大)。</li></ul><p><img src="/2020/06/19/百面机器学习概述/kmeans2.png" alt=""></p><p> 从小到大遍历$k$，然后计算所有样本的平均轮廓系数，找出最大轮廓系数对应的$k$.下图给出$k$与轮廓系数的关系：</p><p> <img src="/2020/06/19/百面机器学习概述/kmeans3.png" alt=""></p><p> 可以看出$k=2$时聚类效果最好。但是$K=2$时SSE却不是最小的，SSE依然很大。猜测是因为：SSE大说明样本间的误差很大。轮廓系数大说明不一定是$a$小，也有可能是$a$很大，但是$b$更大，导致SSE就很大。所以在选择$k$时需要同时看轮廓法和SSE法。</p></li></ol><ul><li>确定了k，k个初始点怎么选<br>（1）则k个初始点要尽可能远<br>（2）可以先对数据进行层次聚类，将层次聚类得到的k个聚类中心作为k-means的初始聚类中心</li><li>K-Means怎么处理超大数据量的聚类<br>K-Means在大数据量时，因为需要计算每个点到质心的距离，非常耗时。一种解决方案是Mini Batch K-Means小批量K-Means，即在计算距离时不必计算所有的样本点，而是从不同类别的样本中抽出一部分计算。这种方法会减少运行时间，但是会造成准确度下降。<br>步骤：<br>（1）给出k个初始质心<br>（2）从每个簇中选出一部分样本计算与k个质心的距离，分到最近的那个簇中<br>（3）根据小批量样本计算新的质心<br>（4）重复2~4，直到质心不再变化或迭代达到上界</li></ul><h2><span id="52-k-means的优化">5.2. K-Means的优化</span></h2><h2><span id="53-knn">5.3. KNN</span></h2><ul><li>KNN和K-Means有什么不同</li><li></li></ul><ol><li>K-Means优缺点<br>优点<br>（1）原理简单，易于实现<br>（2）可解释强<br>缺点：<br>（1）容易受初始中心的影响，可能会陷入局部最优<br>（2）k的选取会影响聚类结果<br>（3）对噪声和异常点敏感<br>（4）不适合环形数据</li></ol><p>手写K-Means算法</p><p><a href="https://zhuanlan.zhihu.com/p/114047758" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/114047758</a></p><h2><span id="54-聚类评价指标">5.4. 聚类评价指标</span></h2><p><a href="https://www.dataapplab.com/machine-learning-interview-questions/" target="_blank" rel="noopener">https://www.dataapplab.com/machine-learning-interview-questions/</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;总结《百面机器学习》有关知识点。&lt;/p&gt;
    
    </summary>
    
      <category term="Machine Learning" scheme="http://yoursite.com/categories/Machine-Learning/"/>
    
    
      <category term="machine learning" scheme="http://yoursite.com/tags/machine-learning/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode之位运算</title>
    <link href="http://yoursite.com/2020/06/07/Leetcode%E4%B9%8B%E4%BD%8D%E8%BF%90%E7%AE%97/"/>
    <id>http://yoursite.com/2020/06/07/Leetcode之位运算/</id>
    <published>2020-06-07T09:35:16.000Z</published>
    <updated>2020-06-18T02:36:14.220Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><!-- TOC --><ul><li><a href="#1-位运算">1. 位运算</a></li><li><a href="#2-总结">2. 总结</a></li></ul><!-- /TOC --><h1><span id="1-位运算">1. 位运算</span></h1><p>位运算总共有5种运算：与，或，异或，左移，右移。<br>左移<code>m&lt;&lt;n</code>表示把m左移n位，在左移n位时，最左边的n位被丢弃，同时最右边补上n个0<br>右移<code>m&gt;&gt;n</code>表示把m右移n位，在右移n位时，最右边的n位被丢弃，在处理左边时比较复杂。如果数字是无符号数，最左边补上n个0。如果数字是一个有符号数，则用数字的符号填补左边的n位。也就是说，如果数字是整数，最左边用0填充，如果数字是负数，最左边用1填充。例如<br>00001010&gt;&gt;2=00000010<br>10001010&gt;&gt;3=11110001</p><p>请实现一个函数，输入一个整数，输出该数二进制表示中 1 的个数。例如，把 9 表示成二进制是 1001，有 2 位是 1。因此，如果输入 9，则该函数输出 2。</p><p>链接：<a href="https://leetcode-cn.com/problems/er-jin-zhi-zhong-1de-ge-shu-lcof" target="_blank" rel="noopener">https://leetcode-cn.com/problems/er-jin-zhi-zhong-1de-ge-shu-lcof</a></p><p><strong>【分析】</strong><br>将一个整数n减去1之后，再和n做与运算，可以将n中最右边的1变成0<br>比如原先n=1100，n-1=1011，n&amp;(n-1)=1000,与运算的结果1000与原先的n=1100相比，就把最后边的1变成0。然后再对1000执行相同的操作，就会变成0000。这样执行2次，说明原始的n中一共有2个1.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hammingWeight</span><span class="params">(self, n)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type n: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        <span class="comment">#n=n&amp;(n-1)可以让原先的n中的1变成0</span></span><br><span class="line">        <span class="keyword">while</span> n:</span><br><span class="line">            res+=<span class="number">1</span></span><br><span class="line">            n=n&amp;(n<span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><p>整数<code>n&amp;1</code>值为0或1，判断n的二进制数的最后一位是0还是1.如果n=8，n&amp;1=0，表示8的二进制1000最后一位是0。如果n=9，n&amp;1=1，表示9的二进制1001最后一位是1.<br>$x^n$中的n变换成二进制为$b_mb_{m-1}…b_2b_1$，二进制和十进制n的关系为$n=2^0b_1+2^1b_2+…+2^{m-1}b_m$,这样就可以把$x^n=x^{2^0b_1+2^1b_2+…+2^{m-1}b_m}=x^{2^0b_1}x^{2^1b_2}…x^{2^{m-1}b_m}$。其中$b_1,b_2….b_m$的值只能为0或1.如果$b_m=0$，那$x^{2^{m-1}b_m}=1$，否则$x^{2^{m-1}b_m}=x^{2^{m-1}}$<br>所以问题的关键就是计算十进制数n，转换成二进制后每一个位数是0还是1.<br>如果第一位是1，就乘上$x^1$,然后把n除以2，就是n=n&gt;&gt;1,然后再判断原始n的第二位。<br>如果第二位是1，就乘上$x^2$<br>如果第三位是1，就乘上$x^4$<br>如果第四位是1，就乘上$x^8$</p><p>n=11，变换成二进制是1011,分别是1,2,4,8，其中只有1,2,8的幂次有效。理论上应该是$x.x^2.x^8$</p><ul><li>进入while循环，n&amp;1=1，$res=x$，然后$x=x^2$，n右移一位成5</li><li>进入while循环，n&amp;1=1，$res=res*x=x^3,x=x^4$,n右移一位变成2</li><li>进入while循环，n&amp;1=0，$x=x^8$,n右移一位变成1</li><li>进入到while循环，n&amp;1=1，$res=x^11,x=x^16$,n右移一位变成0</li><li>退出while循环，返回res</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">myPow</span><span class="params">(self, x, n)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type x: float</span></span><br><span class="line"><span class="string">        :type n: int</span></span><br><span class="line"><span class="string">        :rtype: float</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> x==<span class="number">0</span>:<span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> n==<span class="number">0</span>:<span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        tmp_n = abs(n)</span><br><span class="line">        res=<span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> tmp_n:</span><br><span class="line">            <span class="keyword">if</span> tmp_n&amp;<span class="number">1</span>:</span><br><span class="line">                res*=x</span><br><span class="line">            x*=x</span><br><span class="line">            tmp_n=tmp_n&gt;&gt;<span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> n&gt;<span class="number">0</span>:<span class="keyword">return</span> res</span><br><span class="line">        <span class="keyword">else</span>:<span class="keyword">return</span> <span class="number">1</span>/res</span><br></pre></td></tr></table></figure><ul><li>时间复杂度：O(logn)</li><li>空间复杂度：O(1)</li></ul><h1><span id="2-总结">2. 总结</span></h1><ol><li>将二进制数字n的最右边的1变成0，n=n&amp;(n-1)<br>2.</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;!-- TOC --&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#1-位运算&quot;&gt;1. 位运算&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#2-总结&quot;&gt;2. 总结&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;!-- /TOC --&gt;
&lt;h1&gt;&lt;span id
      
    
    </summary>
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode之动态规划</title>
    <link href="http://yoursite.com/2020/06/06/Leetcode%E4%B9%8B%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    <id>http://yoursite.com/2020/06/06/Leetcode之动态规划/</id>
    <published>2020-06-06T06:55:38.000Z</published>
    <updated>2020-06-27T07:43:44.769Z</updated>
    
    <content type="html"><![CDATA[<h1><span id="1-动态规划">1. 动态规划</span></h1><p>如果是求一个问题的最优解（通常是最大值或最小值），而且该问题可以分解成若干个子问题，并且子问题之间还有重叠的更小的子问题，可以考虑使用动态规划。</p><p>在解决动态规划问题时，需要分解成子问题，这里需要将子问题的最优解保存下来（一般是一维或二维数组），作为求取大问题最优解的基础。</p><p>做动态规划的三个关键：</p><ol><li>dp[i]表示什么意思（如果二维，dp[i][j]）</li><li>根据dp[i]和dp[i-1]的关系写出状态转移矩阵</li><li>确定初始条件，dp[0]</li></ol><a id="more"></a><!-- TOC --><ul><li><a href="#1-动态规划">1. 动态规划</a></li><li><a href="#2-剪绳子">2. 剪绳子</a></li><li><a href="#3-最大子序列和">3. 最大子序列和</a></li><li><a href="#4-乘积最大子数组">4. 乘积最大子数组</a></li><li><a href="#5-股票问题">5. 股票问题</a><ul><li><a href="#51-买卖股票的最佳时机">5.1. 买卖股票的最佳时机</a></li><li><a href="#52-买卖股票的最佳时机-ii">5.2. 买卖股票的最佳时机 II</a></li><li><a href="#53-买卖股票的最佳时机-iii">5.3. 买卖股票的最佳时机 III</a></li><li><a href="#54-买卖股票的最佳时机-iv">5.4. 买卖股票的最佳时机 IV</a></li><li><a href="#55-最佳买卖股票时机含冷冻期">5.5. 最佳买卖股票时机含冷冻期</a></li><li><a href="#56-买卖股票的最佳时机含手续费">5.6. 买卖股票的最佳时机含手续费</a></li><li><a href="#57-总结">5.7. 总结</a></li></ul></li><li><a href="#6-打家劫舍">6. 打家劫舍</a><ul><li><a href="#61-打家劫舍-i">6.1. 打家劫舍 I</a></li><li><a href="#62-打家劫舍-ii">6.2. 打家劫舍 II</a></li><li><a href="#63-打家劫舍iii">6.3. 打家劫舍III</a></li><li><a href="#64-总结">6.4. 总结</a></li></ul></li><li><a href="#7-最长回文子串">7. 最长回文子串</a></li><li><a href="#8-回文子串">8. 回文子串</a></li><li><a href="#9-背包问题">9. 背包问题</a><ul><li><a href="#91-0-1背包问题">9.1. 0-1背包问题</a></li><li><a href="#92-背包初始化问题">9.2. 背包初始化问题</a></li><li><a href="#93-完全背包问题">9.3. 完全背包问题</a></li><li><a href="#94-多重背包问题">9.4. 多重背包问题</a></li><li><a href="#95-二维背包问题">9.5. 二维背包问题</a></li><li><a href="#96-分割等和子集">9.6. 分割等和子集</a></li><li><a href="#97-一和零">9.7. 一和零</a></li><li><a href="#98-目标和">9.8. 目标和</a></li><li><a href="#99-零钱兑换">9.9. 零钱兑换</a></li><li><a href="#910-零钱兑换-ii">9.10. 零钱兑换 II</a></li><li><a href="#911-完全平方数">9.11. 完全平方数</a></li><li><a href="#整数拆分">整数拆分</a></li></ul></li><li><a href="#10-路径问题">10. 路径问题</a><ul><li><a href="#101-不同路径">10.1. 不同路径</a></li><li><a href="#102-不同路径ii">10.2. 不同路径II</a></li><li><a href="#103-下降路径最小和">10.3. 下降路径最小和</a></li><li><a href="#104-下降路径最小和ii">10.4. 下降路径最小和II</a></li><li><a href="#105-最小路径和">10.5. 最小路径和</a></li><li><a href="#106-三角形最小路径和">10.6. 三角形最小路径和</a></li></ul></li><li><a href="#统计全为1的正方形子矩形">统计全为1的正方形子矩形</a></li><li><a href="#最大正方形">最大正方形</a></li><li><a href="#最长上升子序列问题">最长上升子序列问题</a><ul><li><a href="#最长上升子序列">最长上升子序列</a></li><li><a href="#无重叠区间">无重叠区间</a></li></ul></li><li><a href="#动态规划--博弈问题">动态规划—博弈问题</a><ul><li><a href="#石子游戏">石子游戏</a></li><li><a href="#预测赢家">预测赢家</a></li></ul></li><li><a href="#11-总结">11. 总结</a></li></ul><!-- /TOC --><h1><span id="2-剪绳子">2. 剪绳子</span></h1><p>给你一根长度为 n 的绳子，请把绳子剪成整数长度的 m 段（m、n都是整数，n&gt;1并且m&gt;1），每段绳子的长度记为 k[0],k[1]…k[m-1] 。请问 k[0]<em>k[1]</em>…*k[m-1] 可能的最大乘积是多少？例如，当绳子的长度是8时，我们把它剪成长度分别为2、3、3的三段，此时得到的最大乘积是18。</p><p>注意：m&gt;1，说明必须要切分，例如长度为2，必须要切分成1+1</p><p>链接：<a href="https://leetcode-cn.com/problems/jian-sheng-zi-lcof" target="_blank" rel="noopener">https://leetcode-cn.com/problems/jian-sheng-zi-lcof</a></p><p><strong>【方法一】</strong><br>使用动态规划解决。<br>状态转移公式：<code>dp[i] = max(dp[i],max(j*(i-j),j*dp[i-j]))</code>,<br>首先求不切割<code>dp[i]</code>和切割的最大值。<br>在切割中，有2种方式：（1）将i切割成j和i-j两部分，不再切割.（2）将i切割成<br>j和i-j两部分，然后再对i-j继续切割。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">cuttingRope</span><span class="params">(self, n)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type n: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="comment">#状态转移公式</span></span><br><span class="line">        <span class="comment">#dp[i] = max(dp[i],max(j*(i-j),j*dp[i-j]))</span></span><br><span class="line">        dp = [<span class="number">0</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(n+<span class="number">1</span>)]<span class="comment">#从0~n</span></span><br><span class="line">        dp[<span class="number">2</span>]=<span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">3</span>,n+<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(i):</span><br><span class="line">                dp[i] = max(dp[i],max(j*(i-j),j*dp[i-j]))</span><br><span class="line">        <span class="keyword">return</span> dp[n]</span><br></pre></td></tr></table></figure><p><strong>【方法二】</strong><br>找规律，也是贪心法则</p><ul><li>如果绳子长度&gt;=5,则尽可能多的切分成3</li><li>绳子长度为4，分成2+2</li><li>绳子长度为3，切分1+2</li><li>绳子长度为2，分成1+1</li></ul><p>总结如下,绳子长度为L：</p><ul><li>L&lt;3,切分成1+(L-1)</li><li>L&gt;=3<ul><li>L%3==0：全部划分为3</li><li>L%3==1：先划分成2+2，然后把剩下的划分为3</li><li>L%3==2：先划分成1个2，然后把剩下的划分成3 </li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">cuttingRope</span><span class="params">(self, n)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type n: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> n &lt;= <span class="number">3</span>:<span class="keyword">return</span> <span class="number">1</span>*(n<span class="number">-1</span>)</span><br><span class="line">        res = <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> n % <span class="number">3</span> == <span class="number">1</span>:</span><br><span class="line">            res = <span class="number">4</span></span><br><span class="line">            n -= <span class="number">4</span></span><br><span class="line">        <span class="keyword">elif</span> n % <span class="number">3</span> == <span class="number">2</span>:</span><br><span class="line">            res = <span class="number">2</span></span><br><span class="line">            n -= <span class="number">2</span></span><br><span class="line">        <span class="keyword">while</span> n:</span><br><span class="line">            res *= <span class="number">3</span></span><br><span class="line">            n -= <span class="number">3</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h1><span id="3-最大子序列和">3. 最大子序列和</span></h1><p>给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。<br><a href="https://leetcode-cn.com/problems/maximum-subarray/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/maximum-subarray/</a></p><p><strong>【方法一】</strong><br>动态规划<br>dp[i]表示以nums[i]为结尾的最大子序列和<br>dp[0]=nums[0]<br><code>dp[i]=max(dp[i-1]+nums[i],nums[i])</code><br>dp[i]的最大值就是看当前元素nums[i]应该单独成一段，还是加入到上一段中dp[i-1]，所以需要从2个中找最大值。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxSubArray</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="comment">#dp[i]表示nums中以i为结尾的最大和</span></span><br><span class="line">        dp = [<span class="number">0</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums))]</span><br><span class="line">        dp[<span class="number">0</span>] = nums[<span class="number">0</span>]</span><br><span class="line">        <span class="comment">#dp[i] = max(dp[i-1]+nums[i],nums[i])</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,len(nums)):</span><br><span class="line">            dp[i] = max(dp[i<span class="number">-1</span>]+nums[i],nums[i])</span><br><span class="line">        <span class="keyword">return</span> max(dp)</span><br></pre></td></tr></table></figure><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(n)</li></ul><p><strong>【优化】</strong><br>上面方法的空间复杂度是O(n),因为dp需要存储n个数的最大值。但其实在计算dp[i]的时候，只需要用到dp[i-1]，其余都没用，所以我们可以将空间复杂度降到O(1),只保留dp[i-1]的值</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxSubArray</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        dp = nums[<span class="number">0</span>]</span><br><span class="line">        res = dp</span><br><span class="line">        <span class="comment">#dp[i] = max(dp[i-1]+nums[i],nums[i])</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,len(nums)):</span><br><span class="line">            dp = max(dp+nums[i],nums[i])</span><br><span class="line">            res = max(res,dp)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><p><strong>【方法二】</strong><br>使用贪心算法，从左向右遍历，一个个数字相加，使用sum记录当前遍历的和，max记录当前遍历和的最大值。如果sum&lt;0，则将sum更新为当前元素的值，重新找新的子序串，然后将sum和max比较，将max更新为较大的值</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxSubArray</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        sub_sum = nums[<span class="number">0</span>]</span><br><span class="line">        res = nums[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,len(nums)):</span><br><span class="line">            <span class="keyword">if</span> sub_sum &lt; <span class="number">0</span>:</span><br><span class="line">                sub_sum = nums[i]</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                sub_sum += nums[i]</span><br><span class="line">            res = max(res,sub_sum)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h1><span id="4-乘积最大子数组">4. 乘积最大子数组</span></h1><p>给你一个整数数组 nums ，请你找出数组中乘积最大的连续子数组（该子数组中至少包含一个数字），并返回该子数组所对应的乘积。</p><p>示例 1:</p><p>输入: [2,3,-2,4]<br>输出: 6<br>解释: 子数组 [2,3] 有最大乘积 6。</p><p>链接：<a href="https://leetcode-cn.com/problems/maximum-product-subarray" target="_blank" rel="noopener">https://leetcode-cn.com/problems/maximum-product-subarray</a></p><p><strong>【分析一】</strong></p><p>乘积的最大值和和不同，两个负数相乘为正数。一个最大的正数乘以负数会变成最小值。因此最大值和最小值是相互转换的，我们可以将这种转换关系设计到状态转移方程中。<br>在遍历到<code>nums[i]</code>时，当前乘积的最大值可能由<code>pre_max</code>转换，也可能由<code>pre_min</code>转换得到，也可能是当前值。<br><code>cur_max=max(pre_max*nums[i],pre_min*nums[i],nums[i])</code><br><code>cur_min=min(pre_max*nums[i],pre_min*nums[i],nums[i])</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxProduct</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        pre_max = nums[<span class="number">0</span>]</span><br><span class="line">        pre_min = nums[<span class="number">0</span>]</span><br><span class="line">        res = nums[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,len(nums)):</span><br><span class="line">            cur_max = max(pre_max*nums[i],pre_min*nums[i],nums[i])</span><br><span class="line">            cur_min = min(pre_max*nums[i],pre_min*nums[i],nums[i])</span><br><span class="line">            res = max(res,cur_max)</span><br><span class="line"></span><br><span class="line">            pre_max = cur_max</span><br><span class="line">            pre_min = cur_min</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h1><span id="5-股票问题">5. 股票问题</span></h1><h2><span id="51-买卖股票的最佳时机">5.1. 买卖股票的最佳时机</span></h2><p>给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。</p><p>如果你最多只允许完成一笔交易（即买入和卖出一支股票一次），设计一个算法来计算你所能获取的最大利润。</p><p>注意：你不能在买入股票前卖出股票。</p><p>链接：<a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock" target="_blank" rel="noopener">https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock</a></p><p><strong>【方法一】</strong><br>一次遍历，记录前i天的最低价格和最大利润</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxProfit</span><span class="params">(self, prices)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type prices: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> prices:<span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="comment">#对于每个价格，记录在它之前的最低价格，求差值，然后和算出来的最大利润比较</span></span><br><span class="line">        <span class="comment">#如果当前差值大于以前的利润，修改max_profile</span></span><br><span class="line">        min_pricce = prices[<span class="number">0</span>]</span><br><span class="line">        max_profile = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> price <span class="keyword">in</span> prices:</span><br><span class="line">            min_pricce = min(min_pricce,price)</span><br><span class="line">            max_profile = max(max_profile,price-min_pricce)</span><br><span class="line">        <span class="keyword">return</span> max_profile</span><br></pre></td></tr></table></figure><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(1)</li></ul><p><strong>【方法二】</strong><br>动态规划<br>dp[i]表示前i天的最大利润，在遍历的过程中找到股票的最低价格，在第i天，看是否需要卖出。如果卖出利润为prices[i]-min_price，如果不卖，就和昨天的利润dp[i-1]一样。<br><code>dp[i]=max(dp[i-1],prices[i]-min_price)</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxProfit</span><span class="params">(self, prices)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type prices: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> prices:<span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        dp = [<span class="number">0</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(len(prices))]</span><br><span class="line">        dp[<span class="number">0</span>]=<span class="number">0</span></span><br><span class="line">        min_pricce = prices[<span class="number">0</span>]<span class="comment">#记录前i天的最低价格</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,len(prices)):</span><br><span class="line">            min_pricce = min(min_pricce,prices[i])</span><br><span class="line">            dp[i] = max(dp[i<span class="number">-1</span>],prices[i]-min_pricce)</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">-1</span>]</span><br></pre></td></tr></table></figure><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(n)</li></ul><h2><span id="52-买卖股票的最佳时机-ii">5.2. 买卖股票的最佳时机 II</span></h2><p>给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。</p><p>设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。</p><p>注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</p><blockquote><p>输入: [7,1,5,3,6,4]<br>输出: 7<br>解释: 在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格=5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。随后，在第 4 天（股票价格=3）的时候买入，在第 5 天（股票价格=6）的时候卖出, 这笔交易所能获得利润 = 6-3 = 3 </p></blockquote><p>链接：<a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii" target="_blank" rel="noopener">https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii</a></p><p><strong>【方法一】</strong></p><p>使用贪心算法只需要一次遍历。其主要想法是逢低便买入，逢高便卖出，即只要明天的价格大于今天的价格，就在今天买下，明天卖出。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxProfit</span><span class="params">(self, prices)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type prices: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="comment">#贪心算法，只遵循一个原则：低价买入，高价出售</span></span><br><span class="line">        <span class="comment">#只要明天的价格比今天高，就买今天的，然后明天卖出，获得差价利润</span></span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(prices)<span class="number">-1</span>):</span><br><span class="line">            diff = prices[i+<span class="number">1</span>] - prices[i]</span><br><span class="line">            <span class="keyword">if</span> diff&gt;<span class="number">0</span>:</span><br><span class="line">                res+=diff</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><p><strong>【方法二】</strong></p><p>一般能用贪心算法解决的，都可以使用动态规划算法。<br>定义dp，使用二维矩阵<br>dp[i][j]:第一维dp[i]表示前i天能获得的最大利润，第二维dp[i][j]表示在第i天手里有没有股票，dp[i][0]表示没有股票，手里持有现金时的最大利润，dp[i][1]表示持有股票的最大利润<br>第一天，dp[0][0]表示持有现金，则最大利润为0，dp[0][0]=0；dp[0][1]表示持有股票，则最大利润为dp[0][1]=-prices[0]。<br>对于dp[i][0]和dp[i][1]的状态转移需要分情况讨论</p><ul><li><p>dp[i][0]第i天持有现金状态</p><ul><li>第i-1天持有股票，第i天卖出股票：dp[i][0]=dp[i-1][1]+prices[i]</li><li>第i-1天没有股票，第i天也没有股票：dp[i][0]=dp[i-1][0]<br>最终dp[i][0]从以上2种情况选最大的作为最终利润 </li></ul></li><li><p>dp[i][1]第i天持有股票状态</p><ul><li>第i-1天没有股票，第i天买入股票：dp[i][1]=dp[i-1][0]-prices[i]</li><li>第i-1天有股票，第i天没有卖出：dp[i][1]=dp[i-1][1]<br>最终dp[i][1]从以上2种情况选最大的作为最终利润 </li></ul></li></ul><p>最终返回的结果是最后一天的最大利润，最后一天手里不能有任何股票，全都卖出，即dp[-1][0]</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxProfit</span><span class="params">(self, prices)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type prices: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="comment">#动态规划</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> prices:<span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        dp = [[<span class="number">0</span>,<span class="number">0</span>] <span class="keyword">for</span> i <span class="keyword">in</span> range(len(prices))]</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">0</span></span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">1</span>]=-prices[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,len(prices)):</span><br><span class="line">            dp[i][<span class="number">0</span>] = max(dp[i<span class="number">-1</span>][<span class="number">1</span>]+prices[i],dp[i<span class="number">-1</span>][<span class="number">0</span>])</span><br><span class="line">            dp[i][<span class="number">1</span>] = max(dp[i<span class="number">-1</span>][<span class="number">0</span>]-prices[i],dp[i<span class="number">-1</span>][<span class="number">1</span>])</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">-1</span>][<span class="number">0</span>]</span><br></pre></td></tr></table></figure><h2><span id="53-买卖股票的最佳时机-iii">5.3. 买卖股票的最佳时机 III</span></h2><p>给定一个数组，它的第 i 个元素是一支给定的股票在第 i 天的价格。</p><p>设计一个算法来计算你所能获取的最大利润。你最多可以完成 两笔 交易。</p><p>注意: 你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</p><p>链接：<a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iii" target="_blank" rel="noopener">https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iii</a></p><p><strong>【分析一】</strong></p><p>以前的dp都是一维或二维，本题因为说交易次数最多为2次，因此交易次数也需要当成一个新的维度考虑在dp中，所以dp变成三维。<code>dp[i][k][j]</code>，三个维度表示：天数i（i=0,1,…n-1），<strong>买入股票的次数</strong>（k=0,1,2），<strong>每买一次交易次数加1</strong>，是否持有股票（0表示没有股票，1表示持有股票）。买入股票的次数为k时，隐含了卖出股票的次数为k或k-1。<br>状态转移方程有2个</p><ul><li><code>dp[i][k][0]</code>第i天没有股票<ol><li>第i-1天也没有股票，第i天什么都没做：<code>dp[i][k][0]=dp[i-1][k][0]</code></li><li>第i-1天有股票，第i天卖了：<code>dp[i][k][0]=dp[i-1][k][1]+prices[i]</code></li></ol></li><li><code>dp[i][k][1]</code>第i天有股票<ol><li>第i-1天也有股票，第i天什么都没做：<code>dp[i][k][1]=dp[i-1][k][1]</code></li><li>第i-1天没有股票，第i天买了股票：<code>dp[i][k][1]=dp[i-1][k-1][0]-prices[i]</code><br>定义好状态转移矩阵，上面只对第三个维度进行遍历，下面初始化dp的i和k</li></ol></li><li>i=0，第1天<br><code>for _k in range(1,k)</code>:对每个k初始化i=0，因为下面的已经包含k=0了，这里从k=1开始遍历<ol><li><code>dp[0][k][0]</code>：第1天没有买股票，<code>dp[0][k][0]=0</code></li><li><code>dp[0][k][1]</code>：第1天买了股票，<code>dp[0][k][1]=-prices[0]</code></li></ol></li><li>k=0，买入股票次数为0<br>for _i in range(i)，对每个i初始化k=0，因为i=0已经在<ol><li><code>dp[i][0][0]</code>：在第i天从来没有买过股票，<code>dp[i][0][0]=0</code></li><li><code>dp[i][0][1]</code>：在第i天从来没有股票，所以也不可能持股，即利润为负无穷，<code>dp[i][0][1]=-float(&#39;inf&#39;)</code></li></ol></li></ul><p>以前2种遍历有重叠的部分：</p><ul><li><code>dp[0][0][0]=0</code></li><li><code>dp[0][0][1]=-float(&#39;inf&#39;)</code></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxProfit</span><span class="params">(self, prices)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type prices: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        n = len(prices)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> prices:<span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        dp = [[[<span class="number">0</span>,<span class="number">0</span>] <span class="keyword">for</span> k <span class="keyword">in</span> range(<span class="number">3</span>)] <span class="keyword">for</span> i <span class="keyword">in</span> range(n)]</span><br><span class="line">        <span class="comment">#初始化，当i=0时</span></span><br><span class="line">        <span class="keyword">for</span> k <span class="keyword">in</span> range(<span class="number">1</span>,<span class="number">3</span>):</span><br><span class="line">            dp[<span class="number">0</span>][k][<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">            dp[<span class="number">0</span>][k][<span class="number">1</span>] = -prices[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">            dp[i][<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">            dp[i][<span class="number">0</span>][<span class="number">1</span>] = -float(<span class="string">'inf'</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 状态转移</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,n):</span><br><span class="line">            <span class="keyword">for</span> k <span class="keyword">in</span> range(<span class="number">1</span>,<span class="number">3</span>):</span><br><span class="line">                dp[i][k][<span class="number">0</span>]=max(dp[i<span class="number">-1</span>][k][<span class="number">0</span>],dp[i<span class="number">-1</span>][k][<span class="number">1</span>]+prices[i])</span><br><span class="line">                dp[i][k][<span class="number">1</span>]=max(dp[i<span class="number">-1</span>][k][<span class="number">1</span>],dp[i<span class="number">-1</span>][k<span class="number">-1</span>][<span class="number">0</span>]-prices[i])</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">-1</span>][<span class="number">-1</span>][<span class="number">0</span>]</span><br></pre></td></tr></table></figure><h2><span id="54-买卖股票的最佳时机-iv">5.4. 买卖股票的最佳时机 IV</span></h2><p>给定一个数组，它的第 i 个元素是一支给定的股票在第 i 天的价格。</p><p>设计一个算法来计算你所能获取的最大利润。你最多可以完成 k 笔交易。</p><p>注意: 你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</p><p>链接：<a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iv" target="_blank" rel="noopener">https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iv</a></p><p><strong>【分析一】</strong></p><p>和上一题一样，只是把原先的2换成k，其余代码不变，但是提交时，出现内存溢出的错误，因为当k较大时，比如k=1000000000，dp占用的空间太大。所以需要对此进行优化。<br>prices中有n天的价格，题目要求需要交易k次，因为有效的交易由买入和卖出组成，至少需要2天，所以有效的交易（有买有卖）次数限制k应该&lt;=n/2，如果k&gt;n/2，就没有约束作用了，相当于k=inf，这和leetcode122题一样。<br>所以代码分成2部分，</p><ul><li>if k&gt;n/2，按照leetcode122的解法（贪心）</li><li>else，按照leetcode123的解法（动态规划）</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxProfit</span><span class="params">(self, k, prices)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type k: int</span></span><br><span class="line"><span class="string">        :type prices: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        n = len(prices)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> prices:<span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> k&gt;n/<span class="number">2</span>:</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(n<span class="number">-1</span>):</span><br><span class="line">                diff = prices[i+<span class="number">1</span>]-prices[i]</span><br><span class="line">                <span class="keyword">if</span> diff&gt;<span class="number">0</span>:</span><br><span class="line">                    res+=diff</span><br><span class="line">            <span class="keyword">return</span> res</span><br><span class="line">        <span class="keyword">else</span>:    </span><br><span class="line">            dp = [[[<span class="number">0</span>,<span class="number">0</span>] <span class="keyword">for</span> _ <span class="keyword">in</span> range(k+<span class="number">1</span>)] <span class="keyword">for</span> i <span class="keyword">in</span> range(n)]</span><br><span class="line">            <span class="comment">#初始化，当i=0时</span></span><br><span class="line">            <span class="keyword">for</span> _k <span class="keyword">in</span> range(<span class="number">1</span>,k+<span class="number">1</span>):</span><br><span class="line">                dp[<span class="number">0</span>][_k][<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">                dp[<span class="number">0</span>][_k][<span class="number">1</span>] = -prices[<span class="number">0</span>]</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">                dp[i][<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">                dp[i][<span class="number">0</span>][<span class="number">1</span>] = -float(<span class="string">'inf'</span>)</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 状态转移</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,n):</span><br><span class="line">                <span class="keyword">for</span> _k <span class="keyword">in</span> range(<span class="number">1</span>,k+<span class="number">1</span>):</span><br><span class="line">                    dp[i][_k][<span class="number">0</span>]=max(dp[i<span class="number">-1</span>][_k][<span class="number">0</span>],dp[i<span class="number">-1</span>][_k][<span class="number">1</span>]+prices[i])</span><br><span class="line">                    dp[i][_k][<span class="number">1</span>]=max(dp[i<span class="number">-1</span>][_k][<span class="number">1</span>],dp[i<span class="number">-1</span>][_k<span class="number">-1</span>][<span class="number">0</span>]-prices[i])</span><br><span class="line">            <span class="keyword">return</span> dp[<span class="number">-1</span>][<span class="number">-1</span>][<span class="number">0</span>]</span><br></pre></td></tr></table></figure><h2><span id="55-最佳买卖股票时机含冷冻期">5.5. 最佳买卖股票时机含冷冻期</span></h2><p>给定一个整数数组，其中第 i 个元素代表了第 i 天的股票价格 。​</p><p>设计一个算法计算出最大利润。在满足以下约束条件下，你可以尽可能地完成更多的交易（多次买卖一支股票）:</p><ul><li>你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</li><li>卖出股票后，你无法在第二天买入股票 (即冷冻期为 1 天)。</li></ul><p>链接：<a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-cooldown" target="_blank" rel="noopener">https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-cooldown</a></p><blockquote><p>输入: [1,2,3,0,2]<br>输出: 3<br>解释: 对应的交易状态为: [买入, 卖出, 冷冻期, 买入, 卖出]</p></blockquote><p><strong>【分析一】</strong></p><p>该题和leetcode122类似，除了增加冷冻期。<br>同样定义dp，使用二维矩阵<br>dp[i][j]:第一维dp[i]表示前i天能获得的最大利润，第二维dp[i][j]表示在第i天手里有没有股票，dp[i][0]表示没有股票，手里持有现金时的最大利润，dp[i][1]表示持有股票的最大利润</p><p>对于dp[i][0]和dp[i][1]的状态转移需要分情况讨论</p><ul><li>dp[i][0]第i天持有现金状态<ul><li>第i-1天持有股票，第i天卖出股票：dp[i][0]=dp[i-1][1]+prices[i]</li><li>第i-1天没有股票，第i天也没有股票：dp[i][0]=dp[i-1][0]<br>最终dp[i][0]从以上2种情况选最大的作为最终利润 </li></ul></li></ul><p>下面这个转移公式与122题有变化。因为增加了冷冻期，在第i天买入股票，状态要从i-2天转移，因为第i-1天是冷冻期。</p><ul><li>dp[i][1]第i天持有股票状态<ul><li>第i-2天卖出股票，第i-1天是冷冻期，第i天买入股票：dp[i][1]=dp[i-2][0]-prices[i]</li><li>第i-1天有股票，第i天没有卖出：dp[i][1]=dp[i-1][1]<br>最终dp[i][1]从以上2种情况选最大的作为最终利润 </li></ul></li></ul><p>对dp进行初始化</p><ul><li>第一天，dp[0][0]表示持有现金，则最大利润为0，dp[0][0]=0</li><li>dp[0][1]表示第一天持有股票，则最大利润为dp[0][1]=-prices[0]</li><li>dp[1][0]表示第2天持有现金，有2种可能：（1）昨天也是持有现金dp[0][0],（2）昨天持有股票，今天卖了，dp[0][1]+prices[1]</li><li>dp[1][1]表示第2天持有股票，有2种情况：（1）昨天也持有股票dp[0][1]，（2）昨天持有现金，今天买了股票dp[0][0]-prices[1]</li></ul><p>最终返回的结果是最后一天的最大利润，最后一天手里不能有任何股票，全都卖出，即dp[-1][0]</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxProfit</span><span class="params">(self, prices)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type prices: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        n = len(prices)</span><br><span class="line">        <span class="keyword">if</span> n&lt;=<span class="number">1</span>:<span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        dp = [[<span class="number">0</span>,<span class="number">0</span>] <span class="keyword">for</span> i <span class="keyword">in</span> range(n)]</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">0</span></span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">1</span>]=-prices[<span class="number">0</span>]</span><br><span class="line">        dp[<span class="number">1</span>][<span class="number">0</span>]=max(dp[<span class="number">0</span>][<span class="number">0</span>],dp[<span class="number">0</span>][<span class="number">1</span>]+prices[<span class="number">1</span>])</span><br><span class="line">        dp[<span class="number">1</span>][<span class="number">1</span>]=max(dp[<span class="number">0</span>][<span class="number">1</span>],dp[<span class="number">0</span>][<span class="number">0</span>]-prices[<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>,n):</span><br><span class="line">            dp[i][<span class="number">0</span>]=max(dp[i<span class="number">-1</span>][<span class="number">0</span>],dp[i<span class="number">-1</span>][<span class="number">1</span>]+prices[i])</span><br><span class="line">            dp[i][<span class="number">1</span>]=max(dp[i<span class="number">-1</span>][<span class="number">1</span>],dp[i<span class="number">-2</span>][<span class="number">0</span>]-prices[i])</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">-1</span>][<span class="number">0</span>]</span><br></pre></td></tr></table></figure><h2><span id="56-买卖股票的最佳时机含手续费">5.6. 买卖股票的最佳时机含手续费</span></h2><p>给定一个整数数组 prices，其中第 i 个元素代表了第 i 天的股票价格 ；非负整数 fee 代表了交易股票的手续费用。</p><p>你可以无限次地完成交易，但是你每笔交易都需要付手续费。如果你已经购买了一个股票，在卖出它之前你就不能再继续购买股票了。</p><p>返回获得利润的最大值。</p><p>注意：这里的一笔交易指买入持有并卖出股票的整个过程，每笔交易你只需要为支付一次手续费。</p><p>链接：<a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with" target="_blank" rel="noopener">https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with</a></p><p><strong>【分析】</strong><br>这道题在leetcode122的基础上改进，每卖出一个股票就要支付手续费。</p><p>定义dp，使用二维矩阵<br>dp[i][j]:第一维dp[i]表示前i天能获得的最大利润，第二维dp[i][j]表示在第i天手里有没有股票，dp[i][0]表示没有股票，手里持有现金时的最大利润，dp[i][1]表示持有股票的最大利润<br>第一天，dp[0][0]表示持有现金，则最大利润为0，dp[0][0]=0；dp[0][1]表示持有股票，则最大利润为dp[0][1]=-prices[0]。<br>对于dp[i][0]和dp[i][1]的状态转移需要分情况讨论</p><ul><li><p>dp[i][0]第i天持有现金状态</p><ul><li>第i-1天持有股票，第i天卖出股票：dp[i][0]=dp[i-1][1]+prices[i]-fee</li><li>第i-1天没有股票，第i天也没有股票：dp[i][0]=dp[i-1][0]<br>最终dp[i][0]从以上2种情况选最大的作为最终利润 </li></ul></li><li><p>dp[i][1]第i天持有股票状态</p><ul><li>第i-1天没有股票，第i天买入股票：dp[i][1]=dp[i-1][0]-prices[i]</li><li>第i-1天有股票，第i天没有卖出：dp[i][1]=dp[i-1][1]<br>最终dp[i][1]从以上2种情况选最大的作为最终利润 </li></ul></li></ul><p>最终返回的结果是最后一天的最大利润，最后一天手里不能有任何股票，全都卖出，即dp[-1][0]</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxProfit</span><span class="params">(self, prices, fee)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type prices: List[int]</span></span><br><span class="line"><span class="string">        :type fee: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        n = len(prices)</span><br><span class="line">        <span class="keyword">if</span> n==<span class="number">0</span>:<span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        dp = [[<span class="number">0</span>,<span class="number">0</span>] <span class="keyword">for</span> i <span class="keyword">in</span> range(n)]</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">0</span></span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">1</span>]=-prices[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,n):</span><br><span class="line">            dp[i][<span class="number">0</span>]=max(dp[i<span class="number">-1</span>][<span class="number">0</span>],dp[i<span class="number">-1</span>][<span class="number">1</span>]+prices[i]-fee)</span><br><span class="line">            dp[i][<span class="number">1</span>]=max(dp[i<span class="number">-1</span>][<span class="number">1</span>],dp[i<span class="number">-1</span>][<span class="number">0</span>]-prices[i])</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">-1</span>][<span class="number">0</span>]</span><br></pre></td></tr></table></figure><h2><span id="57-总结">5.7. 总结</span></h2><p>对以上6个问题做一个分类</p><ul><li>Leetcode121：只交易一次（k=1，贪心或DP）</li><li>Leetcode122：不限交易次数（k=inf，贪心或二维DP）<ul><li>Leetcode309：不限交易次数（k=inf），但有冷冻期的条件</li><li>Leetcode714：不限交易次数（k=inf），但有手续费的条件</li></ul></li><li>Leetcode188：最多交易k次（三维DP）<ul><li>Leetcode123：最多交易2次（k=2，三维DP）</li></ul></li></ul><h1><span id="6-打家劫舍">6. 打家劫舍</span></h1><h2><span id="61-打家劫舍-i">6.1. 打家劫舍 I</span></h2><p>你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。</p><p>给定一个代表每个房屋存放金额的非负整数数组，计算你 不触动警报装置的情况下 ，一夜之内能够偷窃到的最高金额。</p><p>链接：<a href="https://leetcode-cn.com/problems/house-robber" target="_blank" rel="noopener">https://leetcode-cn.com/problems/house-robber</a></p><p>输入：[1,2,3,1]<br>输出：4<br>解释：偷窃 1 号房屋 (金额 = 1) ，然后偷窃 3 号房屋 (金额 = 3)。<br>     偷窃到的最高金额 = 1 + 3 = 4 。</p><p><strong>【分析一】</strong></p><p><code>dp[i]</code>表示在第i家的最大金额。<br>动态转移方程：<br><code>dp[i] = max(dp[i-2]+nums[i],dp[i-1])</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">rob</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> nums:<span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> len(nums)&lt;=<span class="number">2</span>:<span class="keyword">return</span> max(nums)</span><br><span class="line">        <span class="comment">#dp[i]表示偷到的i个房屋所获得的最大金额</span></span><br><span class="line">        dp = [<span class="number">0</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums))]</span><br><span class="line">        <span class="comment">#dp[i] = max(dp[i-2]+nums[i],dp[i-1])</span></span><br><span class="line">        dp[<span class="number">0</span>] = nums[<span class="number">0</span>]</span><br><span class="line">        dp[<span class="number">1</span>] = max(nums[<span class="number">0</span>],nums[<span class="number">1</span>])</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>,len(nums)):</span><br><span class="line">            dp[i] = max(dp[i<span class="number">-2</span>]+nums[i],dp[i<span class="number">-1</span>])</span><br><span class="line">        <span class="keyword">return</span> max(dp)</span><br></pre></td></tr></table></figure><p><strong>【优化】</strong></p><p>观察动态转移方程，dp[i]只和dp[i-2]和dp[i-1]有关，所以只用2个变量来保存这2个值就可以了，不用数组来保存。<br><code>dp[i] = max(dp[i-2]+nums[i],dp[i-1])</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> nums:<span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> len(nums)&lt;=<span class="number">2</span>:<span class="keyword">return</span> max(nums)</span><br><span class="line">        pre_pre = nums[<span class="number">0</span>]</span><br><span class="line">        pre = max(nums[<span class="number">0</span>],nums[<span class="number">1</span>])</span><br><span class="line">        max_res = <span class="number">0</span></span><br><span class="line">        cur = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>,len(nums)):</span><br><span class="line">            cur = max(pre_pre+nums[i],pre)</span><br><span class="line">            <span class="keyword">if</span> cur&gt;max_res:</span><br><span class="line">                max_res = cur</span><br><span class="line">            pre_pre = pre</span><br><span class="line">            pre = cur</span><br><span class="line">        <span class="keyword">return</span> max_res</span><br></pre></td></tr></table></figure><h2><span id="62-打家劫舍-ii">6.2. 打家劫舍 II</span></h2><p>你是一个专业的小偷，计划偷窃沿街的房屋，每间房内都藏有一定的现金。这个地方所有的房屋都围成一圈，这意味着第一个房屋和最后一个房屋是紧挨着的。同时，相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。</p><p>给定一个代表每个房屋存放金额的非负整数数组，计算你在不触动警报装置的情况下，能够偷窃到的最高金额。</p><p>示例 1:</p><p>输入: [2,3,2]<br>输出: 3<br>解释: 你不能先偷窃 1 号房屋（金额 = 2），然后偷窃 3 号房屋（金额 = 2）, 因为他们是相邻的。</p><p>链接：<a href="https://leetcode-cn.com/problems/house-robber-ii" target="_blank" rel="noopener">https://leetcode-cn.com/problems/house-robber-ii</a></p><p>【注】这道题和上一题的区别是：屋子围成环形，第一个房子和最后一个房子相邻</p><p>将环形问题变成单排问题来解决.第一间房子和最后一间房子相邻，有以下3种偷窃情况:</p><ol><li>偷第一间房子，不偷最后一间房子</li><li>不偷第一间房子，偷最后一间房子</li><li>2间房子都不偷<br>综合以上3种情况，可以总结为情况1和情况2，因为房子金额为非负数，多偷一间房子的钱肯定&gt;=不偷</li></ol><p>则环形房子偷的最大金额是情况1和情况2的最大值。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">rob</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">sub_rob</span><span class="params">(nums)</span>:</span></span><br><span class="line">            pre_pre = nums[<span class="number">0</span>]</span><br><span class="line">            pre = max(nums[<span class="number">0</span>],nums[<span class="number">1</span>])</span><br><span class="line">            res_max = max(pre_pre,pre)</span><br><span class="line">            cur = <span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>,len(nums)):</span><br><span class="line">                cur = max(pre_pre+nums[i],pre)</span><br><span class="line">                <span class="keyword">if</span> cur&gt;res_max:</span><br><span class="line">                    res_max = cur</span><br><span class="line">                pre_pre = pre</span><br><span class="line">                pre = cur</span><br><span class="line">            <span class="keyword">return</span> res_max</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> nums:<span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> len(nums)&lt;=<span class="number">2</span>:<span class="keyword">return</span> max(nums)</span><br><span class="line">        n = len(nums)</span><br><span class="line">        <span class="keyword">return</span> max(sub_rob(nums[<span class="number">0</span>:n<span class="number">-1</span>]),sub_rob(nums[<span class="number">1</span>:n]))</span><br></pre></td></tr></table></figure><h2><span id="63-打家劫舍iii">6.3. 打家劫舍III</span></h2><p>在上次打劫完一条街道之后和一圈房屋后，小偷又发现了一个新的可行窃的地区。这个地区只有一个入口，我们称之为“根”。 除了“根”之外，每栋房子有且只有一个“父“房子与之相连。一番侦察之后，聪明的小偷意识到“这个地方的所有房屋的排列类似于一棵二叉树”。 如果两个直接相连的房子在同一天晚上被打劫，房屋将自动报警。</p><p>计算在不触动警报的情况下，小偷一晚能够盗取的最高金额。</p><p>链接：<a href="https://leetcode-cn.com/problems/house-robber-iii" target="_blank" rel="noopener">https://leetcode-cn.com/problems/house-robber-iii</a></p><p><img src="/2020/06/06/Leetcode之动态规划/1.png" alt=""></p><p><strong>【分析一】</strong></p><p>这道题考察的是怎么在二叉树上进行动态规划。<br>每个节点有2个孩子。根节点称为爷爷，有2个儿子，有4个孙子。相邻节点不能同时偷的意思是爷爷偷了，那儿子就不能偷，但是孙子可以偷。那最大金额=爷爷的钱+4个孙子的钱 VS 2个儿子的钱，看哪个组合多</p><p>使用递归，但是这种方法超时。因为递归会重复计算。比如在计算2个儿子的最大金额时，当这2个儿子称为爷爷时又会重新计算一遍孙子的金额。</p><p>注意：递归需要从树的下面往上看，在叶子节点的金额是最少的，儿子的金额比孙子多，爷爷的金额比儿子多。可能会有这样的疑问：既然不能相邻的节点连续偷，那可以左孩子偷的钱+右孩子的2个孩子偷的钱。其实这种情况已经被2个儿子偷考虑进去了，因为左孩子+2个孙子 《 2个儿子</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">rob</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type root: TreeNode</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:<span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        root_money = root.val</span><br><span class="line">        method1 = root_money<span class="comment">#爷爷加上4个孙子的钱</span></span><br><span class="line">        method2 = <span class="number">0</span><span class="comment">#2个孩子的钱</span></span><br><span class="line">        <span class="keyword">if</span> root.left:</span><br><span class="line">            method1+=(self.rob(root.left.left)+self.rob(root.left.right))</span><br><span class="line">        <span class="keyword">if</span> root.right:</span><br><span class="line">            method1+=(self.rob(root.right.left)+self.rob(root.right.right))</span><br><span class="line">        method2 = self.rob(root.left)+self.rob(root.right)</span><br><span class="line">        <span class="keyword">return</span> max(method1,method2)</span><br></pre></td></tr></table></figure><p><strong>【分析二】</strong></p><p>为了解决上述重复计算的问题，使用空间换时间的方法，将已经计算的金额保存起来。二叉树不适合使用数组来当缓存，使用哈希表存储，节点作为key，当前节点的最大金额为value</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode(object):</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">rob</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type root: TreeNode</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">sub_rob</span><span class="params">(root,max_val)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> root:<span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">            <span class="keyword">if</span> root <span class="keyword">in</span> max_val:<span class="keyword">return</span> max_val[root]</span><br><span class="line">            </span><br><span class="line">            method1 = root.val<span class="comment">#爷爷加上4个孙子的钱</span></span><br><span class="line">            <span class="keyword">if</span> root.left:</span><br><span class="line">                method1+=(sub_rob(root.left.left,max_val)+sub_rob(root.left.right,max_val))</span><br><span class="line">            <span class="keyword">if</span> root.right:</span><br><span class="line">                method1+=(sub_rob(root.right.left,max_val)+sub_rob(root.right.right,max_val))</span><br><span class="line">            method2 = sub_rob(root.left,max_val)+sub_rob(root.right,max_val)</span><br><span class="line">            max_val[root] = max(method1,method2)</span><br><span class="line">            <span class="keyword">return</span> max_val[root]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:<span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        max_val = dict()</span><br><span class="line">        <span class="keyword">return</span> sub_rob(root,max_val)</span><br></pre></td></tr></table></figure><p><strong>【分析三】</strong></p><p>参照买股票问题，每个节点都有2种状态：偷和不偷。dp使用二维数据组，</p><ul><li>dp[i][0]：节点i不偷时的最大金额。节点i不偷，那i.left和i.right可以偷也可以不偷。则<code>dp[i][0] = max(dp[i.left][1],dp[i.left][0]) + max(dp[i.right][1],dp[i.right][0])</code></li><li>dp[i][1]：节点i偷时的最大金额。节点i偷，那i.left和i.right只能选择不偷，则<code>dp[i][1] = dp[i.left][0]+dp[i.right][0]+i.val</code></li><li>空间优化：由于在计算dp[i]时，只需要dp[i.left]和dp[i.right]的信息，所以不需要使用dp[][]二维数组。只需要3个一维数组，left[0]和left[1]表示左节点偷和不偷的最大金额，right[0]和right[1]表示右节点偷和不偷的最大金额。root[0]和root[1]表示根节点</li><li>初始化</li><li>返回结果：输出根节点中2个状态的最大值</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">rob</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type root: TreeNode</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">sub_rob</span><span class="params">(root)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> root:<span class="keyword">return</span> [<span class="number">0</span>,<span class="number">0</span>]</span><br><span class="line">            left = sub_rob(root.left)</span><br><span class="line">            right = sub_rob(root.right)</span><br><span class="line"></span><br><span class="line">            root_val = [<span class="number">0</span>,<span class="number">0</span>]<span class="comment">#根节点2种状态的最大金额</span></span><br><span class="line">            root_val[<span class="number">0</span>] = max(left[<span class="number">0</span>],left[<span class="number">1</span>])+max(right[<span class="number">0</span>],right[<span class="number">1</span>])</span><br><span class="line">            root_val[<span class="number">1</span>] = left[<span class="number">0</span>]+right[<span class="number">0</span>]+root.val</span><br><span class="line">            <span class="keyword">return</span> root_val</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:<span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        root_val = sub_rob(root)</span><br><span class="line">        <span class="keyword">return</span> max(root_val)</span><br></pre></td></tr></table></figure><h2><span id="64-总结">6.4. 总结</span></h2><p>第一题是单排动态规划问题<br>第二题是环形动态规划问题，可以转换为多个单排问题解决，然后求多个单排问题的最大值<br>第三题是树形动态规划问题，使用递归解决</p><h1><span id="7-最长回文子串">7. 最长回文子串</span></h1><p>给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为 1000。</p><p>示例 1：</p><p>输入: “babad”<br>输出: “bab”<br>注意: “aba” 也是一个有效答案。</p><p>链接：<a href="https://leetcode-cn.com/problems/longest-palindromic-substring" target="_blank" rel="noopener">https://leetcode-cn.com/problems/longest-palindromic-substring</a></p><p><strong>【分析一】</strong></p><p>暴力求解</p><p>先以第一个字符为头，找长度为2,3，。。。的字符串中是否是回文字符串，使用res_str记录下来。然后以第二个字符为头，找长度为2,3，。。。的字符串中是否是回文字符串。。。</p><p>但是这种方法超时</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">longestPalindrome</span><span class="params">(self, s)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type s: str</span></span><br><span class="line"><span class="string">        :rtype: str</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="comment">#暴力求解</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> s:<span class="keyword">return</span> <span class="string">''</span></span><br><span class="line">        <span class="keyword">if</span> len(s)==<span class="number">1</span>:<span class="keyword">return</span> s</span><br><span class="line">        n = len(s)</span><br><span class="line">        res_len = <span class="number">0</span><span class="comment">#当前回文子串的最长长度</span></span><br><span class="line">        res_str = <span class="string">''</span><span class="comment">#当前最长的回文串</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">#以第一个字符为头，长度为2,3，。。。的字符串中是否是回文字符串，使用res_str记录下来</span></span><br><span class="line">        <span class="comment">#然后以第二个字符为头，找长度为2,3，。。。的字符串中是否是回文字符串。。。</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>,n<span class="number">-1</span>):<span class="comment">#当前开始遍历的字符下标</span></span><br><span class="line">            <span class="keyword">for</span> cur_len <span class="keyword">in</span> range(<span class="number">2</span>,n-i+<span class="number">1</span>):<span class="comment">#字符串的长度</span></span><br><span class="line">                cur_str = s[i:i+cur_len]</span><br><span class="line">                <span class="keyword">if</span> cur_str == cur_str[::<span class="number">-1</span>]:</span><br><span class="line">                    <span class="keyword">if</span> cur_len&gt;res_len:</span><br><span class="line">                        res_len = cur_len</span><br><span class="line">                        res_str = cur_str</span><br><span class="line">        <span class="keyword">return</span> s[<span class="number">0</span>] <span class="keyword">if</span> res_str==<span class="string">''</span> <span class="keyword">else</span> res_str</span><br></pre></td></tr></table></figure><p><strong>【分析二】</strong></p><p>动态规划的关键就是找出什么是状态和状态转移方程，<br>我们先看问题：找出最长的回文子串</p><ul><li>一个回文串去掉2个头后，剩下的依然是回文串</li><li>如果一个字符串的头尾2个字符不相等，一定不是回文串</li><li>如果一个字符串的头尾2个字符相等，才有必要继续判断下去：<ul><li>如果里面的子串是回文，则整个字符串就是回文</li><li>如果里面的子串不是回文，则整个字符串不是回文</li></ul></li></ul><ol><li>定义状态<br><code>dp[i][j]</code>表示子串s[i..j]是否是回文串。因此dp[][]是bool类型的值。这里的s[i…j]是左闭右闭区间，包括s[i]和s[j]</li><li><p>状态转移方程<br><code>dp[i][j] = (s[i]==s[j]) and dp[i+1][j-1]</code></p><ul><li>这里的<code>i&lt;=j</code>，因此只用填二维表的对角线和对角线以上的部分就可以了。</li><li><code>dp[i+1][j-1]</code>，s[i+1..j-1]中至少有1个元素，即<code>j-1-(i+1)&gt;=1</code>,可得出<code>j-i&gt;=3</code></li><li>因此当<code>j-i&gt;=3</code>时才可以使用动态转移方程。当<code>j-i&lt;3</code>时，就可以当做特殊情况单独处理。<code>j-i可以是0,1,2</code>，即子串长度分为<code>1,2,3</code>，当子串长度为1时肯定是回文，当子串长度为2和3时，如果<code>s[i]==s[j]</code>，那肯定也是回文。因此在<code>s[i]==s[j] and j-i&lt;3</code>时，可以直接下结论<code>dp[i][j]=True</code>,否则才进行状态转移。</li></ul></li><li>初始化<br>初始化时，单个字符串一定是回文，因此对角线先初始化为True，即<code>dp[i][i]=True</code></li><li>返回值<br>只要一得到<code>dp[i][j]=True</code>，即记录子串的长度和起始位置。</li><li>考虑优化空间<br>在填表的过程中，dp[i][j]只和dp[i+1][j-1]有关，即和左下放的表格有关，因此是可以优化的，但是优化后可读性就会变差，这里就不优化了。</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">longestPalindrome</span><span class="params">(self, s)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type s: str</span></span><br><span class="line"><span class="string">        :rtype: str</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="comment">#暴力求解</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> s:<span class="keyword">return</span> <span class="string">''</span></span><br><span class="line">        <span class="keyword">if</span> len(s)==<span class="number">1</span>:<span class="keyword">return</span> s</span><br><span class="line">        n = len(s)</span><br><span class="line">        dp = [[<span class="keyword">False</span> <span class="keyword">for</span> _ <span class="keyword">in</span> range(n)] <span class="keyword">for</span> _ <span class="keyword">in</span> range(n)]</span><br><span class="line">        </span><br><span class="line">        <span class="comment">#回文串的长度，不能为0，比如"ac"不是回文字</span></span><br><span class="line">        <span class="comment">#符串，但是只有1个字符'a'或'c'是回文字符串，</span></span><br><span class="line">        <span class="comment">#因此回文字符串的长度最小也是1</span></span><br><span class="line">        res_len = <span class="number">1</span></span><br><span class="line">        start = <span class="number">0</span><span class="comment">#回文串开始的下标</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">#初始化对角线为True</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">            dp[i][i] = <span class="keyword">True</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>,n):</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>,j):<span class="comment">#这里i取不到j，如果i取到j，则dp[i][j]就是对角线上的值，在前面已经赋值过了 </span></span><br><span class="line">                <span class="keyword">if</span> s[i] == s[j]:</span><br><span class="line">                    <span class="keyword">if</span> j - i &lt;<span class="number">3</span>:<span class="comment">#2&lt;=子串长度&lt;=3,子串长度为2或3时，通过头尾的字符可以直接判断</span></span><br><span class="line">                        dp[i][j] = <span class="keyword">True</span></span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        <span class="comment">#2层for循环，必须是j在外循环，i在内循环</span></span><br><span class="line">                        <span class="comment">#因此dp[i][j]和dp[i+1][j-1]有关，如果i在外循环</span></span><br><span class="line">                        <span class="comment">#在遍历dp[i][:]的时候，并不知道dp[i+1][:]的值</span></span><br><span class="line">                        <span class="comment">#而如果j在外循环时，dp[:][j]可以知道dp[:][j-1]的值</span></span><br><span class="line">                        dp[i][j] = dp[i+<span class="number">1</span>][j<span class="number">-1</span>]</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    dp[i][j] = <span class="keyword">False</span></span><br><span class="line">                </span><br><span class="line">                <span class="keyword">if</span> dp[i][j]:</span><br><span class="line">                    <span class="keyword">if</span> j-i+<span class="number">1</span>&gt;res_len:</span><br><span class="line">                        res_len = j-i+<span class="number">1</span></span><br><span class="line">                        start = i</span><br><span class="line">        <span class="keyword">return</span> s[start:start+res_len]</span><br></pre></td></tr></table></figure><ul><li>时间复杂度：O(n^2)</li><li>空间复杂度：O(n^2)</li></ul><p><strong>【分析三】</strong></p><p>中心扩散法：枚举可能出现的回文子串的中心位置，从中心位置尝试尽可能扩散出去，得到一个回文串。</p><p>中心扩散法的思路是：遍历每个字符，以这个字符为中心，利用回文串左右对称的特征，向两边扩散，看最多能扩散多远。<br>枚举中心位置的时间复杂度是O(N)，从中心扩散得到回文子串的时间复杂度为O(N)，因此时间复杂度为O(N^2)</p><p>注意：回文串的长度为奇数和偶数时，中心不一样</p><ul><li>当回文串长度为奇数时，中心是中间的具体字符，例如<code>bab</code>,中心为<code>a</code></li><li>当回文串长度为偶数时，中心是中间2个字符的空隙，例如<code>baab</code>的中心是2个<code>a</code>中间的空隙</li></ul><p><img src="/2020/06/06/Leetcode之动态规划/2.png" alt=""></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">longestPalindrome</span><span class="params">(self, s)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type s: str</span></span><br><span class="line"><span class="string">        :rtype: str</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="comment">#暴力求解</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> s:<span class="keyword">return</span> <span class="string">''</span></span><br><span class="line">        <span class="keyword">if</span> len(s)==<span class="number">1</span>:<span class="keyword">return</span> s</span><br><span class="line">        n = len(s)</span><br><span class="line"></span><br><span class="line">        res_len = <span class="number">1</span><span class="comment">#回文串的长度，不能为0，比如"ac"不是回文字符串，但是只有1个字符'a'或'c'是回文字符串，因此回文字符串的长度最小也是1</span></span><br><span class="line">        res_max = s[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n):<span class="comment">#遍历中心节点</span></span><br><span class="line">            str_odd,len_odd = self.center_spread(s,i,i)</span><br><span class="line">            str_even,len_even = self.center_spread(s,i,i+<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">            <span class="comment">#找到当前的最长回文子串,首先求出奇偶长度的最大值</span></span><br><span class="line">            <span class="comment">#然后看这个最大值和当前的res_len比较</span></span><br><span class="line">            tmp_len = len_odd <span class="keyword">if</span> len_odd&gt;len_even <span class="keyword">else</span> len_even</span><br><span class="line">            tmp_res = str_odd <span class="keyword">if</span> tmp_len%<span class="number">2</span>==<span class="number">1</span> <span class="keyword">else</span> str_even</span><br><span class="line">            <span class="keyword">if</span> tmp_len&gt;res_len:</span><br><span class="line">                res_len = tmp_len</span><br><span class="line">                res_max = tmp_res</span><br><span class="line">        <span class="keyword">return</span> res_max</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">center_spread</span><span class="params">(self,s,left,right)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        left,right为中心位置</span></span><br><span class="line"><span class="string">        如果left==right，说明之后找到的回文串长度为奇数</span></span><br><span class="line"><span class="string">        如果left+1=right，说明之后找到的回文串长度为偶数</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        i,j = left,right</span><br><span class="line">        n = len(s)</span><br><span class="line">        <span class="comment">#babad举例，第2个b为中心位</span></span><br><span class="line">        <span class="keyword">while</span> i&gt;=<span class="number">0</span> <span class="keyword">and</span> j&lt;n <span class="keyword">and</span> s[i] == s[j]:</span><br><span class="line">            i-=<span class="number">1</span></span><br><span class="line">            j+=<span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> s[i+<span class="number">1</span>:j],j-i+<span class="number">1</span></span><br></pre></td></tr></table></figure><h1><span id="8-回文子串">8. 回文子串</span></h1><p>给定一个字符串，你的任务是计算这个字符串中有多少个回文子串。</p><p>具有不同开始位置或结束位置的子串，即使是由相同的字符组成，也会被计为是不同的子串。</p><p>示例 1:<br>输入: “abc”<br>输出: 3<br>解释: 三个回文子串: “a”, “b”, “c”.</p><p>链接：<a href="https://leetcode-cn.com/problems/palindromic-substrings" target="_blank" rel="noopener">https://leetcode-cn.com/problems/palindromic-substrings</a></p><p>【分析一】</p><p>参考上一题，使用dp[i][j]来记录s[i]…s[j]是否为回文串，<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">countSubstrings</span><span class="params">(self, s)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type s: str</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="comment">#dp[i][j] = (s[i]==s[j]) and dp[i+1][j-1]</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> s:<span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> len(s)==<span class="number">1</span>:<span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        n = len(s)</span><br><span class="line">        dp = [[<span class="keyword">False</span> <span class="keyword">for</span> _ <span class="keyword">in</span> range(n)] <span class="keyword">for</span> _ <span class="keyword">in</span> range(n)]</span><br><span class="line">        count = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">            dp[i][i] = <span class="keyword">True</span></span><br><span class="line">            count+=<span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">#j&gt;=i</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>,n):</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>,j):</span><br><span class="line">                <span class="keyword">if</span> s[i]==s[j]:</span><br><span class="line">                    <span class="keyword">if</span> j-i&lt;<span class="number">3</span>:</span><br><span class="line">                        dp[i][j] = <span class="keyword">True</span></span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        dp[i][j] = dp[i+<span class="number">1</span>][j<span class="number">-1</span>]</span><br><span class="line">                <span class="keyword">if</span> dp[i][j]:</span><br><span class="line">                    count+=<span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> count</span><br></pre></td></tr></table></figure></p><h1><span id="9-背包问题">9. 背包问题</span></h1><ol><li>0-1背包问题<br>每个物品最多只能放一次</li><li>完全背包问题<br>每个物品可以放无限次</li><li>多重背包问题<br>每个物品有一个固定的次数上限</li><li>混合三种背包问题<br>将前面三种简单问题叠加成复杂的问题</li><li>二维费用的背包问题<br>背包有体积和重量2个维度的限制</li><li>分组背包问题<br>将物品分组，每组最多只能选一件</li><li>背包问题求方案数</li><li>求背包问题的方案</li><li>有依赖的背包问题</li></ol><h2><span id="91-0-1背包问题">9.1. 0-1背包问题</span></h2><p>0-1背包问题：给定背包体积$V$，n个物品的体积$v_i$和价值$w_i$，每个物品只能拿一次，求所拿的最大价值。</p><p>输入格式<br>第一行两个整数，N，V，用空格隔开，分别表示物品数量和背包容积。</p><p>接下来有 N 行，每行两个整数 $v_i$,$w_i$，用空格隔开，分别表示第 i 件物品的体积和价值。</p><p>输出格式<br>输出一个整数，表示最大价值。</p><p>数据范围<br>$0&lt;N,V≤1000$<br>$0&lt;v_i,w_i≤1000$</p><blockquote><p>输入样例<br>4 5<br>1 2<br>2 4<br>3 4<br>4 5</p><p>输出样例：<br>8</p></blockquote><p><strong>定义状态</strong><br><code>f[i][j]</code>表示只看前i个物品(1&lt;=i&lt;=n,只知道前i个物品，并不是把前i个物品都放在包中)，背包容量为j的情况下，能拿到的最大价值。<br>最终求的值是<code>f[N][V]</code>，知道前N个物品，背包容量为V的最大价值。<br>看一下f[i][j]怎么算，假设前i-1个物品都考虑完了，现在考虑第i个物品，第i个物品有2种选择：放包里和不放包里。</p><ul><li>放包里：则前i-1个物品能够用的空间为$j-v_i$，$f[i][j]=f[i-1][j-v_i]+w_i$</li><li>不放包里：$f[i][j]=f[i-1][j]$<br>则$f[i][j]=max\{f[i-1][j],f[i-1][j-v_i]+w_i\}$</li></ul><p><strong>初始化</strong><br><code>f[][]</code>全都初始化为0，其中包括：<br><code>f[0][0~V]</code>：物体个数为0<br><code>f[1~N][0]</code>：背包容量为0</p><ul><li>时间复杂度：O(NV)，N为物品个数，V为背包体积</li><li>空间复杂度：O(NV)</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">package</span><span class="params">(V,N,volume,value)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    V：背包的容量</span></span><br><span class="line"><span class="string">    N：物体的个数</span></span><br><span class="line"><span class="string">    volume：N个物体的体积</span></span><br><span class="line"><span class="string">    value：N个物体的价值</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="comment">#f[i][j]:前i个物体，背包容量为j的最大价值</span></span><br><span class="line">    f = [[<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> range(V+<span class="number">1</span>)] <span class="keyword">for</span> _ <span class="keyword">in</span> range(N+<span class="number">1</span>)]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,N+<span class="number">1</span>):<span class="comment">#遍历每个物体</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>,V+<span class="number">1</span>):<span class="comment">#遍历每个体积</span></span><br><span class="line">            <span class="keyword">if</span> volume[i]&gt;j:</span><br><span class="line">                f[i][j] = f[i<span class="number">-1</span>][j]</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                f[i][j] = max(f[i<span class="number">-1</span>][j],f[i<span class="number">-1</span>][j-volume[i]]+value[i])</span><br><span class="line">    print(f[N][V])</span><br><span class="line">    </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    <span class="comment">#读取输入数据</span></span><br><span class="line">    <span class="comment">#N：物品个数、V：背包体积</span></span><br><span class="line">    N,V = map(int,input().split())</span><br><span class="line">    volume,value = [<span class="number">0</span>,],[<span class="number">0</span>,]<span class="comment">#体积、价值</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(N):</span><br><span class="line">        volume_i,value_i = map(int,input().split())</span><br><span class="line">        volume.append(volume_i)</span><br><span class="line">        value.append(value_i)</span><br><span class="line">    package(V,N,volume,value)</span><br></pre></td></tr></table></figure><p><strong>【优化】</strong><br>发现<code>f[i][j]</code>只和<code>f[i-1]</code>的值有关<br>$f[i][j]=max\{f[i-1][j],f[i-1][j-v_i]+w_i\}$<br>所以不需要使用二维数组，使用一维数组就可以了，状态转移方程变成<br>$f[j]=max\{f[j],f[j-v_i]+w_i\}$<br>第二重for循环时，体积遍历从大到小遍历，这样在进行第i个循环时，计算$f[j]$时用到的$f[j]$和$f[j-v_i]$用到的都是上一个循环i-1的值。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">package</span><span class="params">(V,N,volume,value)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    V：背包的容量</span></span><br><span class="line"><span class="string">    N：物体的个数</span></span><br><span class="line"><span class="string">    volume：N个物体的体积</span></span><br><span class="line"><span class="string">    value：N个物体的价值</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="comment">#f[j]:只看前i个物体，背包容量为j的最大价值</span></span><br><span class="line">    f = [<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> range(V+<span class="number">1</span>)]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,N+<span class="number">1</span>):<span class="comment">#遍历每个物体</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(V,volume[i]+<span class="number">1</span>,<span class="number">-1</span>):<span class="comment">#遍历每个体积</span></span><br><span class="line">                <span class="comment">#第一个f[j]表示前i个物体，容量为j的最大价值</span></span><br><span class="line">                <span class="comment">#第二个f[j]表示前i-1个物体，容量为j的最大价值</span></span><br><span class="line">                f[j] = max(f[j],f[j-volume[i]]+value[i])</span><br><span class="line">    print(f[V])</span><br><span class="line">    </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    <span class="comment">#读取输入数据</span></span><br><span class="line">    <span class="comment">#N：物品个数、V：背包体积</span></span><br><span class="line">    N,V = map(int,input().split())</span><br><span class="line">    volume,value = [<span class="number">0</span>,],[<span class="number">0</span>,]<span class="comment">#体积、价值</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(N):</span><br><span class="line">        volume_i,value_i = map(int,input().split())</span><br><span class="line">        volume.append(volume_i)</span><br><span class="line">        value.append(value_i)</span><br><span class="line">    package(V,N,volume,value)</span><br></pre></td></tr></table></figure><h2><span id="92-背包初始化问题">9.2. 背包初始化问题</span></h2><p>上一题没有要求把背包装满，但是有的问题可能要求“恰好装满背包的最优解”。注意这2种问法在初始化的时候有所不同。</p><ul><li>恰好装满背包。只有f[0]=0，其余f[1~V]全都初始化为$-\infty$</li><li>没有要求背包装满，f[0~V]=0</li></ul><p>可以这样理解：初始化的f事实上就是在0个物体放入背包的状态。f[0]表示0个物体放入容量0的背包的最大价值，f[V]表示0个物体放入容量0的背包的最大价值。如果要求背包恰好装满，那么此时只有容量为0的背包才能被体积为0的物体恰好填满。$f[1,…V]$在物体个数为0时都不能被填满，即属于未定义的状态，那就初始化为$-\infty$。如果背包没有要求被填满，那任意一个背包容量都有一个合法解，$f[1,…V]$都不能被0个物体填满，所以$f[0,1,…V]$都可以初始化为0.</p><h2><span id="93-完全背包问题">9.3. 完全背包问题</span></h2><p>背包容量为V，有N个物体，体积为$v_i$，价值为$w_i$，每个物体可以被无限装入包中。求将哪些物体装入包中价值最大。</p><p>输入格式<br>第一行两个整数，N，V，用空格隔开，分别表示物品种数和背包容积。</p><p>接下来有 N 行，每行两个整数 $v_i,w_i$，用空格隔开，分别表示第 i 种物品的体积和价值。</p><p>输出格式<br>输出一个整数，表示最大价值。</p><p>数据范围<br>$0&lt;N,V≤1000$<br>$0&lt;v_i,w_i≤1000$</p><blockquote><p>输入样例<br>4 5<br>1 2<br>2 4<br>3 4<br>4 5</p><p>输出样例：<br>10</p></blockquote><p><strong>【分析一】</strong></p><p>每个物体可以选多次，则完全背包问题的二维状态转移方程变成</p><p>$f[i][j]=max\{f[i-1][j-k<em>v_i]+k</em>w_i \quad| \quad 0&lt;=k*v_i&lt;=j\}$</p><p>在考虑第i件物体时，可以放0,1,2,…k件，只要$0&lt;=k<em>v_i&lt;=j$，那前i-1件物体能用的背包容量为$j-k</em>v_i$。现在要做的就是在看k等于多少时，背包的价值最大。</p><p>以上使用的是二维数组，$f[i]$的值和$f[i-1]$的值有关系。现在考虑$f[i][j]$和本层的$f[i][0,…V]$有什么关系。<br>$f[i][j]$和$f[i][0,..V]$都有可能包含第i个物品，所以将问题转换成“每次添加一个物品i的状态转移”</p><ol><li>$f[i][j]$如果包含物品i，则$f[i][j-v_i]$中物品i的数量比$f[i][j]$少一个，此时$f[i][j]=f[i][j-v_i]+w_i$</li><li>如果f[i][j]不包含物品i，则$f[i][j]=f[i-1][j]$</li></ol><p>则完全背包的一维状态转移方程变成<br>$f[i][j]=max\{f[i-1][j],f[i][j-v_i]+w_i\}$</p><p>这个转移方程和0-1背包问题的转移方程$f[i][j]=max\{f[i-1][j],f[i-1][j-v_i]+w_i\}$类似。</p><blockquote><p>需要注意的是：<br>对于二维数组的0-1背包问题，第二层循环（遍历背包容量V）可以是正序，也可以逆序。对于一维数组的0-1背包问题，第二层循环必须逆序。<br>对于完全背包问题，无论是二维数组还是一维数组，第二层循环都必须是正序。</p></blockquote><p>完全背包的一维状态转移方程：<br>$f[j]=max\{f[j],f[j-v_i]+w_i\}$</p><p>在第二层for循环时，正序遍历V。在遍历第i个物品时，第一个$f[j]$表示$f[i][j]$，第二个$f[j]$表示上一个循环的最大价值，即$f[i-1][j]$，$f[j-v_i]+w_i$表示当前循环的最大价值，即$f[i][j-v_i]+w_i$。因为在计算f[j]的时候用到$f[j-v_i]$，因为容量是正序遍历，所有比j小的容量都已经被计算过，所以$f[j-v_i]$表示在考虑前i个物品时(包括第i个物品)，当背包容量为$j-v_i$时的最大价值,$f[j-v_i]$可能已经包含若干个第i个物品了。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">package</span><span class="params">(V,N,volume,value)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    V：背包的体积</span></span><br><span class="line"><span class="string">    N：物体的个数</span></span><br><span class="line"><span class="string">    volume：N个物体的体积</span></span><br><span class="line"><span class="string">    value：N个物体的价值</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    f = [<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> range(V+<span class="number">1</span>)]</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(N+<span class="number">1</span>):<span class="comment">#遍历每个物品</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>,V+<span class="number">1</span>):<span class="comment">#遍历每个体积</span></span><br><span class="line">            <span class="keyword">if</span> j &gt;= volume[i]:</span><br><span class="line">                f[j] = max(f[j],f[j-volume[i]]+value[i])</span><br><span class="line">    print(f[V])</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    N,V = map(int,input().split())</span><br><span class="line">    volume,value = [<span class="number">0</span>,],[<span class="number">0</span>,]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(N):</span><br><span class="line">        volume_tmp,value_tmp = map(int,input().split())</span><br><span class="line">        volume.append(volume_tmp)</span><br><span class="line">        value.append(value_tmp)</span><br><span class="line">    package(V,N,volume,value)</span><br></pre></td></tr></table></figure><h2><span id="94-多重背包问题">9.4. 多重背包问题</span></h2><p>背包容量为V，有N种物品，每种物品最多有$s_i$件，体积为$v_i$，价值为$w_i$。怎么装物品才能使背包价值最大。</p><p>输入格式<br>第一行两个整数，N，V，用空格隔开，分别表示物品种数和背包容积。</p><p>接下来有 N 行，每行三个整数 vi,wi,si，用空格隔开，分别表示第 i 种物品的体积、价值和数量。</p><p>输出格式<br>输出一个整数，表示最大价值。</p><p>数据范围<br>$0&lt;N,V≤100$<br>$0&lt;v_i,w_i,s_i≤100$</p><blockquote><p>输入样例<br>4 5<br>1 2 3<br>2 4 1<br>3 4 3<br>4 5 2</p><p>输出样例：<br>10</p></blockquote><p><strong>【分析一】</strong></p><p>多重背包是0-1背包的扩展，所以枚举体积的时候也是从大到小。<br>0-1背包问题每个物品只有2个选择：选和不选<br>多重背包问题每种物品有s+1中选择：选0个，选1个，选2个，….，选s个。<br>多重背包问题的二维状态转移方程为：<br>$f[i][j] = max\{f[i-1][j-k<em>v_i]+k</em>w_i\} \quad  0&lt;=k&lt;=s_i$</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">package</span><span class="params">(N,V,volume,value,s)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    N：N中物品</span></span><br><span class="line"><span class="string">    V：背包体积</span></span><br><span class="line"><span class="string">    volume：每种物品的体积</span></span><br><span class="line"><span class="string">    value：每种物品的价值</span></span><br><span class="line"><span class="string">    s：每种物品的数量</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    f =  [<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> range(V+<span class="number">1</span>)]</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,N+<span class="number">1</span>):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(V,<span class="number">0</span>,<span class="number">-1</span>):</span><br><span class="line">            <span class="keyword">for</span> k <span class="keyword">in</span> range(<span class="number">0</span>,s[i]+<span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> k * volume[i]&lt;=j:</span><br><span class="line">                    f[j] = max(f[j],f[j-k*volume[i]]+k*value[i])</span><br><span class="line">    print(f[V])</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    N,V = map(int,input().split())</span><br><span class="line">    volume,value,s = [<span class="number">0</span>,],[<span class="number">0</span>,],[<span class="number">0</span>,]</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(N):</span><br><span class="line">        volume_tmp,value_tmp,s_tmp = map(int,input().split())</span><br><span class="line">        volume.append(volume_tmp)</span><br><span class="line">        value.append(value_tmp)</span><br><span class="line">        s.append(s_tmp)</span><br><span class="line">    package(N,V,volume,value,s)</span><br></pre></td></tr></table></figure><h2><span id="95-二维背包问题">9.5. 二维背包问题</span></h2><p>背包容量为V，能承受的重量为M。<br>有N个物品，体积为$v_i$，重量为$m_i$，价值为$v_i$<br>每个物品只能用一次，求背包的最大价值。</p><p>输入格式<br>第一行两个整数，N,V,M，用空格隔开，分别表示物品件数、背包容积和背包可承受的最大重量。</p><p>接下来有 N 行，每行三个整数 $v_i,m_i,w_i$，用空格隔开，分别表示第 i 件物品的体积、重量和价值。</p><p>输出格式<br>输出一个整数，表示最大价值。</p><p>数据范围<br>$0&lt;N≤1000$<br>$0&lt;V,M≤100$<br>$0&lt;v_i,m_i≤100$<br>$0&lt;w_i≤1000$</p><blockquote><p>输入样例<br>4 5 6<br>1 2 3<br>2 4 4<br>3 4 5<br>4 5 6</p><p>输出样例：<br>8</p></blockquote><p><strong>【分析一】</strong></p><p>一个物品有2种代价：体积和重量。在定义状态的时候也需要加一维。<br><code>f[i][j][k]</code>表示前i件物品在体积为j，承重为k的包中获得的最大价值。状态转移方程为<br>$f[i][j][k] = max\{f[i-1][j][k],f[i-1][j-v_i][k-m_i]+w_i\}$</p><p>同0-1背包一样，对空间进行优化，将三维数据优化为二维数组。有3重for循环，第一层for遍历N，第二层for遍历体积V，第三层for遍历重量M。其中第二层和第三层是倒序遍历。</p><p>$f[j][k] = max\{f[j][k],f[j-v_i][k-m_i]+w_i\}$</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">package</span><span class="params">(N,M,V,volume,weight,value)</span>:</span></span><br><span class="line">    f = [[<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> range(M+<span class="number">1</span>)] <span class="keyword">for</span> _ <span class="keyword">in</span> range(V+<span class="number">1</span>)]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,N+<span class="number">1</span>):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(V,volume[i]<span class="number">-1</span>,<span class="number">-1</span>):</span><br><span class="line">            <span class="keyword">for</span> k <span class="keyword">in</span> range(M,weight[i]<span class="number">-1</span>,<span class="number">-1</span>):</span><br><span class="line">                f[j][k] = max(f[j][k],f[j-volume[i]][k-weight[i]]+value[i])</span><br><span class="line">    print(f[V][M])</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    N,V,M = map(int,input().split())</span><br><span class="line">    volume,weight,value = [<span class="number">0</span>,],[<span class="number">0</span>,],[<span class="number">0</span>,]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(N):</span><br><span class="line">        volume_tmp,weight_tmp,value_tmp = map(int,input().split())</span><br><span class="line">        volume.append(volume_tmp)</span><br><span class="line">        weight.append(weight_tmp)</span><br><span class="line">        value.append(value_tmp)</span><br><span class="line">    package(N,M,V,volume,weight,value)</span><br></pre></td></tr></table></figure><h2><span id="96-分割等和子集">9.6. 分割等和子集</span></h2><p>给定一个只包含正整数的非空数组，是否可以将这个数组分割成2个子集，使这2个子集的元素和相等，</p><p>注意:</p><p>每个数组中的元素不会超过 100<br>数组的大小不会超过 200</p><blockquote><p>示例 1:<br>输入: [1, 5, 11, 5]<br>输出: true<br>解释: 数组可以分割成 [1, 5, 5] 和 [11].</p></blockquote><p>链接：<a href="https://leetcode-cn.com/problems/partition-equal-subset-sum" target="_blank" rel="noopener">https://leetcode-cn.com/problems/partition-equal-subset-sum</a></p><p><strong>【分析一】</strong></p><p>这道题的等价替换：从一个数组中挑选一些元素，使得这些元素和是整个数组元素和的一半。前提是数组的和一定是偶数。<br>本题的原型是0-1背包问题，给定一个背包容量为sum/2，和N个物品，每个物品的体积为$v_i$，是否存在一种装法，恰好能装满背包。</p><ul><li>0-1背包问题选取物品的容量不能超过背包容量</li><li>本题选取的数字之和恰好等于规定和的一半。<br>这一点区别，决定了在初始化的时候，所有值应该初始化为False。<br>作为0-1背包问题，它的特点是：物品一个个的选，背包容量一点一点的加。</li></ul><p><strong>定义状态</strong></p><p><code>dp[i][j]</code>在前i个数中挑选一些正整数，使得元素和恰好为j。<code>dp[i][j]=True</code>，表示和恰好为j，<code>dp[i][j]=False</code>表示和不能恰好为j，小于j。<br>在考虑第i个数时，有2种选择</p><ul><li>不选第i个数nums[i]，则和是否恰好为j取决于上一阶段的状态，<code>dp[i][j] = dp[i-1][j]</code></li><li>选第i个数nums[i]，则<code>dp[i][j] = dp[i-1][j-nums[i]]</code></li></ul><p><strong>状态转移方程</strong></p><p><code>dp[i][j] = dp[i-1][j] or dp[i-1][j-nums[i]]</code></p><p>首先求nums的和，如果和为奇数，说明找不到一些元素使其元素和为总和的一半，直接返回false</p><p>这里的target为总和的一半，可以看做是背包的容量。<br>假设nums中有5个元素，则状态转移方程f中有5行，第一行表示从前1个数中挑选，第二行表示从前2个数中挑选。假设target=12，先初始化状态转移矩，初始化第一行，即只从前1个数中查找，假设nums[0]为5，则f[0][5] = True，表示5这个数恰好能把容量为5的背包填满。</p><p>然后遍历后面的几行。</p><ul><li>如果<code>nums[i]==j</code>，说明当前这个数就能把背包填满，则f[i][j]=True</li><li>如果<code>nums[i]&lt;j</code>，则当前nums[i]有2种选择：选或者不选。</li><li>否则<code>nums[i]&gt;j</code>，说明nums[i]一定不能选，则f[i][j]=f[i-1][j]</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">canPartition</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> len(nums)==<span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">        <span class="keyword">if</span> sum(nums)&amp;<span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">        n = len(nums)</span><br><span class="line">        target = sum(nums)&gt;&gt;<span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">#f[0~n-1][0~target]</span></span><br><span class="line">        </span><br><span class="line">        f = [[<span class="keyword">False</span> <span class="keyword">for</span> _ <span class="keyword">in</span> range(target+<span class="number">1</span>)] <span class="keyword">for</span> _ <span class="keyword">in</span> range(n)]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> nums[<span class="number">0</span>] &lt;= target:</span><br><span class="line">            f[<span class="number">0</span>][nums[<span class="number">0</span>]] = <span class="keyword">True</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">#写法1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,n):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">0</span>,target+<span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> nums[i] == j:</span><br><span class="line">                    f[i][j] = <span class="keyword">True</span></span><br><span class="line">                <span class="keyword">elif</span> nums[i] &lt; j:</span><br><span class="line">                    f[i][j] = f[i<span class="number">-1</span>][j-nums[i]] <span class="keyword">or</span> f[i<span class="number">-1</span>][j]</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    f[i][j] = f[i<span class="number">-1</span>][j]</span><br><span class="line">        <span class="comment">#写法2</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,n):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">0</span>,target+<span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> nums[i] &lt;= j:</span><br><span class="line">                    f[i][j] = f[i<span class="number">-1</span>][j-nums[i]] <span class="keyword">or</span> f[i<span class="number">-1</span>][j]</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    f[i][j] = f[i<span class="number">-1</span>][j]</span><br><span class="line">                    </span><br><span class="line">        <span class="keyword">return</span> f[n<span class="number">-1</span>][target]</span><br></pre></td></tr></table></figure><p><strong>【优化】</strong></p><p>参考0-1背包问题，将二维矩阵优化为一维矩阵</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">canPartition</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> len(nums)==<span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">        <span class="keyword">if</span> sum(nums)&amp;<span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">        n = len(nums)</span><br><span class="line">        target = sum(nums)&gt;&gt;<span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">#f[0~target]</span></span><br><span class="line">        f = [<span class="keyword">False</span> <span class="keyword">for</span> _ <span class="keyword">in</span> range(target+<span class="number">1</span>)]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> nums[<span class="number">0</span>] &lt;= target:</span><br><span class="line">            f[nums[<span class="number">0</span>]] = <span class="keyword">True</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,n):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(target,nums[i]<span class="number">-1</span>,<span class="number">-1</span>):</span><br><span class="line">                <span class="keyword">if</span> f[target]:<span class="comment">#提前剪枝</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">                f[j] = f[j-nums[i]] <span class="keyword">or</span> f[j]</span><br><span class="line">        <span class="keyword">return</span> f[target]</span><br></pre></td></tr></table></figure><h2><span id="97-一和零">9.7. 一和零</span></h2><p>在计算机界中，我们总是追求用有限的资源获取最大的收益。</p><p>现在，假设你分别支配着 m 个 0 和 n 个 1。另外，还有一个仅包含 0 和 1 字符串的数组。</p><p>你的任务是使用给定的 m 个 0 和 n 个 1 ，找到能拼出存在于数组中的字符串的最大数量。每个 0 和 1 至多被使用一次。</p><p>注意:</p><p>给定 0 和 1 的数量都不会超过 100。<br>给定字符串数组的长度不会超过 600。<br>示例 1:</p><p>输入: Array = {“10”, “0001”, “111001”, “1”, “0”}, m = 5, n = 3<br>输出: 4</p><p>解释: 总共 4 个字符串可以通过 5 个 0 和 3 个 1 拼出，即 “10”,”0001”,”1”,”0”</p><p>链接：<a href="https://leetcode-cn.com/problems/ones-and-zeroes" target="_blank" rel="noopener">https://leetcode-cn.com/problems/ones-and-zeroes</a></p><p><strong>【分析一】</strong></p><p>这道题的本质是二维背包问题。背包能装m个0，n个1，现在有N个字符串，每个字符串只由0和1组成，问装哪些字符串使得背包中字符串个数最多。每个字符串有2个代价，分别是消耗的0和1，价值都是1，即个数，每次向包中加一个字符串，价值（个数）就加1。<br>将问题形式化为二维背包问题之后就很简单了，二维背包问题的状态转移方程为：</p><p>$f[j][k] = max\{f[j][k],f[j-v_i][k-m_i]+1\}$</p><p>j表示背包中0的个数，k表示背包中1的个数。</p><p>首先需要定义一个函数，输入一个字符串，计算该字符串中0和1的个数。<br>然后使用二维背包问题的模板解决该问题。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findMaxForm</span><span class="params">(self, strs, m, n)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type strs: List[str]</span></span><br><span class="line"><span class="string">        :type m: int#0的个数</span></span><br><span class="line"><span class="string">        :type n: int#1的个数</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> strs:<span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        f = [[<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> range(n+<span class="number">1</span>)] <span class="keyword">for</span> _ <span class="keyword">in</span> range(m+<span class="number">1</span>)]</span><br><span class="line">        <span class="keyword">for</span> cur_str <span class="keyword">in</span> strs:</span><br><span class="line">            count_0,count_1 = self.countZeroAndOne(cur_str)</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(m,count_0<span class="number">-1</span>,<span class="number">-1</span>):</span><br><span class="line">                <span class="keyword">for</span> k <span class="keyword">in</span> range(n,count_1<span class="number">-1</span>,<span class="number">-1</span>):</span><br><span class="line">                    f[j][k]=max(f[j][k],f[j-count_0][k-count_1]+<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> f[m][n]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">countZeroAndOne</span><span class="params">(self,input_str)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        计算输入字符串中0和1的个数</span></span><br><span class="line"><span class="string">        input_str:当前输入的字符串</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        count_0,count_1 = <span class="number">0</span>,<span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> input_str:</span><br><span class="line">            <span class="keyword">if</span> i == <span class="string">'0'</span>:</span><br><span class="line">                count_0+=<span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                count_1+=<span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> count_0,count_1</span><br></pre></td></tr></table></figure><h2><span id="98-目标和">9.8. 目标和</span></h2><p>给定一个非负整数数组，a1, a2, …, an, 和一个目标数，S。现在你有两个符号 + 和 -。对于数组中的任意一个整数，你都可以从 + 或 -中选择一个符号添加在前面。<br>返回可以使最终数组和为目标数 S 的所有添加符号的方法数。</p><blockquote><p>示例：<br>输入：nums: [1, 1, 1, 1, 1], S: 3<br>输出：5<br>解释：<br>-1+1+1+1+1 = 3<br>+1-1+1+1+1 = 3<br>+1+1-1+1+1 = 3<br>+1+1+1-1+1 = 3<br>+1+1+1+1-1 = 3<br>一共有5种方法让最终目标和为3。</p></blockquote><p>链接：<a href="https://leetcode-cn.com/problems/target-sum" target="_blank" rel="noopener">https://leetcode-cn.com/problems/target-sum</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商</p><p><strong>【分析一】</strong></p><p>怎么看出这是一道背包问题呢？<br>在给定的数组中，找最大利益或达到某个值，这类问题可以被归为背包问题。</p><p>定义状态<br><code>dp[i][j]</code>表示考虑前i个数，使其元素和为j的方案数。<br>对于第i个数nums[i]，我们考虑的不是nums[i]选还是不选，而是nums[i]是加还是减，</p><ul><li>如果nums[i]为减，则前i-1个数的和为j+nums[i]，方案数为<code>dp[i-1][j+nums[i]]</code></li><li>如果nums[i]为加，则前i-1个数的和为j-nums[i],方案数为<code>dp[i-1][j-nums[i]]</code></li></ul><p>状态转移方程为<br><code>dp[i][j]=dp[i-1][j+nums[i]] + dp[i-1][j-nums[i]]</code></p><p>假设nums=[1,1,1,1,1]，则i的取值为0,1,2,3,4，表示考虑前1,…5个数。j的取值为-5,-4,-3,-2,-1,0,1,2,3,4,5，表示nums中可能的和。</p><p>初始化<br><code>dp[0][0]=1</code>表示考虑前0个数，和为0的方案数为1</p><p>状态转移矩阵为</p><p><img src="/2020/06/06/Leetcode之动态规划/3.png" alt=""></p><p>j表示元素之和，例如上面的例子中j取值-5,-4,…5，但是在dp数组中，数组下标从0开始，也是就是原先j=-5，在dp中下标为0，j=-4，下标为1，j=0，下标为5。所以代码实现中第二层for循环，j取值从-5到5，在dp的下标中需要加上max_sum，将其变换成0~10</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findTargetSumWays</span><span class="params">(self, nums, S)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :type S: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> nums:<span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> abs(sum(nums)) &lt; abs(S):<span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        N = len(nums)</span><br><span class="line">        max_sum = sum(nums)</span><br><span class="line"></span><br><span class="line">        dp = [[<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> range(<span class="number">2</span>*max_sum+<span class="number">1</span>)] <span class="keyword">for</span> _ <span class="keyword">in</span> range(N)]</span><br><span class="line"></span><br><span class="line">        dp[<span class="number">0</span>][nums[<span class="number">0</span>]+max_sum] = <span class="number">1</span></span><br><span class="line">        <span class="comment">#注意这里是累加1，而不是直接赋值为1</span></span><br><span class="line">        <span class="comment">#因为nums[0]+max_sum和-nums[0]+max_sum可能相同，此时dp[0][-nums[0]+max_sum]应该为2，即在原先1的基础上再加1。如果不设置为累加，则dp[0][-nums[0]+max_sum]就为1，初始化就错了。</span></span><br><span class="line">        <span class="comment">#例如[0,0,0,0,1]</span></span><br><span class="line">        dp[<span class="number">0</span>][-nums[<span class="number">0</span>]+max_sum] += <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,N):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(-max_sum,max_sum+<span class="number">1</span>):</span><br><span class="line">                tmp1,tmp2 = <span class="number">0</span>,<span class="number">0</span></span><br><span class="line">                <span class="keyword">if</span> j-nums[i]+max_sum&lt;<span class="number">0</span>:</span><br><span class="line">                    tmp1 = <span class="number">0</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    tmp1 = dp[i<span class="number">-1</span>][j-nums[i]+max_sum]</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">if</span> j+nums[i]+max_sum&gt;<span class="number">2</span>*max_sum:</span><br><span class="line">                    tmp2 = <span class="number">0</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    tmp2 = dp[i<span class="number">-1</span>][j+nums[i]+max_sum]</span><br><span class="line">                dp[i][j+max_sum] = tmp1 + tmp2</span><br><span class="line">        <span class="keyword">return</span> dp[N<span class="number">-1</span>][S+max_sum]</span><br></pre></td></tr></table></figure><h2><span id="99-零钱兑换">9.9. 零钱兑换</span></h2><p>给定不同面额的硬币 coins 和一个总金额 amount。编写一个函数来计算可以凑成总金额所需的最少的硬币个数。如果没有任何一种硬币组合能组成总金额，返回 -1。</p><p>说明:<br>你可以认为每种硬币的数量是无限的。</p><blockquote><p>示例 1:<br>输入: coins = [1, 2, 5], amount = 11<br>输出: 3<br>解释: 11 = 5 + 5 + 1</p></blockquote><p>链接：<a href="https://leetcode-cn.com/problems/coin-change" target="_blank" rel="noopener">https://leetcode-cn.com/problems/coin-change</a></p><p><strong>【分析一】</strong></p><p>这是一道完全背包问题，背包容量为amount，从一堆硬币中选出一些，使得总金额恰好等于amount。与标准完全背包问题不同的是</p><ul><li>本题要求恰好装满背包，即总金额恰好为amount。标准背包问题只要求容量小于等于背包</li><li>本题求最少的硬币数。标准背包问题求最大价值。</li></ul><p>完全背包问题可以使用一维数组来转移，这里直接写一维状态转移方程。<br><strong>定义状态</strong><br>f[j]：考虑前i个硬币，背包中硬币总金额恰好为j时的硬币个数。<br><strong>状态转移方程</strong><br><code>f[j]=min(f[j],f[j-coins[i]+1])</code><br>第一个<code>f[j]</code>表示考虑前i个硬币，背包总金额为j的硬币数<br>第二个<code>f[j]</code>表示考虑前i-1个硬币，背包总金额为j的硬币数<br><code>f[j-coins[i]]</code>表示考虑前i个硬币，向背包中多放一个第i个硬币，</p><p><strong>初始化</strong><br>因为题目要求背包金额恰好为amount的硬币个数。<br>初始化即考虑前0个硬币的情况，使用一个不可能的值，即正无穷进行初始化。<br>对于一些特殊情况，单独处理：</p><ul><li>当amount=0时，用0个硬币恰好装满背包。</li><li>当coins[0]=5时，说明用第一个硬币恰好能装满容量为5的背包，即<code>f[coins[0]] = 1</code></li></ul><p>第一层for循环遍历所有的硬币。第二层for循环遍历所有的总金额。当j=amount时，找出当前的硬币数，并记录最小的硬币数。最终返回的时候，需要判断res的值。如果res为inf时，说明没有一种方案可以使总金额为amount，题目要求这种无解的情况返回-1，否则返回最少的硬币数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">coinChange</span><span class="params">(self, coins, amount)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type coins: List[int]</span></span><br><span class="line"><span class="string">        :type amount: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> coins:<span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">        <span class="keyword">if</span> amount == <span class="number">0</span>:<span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        n = len(coins)</span><br><span class="line">        <span class="comment">#f[i][j]:考虑前i个硬币，恰好凑成j的硬币数</span></span><br><span class="line">        f = [float(<span class="string">'inf'</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> range(amount+<span class="number">1</span>)]</span><br><span class="line"></span><br><span class="line">        f[<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> coins[<span class="number">0</span>] &lt;= amount:</span><br><span class="line">            f[coins[<span class="number">0</span>]] = <span class="number">1</span></span><br><span class="line">            </span><br><span class="line">        <span class="comment">#对于第i个硬币，有2种选择：选、不选</span></span><br><span class="line">        <span class="comment">#第i个硬币可以选0,1,2,...k个，f[i][j]= f[i-1][j-k*coins[i]]+k</span></span><br><span class="line">        <span class="comment">#将其优化到本层，f[i][j] = f[i][j-coins[i]]+1</span></span><br><span class="line">        res = float(<span class="string">'inf'</span>)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>,n):<span class="comment">#考虑前i个硬币</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(coins[i],amount+<span class="number">1</span>):<span class="comment">#总金额为j</span></span><br><span class="line">                f[j] = min(f[j],f[j-coins[i]]+<span class="number">1</span>)</span><br><span class="line">                <span class="keyword">if</span> j == amount <span class="keyword">and</span> f[amount] &lt; res:</span><br><span class="line">                    res = f[amount]</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span> <span class="keyword">if</span> res==float(<span class="string">'inf'</span>) <span class="keyword">else</span> res</span><br></pre></td></tr></table></figure><h2><span id="910-零钱兑换-ii">9.10. 零钱兑换 II</span></h2><p>给定不同面额的硬币和一个总金额。写出函数来计算可以凑成总金额的硬币组合数。假设每一种面额的硬币有无限个。 </p><blockquote><p>示例 1:<br>输入: amount = 5, coins = [1, 2, 5]<br>输出: 4<br>解释: 有四种方式可以凑成总金额:<br>5=5<br>5=2+2+1<br>5=2+1+1+1<br>5=1+1+1+1+1</p></blockquote><p>链接：<a href="https://leetcode-cn.com/problems/coin-change-2" target="_blank" rel="noopener">https://leetcode-cn.com/problems/coin-change-2</a></p><p><strong>【分析一】</strong><br>这道题相对上一道题求得是组合数，而不是硬币数。所以状态的定义也需要修改以下。<br><strong>定义状态</strong><br><code>f[j]</code>：表示考虑前i个硬币时，背包金额恰好为j的组合数。当j为0时，说明背包中金额为0，这是不向背包中装任何硬币，恰好满足金额为0，这是一种方案，所以f[0]=1。<br><strong>状态转移方程</strong><br>对于第i个硬币，有2种选择：选和不选。</p><ul><li>不选第i个硬币，则前i-1个硬币的总金额为j，组合数为<code>f[i-1][j]</code></li><li>选第i个硬币，则没选这个硬币之前的金额为j-coins[i]，组合数为<code>f[i][j-coins[i]]</code></li></ul><p>则<code>f[i][j] = f[i-1][j]+f[i][j-coins[i]]</code><br>将其压缩为一维状态方程，第二层for循环必须从小到大。<br><code>f[j]=f[j]+f[j-coins[i]]</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">change</span><span class="params">(self, amount, coins)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type amount: int</span></span><br><span class="line"><span class="string">        :type coins: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> amount==<span class="number">0</span>:<span class="keyword">return</span> <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">#f[j]表示考虑前i个硬币时，总金额为j的组合数</span></span><br><span class="line">        <span class="comment">#f[j] = f[j]+f[j-coins[i]]</span></span><br><span class="line">        f = [<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> range(amount+<span class="number">1</span>)]</span><br><span class="line">        f[<span class="number">0</span>]=<span class="number">1</span></span><br><span class="line">        n = len(coins)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(coins[i],amount+<span class="number">1</span>):</span><br><span class="line">                f[j] += f[j-coins[i]]</span><br><span class="line">        <span class="keyword">return</span> f[amount]</span><br></pre></td></tr></table></figure><h2><span id="911-完全平方数">9.11. 完全平方数</span></h2><p>给定正整数 n，找到若干个完全平方数（比如 1, 4, 9, 16, …）使得它们的和等于 n。你需要让组成和的完全平方数的个数最少。</p><blockquote><p>示例 1:<br>输入: n = 12<br>输出: 3<br>解释: 12 = 4 + 4 + 4.</p></blockquote><p>链接：<a href="https://leetcode-cn.com/problems/perfect-squares" target="_blank" rel="noopener">https://leetcode-cn.com/problems/perfect-squares</a></p><p><strong>【分析一】</strong></p><p>我觉得这是完全背包问题，和找零钱一样。<br>背包容量为n，给定一个数组nums，从nums中挑选一些数，使得恰好装满背包，并且个数最少。<br>这里需要提前求出nums，即先使用一个for循环求出所有小于等于n的完全平方数。<br><code>dp[j]</code>表示考虑前i个平方数，和恰好为j的数字个数。对于第i个平方数，有2各种选择：选，不选</p><ul><li>选：dp[j]=dp[j-nums[i]]+1</li><li>不选：dp[j]=dp[j]</li></ul><p><code>dp[j]=min(dp[j-nums[i]]+1,dp[j])</code><br>第一个<code>dp[j]</code>表示考虑前i个平方数的数字个数<br>第二个<code>dp[j]</code>表示只考虑前i-1个平方数的数字个数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">numSquares</span><span class="params">(self, n)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type n: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">1</span>:<span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        nums = []<span class="comment">#存储所有&lt;=n的平方数</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,n):</span><br><span class="line">            <span class="keyword">if</span> i*i&lt;=n:</span><br><span class="line">                nums.append(i*i)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        dp = [float(<span class="string">'inf'</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> range(n+<span class="number">1</span>)]</span><br><span class="line">        <span class="comment">#完全背包问题，背包容量为n，从nums中</span></span><br><span class="line">        dp[<span class="number">0</span>]=<span class="number">0</span></span><br><span class="line">        dp[<span class="number">1</span>]=<span class="number">1</span></span><br><span class="line">        res = float(<span class="string">'inf'</span>)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums)):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>,n+<span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> nums[i]&lt;=j:</span><br><span class="line">                    dp[j]=min(dp[j-nums[i]]+<span class="number">1</span>,dp[j])</span><br><span class="line">                <span class="keyword">if</span> j == n:</span><br><span class="line">                    res = min(res,dp[j])</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><p><strong>【分析二】</strong></p><p>同样使用二重循环，外层for循环遍历背包容量，内层循环遍历所有的平方数。<br>注意：内层循环不能使用for循环，否则超时</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">numSquares</span><span class="params">(self, n)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type n: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">1</span>:<span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        dp = [float(<span class="string">'inf'</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> range(n+<span class="number">1</span>)]</span><br><span class="line">        <span class="comment">#完全背包问题，背包容量为n，从nums中</span></span><br><span class="line">        dp[<span class="number">0</span>]=<span class="number">0</span></span><br><span class="line">        dp[<span class="number">1</span>]=<span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>,n+<span class="number">1</span>):</span><br><span class="line">            j=<span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> j*j&lt;=i:</span><br><span class="line">                dp[i] = min(dp[i-j*j]+<span class="number">1</span>,dp[i])</span><br><span class="line">                j+=<span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> dp[n]</span><br></pre></td></tr></table></figure><h2><span id="整数拆分">整数拆分</span></h2><p>给定一个正整数 n，将其拆分为至少两个正整数的和，并使这些整数的乘积最大化。 返回你可以获得的最大乘积。</p><blockquote><p>示例 1:<br>输入: 2<br>输出: 1<br>解释: 2 = 1 + 1, 1 × 1 = 1。</p></blockquote><p>链接：<a href="https://leetcode-cn.com/problems/integer-break" target="_blank" rel="noopener">https://leetcode-cn.com/problems/integer-break</a></p><p><strong>【分析一】</strong></p><p>这道题同样是完全背包问题<br>背包的容量为n，在数组中挑选一些数，使得这些数之和为n，问怎么挑选才能使得这些数的乘积最大。</p><p><code>dp[j]</code>考虑前i个数，和为j的最大乘积<br><code>dp[j]=max(dp[j-k]*k,dp[j])</code></p><p>第一层for循环遍历所有的数，考虑前1个数，考虑前n-1个数，这里不能取到n，因为题目要求将n拆分成至少2个正整数的和，所以不能是n=n+0。第二层for循环遍历所有的和，从1到n。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">integerBreak</span><span class="params">(self, n)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type n: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="comment">#dp[j]:考虑前i个数，和恰好为j的乘积</span></span><br><span class="line">        dp = [<span class="number">0</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(n+<span class="number">1</span>)]</span><br><span class="line">        dp[<span class="number">0</span>]=<span class="number">1</span></span><br><span class="line">        <span class="comment">#dp[j]=max(dp[j-k]*k,dp[j])</span></span><br><span class="line"></span><br><span class="line">        res = float(<span class="string">'-inf'</span>)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,n):<span class="comment">#考虑前i个数</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(i,n+<span class="number">1</span>):<span class="comment">#和为j</span></span><br><span class="line">                dp[j] = max(dp[j-i]*i,dp[j])</span><br><span class="line">            <span class="keyword">if</span> j == n:</span><br><span class="line">                res = max(res,dp[j])</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h1><span id="10-路径问题">10. 路径问题</span></h1><p>在矩阵中找最小路径和、最大路径和、路径条数</p><h2><span id="101-不同路径">10.1. 不同路径</span></h2><p>一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。</p><p>机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。<br>问总共有多少条不同的路径？</p><p><img src="/2020/06/06/Leetcode之动态规划/4.png" alt=""></p><p>链接：<a href="https://leetcode-cn.com/problems/unique-paths" target="_blank" rel="noopener">https://leetcode-cn.com/problems/unique-paths</a></p><p><strong>【分析一】</strong></p><p>定义状态<br><code>dp[i][j]</code>表示从原点走到(i,j)的路径条数。由于机器人只能向下或向右移动一步，所以对于(i,j)来说，只有它上面的格子和它左边的格子能够到达它，所以<code>dp[i][j]</code>为上面格子(i-1,j)的路径 + 左边格子(i,j-1)的路径之和。<br>状态转移方程<br><code>dp[i][j]=dp[i-1][j]+dp[i][j-1]</code></p><p><strong>初始化</strong><br>对于边界信息，例如第一行<code>dp[0][j]</code>和第一列<code>dp[i][0]</code>，初始化为1，因为从原点到第一行、第一列某个格子只有1条路径</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">uniquePaths</span><span class="params">(self, m, n)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type m: int，行</span></span><br><span class="line"><span class="string">        :type n: int，列</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        dp = [[<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> range(n)] <span class="keyword">for</span> _ <span class="keyword">in</span> range(m)]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(m):</span><br><span class="line">            dp[i][<span class="number">0</span>]=<span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(n):</span><br><span class="line">            dp[<span class="number">0</span>][j]=<span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,m):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>,n):</span><br><span class="line">                dp[i][j]=dp[i<span class="number">-1</span>][j]+dp[i][j<span class="number">-1</span>]</span><br><span class="line">        <span class="keyword">return</span> dp[m<span class="number">-1</span>][n<span class="number">-1</span>]</span><br></pre></td></tr></table></figure><ul><li>时间复杂度：O(m*n)</li><li>空间复杂度：O(m*n)</li></ul><p><strong>【空间优化】</strong></p><p>每个点只需要知道它上面格子和左边格子的路径即可，所以不需要使用数组，只用2个变量来记录。</p><ul><li>时间复杂度：O(m*n)</li><li>空间复杂度：O(2*n)</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">uniquePaths</span><span class="params">(self, m, n)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type m: int，行</span></span><br><span class="line"><span class="string">        :type n: int，列</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="comment">#使用pre记录上一行的值，cur记录当前行的值</span></span><br><span class="line">        pre = [<span class="number">1</span> <span class="keyword">for</span> _ <span class="keyword">in</span> range(n)]</span><br><span class="line">        cur = [<span class="number">1</span> <span class="keyword">for</span> _ <span class="keyword">in</span> range(n)]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,m):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>,n):</span><br><span class="line">                cur[j] = pre[j]+cur[j<span class="number">-1</span>]</span><br><span class="line">            pre = cur[:]</span><br><span class="line">        <span class="keyword">return</span> cur[<span class="number">-1</span>]</span><br></pre></td></tr></table></figure><p>上面使用2个数组来保存上一行的值和当前的值。下面再次进行空间优化，只使用一个数组cur，既保存上一行的值，也保存当前行的值。</p><ul><li>时间复杂度：O(m*n)</li><li>空间复杂度：O(n)</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">uniquePaths</span><span class="params">(self, m, n)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type m: int，行</span></span><br><span class="line"><span class="string">        :type n: int，列</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="comment">#只使用一个数组</span></span><br><span class="line">        cur = [<span class="number">1</span> <span class="keyword">for</span> _ <span class="keyword">in</span> range(n)]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,m):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>,n):</span><br><span class="line">                cur[j] += cur[j<span class="number">-1</span>]</span><br><span class="line">        <span class="keyword">return</span> cur[<span class="number">-1</span>]</span><br></pre></td></tr></table></figure><h2><span id="102-不同路径ii">10.2. 不同路径II</span></h2><p>一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。<br>机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。<br>现在考虑网格中有障碍物，网格中的障碍物和空位置分别用 1 和 0 来表示。那么从左上角到右下角将会有多少条不同的路径？</p><p>链接：<a href="https://leetcode-cn.com/problems/unique-paths-ii" target="_blank" rel="noopener">https://leetcode-cn.com/problems/unique-paths-ii</a></p><p><img src="/2020/06/06/Leetcode之动态规划/4.png" alt=""></p><blockquote><p>示例 1:<br>输入:<br>[<br>  [0,0,0],<br>  [0,1,0],<br>  [0,0,0]<br>]<br>输出: 2<br>解释:<br>3x3 网格的正中间有一个障碍物。<br>从左上角到右下角一共有 2 条不同的路径：<br>向右 -&gt; 向右 -&gt; 向下 -&gt; 向下<br>向下 -&gt; 向下 -&gt; 向右 -&gt; 向右</p></blockquote><p><strong>【分析一】</strong></p><p>同样使用二维数组来保存每个格子的路径数。<br>在初始化的时候需要注意：初始化第一行或第一列的时候，一旦遇到了1，在这一行后面的格子和这一列后面的格子都不能到达，所以为0。即初始化时使用while而不能使用for。使用while一段遇到1就退出while循环，而使用for会一直走到这一行和这一列的末尾。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">uniquePathsWithObstacles</span><span class="params">(self, obstacleGrid)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type obstacleGrid: List[List[int]]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> obstacleGrid:<span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> obstacleGrid[<span class="number">0</span>][<span class="number">0</span>]==<span class="number">1</span>:<span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        m,n = len(obstacleGrid),len(obstacleGrid[<span class="number">0</span>])<span class="comment">#m行，n列</span></span><br><span class="line">        dp = [[<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> range(n)] <span class="keyword">for</span> _ <span class="keyword">in</span> range(m)]</span><br><span class="line">        i = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> i &lt; m <span class="keyword">and</span> obstacleGrid[i][<span class="number">0</span>]!=<span class="number">1</span>:</span><br><span class="line">            dp[i][<span class="number">0</span>]=<span class="number">1</span></span><br><span class="line">            i+=<span class="number">1</span></span><br><span class="line">        j = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> j &lt; n <span class="keyword">and</span> obstacleGrid[<span class="number">0</span>][j]!=<span class="number">1</span>:</span><br><span class="line">            dp[<span class="number">0</span>][j]=<span class="number">1</span></span><br><span class="line">            j+=<span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,m):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>,n):</span><br><span class="line">                <span class="keyword">if</span> obstacleGrid[i][j]!=<span class="number">1</span>:<span class="comment">#如果能到达</span></span><br><span class="line">                    dp[i][j]=dp[i<span class="number">-1</span>][j]+dp[i][j<span class="number">-1</span>]</span><br><span class="line">                <span class="comment">#否则dp[i][j]=0</span></span><br><span class="line">        <span class="keyword">return</span> dp[m<span class="number">-1</span>][n<span class="number">-1</span>]</span><br></pre></td></tr></table></figure><p><strong>【空间优化】</strong></p><p>将dp优化为一维数组，用来保存上一层和当前层的路径条数。<br>首先dp初始化为0，然后对于第一行的值，在障碍之前的格子路径再次初始化为1，之后的格子路径还是0.这里只对第一行进行初始化。<br>然后2重for循环遍历时，i从第二行开始，j也从第二列开始。但是对于第二行的第一列还没有初始化，所以在第一层for循环之后先对改行的第1列进行初始化。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">uniquePathsWithObstacles</span><span class="params">(self, obstacleGrid)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type obstacleGrid: List[List[int]]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="comment">#空间优化：一维数组</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> obstacleGrid:<span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> obstacleGrid[<span class="number">0</span>][<span class="number">0</span>]==<span class="number">1</span>:<span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        m,n = len(obstacleGrid),len(obstacleGrid[<span class="number">0</span>])<span class="comment">#m行，n列</span></span><br><span class="line">        dp = [<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> range(n)]</span><br><span class="line">        j = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> j &lt; n <span class="keyword">and</span> obstacleGrid[<span class="number">0</span>][j]!=<span class="number">1</span>:</span><br><span class="line">            dp[j]=<span class="number">1</span></span><br><span class="line">            j+=<span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,m):</span><br><span class="line">            <span class="comment">#对i行的第一列初始化</span></span><br><span class="line">            <span class="keyword">if</span> obstacleGrid[i][<span class="number">0</span>]!=<span class="number">1</span> <span class="keyword">and</span> dp[<span class="number">0</span>]!=<span class="number">0</span>:</span><br><span class="line">                dp[<span class="number">0</span>]=<span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                dp[<span class="number">0</span>]=<span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>,n):</span><br><span class="line">                <span class="keyword">if</span> obstacleGrid[i][j]!=<span class="number">1</span>:<span class="comment">#如果能到达</span></span><br><span class="line">                    dp[j] += dp[j<span class="number">-1</span>]</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    dp[j]=<span class="number">0</span></span><br><span class="line">        <span class="keyword">return</span> dp[n<span class="number">-1</span>]</span><br></pre></td></tr></table></figure><p>这道题和上一道题的区别是这道题有障碍，上一题没有障碍。所以上一题对dp初始化为1，表示每个格子至少有1条路径可以到达。但是这一道题对dp初始化为0，然后再对第一行和第一列的某些特殊格子再单独初始化为1。</p><h2><span id="103-下降路径最小和">10.3. 下降路径最小和</span></h2><p>给定一个方形整数数组 A，我们想要得到通过 A 的下降路径的最小和。</p><p>下降路径可以从第一行中的任何元素开始，并从每一行中选择一个元素。在下一行选择的元素和当前行所选元素最多相隔一列。</p><p>链接：<a href="https://leetcode-cn.com/problems/minimum-falling-path-sum" target="_blank" rel="noopener">https://leetcode-cn.com/problems/minimum-falling-path-sum</a></p><blockquote><p>输入：<code>[[1,2,3],[4,5,6],[7,8,9]]</code><br>输出：12<br>解释：<br>可能的下降路径有：<br>[1,4,7], [1,4,8], [1,5,7], [1,5,8], [1,5,9]<br>[2,4,7], [2,4,8], [2,5,7], [2,5,8], [2,5,9], [2,6,8], [2,6,9]<br>[3,5,7], [3,5,8], [3,5,9], [3,6,8], [3,6,9]<br>和最小的下降路径是 [1,4,7]，所以答案是 12。</p></blockquote><p><strong>【分析一】</strong></p><p>定义状态<br><code>dp[i][j]</code>表示格子(i,j)的最小路径和。<br>一个格子只能向左下，正下，右下移动，所以(i,j)的最小路径和为min(左上，正上，右上)+A[i][j]，即状态转移方程为：<br><code>dp[i][j]=min(dp[i-1][j-1],dp[i-1][j],dp[i-1][j+1])</code></p><p>需要注意边界情况：</p><ul><li>在求第一列的dp时，它的左上方没有元素，所以只用求正上方和右上方的最小值</li><li>在求最后一列的dp时，它的右上方没有元素，所以只用求左上方和正上方的最小值</li></ul><p>遍历完整个数组后，得到完整的dp，然后求最后一行路径的最小值，作为结果返回。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minFallingPathSum</span><span class="params">(self, A)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type A: List[List[int]]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        m = len(A)</span><br><span class="line">        dp = [[<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> range(m)] <span class="keyword">for</span> _ <span class="keyword">in</span> range(m)]</span><br><span class="line"></span><br><span class="line">        <span class="comment">#初始化第一行</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(m):</span><br><span class="line">            dp[<span class="number">0</span>][j] = A[<span class="number">0</span>][j]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,m):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(m):</span><br><span class="line">                <span class="keyword">if</span> j<span class="number">-1</span>&lt;<span class="number">0</span>:</span><br><span class="line">                    dp[i][j]=min(dp[i<span class="number">-1</span>][j],dp[i<span class="number">-1</span>][j+<span class="number">1</span>])+A[i][j]</span><br><span class="line">                <span class="keyword">elif</span> j+<span class="number">1</span>&gt;=m:</span><br><span class="line">                    dp[i][j]=min(dp[i<span class="number">-1</span>][j<span class="number">-1</span>],dp[i<span class="number">-1</span>][j])+A[i][j]</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    dp[i][j]=min(dp[i<span class="number">-1</span>][j<span class="number">-1</span>],dp[i<span class="number">-1</span>][j],dp[i<span class="number">-1</span>][j+<span class="number">1</span>])+A[i][j]</span><br><span class="line"></span><br><span class="line">        res = float(<span class="string">'inf'</span>)</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(m):</span><br><span class="line">            <span class="keyword">if</span> dp[m<span class="number">-1</span>][j]&lt;res:</span><br><span class="line">                res = dp[m<span class="number">-1</span>][j]</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h2><span id="104-下降路径最小和ii">10.4. 下降路径最小和II</span></h2><p>给你一个整数方阵 arr ，定义「非零偏移下降路径」为：从 arr 数组中的每一行选择一个数字，且按顺序选出来的数字中，相邻数字不在原数组的同一列。<br>请你返回非零偏移下降路径数字和的最小值。</p><p>链接：<a href="https://leetcode-cn.com/problems/minimum-falling-path-sum-ii" target="_blank" rel="noopener">https://leetcode-cn.com/problems/minimum-falling-path-sum-ii</a></p><blockquote><p>示例 1：<br>输入：arr = [[1,2,3],[4,5,6],[7,8,9]]<br>输出：13<br>解释：<br>所有非零偏移下降路径包括：<br>[1,5,9], [1,5,7], [1,6,7], [1,6,8],<br>[2,4,8], [2,4,9], [2,6,7], [2,6,8],<br>[3,4,8], [3,4,9], [3,5,7], [3,5,9]<br>下降路径中数字和最小的是 [1,5,7] ，所以答案是 13 。</p></blockquote><p><strong>【分析一】</strong></p><p><code>dp[i][j]</code>表示以<code>arr[i][j]</code>为结尾的最小路径和。每一行和上一行的值不能是同一列，所以需要找出上一行除了当前列的最小值。下面使用三重循环，第一个for循环遍历所有的行，第二个for循环遍历当前行所有的列，第三个for循环遍历上一行所有的列，除了当前列j,并记录上一行所有的最小路径和。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minFallingPathSum</span><span class="params">(self, arr)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type arr: List[List[int]]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="comment">#dp[i][j]表示以arr[i][j]为结尾的最小和</span></span><br><span class="line">        <span class="comment">#dp[i][j]=min&#123;dp[i-1][k]&#125;+arr[i][j],(k!=j)</span></span><br><span class="line">        m,n = len(arr),len(arr[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line">        dp = [[<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> range(n)] <span class="keyword">for</span> _ <span class="keyword">in</span> range(m)]</span><br><span class="line"></span><br><span class="line">        <span class="comment">#dp的第一行就是该行的值</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(n):</span><br><span class="line">            dp[<span class="number">0</span>][j] = arr[<span class="number">0</span>][j]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(m):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(n):</span><br><span class="line">                last_min = float(<span class="string">'inf'</span>)</span><br><span class="line">                <span class="keyword">for</span> k <span class="keyword">in</span> range(n):</span><br><span class="line">                    <span class="keyword">if</span> k != j:</span><br><span class="line">                        last_min = min(last_min,dp[i<span class="number">-1</span>][k])</span><br><span class="line">                dp[i][j] = last_min + arr[i][j]</span><br><span class="line">        <span class="comment">#找出最后一行最小的和</span></span><br><span class="line">        res = float(<span class="string">'inf'</span>)</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(n):</span><br><span class="line">            res = min(res,dp[m<span class="number">-1</span>][j])</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h2><span id="105-最小路径和">10.5. 最小路径和</span></h2><p>给定一个包含非负整数的 m x n 网格，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。</p><p>说明：每次只能向下或者向右移动一步。</p><blockquote><p>示例:<br>输入:<br>[<br>  [1,3,1],<br>  [1,5,1],<br>  [4,2,1]<br>]<br>输出: 7<br>解释: 因为路径 1→3→1→1→1 的总和最小。</p></blockquote><p>链接：<a href="https://leetcode-cn.com/problems/minimum-path-sum" target="_blank" rel="noopener">https://leetcode-cn.com/problems/minimum-path-sum</a></p><p><strong>【分析一】</strong><br><code>dp[i][j]</code>表示在(i,j)的最小路径和。首先将dp初始化为0，然后再单独处理dp的第一行和第一列。<br>状态转移方程<br><code>dp[i][j]=min(dp[i-1][j],dp[i][j-1])+grid[i][j]</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minPathSum</span><span class="params">(self, grid)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type grid: List[List[int]]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> grid:<span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        m,n = len(grid),len(grid[<span class="number">0</span>])</span><br><span class="line">        <span class="comment">#dp[i][j]=min(dp[i-1][j],dp[i][j-1])+grid[i][j]</span></span><br><span class="line">        dp = [[<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> range(n)] <span class="keyword">for</span> _ <span class="keyword">in</span> range(m)]</span><br><span class="line">        </span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = grid[<span class="number">0</span>][<span class="number">0</span>]</span><br><span class="line">        </span><br><span class="line">        <span class="comment">#初始化第一行和第一列</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>,n):</span><br><span class="line">            dp[<span class="number">0</span>][j] = dp[<span class="number">0</span>][j<span class="number">-1</span>]+grid[<span class="number">0</span>][j]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,m):</span><br><span class="line">            dp[i][<span class="number">0</span>] = dp[i<span class="number">-1</span>][<span class="number">0</span>]+grid[i][<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,m):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>,n):</span><br><span class="line">                dp[i][j] = min(dp[i<span class="number">-1</span>][j],dp[i][j<span class="number">-1</span>])+grid[i][j]</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">-1</span>][<span class="number">-1</span>]</span><br></pre></td></tr></table></figure><p><strong>【空间优化】</strong><br>将二维数组优化为一维数组，<br><code>dp[j]=min(dp[j],dp[j-1])+grid[i][j]</code><br>第一个<code>dp[j]</code>表示当前行的最小路径和<br>第二个<code>dp[j]</code>表示正上方的最小路径和<br><code>dp[j-1]</code>表示当前行左边的最小路径和</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minPathSum</span><span class="params">(self, grid)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type grid: List[List[int]]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> grid:<span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        m,n = len(grid),len(grid[<span class="number">0</span>])</span><br><span class="line">        <span class="comment">#dp[j]=min(dp[j],dp[j-1])+grid[i][j]</span></span><br><span class="line">        dp = [<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> range(n)]</span><br><span class="line">        </span><br><span class="line">        dp[<span class="number">0</span>] = grid[<span class="number">0</span>][<span class="number">0</span>]</span><br><span class="line">        </span><br><span class="line">        <span class="comment">#初始化第一行</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>,n):</span><br><span class="line">            dp[j] = dp[j<span class="number">-1</span>]+grid[<span class="number">0</span>][j]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,m):</span><br><span class="line">            dp[<span class="number">0</span>]=dp[<span class="number">0</span>]+grid[i][<span class="number">0</span>]</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>,n):</span><br><span class="line">                dp[j] = min(dp[j],dp[j<span class="number">-1</span>])+grid[i][j]</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">-1</span>]</span><br></pre></td></tr></table></figure><h2><span id="106-三角形最小路径和">10.6. 三角形最小路径和</span></h2><p>给定一个三角形，找出自顶向下的最小路径和。每一步只能移动到下一行中相邻的结点上。</p><p>相邻的结点 在这里指的是 下标 与 上一层结点下标 相同或者等于 上一层结点下标 + 1 的两个结点。</p><p>链接：<a href="https://leetcode-cn.com/problems/triangle" target="_blank" rel="noopener">https://leetcode-cn.com/problems/triangle</a></p><blockquote><p>例如，给定三角形：<br>[<br>     [2],<br>    [3,4],<br>   [6,5,7],<br>  [4,1,8,3]<br>]<br>自顶向下的最小路径和为 11（即，2 + 3 + 5 + 1 = 11）。</p></blockquote><p><strong>【分析一】</strong><br><code>dp[i][j]</code>表示以<code>triangle[i][j]</code>为结尾的最小路径和。当前值由正上方<code>dp[i-1][j]</code>和左上方的值<code>dp[i-1][j-1]</code>转移得到。<br>即<code>dp[i][j]=min(dp[i-1][j],dp[i-1][j-1])+triangle[i][j]</code><br>使用一维数据进行空间优化<br><code>dp[j]=min(dp[j],dp[j-1])+triangle[i][j]</code><br>需要注意的时，等号后面的<code>dp[j]</code>和<code>dp[j-1]</code>都是上一行的值，所以在第二层for循环需要倒序遍历<code>j</code>，这是<code>dp[j-1]</code>才不会被当前行的值所覆盖。<br>同时需要注意，三角形中每一行的元素个数不一样，注意边界问题。</p><ul><li>当<code>j=0</code>时，<code>dp[j]</code>只能由正上方的元素转移，因为它左上方没有值</li><li>当<code>j=i</code>时，即当前行的最后一个元素，只能由左上方的元素转移，因为它正上方没有元素</li><li>其余元素由正上方和左上方的元素转移</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minimumTotal</span><span class="params">(self, triangle)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type triangle: List[List[int]]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        n = len(triangle)<span class="comment">#三角形的行数</span></span><br><span class="line">        dp = [<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> range(n)]</span><br><span class="line">        <span class="comment">#dp[j] = min(dp[j],dp[j-1])+triangle[j]</span></span><br><span class="line">        <span class="comment">#初始化</span></span><br><span class="line">        dp[<span class="number">0</span>]=triangle[<span class="number">0</span>][<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,n):<span class="comment">#从第二行开始遍历</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(i,<span class="number">-1</span>,<span class="number">-1</span>):</span><br><span class="line">                <span class="keyword">if</span> j == <span class="number">0</span>:</span><br><span class="line">                    dp[j] = dp[j]+triangle[i][j]</span><br><span class="line">                <span class="keyword">elif</span> j == i:</span><br><span class="line">                    dp[j] = dp[j<span class="number">-1</span>]+triangle[i][j]</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    dp[j] = min(dp[j],dp[j<span class="number">-1</span>])+triangle[i][j]</span><br><span class="line">        <span class="keyword">return</span> min(dp)</span><br></pre></td></tr></table></figure><h1><span id="统计全为1的正方形子矩形">统计全为1的正方形子矩形</span></h1><p>给你一个 m * n 的矩阵，矩阵中的元素不是 0 就是 1，请你统计并返回其中完全由 1 组成的 正方形 子矩阵的个数。</p><blockquote><p>示例 1：<br>输入：matrix =<br>[<br>  [0,1,1,1],<br>  [1,1,1,1],<br>  [0,1,1,1]<br>]<br>输出：15<br>解释：<br>边长为 1 的正方形有 10 个。<br>边长为 2 的正方形有 4 个。<br>边长为 3 的正方形有 1 个。<br>正方形的总数 = 10 + 4 + 1 = 15.</p></blockquote><p>链接：<a href="https://leetcode-cn.com/problems/count-square-submatrices-with-all-ones" target="_blank" rel="noopener">https://leetcode-cn.com/problems/count-square-submatrices-with-all-ones</a></p><p><strong>【分析一】</strong></p><p><code>dp[i][j][k]</code>表示以<code>matrix[i][j]</code>为右下角，边长为k的正方形区域是否全为1，全为1,<code>dp[i][j][k]=True</code>,否则为<code>False</code>.<br>以(2,3)为右下角，边长为3的正方形区域是否全为1：</p><ul><li>先判断(i,j)位置是否为1，如果不是1，说明不能组成正方形，如果是，进行下一步判断</li><li>分别判断以<code>(i-1,j),(i-1,j-1),(i,j-1)</code>为右下角的区域是否能构成边长为2的正方形，如果能构成，说明<code>dp[i][j][k]=True</code></li></ul><p><img src="/2020/06/06/Leetcode之动态规划/5.png" alt=""></p><p>状态转移方程为:<br><code>dp[i][j][k]=(matrix[i][j] and dp[i-1][j][k-1] and dp[i-1][j-1][k-1] and dp[i][j-1][k-1])</code></p><p>但是这样时间复杂度太多，三重循环，超时</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">countSquares</span><span class="params">(self, matrix)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type matrix: List[List[int]]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="comment">#dp[i][j][k]以matrix[i][j]为右下角，边长为k的正方形是否全是1，True或者False</span></span><br><span class="line">        m,n = len(matrix),len(matrix[<span class="number">0</span>])</span><br><span class="line">        max_len = min(m,n)<span class="comment">#正方形最大的边长</span></span><br><span class="line"></span><br><span class="line">        dp = [[[<span class="keyword">False</span> <span class="keyword">for</span> _ <span class="keyword">in</span> range(max_len+<span class="number">1</span>)] <span class="keyword">for</span> _ <span class="keyword">in</span> range(n)] <span class="keyword">for</span> _ <span class="keyword">in</span> range(m)]</span><br><span class="line">        <span class="comment">#初始化边长为1的正方形的个数</span></span><br><span class="line">        count = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(m):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(n):</span><br><span class="line">                <span class="keyword">if</span> matrix[i][j]==<span class="number">1</span>:</span><br><span class="line">                    dp[i][j][<span class="number">1</span>]=<span class="keyword">True</span></span><br><span class="line">                    count+=<span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,m):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>,n):</span><br><span class="line">                <span class="keyword">for</span> k <span class="keyword">in</span> range(<span class="number">2</span>,max_len+<span class="number">1</span>):</span><br><span class="line">                    <span class="keyword">if</span> matrix[i][j] == <span class="number">1</span>:</span><br><span class="line">                        dp[i][j][k] = dp[i<span class="number">-1</span>][j][k<span class="number">-1</span>] <span class="keyword">and</span> dp[i][j<span class="number">-1</span>][k<span class="number">-1</span>] <span class="keyword">and</span> dp[i<span class="number">-1</span>][j<span class="number">-1</span>][k<span class="number">-1</span>]</span><br><span class="line">                    <span class="keyword">if</span> dp[i][j][k]:</span><br><span class="line">                        count+=<span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> count</span><br></pre></td></tr></table></figure><p><strong>【空间优化】</strong></p><p>这里针对上述情况进行优化，将三维数组压缩为二维。<br>题目并不关心边长为1,2..k的正方形各有多少，并且以(i,j)为右下角边长为k的正方形全为1的话，那么以(i,j)为右下角，边长为1,2,…k-1的正方形也一定全为1.</p><p><img src="/2020/06/06/Leetcode之动态规划/6.png" alt=""></p><p>如上图所示，红色区域中是以(2,3)为右下角边长为3的正方形，这里以(2,3)为右下角的正方形还有边长为1，边长的2的这2个正方形。所以以(2,3)为右下角的正方形个数有3个，正是最大正方形的边长。</p><p>所以状态<code>dp[i][j]</code>表示以<code>matrix[i][j]</code>为右下角的正方形最大边长。<br><code>dp[i][j]=min(dp[i-1][j],dp[i-1][j-1],dp[i][j-1])+1</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">countSquares</span><span class="params">(self, matrix)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type matrix: List[List[int]]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="comment">#dp[i][j][k]以matrix[i][j]为右下角，边长为k的正方形是否全是1，True或者False</span></span><br><span class="line">        m,n = len(matrix),len(matrix[<span class="number">0</span>])</span><br><span class="line">        dp = [[<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> range(n)] <span class="keyword">for</span> _ <span class="keyword">in</span> range(m)]</span><br><span class="line"></span><br><span class="line">        <span class="comment">#初始化边长为1的正方形的个数</span></span><br><span class="line">        count = <span class="number">0</span></span><br><span class="line">        <span class="comment">#初始化第一行和第一列</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(n):</span><br><span class="line">            <span class="keyword">if</span> matrix[<span class="number">0</span>][j] == <span class="number">1</span>:</span><br><span class="line">                dp[<span class="number">0</span>][j] = <span class="number">1</span></span><br><span class="line">                count+=<span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(m):</span><br><span class="line">            <span class="keyword">if</span> matrix[i][<span class="number">0</span>]==<span class="number">1</span>:</span><br><span class="line">                dp[i][<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">                count+=<span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> matrix[<span class="number">0</span>][<span class="number">0</span>]==<span class="number">1</span>:</span><br><span class="line">            count-=<span class="number">1</span> <span class="comment"># matrix[0][0]被计算了2次</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,m):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>,n):</span><br><span class="line">                <span class="keyword">if</span> matrix[i][j] == <span class="number">1</span>:</span><br><span class="line">                    dp[i][j] = min(dp[i<span class="number">-1</span>][j],dp[i<span class="number">-1</span>][j<span class="number">-1</span>],dp[i][j<span class="number">-1</span>])+<span class="number">1</span></span><br><span class="line">                    count+=dp[i][j]</span><br><span class="line">        <span class="keyword">return</span> count</span><br></pre></td></tr></table></figure><h1><span id="最大正方形">最大正方形</span></h1><p>在一个由 0 和 1 组成的二维矩阵内，找到只包含 1 的最大正方形，并返回其面积。</p><blockquote><p>示例:<br>输入:<br>1 0 1 0 0<br>1 0 1 1 1<br>1 1 1 1 1<br>1 0 0 1 0<br>输出: 4</p></blockquote><p>链接：<a href="https://leetcode-cn.com/problems/maximal-square" target="_blank" rel="noopener">https://leetcode-cn.com/problems/maximal-square</a></p><p><strong>【分析一】</strong></p><p>和和上一题的状态转移方程一样<br><code>dp[i][j]=min(dp[i-1][j],dp[i-1][j-1],dp[i][j-1])+1</code><br><code>dp[i][j]</code>表示以<code>matrix[i][j]</code>为右下角的正方形的最大边长</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maximalSquare</span><span class="params">(self, matrix)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type matrix: List[List[str]]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> matrix:<span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        m,n = len(matrix),len(matrix[<span class="number">0</span>])<span class="comment">#二维矩阵的行数，列数</span></span><br><span class="line"></span><br><span class="line">        res = <span class="number">0</span><span class="comment">#正方形最大边长</span></span><br><span class="line">        dp = [[<span class="number">0</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(n)] <span class="keyword">for</span> _ <span class="keyword">in</span> range(m)]</span><br><span class="line">        <span class="comment">#初始化第一行和第一列</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(n):</span><br><span class="line">            <span class="keyword">if</span> matrix[<span class="number">0</span>][j]==<span class="string">'1'</span>:</span><br><span class="line">                dp[<span class="number">0</span>][j]=<span class="number">1</span></span><br><span class="line">                res = max(res,dp[<span class="number">0</span>][j])</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(m):</span><br><span class="line">            <span class="keyword">if</span> matrix[i][<span class="number">0</span>]==<span class="string">'1'</span>:</span><br><span class="line">                dp[i][<span class="number">0</span>]=<span class="number">1</span></span><br><span class="line">                res = max(res,dp[i][<span class="number">0</span>])</span><br><span class="line">        </span><br><span class="line">        <span class="comment">#i，j表示正方形的左边界和右边界</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,m):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>,n):</span><br><span class="line">                <span class="keyword">if</span> matrix[i][j]==<span class="string">'1'</span>:</span><br><span class="line">                    dp[i][j]=min(dp[i<span class="number">-1</span>][j],dp[i<span class="number">-1</span>][j<span class="number">-1</span>],dp[i][j<span class="number">-1</span>])+<span class="number">1</span></span><br><span class="line">                    res = max(res,dp[i][j])</span><br><span class="line">        <span class="keyword">return</span> res*res</span><br></pre></td></tr></table></figure><h1><span id="最长上升子序列问题">最长上升子序列问题</span></h1><h2><span id="最长上升子序列">最长上升子序列</span></h2><p>给定一个无序的整数数组，找到其中最长上升子序列的长度</p><blockquote><p>示例:<br>输入: [10,9,2,5,3,7,101,18]<br>输出: 4<br>解释: 最长的上升子序列是 [2,3,7,101]，它的长度是 4。</p></blockquote><p>说明：可能有多个最长上升子序列，只需要返回对应的长度即可。</p><p>【分析一】</p><ul><li><p>首先需要明确几个概念</p><ol><li>子序列和子串<br>子序列不要求连续。例如<code>[3,6,8]</code>是<code>[3,4,5,6,7,8]</code>的子序列。子串要求连续。</li><li>这里是上升是严格上升，<code>[1,2,2,3]</code>不是上升子序列</li><li>子序列在原始数组中的相对位置不能变</li></ol></li></ul><ul><li><p>定义状态<br><code>dp[i]</code>表示以<code>nums[i]</code>为结尾的上升子序列长度，<code>nums[i]</code>一定要被选上，是上升子序列的最后一个元素。<br><strong>注意：我们以前定义的状态<code>dp[i]</code>大多是考虑前i个元素的xx，这里的<code>nums[i]</code>可选可不选，但是这里的<code>nums[i]</code>必须被选上</strong></p></li><li><p>状态转移方程<br>对于<code>nums[i]</code>，它前面的数有[0,1,…i-1]，如果上升子序列以<code>nums[i]</code>为结果，那前面<code>nums[0,1,..i-1]</code>必须要有比<code>nums[i]</code>小的数，在这些数中找一个最大的dp值，在此基础上加1<br><code>if nums[j] &lt; nums[i]</code>，j的取值为<code>0,1,2,..i-1</code><br><code>dp[i]=max(dp[j])+1</code><br>如果前面没有比<code>nums[i]</code>小的数，那只能<code>nums[i]</code>自己组成一个上升子序列，<code>dp[i]=1</code><br>状态转移方程为<br><code>dp[i]=max(dp[i],dp[j]+1) for j in [0,i)</code></p></li></ul><p>例如<code>[10,9,2,5,3,7,100,18]</code><br>首先初始化<code>dp=[1,1,1,1,1,1,1,1]</code></p><ul><li>第一个for循环首先遍历到9，第二个for循环遍历9之前的数[10]，没有比9小，所以dp[1]=1表示以9为结尾的上升子序列长度为1.</li><li>然后遍历到2，找到2之前的元素[10,9]，没有比2小的，所以dp[2]=1</li><li>然后遍历到5，找到5之前的元素[10,9,2],其中2比5小，dp[3]=2，表示以5为结尾的上升子序列长度为2</li><li>然后遍历到3，之前的元素只有2比3小，所以dp[4]=2</li><li>然后遍历到7，之前的元素有[2,5,3]比7小，这3个数组dp最大的是5和3，都是2，所以dp[5]=2+1=3</li><li>然后遍历到100，之前的元素有[10,9,2,5,3,7]比100小，这些数中dp最大的是7，dp为3，所以100的dp[6]=4</li><li>然后遍历到18，之前的元素有[10,9,2,5,3,7]比18小，这些数中dp最大的是7，dp为3，所以dp[7]=4</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lengthOfLIS</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> nums:<span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="comment">#dp[i]以nums[i]为结尾的最长上升子序列</span></span><br><span class="line">        n = len(nums)</span><br><span class="line">        dp = [<span class="number">1</span> <span class="keyword">for</span> _ <span class="keyword">in</span> range(n)]</span><br><span class="line">        <span class="comment">#对于第i个数有2个选择：选，不选</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,n):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">0</span>,i):</span><br><span class="line">                <span class="keyword">if</span> nums[j] &lt; nums[i]:</span><br><span class="line">                    dp[i] = max(dp[i],dp[j]+<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> max(dp)</span><br></pre></td></tr></table></figure><ul><li>时间复杂度：O(n^2)</li><li>空间复杂度：O(n)</li></ul><p>【优化】</p><ul><li>时间复杂度：O(nlogn)</li><li>空间复杂度：O(n)</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lengthOfLIS</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> nums:<span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        n = len(nums)</span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">1</span>:<span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        last = [nums[<span class="number">0</span>],]</span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> nums[<span class="number">1</span>:n]:<span class="comment">#遍历nums中每个元素</span></span><br><span class="line">            <span class="keyword">if</span> num &gt; last[<span class="number">-1</span>]:<span class="comment">#如果nums大于last中所有元素，插入到last的末尾</span></span><br><span class="line">                last.append(num)</span><br><span class="line">                <span class="keyword">continue</span><span class="comment">#遍历下一个元素</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">#如果num&lt;=last中的元素，则将num替换掉比num大的最小的元素</span></span><br><span class="line">            left,right = <span class="number">0</span>,len(last)<span class="number">-1</span></span><br><span class="line">            <span class="keyword">while</span> left &lt; right:</span><br><span class="line">                mid = left+(right-left)/<span class="number">2</span></span><br><span class="line">                <span class="keyword">if</span> last[mid] &lt; num:</span><br><span class="line">                    left = mid+<span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    right = mid</span><br><span class="line">            last[left] = num</span><br><span class="line">        <span class="keyword">return</span> len(last)</span><br></pre></td></tr></table></figure><h2><span id="无重叠区间">无重叠区间</span></h2><h1><span id="动态规划博弈问题">动态规划—博弈问题</span></h1><h2><span id="石子游戏">石子游戏</span></h2><p>亚历克斯和李用几堆石子在做游戏。偶数堆石子排成一行，每堆都有正整数颗石子 piles[i] 。</p><p>游戏以谁手中的石子最多来决出胜负。石子的总数是奇数，所以没有平局。</p><p>亚历克斯和李轮流进行，亚历克斯先开始。 每回合，玩家从行的开始或结束处取走整堆石头。 这种情况一直持续到没有更多的石子堆为止，此时手中石子最多的玩家获胜。</p><p>假设亚历克斯和李都发挥出最佳水平，当亚历克斯赢得比赛时返回 true ，当李赢得比赛时返回 false 。</p><blockquote><p>示例：<br>输入：[5,3,4,5]<br>输出：true<br>解释：<br>亚历克斯先开始，只能拿前 5 颗或后 5 颗石子 。<br>假设他取了前 5 颗，这一行就变成了 [3,4,5] 。<br>如果李拿走前 3 颗，那么剩下的是 [4,5]，亚历克斯拿走后 5 颗赢得 10 分。<br>如果李拿走后 5 颗，那么剩下的是 [3,4]，亚历克斯拿走后 4 颗赢得 9 分。<br>这表明，取前 5 颗石子对亚历克斯来说是一个胜利的举动，所以我们返回 true 。</p></blockquote><p>链接：<a href="https://leetcode-cn.com/problems/stone-game" target="_blank" rel="noopener">https://leetcode-cn.com/problems/stone-game</a></p><p><strong>【分析一】</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">stoneGame</span><span class="params">(self, piles)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type piles: List[int]</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        n = len(piles)</span><br><span class="line">        dp = [[<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> range(n)] <span class="keyword">for</span> _ <span class="keyword">in</span> range(n+<span class="number">1</span>)]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">            dp[i][i] = piles[i]</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n<span class="number">-1</span>,<span class="number">-1</span>,<span class="number">-1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(i+<span class="number">1</span>,n):</span><br><span class="line">                dp[i][j] = max(piles[i]-dp[i+<span class="number">1</span>][j],piles[j]-dp[i][j<span class="number">-1</span>])</span><br><span class="line">        <span class="keyword">if</span> dp[<span class="number">0</span>][n<span class="number">-1</span>]&lt;<span class="number">0</span>:<span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">        <span class="keyword">else</span>:<span class="keyword">return</span> <span class="keyword">True</span></span><br></pre></td></tr></table></figure><h2><span id="预测赢家">预测赢家</span></h2><p>给定一个表示分数的非负整数数组。 玩家1从数组任意一端拿取一个分数，随后玩家2继续从剩余数组任意一端拿取分数，然后玩家1拿，……。每次一个玩家只能拿取一个分数，分数被拿取之后不再可取。直到没有剩余分数可取时游戏结束。最终获得分数总和最多的玩家获胜。</p><p>给定一个表示分数的数组，预测玩家1是否会成为赢家。你可以假设每个玩家的玩法都会使他的分数最大化。</p><blockquote><p>示例 1:<br>输入: [1, 5, 2]<br>输出: False<br>解释: 一开始，玩家1可以从1和2中进行选择。<br>如果他选择2（或者1），那么玩家2可以从1（或者2）和5中进行选择。如果玩家2选择了5，那么玩家1则只剩下1（或者2）可选。<br>所以，玩家1的最终分数为 1 + 2 = 3，而玩家2为 5。<br>因此，玩家1永远不会成为赢家，返回 False。</p></blockquote><p>链接：<a href="https://leetcode-cn.com/problems/predict-the-winner" target="_blank" rel="noopener">https://leetcode-cn.com/problems/predict-the-winner</a></p><p><strong>【分析一】</strong></p><p><code>dp[i][j]</code>表示在<code>nums[i,...,j]</code>中，当前人（不一定是先手）与另一个人总数的最大分差。<br>对于<code>nums[i,...,j]</code>这些数字，当前操作人可以选择<code>nums[i]</code>，也可以选择<code>nums[j]</code></p><ul><li>当前人选择<code>nums[i]</code>,留给对手的是<code>nums[i+1,...,j]</code>，减去对手在<code>dp[i+1][j]</code>的领先，就是当前人的领先</li><li>当前人选择<code>nums[j]</code>，留给对手的是<code>nums[i,...,j-1]</code>，减去对手在<code>dp[i][j-1]</code>的领先，就是当前人的领先</li><li>在这2个领先中取最大的那个<br><code>dp[i][j]-max(nums[i]-dp[i+1][j],nums[j]-dp[i][j-1])</code></li></ul><p>因为在计算<code>dp[i][j]</code>时需要用到<code>dp[i+1][j]</code>和<code>dp[i][j-1]</code>，所以需要计算<code>dp[i+1]</code>，即i要从后往前遍历，<code>d[j-1]</code>，j要从前往后遍历。并且<code>j&gt;=i</code></p><p>初始化<br><code>dp[i][i]=nums[i]</code>，表示当前人只剩下<code>nums[i]</code>可以选择，对手没有数可以选择，所以最差分差为<code>nums[i]</code></p><ul><li>时间复杂度：O(n2)</li><li>空间复杂度：O(n2)</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">PredictTheWinner</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        n = len(nums)</span><br><span class="line">        <span class="comment">#这里的行为n+1，是为了状态转移时i+1越界</span></span><br><span class="line">        dp = [[<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> range(n)] <span class="keyword">for</span> _ <span class="keyword">in</span> range(n+<span class="number">1</span>)]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">            dp[i][i] = nums[i]</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n<span class="number">-1</span>,<span class="number">-1</span>,<span class="number">-1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(i+<span class="number">1</span>,n):</span><br><span class="line">                dp[i][j] = max(nums[i]-dp[i+<span class="number">1</span>][j],nums[j]-dp[i][j<span class="number">-1</span>])</span><br><span class="line">        <span class="keyword">if</span> dp[<span class="number">0</span>][n<span class="number">-1</span>]&lt;<span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">True</span></span><br></pre></td></tr></table></figure><h1><span id="11-总结">11. 总结</span></h1><ol><li><p>动态规划的思路是自底向上，先从最基本最简单的问题出发，逐步计算中间过程，最后得到需要求的解。<br>动态规划要求“后无效性”，即dp[i]依赖dp的某个值，这个值必须在dp[i]之前已经被正确求出来。<br>在做动态规划问题时，需要考虑以下问题</p><ul><li>状态<br>首先定义状态，看看题目问的问题可不可以作为状态。哪个状态方便转移就定义哪个状态</li><li>状态转移方程<br>其实就是多个问题找最优解。将当前问题分解成多个子问题，找出子问题的解，然后再从子问题中找出最优解</li><li>初始化<br>对dp进行初始化</li><li>返回结果<br>通过求解dp，思考怎么返回最终的结果，有些问题并不是返回dp[-1]</li><li>优化空间<br>写完代码之后，看一下是否可以优化空间，即表格，数组复用。观察状态转移矩阵，看看是否有些dp在用了之后就不再用到，可以使用变量来代替数据<br>多练习0-1背包问题</li></ul></li><li><p>动态规划在求子序列，子数组，例如最大子序列和，最大子序列乘积等问题时，状态dp[i]为以i为结尾的最大值。这是一个经验。</p></li><li><p>在给定的数组中，找最大利益或达到某个值，这类问题可以被归为背包问题。</p><ul><li>第一层for遍历数组</li><li>第二层遍历背包容量</li><li>然后找出状态转移方程。背包问题需要注意初始化的值，例如f[0],f[nums[0]]的初始值。</li></ul></li><li><p>动态规划和贪心的区别<br>动态规划简单点说就是填写表格，用表格记录以前问题的最优解。可以用二层for循环实现。动态规划就是用空间换时间，避免子问题重复计算。<br>贪心算法不需要填表，只着眼于当前最优的解。<br>时间复杂度：暴力&gt;动态规划&gt;贪心</p></li><li>博弈问题一般都是涉及2个聪明人</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;1-动态规划&quot;&gt;&lt;a href=&quot;#1-动态规划&quot; class=&quot;headerlink&quot; title=&quot;1. 动态规划&quot;&gt;&lt;/a&gt;1. 动态规划&lt;/h1&gt;&lt;p&gt;如果是求一个问题的最优解（通常是最大值或最小值），而且该问题可以分解成若干个子问题，并且子问题之间还有重叠的更小的子问题，可以考虑使用动态规划。&lt;/p&gt;
&lt;p&gt;在解决动态规划问题时，需要分解成子问题，这里需要将子问题的最优解保存下来（一般是一维或二维数组），作为求取大问题最优解的基础。&lt;/p&gt;
&lt;p&gt;做动态规划的三个关键：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;dp[i]表示什么意思（如果二维，dp[i][j]）&lt;/li&gt;
&lt;li&gt;根据dp[i]和dp[i-1]的关系写出状态转移矩阵&lt;/li&gt;
&lt;li&gt;确定初始条件，dp[0]&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode之回溯</title>
    <link href="http://yoursite.com/2020/06/06/Leetcode%E4%B9%8B%E5%9B%9E%E6%BA%AF/"/>
    <id>http://yoursite.com/2020/06/06/Leetcode之回溯/</id>
    <published>2020-06-06T02:41:31.000Z</published>
    <updated>2020-06-18T02:35:03.769Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><!-- TOC --><ul><li><a href="#1-回溯">1. 回溯</a></li><li><a href="#2-矩阵中单词路径搜索">2. 矩阵中单词路径搜索</a></li><li><a href="#3-机器人的运动范围">3. 机器人的运动范围</a></li><li><a href="#4-全排列">4. 全排列</a></li><li><a href="#5-全排列-ii">5. 全排列 II</a></li><li><a href="#6-组合">6. 组合</a></li><li><a href="#7-组合总和">7. 组合总和</a></li><li><a href="#8-组合总和-ii">8. 组合总和 II</a></li><li><a href="#9-组合总和-iii">9. 组合总和 III</a></li><li><a href="#10-括号生成">10. 括号生成</a></li><li><a href="#11-n皇后">11. N皇后</a></li><li><a href="#12-总结">12. 总结</a></li></ul><!-- /TOC --><h1><span id="1-回溯">1. 回溯</span></h1><p>回溯可以看做是暴力法的升级。回溯法非常适合由多个步骤组成的问题，每个步骤都有多个选项。当我们在某一步选择了其中一个选项时，就进入到下一步，然后又面临新的选项，就这样重读选择，直至达到最终的状态。</p><p>回溯问题可以理解成在一个树上进行深度优先遍历。例如给定[1,2,3]，求一共有多少种组合。第一个数字可以是1,2,3，有3种选择。然后第二个数字有2种选择，第三个数字有1个选择。<br>回溯就是在这个树上进行深度遍历时，从较深的节点层返回较浅的节点层，需要将状态回复到过去，这个恢复的过程就是“回溯”<br>回溯算法一般用递归实现。回溯算法的时间复杂度很高，因此在遍历时，如果能提前直到这一分支不可能达到满意的结果，就可以提前结束，这一操作称为“剪枝”<br>回溯+剪枝可以加快搜索速度，在这之前，一般需要做一些预处理工作来达到剪枝的目的，例如排序。但这会节省很多剪枝的时间。在回溯+剪枝时，因为时间复杂度很高，所以能用空间换时间就尽量用空间，来减少时间的消耗。</p><p><img src="/2020/06/06/Leetcode之回溯/1.png" alt=""></p><p>做回溯问题时，最好先画图，考虑以下问题</p><ul><li>分支如何产生</li><li>题目需要的解在哪里，是在叶子节点，还是非叶子节点，还是在从根节点到叶子节点的路径上</li><li>哪些搜索会产生不必要的解，如果知道这个分支会产生不必要的解，应该做剪枝，剪枝的条件是什么，代码怎么写。</li></ul><p><img src="/2020/06/06/Leetcode之回溯/3.png" alt=""></p><p>在二维矩阵寻找路径的问题，基本都可以用回溯解决</p><p>【参考资料】</p><p><a href="https://leetcode-cn.com/problems/permutations/solution/hui-su-suan-fa-python-dai-ma-java-dai-ma-by-liweiw/" target="_blank" rel="noopener">从全排列问题开始理解「回溯」算法</a></p><p><a href="https://leetcode-cn.com/problems/permutations/solution/hui-su-suan-fa-xiang-jie-by-labuladong-2/" target="_blank" rel="noopener">扒一扒回溯算法的裤子</a></p><p><strong>【回溯算法模板】</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">result = []</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">backtrack</span><span class="params">(路径, 选择列表)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> 满足结束条件:</span><br><span class="line">        result.add(路径)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> 选择 <span class="keyword">in</span> 选择列表:</span><br><span class="line">        做选择</span><br><span class="line">        backtrack(路径, 选择列表)</span><br><span class="line">        撤销选择  <span class="comment">#在递归后撤销选择</span></span><br></pre></td></tr></table></figure><h1><span id="2-矩阵中单词路径搜索">2. 矩阵中单词路径搜索</span></h1><p>请设计一个函数，用来判断在一个矩阵中是否存在一条包含某字符串所有字符的路径。路径可以从矩阵中的任意一格开始，每一步可以在矩阵中向左、右、上、下移动一格。如果一条路径经过了矩阵的某一格，那么该路径不能再次进入该格子。例如，在下面的3×4的矩阵中包含一条字符串“bfce”的路径（路径中的字母用加粗标出）。</p><p>[[“a”,”<strong>b</strong>“,”c”,”e”],</p><p>[“s”,”<strong>f</strong>“,”<strong>c</strong>“,”s”],</p><p>[“a”,”d”,”<strong>e</strong>“,”e”]]</p><p>但矩阵中不包含字符串“abfb”的路径，因为字符串的第一个字符b占据了矩阵中的第一行第二个格子之后，路径不能再次进入这个格子。</p><p>链接：<a href="https://leetcode-cn.com/problems/ju-zhen-zhong-de-lu-jing-lcof" target="_blank" rel="noopener">https://leetcode-cn.com/problems/ju-zhen-zhong-de-lu-jing-lcof</a></p><p><strong>【分析】</strong></p><p>使用深度有限搜索DFS+回溯方法来解决</p><p>深度优先搜索：先找到一个可能的方向，朝这个方向搜到底，如果不满足，再回溯到上一个节点，沿这个方向搜索<br>回溯：在搜索中，遇到这条路不可能和目标字符串匹配的情况，则返回</p><p>这道题使用递归</p><ul><li>递归的参数：当前元素在board的位置<code>board[i][j]</code>,当前需要匹配的字符<code>word[k]</code></li><li>递归终止条件<ul><li>返回false：i和j越界，当前元素board[i][j]和board[k]不相等，当前元素board[i][j]已经被访问过</li><li>返回true：字符串word已经全部匹配，即k=len(word)-1<br>递推工作：</li></ul></li></ul><ol><li>标记当前元素已经被访问过</li><li>搜索board[i][j]的上下左右4个方向，是否和board[k+1]匹配</li><li>如果匹配，返回True，如果都不匹配，回溯，说明当前元素board[i][j]行不通，将其标记为未采纳该节点</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">exist</span><span class="params">(self, board, word)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type board: List[List[str]]</span></span><br><span class="line"><span class="string">        :type word: str</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        rows,cols = len(board),len(board[<span class="number">0</span>])</span><br><span class="line">        <span class="comment">#标记当前是否被访问</span></span><br><span class="line">        visit = [[<span class="number">0</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(cols)] <span class="keyword">for</span> i <span class="keyword">in</span> range(rows)]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(rows):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(cols):</span><br><span class="line">                <span class="keyword">if</span> board[i][j] == word[<span class="number">0</span>]:</span><br><span class="line">                    <span class="keyword">if</span> self.dfs(i,j,<span class="number">0</span>,board,word,visit):<span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(self,i,j,k,board,word,visit)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        board[i][j]</span></span><br><span class="line"><span class="string">        word[k]</span></span><br><span class="line"><span class="string">        判断board[i][j]和word[k]是否匹配，如果匹配，则判断board[i][j]的下一个元素和word[k+1]是否匹配</span></span><br><span class="line"><span class="string">        如果不匹配，直接返回false</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="comment">#递归结束的条件</span></span><br><span class="line">        <span class="comment">#1.board[i][j]已经访问过，返回false</span></span><br><span class="line">        <span class="comment">#2.board[i][j]与word[k]不相等，返回false</span></span><br><span class="line">        <span class="comment">#3.board[i][j]超出索引，返回false</span></span><br><span class="line">        <span class="comment">#4.word已全部匹配，即k=len(word)-1</span></span><br><span class="line">        deltas = [[<span class="number">0</span>,<span class="number">1</span>],[<span class="number">0</span>,<span class="number">-1</span>],[<span class="number">1</span>,<span class="number">0</span>],[<span class="number">-1</span>,<span class="number">0</span>]]</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> <span class="number">0</span> &lt;= i &lt; len(board) <span class="keyword">or</span> <span class="keyword">not</span> <span class="number">0</span> &lt;= j &lt; len(board[<span class="number">0</span>]) <span class="keyword">or</span> board[i][j]!= word[k] <span class="keyword">or</span> visit[i][j] == <span class="number">1</span>:<span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">        <span class="keyword">if</span> k == len(word)<span class="number">-1</span>:<span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">        visit[i][j] = <span class="number">1</span><span class="comment">#board[i][j]和word[k]匹配</span></span><br><span class="line">        <span class="keyword">for</span> delta <span class="keyword">in</span> deltas:<span class="comment">#搜索board的上下左右是否和word[k+1]匹配</span></span><br><span class="line">            next_i = i+delta[<span class="number">0</span>]</span><br><span class="line">            next_j = j+delta[<span class="number">1</span>]</span><br><span class="line">            <span class="keyword">if</span> self.dfs(next_i,next_j,k+<span class="number">1</span>,board,word,visit):<span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">        visit[i][j] = <span class="number">0</span><span class="comment">#上下左右都不匹配，回溯        </span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">False</span></span><br></pre></td></tr></table></figure><h1><span id="3-机器人的运动范围">3. 机器人的运动范围</span></h1><p>地上有一个m行n列的方格，从坐标 [0,0] 到坐标 [m-1,n-1] 。一个机器人从坐标 [0, 0] 的格子开始移动，它每次可以向左、右、上、下移动一格（不能移动到方格外），也不能进入行坐标和列坐标的数位之和大于k的格子。例如，当k为18时，机器人能够进入方格 [35, 37] ，因为3+5+3+7=18。但它不能进入方格 [35, 38]，因为3+5+3+8=19。请问该机器人能够到达多少个格子？</p><p>链接：<a href="https://leetcode-cn.com/problems/ji-qi-ren-de-yun-dong-fan-wei-lcof" target="_blank" rel="noopener">https://leetcode-cn.com/problems/ji-qi-ren-de-yun-dong-fan-wei-lcof</a></p><ul><li>深度优先搜索+回溯</li><li>用队列实现广度优先搜索</li></ul><p><strong>【方法一】</strong><br>深度优先搜搜+回溯<br>使用visit记录m行n列矩阵的遍历情况。</p><ul><li>递归的参数：当前元素在board的位置<code>[i][j]</code></li><li>递归终止条件<ul><li>返回0（当前元素没有被访问）：i和j越界，i和j位数和大于k，当前元素[i][j]已经被访问过，</li></ul></li></ul><p>递推工作：</p><ol><li>当前元素符合条件，标记当前元素已经被访问过</li><li>搜索[i][j]的上下左右4个方向，记录每个方向走过的格子个数，</li><li>返回结果+1，表示除了4个方向访问的格子，还要加上当前访问的格子[i][j]</li></ol><p>优化：</p><ul><li>其实只需要访问下和右2个方向就可以了，不需要访问4个方向</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">movingCount</span><span class="params">(self, m, n, k)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type m: int</span></span><br><span class="line"><span class="string">        :type n: int</span></span><br><span class="line"><span class="string">        :type k: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="comment">#时间复杂度：O(mn)</span></span><br><span class="line">        <span class="comment">#空间复杂度：O(mn),visit数组</span></span><br><span class="line">        <span class="comment">#优化：搜索反向其实只用向下和向右就可以了</span></span><br><span class="line">        visit = [[<span class="number">0</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(n)] <span class="keyword">for</span> j <span class="keyword">in</span> range(m)]</span><br><span class="line">        all_sum = self.dfs(<span class="number">0</span>,<span class="number">0</span>,m,n,k,visit)</span><br><span class="line">        <span class="keyword">return</span> all_sum</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(self,i,j,m,n,k,visit)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        i和j表示机器人当前的格子</span></span><br><span class="line"><span class="string">        m和n，k是题目给定的参数</span></span><br><span class="line"><span class="string">        visit记录遍历情况</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        deltas = [[<span class="number">0</span>,<span class="number">1</span>],[<span class="number">0</span>,<span class="number">-1</span>],[<span class="number">1</span>,<span class="number">0</span>],[<span class="number">-1</span>,<span class="number">0</span>]]</span><br><span class="line">        <span class="comment">#递归结束的条件</span></span><br><span class="line">        <span class="comment">#1.i和j超过范围</span></span><br><span class="line">        <span class="comment">#2.i和j的位数之和超过k</span></span><br><span class="line">        <span class="comment">#3.i和j已经被访问过</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> <span class="number">0</span>&lt;=i&lt;m <span class="keyword">or</span> <span class="keyword">not</span> <span class="number">0</span>&lt;=j&lt;n <span class="keyword">or</span> self.digit_sum(i)+self.digit_sum(j)&gt;k <span class="keyword">or</span> visit[i][j]==<span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        visit[i][j] = <span class="number">1</span></span><br><span class="line">        all_sum = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> delta <span class="keyword">in</span> deltas:</span><br><span class="line">            next_i = i + delta[<span class="number">0</span>]</span><br><span class="line">            next_j = j + delta[<span class="number">1</span>]</span><br><span class="line">            all_sum += self.dfs(next_i,next_j,m,n,k,visit)</span><br><span class="line">        <span class="keyword">return</span> all_sum + <span class="number">1</span><span class="comment">#加1是为了加上当前访问的格子i,j</span></span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">digit_sum</span><span class="params">(self,i)</span>:</span></span><br><span class="line">        all_sum = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> i &gt; <span class="number">0</span>:</span><br><span class="line">            all_sum += i%<span class="number">10</span></span><br><span class="line">            i /= <span class="number">10</span></span><br><span class="line">        <span class="keyword">return</span> all_sum</span><br></pre></td></tr></table></figure><p><strong>【方法二】</strong></p><p>广度优先遍历BFS</p><p>queue中保存当前待检测的格子，里面保存的值有4个元素(i,j,sum_i,sum_j)，分别表示：当前格子的下标i和j，下标的位数</p><p>因为机器人要求从(0,0)出发，所以首先将(0,0,0,0)加入到queue中，遍历第一个格子，判断当前格式是否符合要求，如果不符合要求，则遍历下一个格子。如果符合要求，将当前格子(i,j)加入到visit中，然后将该格子的下和右格子加入队列中，等待遍历。最终返回visit的长度即为访问的格子数量</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">movingCount</span><span class="params">(self, m, n, k)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type m: int</span></span><br><span class="line"><span class="string">        :type n: int</span></span><br><span class="line"><span class="string">        :type k: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        queue = [(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>)]<span class="comment">#当前元素的位置i,j和位数和</span></span><br><span class="line">        visit = set()</span><br><span class="line">        <span class="keyword">while</span> queue:</span><br><span class="line">            i,j,sum_i,sum_j = queue.pop(<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> <span class="number">0</span>&lt;=i&lt;m <span class="keyword">or</span> <span class="keyword">not</span> <span class="number">0</span>&lt;=j&lt;n <span class="keyword">or</span> sum_i+sum_j&gt;k <span class="keyword">or</span> (i,j) <span class="keyword">in</span> visit:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            visit.add((i,j))</span><br><span class="line">            queue.append((i+<span class="number">1</span>,j,self.digit_sum(i+<span class="number">1</span>),sum_j))</span><br><span class="line">            queue.append((i,j+<span class="number">1</span>,sum_i,self.digit_sum(j+<span class="number">1</span>)))</span><br><span class="line">        <span class="keyword">return</span> len(visit)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">digit_sum</span><span class="params">(self,i)</span>:</span></span><br><span class="line">        all_sum = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> i &gt; <span class="number">0</span>:</span><br><span class="line">            all_sum += i%<span class="number">10</span></span><br><span class="line">            i /= <span class="number">10</span></span><br><span class="line">        <span class="keyword">return</span> all_sum</span><br></pre></td></tr></table></figure><h1><span id="4-全排列">4. 全排列</span></h1><p>给定一个 <strong>没有重复 数字</strong>的序列，返回其所有可能的全排列。</p><blockquote><p>输入: [1,2,3]<br>输出:<br>[<br>  [1,2,3],<br>  [1,3,2],<br>  [2,1,3],<br>  [2,3,1],<br>  [3,1,2],<br>  [3,2,1]<br>]</p></blockquote><p>链接：<a href="https://leetcode-cn.com/problems/permutations" target="_blank" rel="noopener">https://leetcode-cn.com/problems/permutations</a></p><p><strong>【分析】</strong></p><p><img src="/2020/06/06/Leetcode之回溯/1.png" alt=""></p><ol><li>这棵树中，除了根节点和叶子节点，其余节点做的事情都一样，都是在还未选择的数字中选一个数，可以用递归实现</li><li>递归结束条件：当递归到树的最后一层时，需要一个变量<code>depth</code>来记录当前遍历到树的第几层</li></ol><p>本题要点</p><ul><li><code>depth</code>：记录当前递归遍历到树的层数</li><li><code>path=[]</code>，记录当前路径中的节点，例如path=[1,2,3]，当下一层选择节点4时，将4添加到path中，path=[1,2,3,4]，然后在回溯的过程中，撤销4的选择，也需要修改path=[1,2,3]，然后再选择3的其他子孩子，例如path=[1,2,3,5]</li><li><code>visit=[]</code>：记录<code>path</code>中哪些数据没有被遍历过。path=[1,2]，则visit[1]=ture,visit[2]=true，剩余没被遍历的节点为false，这样在path考虑下一个数字时，可以直接从visit为false的数字中选择。</li><li>在path选择下一个节点时，visit中有多个未被访问的节点，使用循环遍历visit中所有未被访问的节点。</li><li><code>res</code>：记录所有的组合结果，例如[[1,2,3],[1,3,2],…]</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">permutation</span><span class="params">(self, s)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type s: str</span></span><br><span class="line"><span class="string">        :rtype: List[str]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(depth)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> depth == len(s):</span><br><span class="line">                res.append(<span class="string">''</span>.join(path[:]))</span><br><span class="line">                <span class="keyword">return</span> </span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(len(s)):</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> visit[i]:</span><br><span class="line">                    visit[i]=<span class="keyword">True</span></span><br><span class="line">                    path.append(s[i])</span><br><span class="line">                    dfs(depth+<span class="number">1</span>)</span><br><span class="line">                    visit[i]=<span class="keyword">False</span></span><br><span class="line">                    path.pop()</span><br><span class="line">        res,path = [],[]</span><br><span class="line">        visit = [<span class="keyword">False</span> <span class="keyword">for</span> _ <span class="keyword">in</span> range(len(s))]</span><br><span class="line">        dfs(depth=<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h1><span id="5-全排列-ii">5. 全排列 II</span></h1><p>给定一个可包含<strong>重复数字</strong>的序列，返回所有不重复的全排列。</p><p>示例:</p><p>输入: [1,1,2]<br>输出:<br>[<br>  [1,1,2],<br>  [1,2,1],<br>  [2,1,1]<br>]</p><p>链接：<a href="https://leetcode-cn.com/problems/permutations-ii" target="_blank" rel="noopener">https://leetcode-cn.com/problems/permutations-ii</a></p><p><strong>【分析一】</strong></p><ul><li><code>depth</code>：记录当前递归遍历到树的层数</li><li><code>path=[]</code>，记录当前路径中的节点，例如path=[a,b,c]</li><li><code>visit=[]</code>：记录<code>path</code>中哪些数据没有被遍历过。path=[a,b]，则visit[1]=ture,visit[2]=true，剩余没被遍历的节点为false，这样在path考虑下一个节点时，可以直接从visit为false的节点中选择。</li><li>在path选择下一个节点时，visit中有多个未被访问的节点，使用循环遍历visit中所有未被访问的节点。</li><li><code>res</code>：记录所有的组合结果，例如[abc],[acb],…]</li></ul><p>depth = 0时，处于第一层[]，depth=3时，说明已经将所有的字母都加入到path中，然后将当前path加入到res中</p><p><strong>一般都是在递归的后面进行回溯</strong>,例如在<code>dfs</code>中，递归函数后，使用<code>visit[i]=False,path.pop()</code>进行回溯</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">              []</span><br><span class="line">    a          <span class="keyword">b </span>           c</span><br><span class="line"> ab  ac     <span class="keyword">ba </span>  <span class="keyword">bc </span>    ca    cb</span><br><span class="line"><span class="symbol">abc</span>  acb   <span class="keyword">bac </span>  <span class="keyword">bca </span>   cab   cba</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">permutation</span><span class="params">(self, s)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type s: str</span></span><br><span class="line"><span class="string">        :rtype: List[str]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(depth)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> depth == len(s):</span><br><span class="line">                res.append(<span class="string">''</span>.join(path[:]))</span><br><span class="line">                <span class="keyword">return</span> </span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(len(s)):</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> visit[i]:</span><br><span class="line">                    visit[i]=<span class="keyword">True</span></span><br><span class="line">                    path.append(s[i])</span><br><span class="line">                    dfs(depth+<span class="number">1</span>)</span><br><span class="line">                    visit[i]=<span class="keyword">False</span></span><br><span class="line">                    path.pop()</span><br><span class="line">        res,path = [],[]</span><br><span class="line">        visit = [<span class="keyword">False</span> <span class="keyword">for</span> _ <span class="keyword">in</span> range(len(s))]</span><br><span class="line">        dfs(depth=<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> list(set(res))</span><br></pre></td></tr></table></figure><p><strong>【分析二】</strong></p><p>上面那个方法没有对重复元素进行判断，只在最后返回值时将list转换为set进行去重，如果数组中全是重复元素，且个数较多，例如[aaaaaaaaaaaaaaaaaaaaaaaaaa……]，那么就会非常耗时。下面对此进行改进。<br>首先需要对s进行排序，然后在<code>dfs</code>中对s进行遍历时，如果当前元素没有被访问，判断当前元素和前一个元素是否相等，且前一个元素已经遍历完成，且被撤销了。<br>这里<code>not visit[i-1]</code>的理解如下：当前数组为[1,1,2]，为了区分这2个1，写成[1,1’,2]。首先第一次选择1，会形成2个组合[1,1’,2]和[1,2,1’]，将这2个组合加入到res中，然后回溯，依次将visit[1’]=false,visit[2]=false,visit[1]=false。然后在进行下一次循环时，第一个数据选中1<code>，此时的s[i]=1&#39;和s[i-1]=1相等，且前面的1已经完成组合和回溯，visit[i-1]==false，这就说明此时的1&#39;可以不用遍历了。如果不加</code>not visit[i-1]`，那么就会在第一个分支中的[1,1’]中，遍历到1’，和上一个元素1相同，就会continue。但当前的visit[1]=true，数字1还没有完成回溯，还需要继续进行。</p><p><img src="/2020/06/06/Leetcode之回溯/2.png" alt=""></p><p>要点</p><ul><li><strong>先对nums进行排序，<code>nums=sorted(nums)</code></strong></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">permuteUnique</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: List[List[int]]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(depth)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> depth == len(nums):</span><br><span class="line">                res.append(path[:])</span><br><span class="line">                <span class="keyword">return</span> </span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums)):</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> visit[i]:<span class="comment">#当前字符为访问，理论上来说可以把该字符加入到path中</span></span><br><span class="line">                    <span class="comment">#但是如果当前字符和前一个字符一样，说明当前字符是重复字符</span></span><br><span class="line">                    <span class="comment">#并且visit[i-1]为false表示前面那个相同的字符之前被访问到根节点，然后被撤销</span></span><br><span class="line">                    <span class="keyword">if</span> i&gt;<span class="number">0</span> <span class="keyword">and</span> nums[i]==nums[i<span class="number">-1</span>] <span class="keyword">and</span> <span class="keyword">not</span> visit[i<span class="number">-1</span>]:</span><br><span class="line">                        <span class="keyword">continue</span></span><br><span class="line">                    visit[i]=<span class="keyword">True</span></span><br><span class="line">                    path.append(nums[i])</span><br><span class="line">                    dfs(depth+<span class="number">1</span>)</span><br><span class="line">                    visit[i] = <span class="keyword">False</span></span><br><span class="line">                    path.pop()</span><br><span class="line">        res,path = [],[]</span><br><span class="line">        visit = [<span class="keyword">False</span> <span class="keyword">for</span> _ <span class="keyword">in</span> range(len(nums))]</span><br><span class="line">        nums = sorted(nums)</span><br><span class="line">        dfs(depth=<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h1><span id="6-组合">6. 组合</span></h1><p>给定两个整数 n 和 k，返回 1 … n 中所有可能的 k 个数的组合。</p><p>示例:</p><p>输入: n = 4, k = 2<br>输出:<br>[<br>  [2,4],<br>  [3,4],<br>  [2,3],<br>  [1,2],<br>  [1,3],<br>  [1,4],<br>]</p><p>链接：<a href="https://leetcode-cn.com/problems/combinations" target="_blank" rel="noopener">https://leetcode-cn.com/problems/combinations</a></p><p><strong>【分析一】</strong></p><p>分析可以发现，第一个选择的数假设为1，第二个选择数要严格大于第一个数，当path的长度为k时，结束递归。</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">                    []</span><br><span class="line">    <span class="number">1</span>                 <span class="number">2</span>              <span class="number">3</span>              <span class="number">4</span>    </span><br><span class="line"><span class="number">12</span>   <span class="number">13</span>  <span class="number">14</span>        <span class="number">23</span>    <span class="number">24</span>          <span class="number">34</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">combine</span><span class="params">(self, n, k)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type n: int</span></span><br><span class="line"><span class="string">        :type k: int</span></span><br><span class="line"><span class="string">        :rtype: List[List[int]]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(res,path)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> len(path) == k:</span><br><span class="line">                res.append(path[:])</span><br><span class="line">                <span class="keyword">return</span> </span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,n+<span class="number">1</span>):<span class="comment">#依次选择</span></span><br><span class="line">                <span class="keyword">if</span> len(path)&gt;<span class="number">0</span> <span class="keyword">and</span> i &lt;= path[<span class="number">-1</span>]:<span class="comment">#只选择比path中大的数,如果&lt;=path[-1]，则继续遍历下一个数</span></span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                path.append(i)</span><br><span class="line">                dfs(res,path)</span><br><span class="line">                path.pop()</span><br><span class="line">        </span><br><span class="line">        res,path = [],[]</span><br><span class="line">        dfs(res,path)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><p><strong>【优化一】</strong><br>对上一种方法进行优化，上一种方法中for循环遍历时，从1开始遍历，然后再使用if语句判断是否比path中的数大。这里改为在for循环中，只遍历比path大的数，即使用start来标识for从哪里开始，这样for出来的数肯定比path中大，不用再使用if语句判断。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">combine</span><span class="params">(self, n, k)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type n: int</span></span><br><span class="line"><span class="string">        :type k: int</span></span><br><span class="line"><span class="string">        :rtype: List[List[int]]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(start,res,path)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> len(path) == k:</span><br><span class="line">                res.append(path[:])</span><br><span class="line">                <span class="keyword">return</span> </span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(start,n+<span class="number">1</span>):</span><br><span class="line">                path.append(i)</span><br><span class="line">                dfs(i+<span class="number">1</span>,res,path)</span><br><span class="line">                path.pop()</span><br><span class="line">        </span><br><span class="line">        res,path = [],[]</span><br><span class="line">        dfs(<span class="number">1</span>,res,path)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><p><strong>【优化二】</strong></p><p>在for循环中，不但可以对开始位置进行剪枝，还可以对结束位置进行剪枝。原先i的取值为[start,n]，但其实在递归中，并不是每次递归i都会取到n，i有一个上限。<br>下面来找规律，如果n=15，k=4<br>当选定了一个元素，即len(path)=1，接下来还可以再选3个元素，i最大为13，选[13,14,15]<br>当选定了两个元素，即len(path)=2，接下来还可以选2个元素，i最大为14，选[14,15]<br>当选定了三个元素，即len(path)=3，接下来还可以选1个元素，i最大为15，选[15]<br>在每个循环中可以选择的元素个数为<code>k-len(path)</code>，i的最大值分别为13,14,15，即<code>max(i)=n-(k-len(path))+1</code></p><p><img src="/2020/06/06/Leetcode之回溯/4.png" alt=""></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">combine</span><span class="params">(self, n, k)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type n: int</span></span><br><span class="line"><span class="string">        :type k: int</span></span><br><span class="line"><span class="string">        :rtype: List[List[int]]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(start,res,path)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> len(path) == k:</span><br><span class="line">                res.append(path[:])</span><br><span class="line">                <span class="keyword">return</span> </span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(start,n-(k-len(path))+<span class="number">2</span>):</span><br><span class="line">                <span class="comment"># if len(path)&gt;0 and i &lt;= path[-1]:</span></span><br><span class="line">                <span class="comment">#     continue</span></span><br><span class="line">                <span class="comment">#i&gt;path[-1]</span></span><br><span class="line">                path.append(i)</span><br><span class="line">                dfs(i+<span class="number">1</span>,res,path)</span><br><span class="line">                path.pop()</span><br><span class="line">        </span><br><span class="line">        res,path = [],[]</span><br><span class="line">        dfs(<span class="number">1</span>,res,path)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h1><span id="7-组合总和">7. 组合总和</span></h1><p>给定一个<strong>无重复元素</strong>的数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。</p><p>candidates 中的数字可以无限制重复被选取。</p><p>说明：<br>所有数字（包括 target）都是正整数。<br>解集不能包含重复的组合。 </p><p>链接：<a href="https://leetcode-cn.com/problems/combination-sum" target="_blank" rel="noopener">https://leetcode-cn.com/problems/combination-sum</a></p><p><strong>重点</strong></p><ul><li>candidates中没有重复元素</li><li>path中元素可以重复被选取</li></ul><p>输入: candidates = [2,3,6,7], target = 7,<br>所求解集为:<br>[<br>  [7],<br>  [2,2,3]<br>]</p><p><strong>【分析一】</strong></p><p>如果path中的和等于target，则将path加入到res中。</p><ul><li>如果path中数字可以重复选取，则递归中开始下标为i</li><li>如果path中数组不可以重复选取，则递归中开始下标为i+1</li></ul><p>先对candidates从小到大排序，在遍历到当前元素时，如果candidates[i]+sum(path)&gt;target，那后面的元素肯定也不可能了，使用break退出for循环进行剪枝。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">combinationSum</span><span class="params">(self, candidates, target)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type candidates: List[int]</span></span><br><span class="line"><span class="string">        :type target: int</span></span><br><span class="line"><span class="string">        :rtype: List[List[int]]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(start,res,path)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> sum(path)==target:</span><br><span class="line">                res.append(path[:])</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(start,len(candidates)):</span><br><span class="line">                <span class="keyword">if</span> candidates[i]+sum(path)&gt;target:<span class="comment">#剪枝</span></span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">                path.append(candidates[i])</span><br><span class="line">                dfs(i,res,path)</span><br><span class="line">                path.pop()</span><br><span class="line">        candidates = sorted(candidates)</span><br><span class="line">        res,path = [],[]</span><br><span class="line">        dfs(<span class="number">0</span>,res,path)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h1><span id="8-组合总和-ii">8. 组合总和 II</span></h1><p>给定一个数组 candidates 和一个目标数 target ，candidates中<strong>有重复元素</strong>，找出 candidates 中所有可以使数字和为 target 的组合。</p><p>candidates 中的每个数字在每个组合中只能使用一次。</p><p>说明：</p><p>所有数字（包括目标数）都是正整数。<br>解集不能包含重复的组合。 </p><p>链接：<a href="https://leetcode-cn.com/problems/combination-sum-ii" target="_blank" rel="noopener">https://leetcode-cn.com/problems/combination-sum-ii</a></p><p>输入: candidates = [10,1,2,7,6,1,5], target = 8,<br>所求解集为:<br>[<br>  [1, 7],<br>  [1, 2, 5],<br>  [2, 6],<br>  [1, 1, 6]<br>]</p><p><strong>重点</strong></p><ul><li>candidates中有重复元素</li><li>每个数字在path中只能使用一次</li></ul><p>在回溯题中，如果数组中有重复元素，在回溯的过程，需要去重，步骤如下</p><ul><li>先对数组排序，<code>nums = sorted(nums)</code></li><li>在for循环内部，使用<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(start,len(nums)):</span><br><span class="line">    <span class="keyword">if</span> i &gt; statr <span class="keyword">and</span> nums[i]==nums[i<span class="number">-1</span>]:</span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">path.append(nums[i])</span><br><span class="line">dfs(...)</span><br><span class="line">path.pop()</span><br></pre></td></tr></table></figure></li></ul><p>对candidates排完序后为[1,1,2,5,6,7,10]<br><code>i</code>是当前考察元素的下标，<code>start</code>是本层最开始的那个元素下标。<strong>这里的去重是同层去重</strong>，例如下图中，第一层的1和1<em>重复，需要将`1</em><code>去掉。在第一个分支中第一层是1，第二层是</code>1<em><code>，这2个1在不同的层，不需要去重。如果只写成</code>nums[i]==nums[i-1]<code>,在树中处于不同层的相同元素也生成不了。为了保留不同层的相同元素，使用</code>i&gt;start<code>将这种情况排除，因为在不同层第一次出现的数字</code>i=start<code>，而在同一层出现的相同的数字</code>i&gt;start<code>，这样就可以把第一层出现的</code>1</em>`给剪枝掉。</p><p><img src="/2020/06/06/Leetcode之回溯/5.png" alt=""></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">combinationSum2</span><span class="params">(self, candidates, target)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type candidates: List[int]</span></span><br><span class="line"><span class="string">        :type target: int</span></span><br><span class="line"><span class="string">        :rtype: List[List[int]]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(start,res,path)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> sum(path)==target:</span><br><span class="line">                res.append(path[:])</span><br><span class="line">                <span class="keyword">return</span> </span><br><span class="line">            </span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(start,len(candidates)):</span><br><span class="line">                <span class="keyword">if</span> candidates[i]+sum(path)&gt;target:</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">                <span class="keyword">if</span> i &gt; start <span class="keyword">and</span> candidates[i]==candidates[i<span class="number">-1</span>]:</span><br><span class="line">                    <span class="keyword">continue</span> </span><br><span class="line">                path.append(candidates[i])</span><br><span class="line">                dfs(i+<span class="number">1</span>,res,path)</span><br><span class="line">                path.pop()</span><br><span class="line">        res,path = [],[]</span><br><span class="line">        candidates = sorted(candidates)</span><br><span class="line">        dfs(<span class="number">0</span>,res,path)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h1><span id="9-组合总和-iii">9. 组合总和 III</span></h1><p>找出所有相加之和为 n 的 k 个数的组合。组合中只允许含有 1 - 9 的正整数，并且每种组合中不存在重复的数字。</p><p>说明：</p><p>所有数字都是正整数。<br>解集不能包含重复的组合。 </p><blockquote><p>示例 1:<br>输入: k = 3, n = 7<br>输出: <code>[[1,2,4]]</code></p></blockquote><p>链接：<a href="https://leetcode-cn.com/problems/combination-sum-iii" target="_blank" rel="noopener">https://leetcode-cn.com/problems/combination-sum-iii</a></p><p><strong>【分析一】</strong></p><ul><li>数组中不包含重复的数字，所以不需要去重</li><li>每个数字只能用一次，所以在递归时start=i+1</li></ul><p>在for循环遍历所有的数字时，i的最大值为9，但并不是每次i都可以取到9，下面举例找i的最大值</p><p>1~9个数，找k个数，和为n，假设k=5，n=15</p><p>当len(path)=0，还可以选5个数，i的最大值为5，选[5,6,7,8,9]<br>当len(path)=1，还可以选4个数，i的最大值为6，选[6,7,8,9]<br>当len(path)=2，还可以选3个数，i的最大值为7，选[7,8,9]</p><p>即i的最大值为<code>10-(k-len(path))</code>,在for循环中，<code>range(start,10-(k-len(path))+1)</code></p><p>在进入<code>dfs</code>之前，先判断n是否符合实际情况，从1~9中选出k个数，最大为[9,8,…9-k+1],即和最大为(19-k)*k/2，如果n大于这个最大值，则不可能找出这k个数，所以这个提前判断一下n的值是否符合实际情况。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">combinationSum3</span><span class="params">(self, k, n)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type k: int</span></span><br><span class="line"><span class="string">        :type n: int</span></span><br><span class="line"><span class="string">        :rtype: List[List[int]]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(start,path,res)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> sum(path)==n <span class="keyword">and</span> len(path)==k:</span><br><span class="line">                res.append(path[:])</span><br><span class="line">                <span class="keyword">return</span> </span><br><span class="line">            </span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(start,<span class="number">10</span>-(k-len(path))+<span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> i+sum(path)&gt;n <span class="keyword">or</span> len(path)&gt;k:</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">                path.append(i)</span><br><span class="line">                dfs(i+<span class="number">1</span>,path,res)</span><br><span class="line">                path.pop()</span><br><span class="line">        <span class="keyword">if</span> k&lt;=<span class="number">0</span> <span class="keyword">or</span> n&lt;=<span class="number">0</span> <span class="keyword">or</span> k&gt;= n:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        <span class="keyword">if</span> n&gt;(<span class="number">19</span>-k)*k/<span class="number">2</span>:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        res,path = [],[]</span><br><span class="line">        dfs(<span class="number">1</span>,path,res)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h1><span id="10-括号生成">10. 括号生成</span></h1><p>数字 n 代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且 有效的 括号组合。</p><p>示例：</p><p>输入：n = 3<br>输出：[<br>       “((()))”,<br>       “(()())”,<br>       “(())()”,<br>       “()(())”,<br>       “()()()”<br>     ]</p><p>链接：<a href="https://leetcode-cn.com/problems/generate-parentheses" target="_blank" rel="noopener">https://leetcode-cn.com/problems/generate-parentheses</a></p><p><strong>【分析一】</strong></p><p>在递归中，使用left和right表示左右括号使用的个数。使用path存储当前括号的组合。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">generateParenthesis</span><span class="params">(self, n)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type n: int</span></span><br><span class="line"><span class="string">        :rtype: List[str]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(path,res,left,right)</span>:</span></span><br><span class="line">            <span class="string">"""</span></span><br><span class="line"><span class="string">            left:左括号已经使用的个数</span></span><br><span class="line"><span class="string">            right:右括号已经使用的个数</span></span><br><span class="line"><span class="string">            """</span></span><br><span class="line">            <span class="keyword">if</span> left==n <span class="keyword">and</span> right==n:</span><br><span class="line">                res.append(<span class="string">""</span>.join(path[:]))</span><br><span class="line">                <span class="keyword">return</span> </span><br><span class="line">            <span class="keyword">if</span> left&lt;right:</span><br><span class="line">                <span class="keyword">return</span> </span><br><span class="line">            <span class="keyword">if</span> left &lt; n:</span><br><span class="line">                path.append(<span class="string">'('</span>)</span><br><span class="line">                dfs(path,res,left+<span class="number">1</span>,right)</span><br><span class="line">                path.pop()</span><br><span class="line">            <span class="keyword">if</span> right &lt; n:</span><br><span class="line">                path.append(<span class="string">')'</span>)</span><br><span class="line">                dfs(path,res,left,right+<span class="number">1</span>)</span><br><span class="line">                path.pop()</span><br><span class="line">        res,path = [],[]</span><br><span class="line">        dfs(path,res,<span class="number">0</span>,<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><p>这个方法和上面的区别是使用path是字符串类型。并且递归时，在传入的参数中对path进行改变，在外部path并没有变化，所以不需要回溯。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">generateParenthesis</span><span class="params">(self, n)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type n: int</span></span><br><span class="line"><span class="string">        :rtype: List[str]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(path,res,left,right)</span>:</span></span><br><span class="line">            <span class="string">"""</span></span><br><span class="line"><span class="string">            left:左括号已经使用的个数</span></span><br><span class="line"><span class="string">            right:右括号已经使用的个数</span></span><br><span class="line"><span class="string">            """</span></span><br><span class="line">            <span class="keyword">if</span> left==n <span class="keyword">and</span> right==n:</span><br><span class="line">                res.append(path)</span><br><span class="line">                <span class="keyword">return</span> </span><br><span class="line">            <span class="keyword">if</span> left&lt;right:</span><br><span class="line">                <span class="keyword">return</span> </span><br><span class="line">            <span class="keyword">if</span> left &lt; n:</span><br><span class="line">                dfs(path+<span class="string">'('</span>,res,left+<span class="number">1</span>,right)</span><br><span class="line">            <span class="keyword">if</span> right &lt; n:</span><br><span class="line">                dfs(path+<span class="string">')'</span>,res,left,right+<span class="number">1</span>)</span><br><span class="line">        res,path = [],<span class="string">''</span></span><br><span class="line">        dfs(path,res,<span class="number">0</span>,<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h1><span id="11-n皇后">11. N皇后</span></h1><p>n 皇后问题研究的是如何将 n 个皇后放置在 n×n 的棋盘上，并且使皇后彼此之间不能相互攻击。即任意2个皇后不能除以同一行，同一列，或者同一对角线上。给定一个整数 n，返回所有不同的 n 皇后问题的解决方案。</p><p>每一种解法包含一个明确的 n 皇后问题的棋子放置方案，该方案中 ‘Q’ 和 ‘.’ 分别代表了皇后和空位。</p><p>链接：<a href="https://leetcode-cn.com/problems/n-queens" target="_blank" rel="noopener">https://leetcode-cn.com/problems/n-queens</a></p><p><strong>【分析一】</strong></p><p>首先board表示某一种摆放方案。先摆放row_start=0的第一行，将皇后摆放在某一列，然后再摆放下一行，因为一行只摆放了一个皇后，所以行没有冲突，在递归中，我们只需要判断列，左上对角线，右上对角线是否有冲突。如果不冲突，在该位置上摆放皇后，即<code>board[row][col]=&#39;Q&#39;</code>,否则回溯<code>board[row][col]=&#39;.&#39;</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">solveNQueens</span><span class="params">(self, n)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type n: int</span></span><br><span class="line"><span class="string">        :rtype: List[List[str]]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(row_start,res,board)</span>:</span></span><br><span class="line">            <span class="string">"""</span></span><br><span class="line"><span class="string">            row_start:当前在row_start行的哪一列摆放皇后，取值0~n-1</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">            """</span></span><br><span class="line">            <span class="keyword">if</span> row_start==n:</span><br><span class="line">                res.append([<span class="string">''</span>.join(board[i]) <span class="keyword">for</span> i <span class="keyword">in</span> range(n)])</span><br><span class="line">                <span class="keyword">return</span> </span><br><span class="line">            </span><br><span class="line">            cols = len(board[<span class="number">0</span>])</span><br><span class="line">            <span class="keyword">for</span> col <span class="keyword">in</span> range(cols):</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> is_valid(board,row_start,col):</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                board[row_start][col]=<span class="string">'Q'</span></span><br><span class="line">                dfs(row_start+<span class="number">1</span>,res,board)</span><br><span class="line">                board[row_start][col]=<span class="string">'.'</span></span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">is_valid</span><span class="params">(borad,row_start,col)</span>:</span></span><br><span class="line">            <span class="string">"""</span></span><br><span class="line"><span class="string">            判断将皇后放在board[row_start][col]是否合理</span></span><br><span class="line"><span class="string">            即判断在col列上是否已经有皇后</span></span><br><span class="line"><span class="string">            判断row_start以上的左上方和右上方的对角线上是否有皇后</span></span><br><span class="line"><span class="string">            """</span></span><br><span class="line">            n = len(board)</span><br><span class="line"></span><br><span class="line">            <span class="comment">#判断所有行在col列是否有皇后</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">                <span class="keyword">if</span> board[i][col] == <span class="string">'Q'</span>:</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment">#判断左上方是否有皇后</span></span><br><span class="line">            i,j = row_start<span class="number">-1</span>,col+<span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> i&gt;=<span class="number">0</span> <span class="keyword">and</span> j&lt;=n<span class="number">-1</span>:</span><br><span class="line">                <span class="keyword">if</span> board[i][j]==<span class="string">'Q'</span>:</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">                i-=<span class="number">1</span></span><br><span class="line">                j+=<span class="number">1</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment">#p判断右上方是否有皇后</span></span><br><span class="line">            i,j = row_start<span class="number">-1</span>,col<span class="number">-1</span></span><br><span class="line">            <span class="keyword">while</span> i&gt;=<span class="number">0</span> <span class="keyword">and</span> j&gt;=<span class="number">0</span>:</span><br><span class="line">                <span class="keyword">if</span> board[i][j]==<span class="string">'Q'</span>:</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">                i-=<span class="number">1</span></span><br><span class="line">                j-=<span class="number">1</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">        res = []</span><br><span class="line">        board = [[<span class="string">'.'</span> <span class="keyword">for</span> _ <span class="keyword">in</span> range(n) ] <span class="keyword">for</span> _ <span class="keyword">in</span> range(n)]</span><br><span class="line">        dfs(<span class="number">0</span>,res,board)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h1><span id="12-总结">12. 总结</span></h1><p>在回溯题中，需要判断给定数组中是否有重复元素，如果有重复元素，在回溯的过程，需要去重，步骤如下</p><ul><li>先对数组排序，<code>nums = sorted(nums)</code></li><li>在for循环内部，使用<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(start,len(nums)):</span><br><span class="line">    <span class="keyword">if</span> i &gt; statr <span class="keyword">and</span> nums[i]==nums[i<span class="number">-1</span>]:</span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">path.append(nums[i])</span><br><span class="line">dfs(...)</span><br><span class="line">path.pop()</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;!-- TOC --&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#1-回溯&quot;&gt;1. 回溯&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#2-矩阵中单词路径搜索&quot;&gt;2. 矩阵中单词路径搜索&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#3-机器人的
      
    
    </summary>
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>How to Build a Graph-Based Deep Learning Architecture in Traffic Domain: A Survey</title>
    <link href="http://yoursite.com/2020/06/02/How-to-Build-a-Graph-Based-Deep-Learning-Architecture-in-Traffic-Domain-A-Survey/"/>
    <id>http://yoursite.com/2020/06/02/How-to-Build-a-Graph-Based-Deep-Learning-Architecture-in-Traffic-Domain-A-Survey/</id>
    <published>2020-06-02T01:41:59.000Z</published>
    <updated>2020-06-18T02:33:30.602Z</updated>
    
    <content type="html"><![CDATA[<p>这篇综述性论文介绍图神经网络在交通领域的应用。</p><a id="more"></a><!-- TOC --><ul><li><a href="#1-摘要">1. 摘要</a></li><li><a href="#2-前言">2. 前言</a></li><li><a href="#3-研究方向">3. 研究方向</a></li><li><a href="#4-问题定义">4. 问题定义</a><ul><li><a href="#41-构建图">4.1. 构建图</a></li><li><a href="#42-构造邻接矩阵">4.2. 构造邻接矩阵</a></li></ul></li><li><a href="#5-前人的模型">5. 前人的模型</a><ul><li><a href="#51-gnn">5.1. GNN</a></li><li><a href="#52-rnn">5.2. RNN</a></li><li><a href="#53-tcn">5.3. TCN</a></li><li><a href="#54-seq2seq">5.4. Seq2Seq</a></li><li><a href="#55-gan">5.5. GAN</a></li></ul></li><li><a href="#6-挑战">6. 挑战</a><ul><li><a href="#61-空间依赖">6.1. 空间依赖</a></li><li><a href="#62-时间依赖">6.2. 时间依赖</a></li><li><a href="#63-时空依赖">6.3. 时空依赖</a></li><li><a href="#64-外部因素">6.4. 外部因素</a></li></ul></li><li><a href="#7-未来方向">7. 未来方向</a></li></ul><!-- /TOC --><h1><span id="1-摘要">1. 摘要</span></h1><p>在交通数据中，有很多数据以图的形式存在，为了充分利用其中的空间信息，很多模型使用图神经网络来处理交通图数据。本文针对交通领域的图网络模型进行总结。</p><h1><span id="2-前言">2. 前言</span></h1><p>在交通预测领域，（1）早期采用的方法有：ARIMA,VAR,Kalman过滤器等，然而，这些方法通常需要一些前提假设，例如数据是静态且线性相关，不能应用在实际数据中。（2）机器学习方法例如SVM，K近邻可以建模交通数据中的非线性相关性，但是模型结构较浅，且需要人工构造和选择特征，不能满足大量交通数据的应用需求。（3）深度学习方法，例如RNN无法捕获空间相关性，CNN无法应用在图数据中，并且CNN更关注local相关性，忽略了global相关性。（4）图神经网络，使用图神经网络来解决交通领域的预测问题。<br>贡献总结如下：</p><ul><li>第一篇介绍图神经网络在交通领域应用的综述</li><li>系统地列出交通领域的研究方向和挑战</li><li>针对4种交通领域数据，介绍如何构建图</li><li>分析了5种应用在图交通领域的技术，介绍了它们的优缺点，以及变体</li><li>讨论了基于图网络的交通任务中4种常见的挑战，并总结对应的解决方案</li><li>收集数据集，开源代码</li></ul><h1><span id="3-研究方向">3. 研究方向</span></h1><p>给出了交通领域的一些研究问题<br><img src="/2020/06/02/How-to-Build-a-Graph-Based-Deep-Learning-Architecture-in-Traffic-Domain-A-Survey/1.png" alt=""></p><ol><li>交通拥堵</li><li>交通需求<br>出租车、自行车、公共交通的需求预测，像滴滴，Uber等线上打车平台经常做这一类问题。</li><li>交通安全<br>预测交通事故的风险，严重程度</li><li>交通监控<br>主要通过监控的图像和视频检测车辆，行人检测。</li><li>自动驾驶<br>自动驾驶要求检测树木，道路，行人，一般和CV领域相关。</li></ol><p>图神经网络在交通领域的应用</p><ol><li>交通状态预测<br>交通状态：交通流量、速度、时间ETA、密度等。</li><li>交通需求预测<br>预测将来用户对出租车、自行车的需求</li><li>交通信号预测<br>减低用户在交叉路口的等待时间，避免交通拥堵</li><li>司机行为分类</li></ol><p>交通事故预测还没有用到图模型。</p><h1><span id="4-问题定义">4. 问题定义</span></h1><p>基于图的交通预测问题，首先需要构件图G。</p><ul><li>图：无权图，有权图，无向图，有向图，取决于具体的任务。</li><li>节点：传感器sensor，路段，道路交叉口，GPS交叉点。</li><li>邻接矩阵A：非0即1，浮点数（表示2个节点的关系，例如相似性，距离）</li></ul><p>给定历史P个时间段所有节点的信息，维度是$\left[\mathcal{X}_{1}, \cdots, \mathcal{X}_{i}, \cdots, \mathcal{X}_{\mathbf{P}}\right] \in \mathbb{R}^{\mathbf{P} \times \mathbf{N} \times \mathbf{F}_{1}}$预测未来Q个时间段的$\mathcal{Y}=\left[\mathcal{Y}_{1}, \cdots, \mathcal{Y}_{j}, \cdots, \mathcal{Y}_{\mathrm{Q}}\right] \in \mathbb{R}^{\mathbf{Q} \times \mathbf{N} \times \mathrm{F}_{\mathrm{O}}}$</p><ul><li>预测的特征只有1个，即$F_O=1$，预测特征有多个，即$F_O&gt;1$</li><li>预测未来时间段只有1个，单步预测，即$Q=1$，预测未来时间段有多个，多步预测，即$Q&gt;1$</li><li>多步预测问题中，一般使用FC（将输出reshape成需要的维度，ASTGCN,T-GCN,），Seq2Seq（使用RNN循环输出预测结果,DCRNN,GMAN），空洞技术（WaveNet）</li></ul><h2><span id="41-构建图">4.1. 构建图</span></h2><p>在构建图时，一般使用3类数据：传感器，GPS轨迹，打车订单数据，</p><ol><li>传感器数据<br>最常用的加州PEMS数据，图中的每个节点表示一个传感器，同一条路上的传感器有边相连。</li><li>GPS数据<br>GPS轨迹数据，需要将GPS匹配到最近的路段上，以路段为节点创建图，或者以交叉路口为节点创建图。这里的图可以是有向，也可以无向。</li></ol><p><img src="/2020/06/02/How-to-Build-a-Graph-Based-Deep-Learning-Architecture-in-Traffic-Domain-A-Survey/3.png" alt="">  </p><ol><li>订单数据<br>将城市划分为网格，每个节点表示一个网格，边表示连通性。可以根据不同的特征来构件图，例如下图使用邻近区域、道路连通性、功能相似区域分别构建3个图。</li></ol><p><img src="/2020/06/02/How-to-Build-a-Graph-Based-Deep-Learning-Architecture-in-Traffic-Domain-A-Survey/4.png" alt="">  </p><ol><li>公共交通数据<ul><li>地铁图：每个地铁站表示一个节点，如果一条线上的2个地铁站相邻则有边。图信号矩阵是inflow和outflow</li><li>公交车图：每个公交站是一个节点，如果一条线上的2个公交站相邻则有边。图信号矩阵进站记录</li></ul></li></ol><h2><span id="42-构造邻接矩阵">4.2. 构造邻接矩阵</span></h2><ol><li>静态邻接矩阵<br>邻接矩阵不会随着时间变化。可以根据节点之间的特征构建多个邻接矩阵，例如功能相似，道路相通，时间相似。邻接矩阵中的值可以是非0即1，也可以表示节点间距离或者相似性。一般通过阈值来定义邻接矩阵，通过调整阈值来控制邻接矩阵的稀疏性。<script type="math/tex; mode=display">\mathbf{a}_{i j}=\left\{\begin{array}{l}\exp \left(-\frac{\mathbf{d}_{i j}^{2}}{\sigma^{2}}\right), i \neq j \text { and } \mathbf{d}_{i j} \geq \epsilon \\0 \quad, i=j \text { or } \mathbf{d}_{i j}<\epsilon\end{array}\right.</script></li></ol><ol><li>动态邻接矩阵<br>有2种情况：1. 邻接矩阵不随着时间变化，但是邻接矩阵不是预先定义好的，而是模型先动态学习节点嵌入，然后根据学习到的节点嵌入构造邻接矩阵。2. 邻接矩阵随着时间变化。</li></ol><h1><span id="5-前人的模型">5. 前人的模型</span></h1><p>分析图神经网络在交通领域的应用，发现GNN通常和其他组件一起用，类似RNN,Seq2Seq，TCN等。</p><h2><span id="51-gnn">5.1. GNN</span></h2><p>GNN在交通领域的应用主要有3个：谱图卷积for无向图，扩散卷积for有向图。</p><ol><li><p>谱图卷积</p><script type="math/tex; mode=display">\begin{aligned}Y_{j} &=\rho\left(\Theta_{j} *_{\mathcal{G}} X\right) \\&=\rho\left(\sum_{i=1}^{\mathbf{F}_{\mathrm{I}}} \theta_{i, j} \tilde{\mathbf{D}}^{-\frac{1}{2}} \tilde{\mathbf{A}} \tilde{\mathbf{D}}^{-\frac{1}{2}} X_{i}\right), 1 \leq j \leq \mathbf{F}_{\mathbf{O}} \\Y &=\rho\left(\tilde{\mathbf{D}}^{-\frac{1}{2}} \tilde{\mathbf{A}} \tilde{\mathbf{D}}^{-\frac{1}{2}} X W\right)\end{aligned}</script><p>谱图卷积要求对称的拉普拉斯矩阵，来实现特征值分解。</p></li><li><p>扩散卷积<br>谱图卷积要求对称的拉普拉斯矩阵，来实现特征值分解。但是对于有向图来说，拉普拉斯矩阵不是对称的。扩散卷积对图的结构，邻接矩阵，拉普拉斯矩阵没有任何限制。扩散卷积可以看做是转移矩阵的幂次，表示从节点i到节点j的转移概率。</p><script type="math/tex; mode=display">y=\Theta *_{\mathcal{G}} x=\sum_{k=0}^{\mathrm{K}-1}\left(\theta_{k, 1}\left(\mathrm{D}_{\mathrm{O}}^{-1} \mathrm{A}\right)^{k}+\theta_{k, 2}\left(\mathrm{D}_{\mathrm{I}}^{-1} \mathrm{A}^{T}\right)^{k}\right) x</script></li></ol><p>总结：谱图卷积和扩散卷积的不同：谱图卷积的邻接矩阵揭示中心节点和它直接邻近的节点更相关。而扩散卷积揭示空间依赖是随机且动态的。扩散卷积比谱图卷积更复杂。扩散卷积可以适用在任何交通网络上，而谱图卷积只能用在对称的图上，即无向图中。</p><p>有些工作在使用SGC和DGC使用以下tricks</p><ul><li>使用SGC时，引入attention机制<br>S表示图信号矩阵，使用切比雪夫多项式计算图卷积时，对S求attention，计算节点之间的影响程度。</li></ul><script type="math/tex; mode=display">\Theta *_{\mathcal{G}} x \approx \sum_{k=0}^{K-1} \theta_{k}\left(T_{k}(\tilde{\mathbf{L}}) \odot \mathbf{S}\right) x$$ $$\mathbf{S} = W_{1} \odot \rho\left(\left(X W_{2}\right) W_{3}(W_{4} X)^{T}+b\right) \in \mathbb{R}^{N \times N}</script><ul><li><p>直接使用邻接矩阵，FFR表示道路特征</p><script type="math/tex; mode=display">\Theta *_{\mathcal{G}} x=\left(W \odot \tilde{\mathbf{A}}^{\mathrm{K}} \odot \mathcal{F} \mathcal{F} \mathcal{R}\right) x</script></li><li><p>在邻接矩阵中引入地理位置信息</p><script type="math/tex; mode=display">\mathbf{S}=\mathbf{A} \odot \omega$$$$Y=\rho\left(\tilde{\mathbf{Q}}^{-\frac{1}{2}} \tilde{\mathbf{S}} \tilde{\mathbf{Q}}^{-\frac{1}{2}} X W\right)</script></li></ul><h2><span id="52-rnn">5.2. RNN</span></h2><p>交通任务预测中很多都是时间序列数据，适用RNN来捕获时间相关性。这里包括三类：RNN,LSTM,GRU</p><ul><li>RNN：输入层，隐藏层，输出层</li><li>LSTM：为了解决RNN的梯度消失和梯度爆炸问题，引入输入门，遗忘门，输出门。</li><li>GRU：LSTM结构复杂，参数更多，用更简单的GRU来代替，只有2个门：重置门</li></ul><p>在交通预测领域中，很少用RNN，大部分都是用GRU，少数用LSTM。在用GRU或LSTM时，有很多小tricks，例如attention，门控机制，残差机制。<br>在使用RNN所用到的tricks</p><ul><li>在RNN中引入空间信息<script type="math/tex; mode=display">\mathbf{H}_{t} = R N N\left(\left[\mathbf{H}_{t-1}, \mathbf{X}_{t}\right] \odot S\right)</script></li><li>引入外部因素<script type="math/tex; mode=display">\mathbf{H}_{t}=G R U\left(\left[\mathbf{H}_{t-1}, \mathbf{X}_{t}\right], \mathbf{E}_{t}\right)+\mathbf{H}_{t-1} W</script></li><li>使用空洞RNN<script type="math/tex; mode=display">\mathbf{H}_{t}=G R U\left(\mathbf{H}_{t-s}, \mathbf{X}_{t}\right)</script></li><li>RNN和图卷积结合<script type="math/tex; mode=display">\begin{aligned}r_{t} &=\sigma\left(\left[\mathbf{H}_{t-1}, \mathbf{X}_{t}\right] *_{\mathcal{G}} W_{r}+b_{r}\right) \\u_{t} &=\boldsymbol{\sigma}\left(\left[\mathbf{H}_{t-1}, \mathbf{X}_{t}\right] *_{\mathcal{G}} W_{u}+b_{u}\right) \\\tilde{\mathbf{H}}_{t} &=\tanh \left(r_{t} \odot\left[\mathbf{H}_{t-1}, \mathbf{X}_{t}\right] *_{\mathcal{G}} W_{h}+b_{h}\right) \\\mathbf{H}_{t} &=u_{t} \odot \mathbf{H}_{t-1}+\left(1-u_{t}\right) \odot \tilde{\mathbf{H}}_{t}\end{aligned}</script></li></ul><h2><span id="53-tcn">5.3. TCN</span></h2><p>虽然RNN可以捕获时间的相关性，但是其不能并行计算，耗时。与之对比，1D卷积运行更快，同样也可以捕获时间相关性。然后1D卷积与RNN相比应用更少，由于1D卷积缺少长期建模的memory机制。后来提出空洞卷积，在长期时间建模上，比RNN效果更好。之后，TCN被广泛应用在时间建模上。</p><p><img src="/2020/06/02/How-to-Build-a-Graph-Based-Deep-Learning-Architecture-in-Traffic-Domain-A-Survey/5.png" alt=""> </p><p>在使用TCN时，有一些小traick</p><ul><li><p>堆叠不同的TCN层，每层使用不同的dilation rate</p><script type="math/tex; mode=display">\mathcal{Y}^{(l+1)}=\sigma\left(\Theta^{l} *_{\mathcal{T} \mathrm{d}^{l}} \mathcal{Y}^{(l)}\right)</script></li><li><p>残差，原始输入+TCN的输出</p><script type="math/tex; mode=display">\mathcal{Y}^{(l+1)}=\mathcal{Y}^{(l)}+\boldsymbol{\operatorname { R e }} \boldsymbol{L} \boldsymbol{U}\left(\Theta_{1}^{l} *_{\mathcal{T}^{\mathrm{d}}}\left(\boldsymbol{\operatorname { R e }} \boldsymbol{L} \boldsymbol{U}\left(\Theta_{0}^{l} *_{\mathcal{T}^{\mathrm{d}}} \mathcal{Y}^{(l)}\right)\right)\right)</script></li><li><p>使用门控机制</p><script type="math/tex; mode=display">\mathcal{Y}=\rho\left(\Theta_{1} *_{\mathcal{T}^{\mathrm{d}}} \mathcal{X}+b_{1}\right) \odot \sigma\left(\Theta_{2} *_{\mathcal{T}^{\mathrm{d}}} \mathcal{X}+b_{2}\right)</script></li></ul><h2><span id="54-seq2seq">5.4. Seq2Seq</span></h2><p>原始的Seq2Seq模型为对输入进行建模，得到一个隐变量$C$,然后将$C$输入到解码器中，进行预测。</p><p><img src="/2020/06/02/How-to-Build-a-Graph-Based-Deep-Learning-Architecture-in-Traffic-Domain-A-Survey/6.png" alt=""> </p><p>对Seq2Seq的改进主要有2点：</p><ul><li><p>改变隐变量C<br>原先输入到decoder的C是固定的，对decoder中所有的时间步来说都一样，然后输入中的值对不同的输出影响程度不同，这里引入attention机制，动态改变C</p><script type="math/tex; mode=display">\begin{array}{l}\mathbf{H}_{i}=\operatorname{Encoder}\left(\mathbf{X}_{i}, \mathbf{H}_{i-1}\right) \\\mathbf{C}_{j}=\sum_{i=1}^{\mathbf{P}}\left(\theta_{j i} \mathbf{H}_{i}\right), \mathbf{S}_{0}=\mathbf{H}_{\mathbf{P}} \\\mathbf{S}_{j}=\operatorname{Decoder}\left(\mathbf{C}_{j}, \mathbf{Y}_{j-1}, \mathbf{S}_{j-1}\right) \\\mathbf{Y}_{j}=\mathbf{S}_{j} W\end{array}</script></li><li><p>采样<br>在decoder在训练阶段和测试阶段的输入是不同的。在训练阶段，decoder的不同时间步输入的真实的label，而在测试阶段，因为不知道label，输入的是上一个时间步预测的结果，这样可能会造成错误累积的问题。为了解决这个问题，可以在训练阶段进行采样，即并不总是输入真实的label，以$\epsilon_{j}$输入真实babel，以$1-\epsilon_{j}$输入上个时间步的预测结果。</p></li></ul><p>交通领域中的多步预测通常采用Seq2Seq架构。Seq2Seq中的encoder和decoder架构通常采用RNN，但是也不一定相同。</p><h2><span id="55-gan">5.5. GAN</span></h2><p>这一模块看的论文较少，以后补充</p><h1><span id="6-挑战">6. 挑战</span></h1><p>尽管交通领域有很多研究方向，但它们都有一些共同的挑战，如下所示，主要分为三类：空间依赖，时间依赖，外部因素。</p><p><img src="/2020/06/02/How-to-Build-a-Graph-Based-Deep-Learning-Architecture-in-Traffic-Domain-A-Survey/2.png" alt=""> </p><h2><span id="61-空间依赖">6.1. 空间依赖</span></h2><p>在一个双向的道路中，R1只受R2的影响，R3对R1的影响较小。如果采用网格的形式，R3和R2对R1的影响相同，这不符合实际。如果采用图的形式，R2对R1的影响较大，R3对R1的影响较小，符合实际。</p><p><img src="/2020/06/02/How-to-Build-a-Graph-Based-Deep-Learning-Architecture-in-Traffic-Domain-A-Survey/7.png" alt=""> </p><p>交通网络中空间依赖十分复杂，可以分成三类：空间局部性，多元关系，全局连通性。</p><ol><li>空间局部性<br>空间局部性表示邻近区域比较远的区域更相关。K阶局部谱图卷积SGCN可以聚合0~K-1跳的邻居信息。还有一些其他工作可以捕获空间局部相关性。比如动态计算邻接矩阵</li><li>多元关系<br>目标区域也可能与距离较远的区域相关。例如功能相似的区域，交通连通的区域。根据这些不同的相似性来创建不同的图。</li><li>全局连通性<br>以上2点更关注网络部分，而忽略了整体的结构。全局连通性表示不同区域的交通情况在整个网络上互相影响。使用扩散卷积、pooling层、self-adaptive邻接矩阵可以捕获到这种全局连通性。</li></ol><h2><span id="62-时间依赖">6.2. 时间依赖</span></h2><p>使用RNN或TCN来捕获时间依赖</p><ol><li>多粒度<br>时间有不同的周期性，例如recent，daily，weekly。</li><li>不同的权重<br>历史信息对目标时间段的影响权重不同。使用Attention机制计算权重分数。</li></ol><h2><span id="63-时空依赖">6.3. 时空依赖</span></h2><p>以上对时间和空间依赖分别建模，如果对时空依赖同时建模，预测效果可能会更好。例如STSGCN</p><h2><span id="64-外部因素">6.4. 外部因素</span></h2><p>天气（雨/温度/空气质量），时间（节假日/周几/几点），特殊时间，POI等信息都会影响交通预测。<br>对于外部因素的处理通常有2种方法：</p><ol><li>和其他因素拼接，输入到模型中</li><li>设计外部因素处理模块，对外部因素单独处理。通常是2个FCN，第一个FCN提取重要信息，第二个FCN从低维特征映射到高维特征</li></ol><h1><span id="7-未来方向">7. 未来方向</span></h1><ol><li>在司机行为分类，车辆/人们轨迹预测，交通事故预测使用图模型。</li><li>大多使用SGCN和DGCN，很少使用GAT,GAE,RNN+GCN，可以使用以上模型解决交通问题</li><li>交通问题大多是回归问题，很少有分类问题，可以使用图模型研究分类问题</li><li>现有模型对外部因素处理比较简单，可以设计更复杂的模型捕获外部因素信息。</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这篇综述性论文介绍图神经网络在交通领域的应用。&lt;/p&gt;
    
    </summary>
    
      <category term="论文阅读笔记" scheme="http://yoursite.com/categories/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="时空领域" scheme="http://yoursite.com/tags/%E6%97%B6%E7%A9%BA%E9%A2%86%E5%9F%9F/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode之树</title>
    <link href="http://yoursite.com/2020/05/29/Leetcode%E4%B9%8B%E6%A0%91/"/>
    <id>http://yoursite.com/2020/05/29/Leetcode之树/</id>
    <published>2020-05-29T13:11:48.000Z</published>
    <updated>2020-06-18T02:35:27.719Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><!-- TOC --><ul><li><a href="#1-树概念介绍">1. 树概念介绍</a></li><li><a href="#2-树的前向遍历">2. 树的前向遍历</a></li><li><a href="#3-二叉树的中序遍历">3. 二叉树的中序遍历</a></li><li><a href="#4-后序遍历">4. 后序遍历</a></li><li><a href="#5-树的层次遍历">5. 树的层次遍历</a></li><li><a href="#6-根据前序和中序创建二叉树">6. 根据前序和中序创建二叉树</a></li><li><a href="#7-计算树的最大深度">7. 计算树的最大深度</a></li><li><a href="#8-对称二叉树">8. 对称二叉树</a></li><li><a href="#9-平衡二叉树">9. 平衡二叉树</a></li><li><a href="#10-二叉树的镜像">10. 二叉树的镜像</a></li><li><a href="#11-二叉搜索树的后序遍历序列">11. 二叉搜索树的后序遍历序列</a></li><li><a href="#12-总结">12. 总结</a></li></ul><!-- /TOC --><h1><span id="1-树概念介绍">1. 树概念介绍</span></h1><ul><li>二叉树一般有2种通用的遍历策略<ul><li>深度优先搜索DFS<ol><li>前序遍历：根左右</li><li>中序遍历：左根右</li><li>后序遍历：左右根</li></ol></li><li>广度优先搜索BFS<br>先遍历第一层，再遍历第二层</li></ul></li></ul><p>值得注意的是，在删除树中的节点时，删除过程将按照后序遍历的顺序进行，也就是先删除左节点和右节点，然后再删除节点本身。</p><ul><li><p>平衡二叉树，需要满足1个条件：</p><ul><li>左右子树深度之差&lt;=1</li></ul></li><li><p>二叉搜索树，需要满足以下2个条件：</p><ul><li>左子树的值&lt;父节点，右子树的值&gt;父节点</li><li>所有左子树和右子树是二叉搜索树</li></ul></li></ul><p>二叉树常见问题<br><a href="https://zhuanlan.zhihu.com/p/91243381" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/91243381</a></p><h1><span id="2-树的前向遍历">2. 树的前向遍历</span></h1><p>给定一个二叉树，返回它的前序遍历序列。</p><p><strong>【方法1】</strong></p><p>前序遍历：根左右<br>迭代遍历树，使用栈的思想来实现。<br>定义一个stack数据，作为临时的存储栈。首先cur指向根节点，循环遍历所有的节点，当cur不为空时，因为先遍历根节点，所以将cur的值保存在res中，然后将cur保存至stack中，然后遍历cur的左节点，直到cur的左节点为空（cur没有左节点，或cur是叶子节点）。当cur为空时，进入到else中，从stack中弹出cur的父节点，然后遍历其右子树。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">preorderTraversal</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type root: TreeNode</span></span><br><span class="line"><span class="string">        :rtype: List[int]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:<span class="keyword">return</span> []</span><br><span class="line">        <span class="comment">#stack作为临时栈，先弹出根节点，再压入右节点和左节点</span></span><br><span class="line">        stack,res = [],[]</span><br><span class="line">        cur = root</span><br><span class="line">        <span class="keyword">while</span> cur <span class="keyword">or</span> stack:</span><br><span class="line">            <span class="keyword">if</span> cur:<span class="comment">#只要根节点不为空，一直向下遍历，知道cur为空</span></span><br><span class="line">                res.append(cur.val)<span class="comment">#将当前根节点的存储到res中</span></span><br><span class="line">                stack.append(cur)</span><br><span class="line">                cur = cur.left</span><br><span class="line">            <span class="keyword">else</span>:<span class="comment">#cur为空，说明该子树没有左子树或者是叶子节点</span></span><br><span class="line">                top = stack.pop()</span><br><span class="line">                cur = top.right</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><p><strong>【方法二】</strong></p><p>迭代方法</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">preorderTraversal</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type root: TreeNode</span></span><br><span class="line"><span class="string">        :rtype: List[int]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:<span class="keyword">return</span> []</span><br><span class="line">        res = []</span><br><span class="line">        self.dfs(root,res)</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(self,root,res)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> root:</span><br><span class="line">            res.append(root.val)</span><br><span class="line">            self.dfs(root.left,res)</span><br><span class="line">            self.dfs(root.right,res)</span><br></pre></td></tr></table></figure><h1><span id="3-二叉树的中序遍历">3. 二叉树的中序遍历</span></h1><p>给定一个二叉树，返回它的中序 遍历。</p><p><strong>【方法一】</strong><br>中序遍历：左根右，<br>每到一个节点A，因为需要先遍历左子树，所以需要把根节点先存储在stack中，然后一直遍历左子树，直到cur为None时，说明当前节点没有左子树，再从stack中弹出None的根节点，然后再遍历根节点的右子树。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inorderTraversal</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type root: TreeNode</span></span><br><span class="line"><span class="string">        :rtype: List[int]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root: <span class="keyword">return</span> []</span><br><span class="line">        stack,res = [],[]</span><br><span class="line">        cur = root</span><br><span class="line">        <span class="keyword">while</span> cur <span class="keyword">or</span> stack:</span><br><span class="line">            <span class="keyword">if</span> cur:</span><br><span class="line">                stack.append(cur)</span><br><span class="line">                cur = cur.left</span><br><span class="line">            <span class="keyword">else</span>:<span class="comment">#当某个节点的左子树为None时，弹出该节点（根节点），然后再遍历其右子树</span></span><br><span class="line">                cur = stack.pop()</span><br><span class="line">                res.append(cur.val)</span><br><span class="line">                cur = cur.right</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><p><strong>【方法二】</strong><br>递归<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inorderTraversal</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type root: TreeNode</span></span><br><span class="line"><span class="string">        :rtype: List[int]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root: <span class="keyword">return</span> []</span><br><span class="line">        res = []</span><br><span class="line">        self.dfs(root,res)</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(self,root,res)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> root:</span><br><span class="line">            <span class="keyword">if</span> root.left:</span><br><span class="line">                self.dfs(root.left,res)</span><br><span class="line">            res.append(root.val)</span><br><span class="line">            <span class="keyword">if</span> root.right:</span><br><span class="line">                self.dfs(root.right,res)</span><br></pre></td></tr></table></figure></p><h1><span id="4-后序遍历">4. 后序遍历</span></h1><p><strong>【方法一】</strong><br>后续遍历：左右根，使用res保存根右左的节点顺序，返回时倒序输出<br>每到一个节点A，先遍历根节点，因为左子树最后遍历，所以先把左子树压入栈中，然后遍历右子树</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">postorderTraversal</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type root: TreeNode</span></span><br><span class="line"><span class="string">        :rtype: List[int]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:<span class="keyword">return</span> []</span><br><span class="line">        stack,res = [],[]</span><br><span class="line">        cur = root</span><br><span class="line">        <span class="keyword">while</span> cur <span class="keyword">or</span> stack:</span><br><span class="line">            <span class="keyword">if</span> cur:</span><br><span class="line">                res.append(cur.val)</span><br><span class="line">                stack.append(cur.left)</span><br><span class="line">                cur = cur.right</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                cur = stack.pop()</span><br><span class="line">        <span class="keyword">return</span> res[::<span class="number">-1</span>]</span><br></pre></td></tr></table></figure><p><strong>【方法二】</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">postorderTraversal</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type root: TreeNode</span></span><br><span class="line"><span class="string">        :rtype: List[int]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:<span class="keyword">return</span> []</span><br><span class="line">        res = []</span><br><span class="line">        self.dfs(root,res)</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(self,root,res)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> root:</span><br><span class="line">            <span class="keyword">if</span> root.left:</span><br><span class="line">                self.dfs(root.left,res)</span><br><span class="line">            <span class="keyword">if</span> root.right:</span><br><span class="line">                self.dfs(root.right,res)</span><br><span class="line">            res.append(root.val)</span><br></pre></td></tr></table></figure><h1><span id="5-树的层次遍历">5. 树的层次遍历</span></h1><p>给你一个二叉树，请你返回其按 层序遍历 得到的节点值。 （即逐层地，从左到右访问所有节点）。</p><p><a href="https://leetcode-cn.com/problems/binary-tree-level-order-traversal/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/binary-tree-level-order-traversal/</a></p><p><strong>【方法一】</strong></p><p>参考<a href="https://leetcode-cn.com/problems/binary-tree-level-order-traversal/solution/die-dai-di-gui-duo-tu-yan-shi-102er-cha-shu-de-cen/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/binary-tree-level-order-traversal/solution/die-dai-di-gui-duo-tu-yan-shi-102er-cha-shu-de-cen/</a></p><p>首先队列中存储根节点，每一次队列中只存储某一层的元素。当队列中存储根节点时，进入while循环，弹出根节点，再将左右子节点压入到队列中。然后再遍历队列的左子节点，弹出左子节点，并将左子节点的孩子压入到队列中，然后遍历队列的右子节点，并将右子节点的孩子压入到队列中。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">levelOrder</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type root: TreeNode</span></span><br><span class="line"><span class="string">        :rtype: List[List[int]]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:<span class="keyword">return</span> []</span><br><span class="line">        queue,res = [root],[]</span><br><span class="line">        <span class="keyword">while</span> queue:</span><br><span class="line">            cur_len = len(queue)<span class="comment">#当前层节点个数</span></span><br><span class="line">            cur_nodes = []<span class="comment">#用来存储当前层的节点</span></span><br><span class="line">            <span class="keyword">for</span> _ <span class="keyword">in</span> range(cur_len):</span><br><span class="line">                <span class="comment">#对于当前层的每个节点，将其左右子节点压入队列中</span></span><br><span class="line">                cur = queue.pop(<span class="number">0</span>)<span class="comment">#注意弹出第一个元素，pop()默认弹出最后一个元素</span></span><br><span class="line">                cur_nodes.append(cur.val)</span><br><span class="line">                <span class="keyword">if</span> cur.left:</span><br><span class="line">                    queue.append(cur.left)</span><br><span class="line">                <span class="keyword">if</span> cur.right:</span><br><span class="line">                    queue.append(cur.right)</span><br><span class="line">            res.append(cur_nodes)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h1><span id="6-根据前序和中序创建二叉树">6. 根据前序和中序创建二叉树</span></h1><p>输入某二叉树的前序遍历和中序遍历的结果，请重建该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。</p><p><a href="https://leetcode-cn.com/problems/zhong-jian-er-cha-shu-lcof/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/zhong-jian-er-cha-shu-lcof/</a></p><p><strong>【分析】</strong><br>使用递归的方式。首先找到整个树的根节点（前序的第一个节点），然后找到该节点在中序的下标（使用字典记录中序每个数字的下标），左边的即为左子树，右边的即为右子树。</p><p>例如：从前序中可以看到根节点为3，其在中序的下标为1，则左边的9为左子树节点，右边的15,20,7为右子树节点。然后递归遍历左子树，返回左子树的根节点作为3的左子树，递归遍历右子树，返回右子树的根节点作为3的右子树。</p><p>前序：3,9,20,15,7<br>中序：9,3,15,20,7</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode(object):</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">buildTree</span><span class="params">(self, preorder, inorder)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type preorder: List[int]</span></span><br><span class="line"><span class="string">        :type inorder: List[int]</span></span><br><span class="line"><span class="string">        :rtype: TreeNode</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="comment">#原理：首先在先序遍历中，第一个节点作为根节点，然后在中序遍历中，找出根节点在中序中的位置，区分哪些是左子树，哪些是右子树，然后分别对左子树和右子树递归</span></span><br><span class="line"></span><br><span class="line">        self.dic = dict()<span class="comment">#用来标记每个节点在中序遍历的位置，key：节点，value：下标</span></span><br><span class="line">        self.pre= preorder<span class="comment">#保存先序遍历</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">#遍历中序，为self.dic赋值</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(inorder)):</span><br><span class="line">            self.dic[inorder[i]] = i</span><br><span class="line">        <span class="keyword">return</span> self.recur(<span class="number">0</span>,<span class="number">0</span>,len(inorder)<span class="number">-1</span>)</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">recur</span><span class="params">(self,pre_root,in_left,in_right)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        pre_root：根节点在前序中的下标</span></span><br><span class="line"><span class="string">        in_left：该子树在中序的最左下标</span></span><br><span class="line"><span class="string">        in_right：该子树在中序的最右下标</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> in_left &gt; in_right:<span class="keyword">return</span> <span class="comment">#递归中止条件</span></span><br><span class="line">        root= TreeNode(self.pre[pre_root])<span class="comment">#创建当前子树的根节点</span></span><br><span class="line">        i = self.dic[root.val]<span class="comment">#搜索根节点在中序的索引</span></span><br><span class="line">        root.left= self.recur(pre_root+<span class="number">1</span>,in_left,i<span class="number">-1</span>)<span class="comment">#递归遍历左子树</span></span><br><span class="line">        root.right = self.recur(pre_root+i-in_left+<span class="number">1</span>,i+<span class="number">1</span>,in_right)</span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure><p>需要解释下，遍历左右子树的下标。<br>根节点在前序的下标为pre_root，在中序的下标为i，整个树在中序的左边界为in_left，右边界为in_right。</p><p><img src="/2020/05/29/Leetcode之树/7-1.png" alt=""></p><ul><li>时间复杂度：O(N)</li><li>空间复杂度：O(N)</li></ul><h1><span id="7-计算树的最大深度">7. 计算树的最大深度</span></h1><p>主要最后要加1<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">depth</span><span class="params">(self,root)</span>:</span></span><br><span class="line">        <span class="comment">#计算树root的最大深度</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:<span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">return</span> max(self.depth(root.left),self.depth(root.right))+<span class="number">1</span></span><br></pre></td></tr></table></figure></p><h1><span id="8-对称二叉树">8. 对称二叉树</span></h1><p>给定一个二叉树，检查它是否是镜像对称的。<br><a href="https://leetcode-cn.com/problems/symmetric-tree/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/symmetric-tree/</a></p><p>镜像对称<br>终止条件：</p><ul><li>如果left和right同时为空，返回True</li><li>如果left和right中有一个为空，或者2个都不为空，但是值不相等，返回False</li></ul><p>在递归中：</p><ul><li>将左节点的左孩子和右节点的右孩子比较</li><li>将左节点的右孩子和右节点的左孩子比较</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isSymmetric</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type root: TreeNode</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:<span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">        <span class="keyword">return</span> self.mirror(root.left,root.right)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">mirror</span><span class="params">(self,left,right)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> left == <span class="keyword">None</span> <span class="keyword">and</span> right == <span class="keyword">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">        <span class="keyword">if</span> left == <span class="keyword">None</span> <span class="keyword">or</span> right == <span class="keyword">None</span> <span class="keyword">or</span> left.val != right.val:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">        <span class="keyword">return</span> self.mirror(left.left,right.right) <span class="keyword">and</span> self.mirror(left.right,right.left)</span><br></pre></td></tr></table></figure><h1><span id="9-平衡二叉树">9. 平衡二叉树</span></h1><p>给定一个二叉树，判断它是否是高度平衡的二叉树。</p><p>本题中，一棵高度平衡二叉树定义为：<br>一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过1。</p><p><strong>【分析一】</strong><br><code>isBalanced(root)</code>判断树root是否是平衡二叉树</p><ul><li>特例处理：如果root为None，返回True</li><li><p>判断是否为平衡二叉树</p><ul><li><code>abs(self.depth(root.left)-self.depth(root.right))&lt;=1</code>root的左右高度差&lt;=1</li><li><code>self.isBalanced(root.left)</code>root的左子树是平衡树</li><li><code>self.isBalanced(root.right)</code>root的右子树是平衡树</li></ul></li></ul><p><code>depth(root)</code>计算树root的最大深度</p><ul><li>终止条件：当root为空时，说明root已经越过叶子节点，返回高度0</li><li>返回左子树和右子树的最大高度+1</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isBalanced</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type root: TreeNode</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:<span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">        <span class="comment">#如果root的左子树和右子树深度之差&lt;=1，且左右子树都是平衡树</span></span><br><span class="line">        <span class="keyword">if</span> abs(self.depth(root.left)-self.depth(root.right))&lt;=<span class="number">1</span> <span class="keyword">and</span> self.isBalanced(root.left) <span class="keyword">and</span> self.isBalanced(root.right):</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">depth</span><span class="params">(self,root)</span>:</span></span><br><span class="line">        <span class="comment">#计算树root的最大深度</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:<span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">return</span> max(self.depth(root.left),self.depth(root.right))+<span class="number">1</span></span><br></pre></td></tr></table></figure><p>【方法二】</p><p>自底向上<br><code>recur(root)</code>返回树root的最大深度</p><ul><li><p>返回值：如果root的左右子树深度差&lt;=1，返回root的深度，max(左,右)+1，否则说明root树不是平衡树，返回-1</p></li><li><p>递归终止条件：root为None时，说明已经越过叶子节点，返回深度为0</p></li><li>当root的左右子树返回值为-1时，表示左或右子树不是平衡树，root直接返回-1</li></ul><p><code>isBalanced(root)</code>判断root是否是平衡树</p><ul><li>判断recur(root)返回值是否为-1，为-1则不是平衡树，否则是平衡树</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isBalanced</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type root: TreeNode</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:<span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">        <span class="keyword">return</span> self.recur(root) != <span class="number">-1</span></span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">recur</span><span class="params">(self,root)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        返回以root为根的树最大深度</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:<span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        left_h= self.recur(root.left)</span><br><span class="line">        <span class="keyword">if</span> left_h==<span class="number">-1</span>:<span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">        right_h = self.recur(root.right)</span><br><span class="line">        <span class="keyword">if</span> right_h == <span class="number">-1</span>:<span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">        <span class="keyword">return</span> max(left_h,right_h)+<span class="number">1</span> <span class="keyword">if</span> abs(left_h-right_h)&lt;=<span class="number">1</span> <span class="keyword">else</span> <span class="number">-1</span></span><br></pre></td></tr></table></figure><h1><span id="10-二叉树的镜像">10. 二叉树的镜像</span></h1><p>请完成一个函数，输入一个二叉树，该函数输出它的镜像。</p><p><a href="https://leetcode-cn.com/problems/er-cha-shu-de-jing-xiang-lcof/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/er-cha-shu-de-jing-xiang-lcof/</a></p><p><strong>【分析一】</strong><br>使用递归</p><ol><li>递归终止条件：当节点root为空时，返回None</li><li>递归工作<ul><li>先使用tmp保存节点root的左子树</li><li>给root.left赋予新的值</li><li>给root.right赋予新的值</li></ul></li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">mirrorTree</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type root: TreeNode</span></span><br><span class="line"><span class="string">        :rtype: TreeNode</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:<span class="keyword">return</span> <span class="keyword">None</span></span><br><span class="line">        <span class="comment">#不用生成新的树，直接在原始树进行修改</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:<span class="keyword">return</span> <span class="keyword">None</span></span><br><span class="line">        tmp = root.left</span><br><span class="line">        root.left = self.mirrorTree(root.right)</span><br><span class="line">        root.right = self.mirrorTree(tmp)</span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure><p><strong>【分析二】</strong><br>使用栈stack遍历树的所有节点，并交换每个节点的左右子树</p><p><img src="/2020/05/29/Leetcode之树/2.png" alt=""></p><ol><li>特例处理：当root为空时，直接使用return</li><li>初始化栈，将root加入到栈中</li><li>遍历栈，刚开始弹出节点4，并将节点2和节点7压入栈中，然后交换节点4的左右节点。然后再进入到while循环中，弹出节点7，再将节点6和节点9压入栈中，交换节点7的左右节点。然后再将节点9弹出栈，因为节点9的左右节点为空，所以没有节点压入shatck中，然后交换节点9的左右节点（交换None）。然后弹出节点6出栈…….</li></ol><p>使用栈，可以看做是DFS，先将右子树内部的节点交换，然后再将左子树内部的节点交换<br>如果使用队列，可以看做是BFS，先交换第一层的左右节点，再交换第二层的左右节点。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">mirrorTree</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type root: TreeNode</span></span><br><span class="line"><span class="string">        :rtype: TreeNode</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:<span class="keyword">return</span> <span class="keyword">None</span></span><br><span class="line">        <span class="comment">#不用生成新的树，直接在原始树进行修改</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:<span class="keyword">return</span> <span class="keyword">None</span></span><br><span class="line">        stack = [root]</span><br><span class="line">        <span class="keyword">while</span> stack:</span><br><span class="line">            cur = stack.pop()</span><br><span class="line">            <span class="keyword">if</span> cur.left:stack.append(cur.left)</span><br><span class="line">            <span class="keyword">if</span> cur.right:stack.append(cur.right)</span><br><span class="line">            cur.left,cur.right = cur.right,cur.left</span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure><h1><span id="11-二叉搜索树的后序遍历序列">11. 二叉搜索树的后序遍历序列</span></h1><p>输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历结果。如果是则返回 true，否则返回 false。假设输入的数组的任意两个数字都互不相同。</p><p><a href="https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-hou-xu-bian-li-xu-lie-lcof/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-hou-xu-bian-li-xu-lie-lcof/</a></p><p><strong>【分析一】</strong><br>二叉搜索树：左子树&lt;根节点，右子树&gt;根节点<br>后序遍历：左右根<br>给定序列的最后一个元素肯定是整个树的根，比它小的是左子树，比它大的是右子树</p><p><img src="/2020/05/29/Leetcode之树/3.png" alt=""></p><p>使用递归的方法，递归函数传入的参数是后续序列。</p><ul><li>递归终止条件：后续序列为空，返回True</li><li>递归返回值：如果当前postorder可以构成二叉搜索树，返回True，否则返回False</li><li>递归工作：<ul><li>找根节点=postorder的最后一个元素</li><li>找左子树的范围</li><li>在右子树中，如果有小于root的值，返回false。如果没有的话，说明root的左右子树都正常</li><li>下面递归判断左子树的后序序列和右子树的后序序列是否正常</li><li>返回2者的and值</li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">verifyPostorder</span><span class="params">(self, postorder)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type postorder: List[int]</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> postorder:<span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">isTree</span><span class="params">(postorder)</span>:</span></span><br><span class="line">            <span class="string">"""</span></span><br><span class="line"><span class="string">            输入一个后续序列，判断是否是某个二叉搜索树的后续序列</span></span><br><span class="line"><span class="string">            如果是，返回True，否则返回False</span></span><br><span class="line"><span class="string">            """</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> postorder:<span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">            root = postorder[<span class="number">-1</span>]</span><br><span class="line">            left,right = <span class="number">0</span>,<span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(len(postorder)):</span><br><span class="line">                <span class="keyword">if</span> postorder[i] &gt; root:</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">            <span class="comment">#跳出for循环的i指向第一个大于root的节点,左子树[0,i-1]</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(i,len(postorder)<span class="number">-1</span>):</span><br><span class="line">                <span class="comment">#如果右子树中有比root小的，返回false</span></span><br><span class="line">                <span class="keyword">if</span> postorder[j] &lt; root:</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">            is_left,is_right = <span class="keyword">False</span>,<span class="keyword">False</span><span class="comment">#判断左后续序列是否能组成二叉搜索树</span></span><br><span class="line">            is_left = isTree(postorder[:i])</span><br><span class="line">            is_right = isTree(postorder[i:<span class="number">-1</span>])</span><br><span class="line">            <span class="keyword">return</span> is_left <span class="keyword">and</span> is_right</span><br><span class="line">        <span class="keyword">return</span> isTree(postorder)</span><br></pre></td></tr></table></figure><ul><li>时间复杂度：O(n2)</li><li>空间复杂度：O(N)0</li></ul><p><strong>【分析二】</strong></p><h1><span id="12-总结">12. 总结</span></h1><ul><li>深度优先搜索DFS一般使用栈结构存储，广度优先搜索BFS一般使用队列结构存储</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;!-- TOC --&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#1-树概念介绍&quot;&gt;1. 树概念介绍&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#2-树的前向遍历&quot;&gt;2. 树的前向遍历&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#3-二叉树的
      
    
    </summary>
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
      <category term="树" scheme="http://yoursite.com/tags/%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode之链表</title>
    <link href="http://yoursite.com/2020/05/24/Leetcode%E4%B9%8B%E9%93%BE%E8%A1%A8/"/>
    <id>http://yoursite.com/2020/05/24/Leetcode之链表/</id>
    <published>2020-05-24T08:19:04.000Z</published>
    <updated>2020-06-18T02:35:16.159Z</updated>
    
    <content type="html"><![CDATA[<p>链表遍历数据时，需要从头遍历。链表只需要给出头指针就可以</p><a id="more"></a><!-- TOC --><ul><li><a href="#1-快慢指针">1. 快慢指针</a><ul><li><a href="#11-找链表的中间节点">1.1. 找链表的中间节点</a></li><li><a href="#12-倒数第k个节点">1.2. 倒数第K个节点</a></li><li><a href="#13-环形链表">1.3. 环形链表</a></li><li><a href="#14-环形链表ii">1.4. 环形链表II</a></li><li><a href="#15-相交链表">1.5. 相交链表</a></li></ul></li><li><a href="#2-反转链表">2. 反转链表</a></li><li><a href="#3-添加新的头结点">3. 添加新的头结点</a><ul><li><a href="#31-两两交换链表中的节点">3.1. 两两交换链表中的节点</a></li><li><a href="#32-删除链表的倒数第n个节点">3.2. 删除链表的倒数第N个节点</a></li></ul></li><li><a href="#4-总结">4. 总结</a></li></ul><!-- /TOC --><h1><span id="1-快慢指针">1. 快慢指针</span></h1><h2><span id="11-找链表的中间节点">1.1. 找链表的中间节点</span></h2><p>给定一个带有头结点 head 的非空单链表，返回链表的中间结点。</p><p>如果有两个中间结点，则返回第二个中间结点。</p><p><strong>【分析】</strong></p><ul><li>当链表中个数为奇数时，返回中间的节点。例如1-&gt;2-&gt;3-&gt;4-&gt;5，返回节点3</li><li>当链表中个数为偶数时，返回右节点。例如1-&gt;2-&gt;3-&gt;4，中间的节点有2和3，返回右节点3</li><li>当链表中个数为偶数时，返回左节点。例如1-&gt;2-&gt;3-&gt;4，中间的节点有2和3，返回右节点2</li></ul><p>使用双指针，慢指针一次走一步，快指针一次走两步</p><p><img src="/2020/05/24/Leetcode之链表/876-1.png" alt=""></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">middleNode</span><span class="params">(self, head)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type head: ListNode</span></span><br><span class="line"><span class="string">        :rtype: ListNode</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        fast,low = head,head</span><br><span class="line">        <span class="comment">#返回右节点</span></span><br><span class="line">        <span class="keyword">while</span> fast <span class="keyword">and</span> fast.next:</span><br><span class="line">            fast = fast.next.next</span><br><span class="line">            low = low.next</span><br><span class="line">        <span class="keyword">return</span> low</span><br></pre></td></tr></table></figure><p><img src="/2020/05/24/Leetcode之链表/876-2.png" alt=""></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">middleNode</span><span class="params">(self, head)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type head: ListNode</span></span><br><span class="line"><span class="string">        :rtype: ListNode</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        fast,low = head,head</span><br><span class="line">        <span class="comment">#返回左节点</span></span><br><span class="line">        <span class="keyword">while</span> fast.next <span class="keyword">and</span> fast.next.next:</span><br><span class="line">            fast = fast.next.next</span><br><span class="line">            low = low.next</span><br><span class="line">        <span class="keyword">return</span> low</span><br></pre></td></tr></table></figure><h2><span id="12-倒数第k个节点">1.2. 倒数第K个节点</span></h2><p>输入一个链表，输出该链表中倒数第k个节点。尾节点是倒数第1个节点。</p><p>例如：给定一个链表: 1-&gt;2-&gt;3-&gt;4-&gt;5, 和 k = 2.<br>返回链表 4-&gt;5</p><p><strong>【分析】</strong><br>使用快慢指针，快指针先向前移动k个节点，慢指针指向head，然后快慢指针一起向前走，当快指针指向null时，此时慢指针指向倒数第k个节点，返回即可。<br>举例：1-&gt;3-&gt;9-&gt;7-&gt;6-&gt;12，k=3，首先fast和low都指向1，然后fast向前移动3步指向7，然后fast和low同时向前走，当fast指向null时，此时low指向7，返回即可。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getKthFromEnd</span><span class="params">(self, head, k)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type head: ListNode</span></span><br><span class="line"><span class="string">        :type k: int</span></span><br><span class="line"><span class="string">        :rtype: ListNode</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> head:<span class="keyword">return</span> head</span><br><span class="line">        <span class="keyword">if</span> k==<span class="number">0</span>:<span class="keyword">return</span> <span class="keyword">None</span></span><br><span class="line">        fast,low = head,head</span><br><span class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> range(k):</span><br><span class="line">            <span class="keyword">if</span> fast:</span><br><span class="line">                fast = fast.next</span><br><span class="line">            <span class="keyword">else</span>:<span class="comment">#防止k大于链表个数</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">None</span></span><br><span class="line">        <span class="keyword">while</span> fast:</span><br><span class="line">            fast = fast.next</span><br><span class="line">            low = low.next</span><br><span class="line">        <span class="keyword">return</span> low</span><br></pre></td></tr></table></figure><h2><span id="13-环形链表">1.3. 环形链表</span></h2><p><a href="https://leetcode-cn.com/problems/linked-list-cycle/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/linked-list-cycle/</a><br>给定一个链表，判断链表中是否有环。</p><ul><li><p><strong>使用set</strong><br>使用set保存节点的引用，而不是节点的值</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">hasCycle</span><span class="params">(self, head)</span>:</span></span><br><span class="line">      <span class="string">"""</span></span><br><span class="line"><span class="string">      :type head: ListNode</span></span><br><span class="line"><span class="string">      :rtype: bool</span></span><br><span class="line"><span class="string">      """</span></span><br><span class="line">      <span class="comment">#使用set，这里set保存的是节点的引用，而不是节点的值</span></span><br><span class="line">      nodes = set()</span><br><span class="line">      <span class="keyword">while</span> head:</span><br><span class="line">          <span class="keyword">if</span> head <span class="keyword">in</span> nodes:</span><br><span class="line">              <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">          nodes.add(head)</span><br><span class="line">          head = head.next</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">False</span></span><br></pre></td></tr></table></figure></li><li><p><strong>快慢指针</strong><br>快指针每次走2步，慢指针每次走1步，如果链表中有环，两者迟早会碰上，如果始终碰不上，则链表中没有环。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">hasCycle</span><span class="params">(self, head)</span>:</span></span><br><span class="line">      <span class="string">"""</span></span><br><span class="line"><span class="string">      :type head: ListNode</span></span><br><span class="line"><span class="string">      :rtype: bool</span></span><br><span class="line"><span class="string">      """</span></span><br><span class="line">      <span class="keyword">if</span> <span class="keyword">not</span> head:<span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">      fast,low = head,head</span><br><span class="line">      <span class="keyword">while</span> fast.next <span class="keyword">and</span> fast.next.next:</span><br><span class="line">          fast = fast.next.next</span><br><span class="line">          low = low.next</span><br><span class="line">          <span class="keyword">if</span> fast == low:</span><br><span class="line">              <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">False</span></span><br></pre></td></tr></table></figure></li></ul><h2><span id="14-环形链表ii">1.4. 环形链表II</span></h2><p>给定一个链表，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。<br>说明：不允许修改给定的链表。<br>链接：<a href="https://leetcode-cn.com/problems/linked-list-cycle-ii" target="_blank" rel="noopener">https://leetcode-cn.com/problems/linked-list-cycle-ii</a></p><p><strong>【分析】</strong><br><a href="https://leetcode-cn.com/problems/linked-list-cycle-ii/solution/wo-dui-di-er-jie-duan-de-li-jie-by-fei-er-10/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/linked-list-cycle-ii/solution/wo-dui-di-er-jie-duan-de-li-jie-by-fei-er-10/</a></p><p><img src="/2020/05/24/Leetcode之链表/142-1.png" alt=""></p><p>快指针每次走2步，慢指针每次走1步，如果链表中存在环，则一定会相遇。如上图所示，2指针在C点相遇，然后让一个指针退回到头结点A，一个指针继续待在C，然后向前走，两指针再次相遇的点就是入环的第一个节点。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">detectCycle</span><span class="params">(self, head)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type head: ListNode</span></span><br><span class="line"><span class="string">        :rtype: ListNode</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> head:<span class="keyword">return</span> <span class="keyword">None</span></span><br><span class="line">        fast,slow = head,head</span><br><span class="line">        <span class="keyword">while</span> fast.next <span class="keyword">and</span> fast.next.next:</span><br><span class="line">            fast = fast.next.next</span><br><span class="line">            slow = slow.next</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> fast == slow:</span><br><span class="line">                slow = head</span><br><span class="line">                <span class="keyword">while</span> slow != fast:</span><br><span class="line">                    slow = slow.next</span><br><span class="line">                    fast = fast.next</span><br><span class="line">                <span class="keyword">return</span> fast</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">None</span></span><br></pre></td></tr></table></figure><h2><span id="15-相交链表">1.5. 相交链表</span></h2><p>编写一个程序，找到两个单链表相交的起始节点。<br><a href="https://leetcode-cn.com/problems/intersection-of-two-linked-lists/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/intersection-of-two-linked-lists/</a></p><p><strong>【分析】</strong></p><p>A链表：1-&gt;2-&gt;3-&gt;8-&gt;7-&gt;9-&gt;11<br>B链表：10-&gt;6-&gt;8-&gt;7-&gt;9-&gt;11<br>相交节点为8，共同拥有部分长度c=4，A和B分别单独拥有的长度a=3，b=2<br>a+c不等于b+c，但如果2个节点同时遍历a+c+b,b+c+a，因为长度一样，则一定会同时结束。如果A和B相交，则一定会在交点处停止，如果A和B不相交，则分别会到达B和A的尾节点。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getIntersectionNode</span><span class="params">(self, headA, headB)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type head1, head1: ListNode</span></span><br><span class="line"><span class="string">        :rtype: ListNode</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        A,B = headA,headB</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> A!=B:</span><br><span class="line">            A = A.next <span class="keyword">if</span> A <span class="keyword">else</span> headB</span><br><span class="line">            B = B.next <span class="keyword">if</span> B <span class="keyword">else</span> headA</span><br><span class="line">        <span class="keyword">return</span> A</span><br></pre></td></tr></table></figure><h1><span id="2-反转链表">2. 反转链表</span></h1><p><strong>【分析】</strong></p><p>反转列表，原先的头结点变成尾节点，首先cur为头结点，pre为None，第一次循环时，先把cur的下一个节点保存成tmp，然后改变cur的next为None，这样就把头结点变成尾节点（next节点为空），然后cur变成pre，开始遍历下一个节点，即tmp，使用cur=tmp赋值。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverseList</span><span class="params">(self, head)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type head: ListNode</span></span><br><span class="line"><span class="string">        :rtype: ListNode</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        cur,pre = head,<span class="keyword">None</span></span><br><span class="line">        <span class="keyword">while</span> cur:</span><br><span class="line">            tmp = cur.next</span><br><span class="line">            cur.next = pre</span><br><span class="line">            pre = cur</span><br><span class="line">            cur = tmp</span><br><span class="line">        <span class="keyword">return</span> pre</span><br></pre></td></tr></table></figure><h1><span id="3-添加新的头结点">3. 添加新的头结点</span></h1><h2><span id="31-两两交换链表中的节点">3.1. 两两交换链表中的节点</span></h2><p>给定一个链表，两两交换其中相邻的节点，并返回交换后的链表。</p><p>你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。</p><p><a href="https://leetcode-cn.com/problems/swap-nodes-in-pairs/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/swap-nodes-in-pairs/</a></p><p>例如：给定 1-&gt;2-&gt;3-&gt;4, 你应该返回 2-&gt;1-&gt;4-&gt;3.</p><p><strong>【分析】</strong><br>在原始链表上添加一个头节点thread，将thread指向原始头结点head。每次交换顺序时，需要有3个指针：a：当前交换的左节点，b：当前交换的右节点，c：a的前一个节点。例如要交换1和2的顺序时，c=-1，a=1，b=2，交换后变成-1-&gt;2-&gt;1-&gt;3-&gt;4，要交换3和4的顺序时，c=1，a=3，b=4，交换后变成-1-&gt;2-&gt;1-&gt;4-&gt;3，然后返回thread的下一个节点，即新的头结点2。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">swapPairs</span><span class="params">(self, head)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type head: ListNode</span></span><br><span class="line"><span class="string">        :rtype: ListNode</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> head <span class="keyword">or</span> <span class="keyword">not</span> head.next:</span><br><span class="line">            <span class="keyword">return</span> head</span><br><span class="line">        thred = ListNode(<span class="number">-1</span>)</span><br><span class="line">        thred.next = head</span><br><span class="line">        c = thred</span><br><span class="line">        <span class="keyword">while</span> c.next <span class="keyword">and</span> c.next.next:</span><br><span class="line">            a,b = c.next,c.next.next</span><br><span class="line">            c.next,a.next = b,b.next</span><br><span class="line">            b.next = a</span><br><span class="line">            c = c.next.next</span><br><span class="line">        <span class="keyword">return</span> thred.next</span><br></pre></td></tr></table></figure><h2><span id="32-删除链表的倒数第n个节点">3.2. 删除链表的倒数第N个节点</span></h2><p>给定一个链表，删除链表的倒数第 n 个节点，并且返回链表的头结点。<br><a href="https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list/</a></p><p>给定一个链表: 1-&gt;2-&gt;3-&gt;4-&gt;5, 和 n = 2.<br>当删除了倒数第二个节点后，链表变为 1-&gt;2-&gt;3-&gt;5.</p><p><strong>【分析】</strong><br>这一题是”找链表中倒数第N个节点”的进阶版。首先使用快慢指针找到倒数第N个节点，同时还要删除，这里需要记录倒数第N个节点的前一个节点。本题通过添加一个头结点来实现。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">removeNthFromEnd</span><span class="params">(self, head, n)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type head: ListNode</span></span><br><span class="line"><span class="string">        :type n: int</span></span><br><span class="line"><span class="string">        :rtype: ListNode</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        fast,low = head,head</span><br><span class="line">        thread = ListNode(<span class="number">-1</span>)<span class="comment">#low的前一个节点</span></span><br><span class="line">        thread.next = head</span><br><span class="line">        pre = thread</span><br><span class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> range(n):</span><br><span class="line">            fast = fast.next</span><br><span class="line">        <span class="keyword">while</span> fast:</span><br><span class="line">            pre = low</span><br><span class="line">            fast = fast.next</span><br><span class="line">            low = low.next</span><br><span class="line">        pre.next = low.next</span><br><span class="line">        <span class="keyword">return</span> thread.next</span><br></pre></td></tr></table></figure><h1><span id="4-总结">4. 总结</span></h1><ol><li>使用快慢指针<br>链表中间节点，链表倒数K个元素，环形链表</li><li>添加新的头结点<br>添加一个新的头节点，next指向原来的头结点，注意返回的时候返回原先的头结点，而不是新建的。</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;链表遍历数据时，需要从头遍历。链表只需要给出头指针就可以&lt;/p&gt;
    
    </summary>
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
      <category term="链表" scheme="http://yoursite.com/tags/%E9%93%BE%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode之排序</title>
    <link href="http://yoursite.com/2020/03/30/Leetcode%E4%B9%8B%E6%8E%92%E5%BA%8F/"/>
    <id>http://yoursite.com/2020/03/30/Leetcode之排序/</id>
    <published>2020-03-30T02:38:24.000Z</published>
    <updated>2020-06-18T09:22:50.161Z</updated>
    
    <content type="html"><![CDATA[<p>开始刷题了，首先整理并实现经典的排序算法并对其优化，使用Python实现。所有的排序默认从小到大排序</p><a id="more"></a><!-- TOC --><ul><li><a href="#1-术语说明">1. 术语说明</a></li><li><a href="#2-冒泡排序">2. 冒泡排序</a><ul><li><a href="#21-冒泡排序">2.1. 冒泡排序</a></li><li><a href="#22-优化1">2.2. 优化1</a></li><li><a href="#23-优化2">2.3. 优化2</a></li></ul></li><li><a href="#3-选择排序">3. 选择排序</a></li><li><a href="#4-插入排序">4. 插入排序</a></li><li><a href="#5-快速排序">5. 快速排序</a><ul><li><a href="#51-快速排序">5.1. 快速排序</a></li><li><a href="#52-优化1">5.2. 优化1</a></li><li><a href="#53-三路快排">5.3. 三路快排</a></li></ul></li><li><a href="#6-归并排序">6. 归并排序</a></li><li><a href="#7-堆排序">7. 堆排序</a><ul><li><a href="#71-堆排序">7.1. 堆排序</a></li><li><a href="#72-应用topk问题">7.2. 应用：topK问题</a></li></ul></li><li><a href="#8-nb三人组小结">8. NB三人组小结</a></li><li><a href="#9-希尔排序插入排序的改良版">9. 希尔排序(插入排序的改良版)</a></li><li><a href="#10-计数排序">10. 计数排序</a></li><li><a href="#11-桶排序">11. 桶排序</a></li><li><a href="#12-基数排序">12. 基数排序</a></li><li><a href="#13-leetcode题">13. LeetCode题</a><ul><li><a href="#131-合并两个有序数组">13.1. 合并两个有序数组</a></li><li><a href="#132-数组中的第k个最大元素">13.2. 数组中的第K个最大元素</a><ul><li><a href="#1321-总结">13.2.1. 总结</a></li></ul></li><li><a href="#133-前-k-个高频元素">13.3. 前 K 个高频元素</a></li><li><a href="#134-面试题39-数组中出现次数超过一半的数字">13.4. 面试题39. 数组中出现次数超过一半的数字</a></li><li><a href="#135-颜色分类">13.5. 颜色分类</a></li><li><a href="#136-两个数组的交集-ii">13.6. 两个数组的交集 II</a></li><li><a href="#137-摆动排序-ii">13.7. 摆动排序 II</a></li></ul></li><li><a href="#数据流的中位数">数据流的中位数</a></li><li><a href="#14-总结">14. 总结</a></li></ul><!-- /TOC --><p>一共有10种排序算法，先给出排序算法的性能<br><img src="/2020/03/30/Leetcode之排序/conclusion.png" alt=""></p><ul><li>low B 三人组：冒泡，选择，插入</li><li>NB 三人组：快排，归并，堆排序</li><li>其他排序：计数排序，基数，希尔排序，桶排序</li></ul><h1><span id="1-术语说明">1. 术语说明</span></h1><ul><li>稳定：原始数据中a=b，并且a在b的前面，排序后a仍然在b的前面</li><li>不稳定：原始数据中a=b，并且a在b的前面，排序后a可能会出现在b的后面</li><li>内排序：所有排序操作都在内存中完成</li><li>外排序：由于数据太大，需要把数据放在磁盘中，而排序通过磁盘和内存的数据传输才能进行</li><li>比较排序：每个数必须和其他数进行比较，才能确定自己的位置。比较排序的优势：适用于各种规模的数据，不管数据分布什么样，都可以进行排序。可以说比较排序适用于一切需要排序的情况</li><li>非比较排序：通过确定每个元素之前，应该有多少元素来排序，针对arr[i]，计算arr[i]之前有多少个元素，则唯一确定了arr[i]在排序后数组中的位置，一次遍历即可解决，算法时间复杂度$O(N)$。非比较排序时间复杂度低，但由于需要占用空间来确定唯一位置，所以对数据规模和数据分布有一定要求</li></ul><p><strong>【交换函数】</strong><br>在比较排序中，需要用到交换函数，先在此定义下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">swap</span><span class="params">(nums,i,j)</span>:</span></span><br><span class="line">    tmp = nums[i]</span><br><span class="line">    nums[i] = nums[j]</span><br><span class="line">    nums[j] = tmp</span><br></pre></td></tr></table></figure><h1><span id="2-冒泡排序">2. 冒泡排序</span></h1><p>最简单的排序之一</p><h2><span id="21-冒泡排序">2.1. 冒泡排序</span></h2><p><strong>基本思想：</strong><br>每个数和它后面的数比较，小的数放在前面，大的数放在后面，最终越小的元素经过交换慢慢浮到数组的顶端，类似于水泡上升一样。<br><strong>步骤：</strong></p><ol><li>2重循环，第一次循环控制比较的次数，假设有n个数，第一次需要比较n-1次，选出n个数中最大的数；第二次需要比较n-2次，选出n-1个数中最大的数，…，剩下2个数，需要比较1次，选出最大的数</li><li>外层循环一共需要比较i=n-1,n-2,…1次，range(n-1,0,-1)</li><li>内存循环j=0,1,2,…i-1，range(0,i)</li><li>将数组分为有序和无序，每一次外循环，都将无序数组的最大值放在后面。首先整个数组都是无序的，经过一次外循环，有序数组个数加1，无序数组减1。然后再经过一次外循环，有序数组个数再加1，无序数组减1，直到所有数据全变成有序。</li></ol><p><img src="/2020/03/30/Leetcode之排序/bubble.gif" alt=""><br><strong>实现：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bubble_sort</span><span class="params">(nums)</span>:</span></span><br><span class="line">    n = len(nums)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(n<span class="number">-1</span>,<span class="number">0</span>,<span class="number">-1</span>):<span class="comment">#排序的趟数，一共n-1趟</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">0</span>,i):<span class="comment">#对0~i-1个数进行排序</span></span><br><span class="line">            <span class="comment">#每个数和后面比较，只有当前面数&gt;后面数才交换，相等不会交换，体现稳定性</span></span><br><span class="line">            <span class="keyword">if</span> nums[j] &gt; nums[j+<span class="number">1</span>]:</span><br><span class="line">                swap(nums,j,j+<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> nums</span><br></pre></td></tr></table></figure><ul><li>空间复杂性：$O(1)$</li><li>时间复杂性：$0(n^2)$</li><li>使用场景：适合小数据的排序，因为算法复杂度高，在数据量大不适用</li></ul><h2><span id="22-优化1">2.2. 优化1</span></h2><p>冒泡排序的关键是与后面的元素进行比较，然后交换，但是当我们发现某次排序过程中没有发生过交换行为，便可以认为，剩下的元素都是有序的，所以也不用比较了。例如：1,2,3,4,5，进行第一次排序时我们就发现后面的2大于1，3大于2…5大于4，此时便可以认为数据有序，不必再进行后面的排序和比较。<br>每次进入内部循环前，设置flag来标记前面0~i-1个数中是否发生交换，没有发生交换，说明前面的数已经是有序的，不用再排序了。<br>在数据完全有序的时候，最好时间复杂度$O(n)$,其他情况总是$O(n^2)$，因此算法在数据基本有序的情况下，性能最好。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bubble_sort1</span><span class="params">(nums)</span>:</span></span><br><span class="line">    n = len(nums)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(n<span class="number">-1</span>,<span class="number">0</span>,<span class="number">-1</span>):</span><br><span class="line">        flag = <span class="keyword">False</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">0</span>,i):</span><br><span class="line">            <span class="keyword">if</span> nums[j] &gt; nums[j+<span class="number">1</span>]:</span><br><span class="line">                swap(nums,j,j+<span class="number">1</span>)</span><br><span class="line">                flag = <span class="keyword">True</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> flag:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">return</span> nums</span><br></pre></td></tr></table></figure><h2><span id="23-优化2">2.3. 优化2</span></h2><p>在交换时，记录最后一次交换的位置，下次内循环时，只用遍历到这个位置就可以了，因为这个位置后的元素已经有序了</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bubble_sort2</span><span class="params">(nums)</span>:</span></span><br><span class="line">    n = len(nums)</span><br><span class="line">    k = n - <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(n<span class="number">-1</span>,<span class="number">0</span>,<span class="number">-1</span>):</span><br><span class="line">        flag = <span class="keyword">False</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">0</span>,k):</span><br><span class="line">            <span class="keyword">if</span> nums[j] &gt; nums[j+<span class="number">1</span>]:</span><br><span class="line">                swap(nums,j,j+<span class="number">1</span>)</span><br><span class="line">                flag = <span class="keyword">True</span></span><br><span class="line">                k = j</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> flag:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">return</span> nums</span><br></pre></td></tr></table></figure><h1><span id="3-选择排序">3. 选择排序</span></h1><p>表现最稳定的排序算法之一，无论什么数据，都是$O(n^2)$的时间复杂度，数据规模越小越好。<br>选择排序和冒泡排序的区别是：选择排序只有在确定了最小值的前提下，才进行交换，大大减少交换的次数。<br><strong>基本思想：</strong></p><ul><li>首先在未排序的数组中找到最小/大元素，放在数组的第一个位置，</li><li>然后再从剩下未排序数组中找最小/大元素，放在第二个位置</li><li>此次类推，直到所有的元素排序完成。</li></ul><p><img src="/2020/03/30/Leetcode之排序/select.gif" alt=""></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">select_sort</span><span class="params">(nums)</span>:</span></span><br><span class="line">    n = len(nums)</span><br><span class="line">    <span class="comment">#每一趟选出无序中最小的数</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">        min_idx = i</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(i+<span class="number">1</span>,n):</span><br><span class="line">            <span class="keyword">if</span> nums[j] &lt; nums[min_idx]:</span><br><span class="line">                min_idx = j</span><br><span class="line">        <span class="keyword">if</span> min_idx != i:<span class="comment">#下标不同才交换</span></span><br><span class="line">            swap(nums,i,min_idx)</span><br><span class="line">    <span class="keyword">return</span> nums</span><br></pre></td></tr></table></figure><ul><li>不稳定</li><li>在各种情况下，复杂度波动小，因此一般优于冒泡排序，在所有的完全交换排序中，选择排序是不错的算法</li><li>时间复杂度$O(n^2)$，使用于简单数据</li></ul><h1><span id="4-插入排序">4. 插入排序</span></h1><p><strong>基本思想：</strong><br>将数组分成2部分：有序数组和无序数组，给无序数组中的一个数，从后向前遍历有序数组，放在特定的位置上，然后再遍历下一个无序数据，再插入到有序数组中。</p><p><strong>步骤：</strong></p><ol><li>从第一个元素开始，该元素认为已经排好序</li><li>取下一个元素，在有序数组中从后向前扫描</li><li>如果该元素(已排序)大于新元素，将该元素(已排序)后移一位</li><li>重复步骤3，直到找到有序数组中 &lt;= 新元素</li><li>将新元素插入到该元素后面</li></ol><p><img src="/2020/03/30/Leetcode之排序/insert.gif" alt=""></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">insert_sort</span><span class="params">(nums)</span>:</span></span><br><span class="line">    n = len(nums)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,n):</span><br><span class="line">        <span class="comment">#只有当nums[i]&lt;有序数据时，才将有序数组中的元素后移</span></span><br><span class="line">        <span class="keyword">if</span> nums[i] &lt; nums[i<span class="number">-1</span>]:</span><br><span class="line">            tmp = nums[i]</span><br><span class="line">            insert_idx = i</span><br><span class="line">            <span class="comment">#遍历nums[i-1,...0]找出nums[i]插入位置</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(i<span class="number">-1</span>,<span class="number">-1</span>,<span class="number">-1</span>):</span><br><span class="line">                <span class="comment">#只有有序数据&gt;无序数据时，才将有序数据后移，</span></span><br><span class="line">                <span class="comment">#有序&lt;=无序，有序数组不用后移，所以插入排序是稳定的</span></span><br><span class="line">                <span class="keyword">if</span> nums[j] &gt; tmp:</span><br><span class="line">                    nums[j+<span class="number">1</span>] = nums[j]</span><br><span class="line">                    insert_idx = j</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">            nums[insert_idx] = tmp</span><br><span class="line">    <span class="keyword">return</span> nums</span><br></pre></td></tr></table></figure><ul><li>在有序数组中找到&lt;=无序数据，不交换位置，所以插入排序是稳定的</li><li>时间复杂度：$O(n^2)$，如果数据已经有序，那么比较次数为$O(n)$，不需要移动。</li><li>适用场景：在数组较大时不适用，但是在数据比较少时，一般作为快排的扩充，例如在JDK 7 java.util.Arrays所用的sort方法的实现中，当待排数组长度小于47时，会使用插入排序。</li></ul><h1><span id="5-快速排序">5. 快速排序</span></h1><h2><span id="51-快速排序">5.1. 快速排序</span></h2><p>在实际运用中冒泡排序很少使用，因为每次排序都要经过大量的交换，费时。快速排序通常比同为$nlog(n)$算法快，在实际应用中是表现最好的算法，因此常被采用，快排采用了分治思想。<br>快排虽然高端，但其思想来自于冒泡排序，冒泡排序通过相邻元素的比较和交换，把最小的元素冒泡在顶端，而快排是比较和交换大数和小数，不仅把小数冒泡到上面，同时把大数沉到下面。<br><strong>基本思想：</strong><br>找出一个基准，通过一趟排序，将待排序数据分割成独立的2部分，一部分基准大，一部分比基准小。快排使用分治法将一串分为2个子串</p><p><strong>步骤：</strong></p><ol><li>从数组中找出一个元素，作为基准（通常选择待排序数组中的第一个或最后一个元素）</li><li>在分区过程中，右指针找比基准小的，左指针找比基准大的，将这2个数交换，即比基准大的放在右边，小于或等于基准的放在左边</li><li>再对左右区间递归执行第二步，直到区间中只有一个数</li></ol><p>举例：5,4,1,8,10,7,9,2,4,3（刚开始）<br>基准值选：5</p><ul><li>首先lp指向5，rp指向3，这时右边的3比基准元素5小，说明该数需要交换。然后在左边找大于5的数，一直到lp指向8，交换8和3，变成[5,4,1,3,10,7,9,2,4,8]</li><li>此时rp指向8，lp指向3。然后rp左移在右边找小于5的数，rp指向4，左边lp指向10，交换4和10变成[5,4,1,3,4,7,9,2,10,8]</li><li>此时rp指向10，lp指向4，在右边找小于5的数，rp指向2，lp指向7，交换2和7，变成[5,4,1,3,4,2,9,7,10,8]</li><li>此时rp指向7，lp指向2，在右边找小于5的数，rp指向2，此时lp也指向2，2个指针相遇，rp==lp，跳出while循环</li><li>交换基准元素5和相遇位置的2，变成[2,4,1,3,4,5,9,7,10,8]，此时5左边的数全小于5，右边的数全大于5，然后递归对[2,4,1,3,4]和[9,7,10,8]进行排序</li></ul><p>注意以下几个点：</p><ul><li>右指针先扫描，首先这也不是绝对的，这取决于基准数的位置，因为在最后两个指针相遇的时候，要交换基准数到相遇的位置。一般选取第一个数作为基准数，那么就是在左边，所以最后相遇的数要和基准数交换，那么相遇的数一定要比基准数小。所以j指针先移动才能先找到比基准数小的数。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">quick_sort</span><span class="params">(nums)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> qsort(nums,<span class="number">0</span>,len(nums)<span class="number">-1</span>)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">qsort</span><span class="params">(nums,left,right)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> left &gt;= right:<span class="comment">#结束条件</span></span><br><span class="line">        <span class="keyword">return</span> nums</span><br><span class="line">    key = nums[left]<span class="comment">#最左边为基准数</span></span><br><span class="line">    lp = left <span class="comment">#左指针</span></span><br><span class="line">    rp = right <span class="comment">#右指针</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> lp &lt; rp:<span class="comment">#退出循环时，lp=rp</span></span><br><span class="line">        <span class="comment">#先移动右指针，直到右边的数&lt;key，说明这个数需要交换</span></span><br><span class="line">        <span class="keyword">while</span> lp &lt; rp <span class="keyword">and</span> nums[rp] &gt;= key:</span><br><span class="line">            rp -= <span class="number">1</span></span><br><span class="line">        <span class="comment">#再移动左指针，直到左边的数&gt;key，说明这个数需要交换</span></span><br><span class="line">        <span class="keyword">while</span> lp &lt; rp <span class="keyword">and</span> nums[lp] &lt;= key:</span><br><span class="line">            lp += <span class="number">1</span></span><br><span class="line">        swap(nums,lp,rp)</span><br><span class="line">    <span class="comment">#当lp==rp时跳出while循环，此时lp和rp指向的数&lt;key，交换相遇位置和基准数，此时key的位置就在lp上</span></span><br><span class="line">    swap(nums,left,lp)</span><br><span class="line">    <span class="comment">#此时lp==rp，此位置存储key，下面对key左和右递归排序</span></span><br><span class="line">    qsort(nums,left,lp<span class="number">-1</span>)</span><br><span class="line">    qsort(nums,rp+<span class="number">1</span>,right)</span><br><span class="line">    <span class="keyword">return</span> nums</span><br></pre></td></tr></table></figure><ul><li>快排不稳定</li><li>时间复杂度：$O(nlog(n))$</li><li>使用场景：在大多情况下都适用，尤其在数据量大时优越性更明显，但是在必要时，需要考虑下优化以提高在最坏情况下的性能</li></ul><h2><span id="52-优化1">5.2. 优化1</span></h2><p>时间复杂度：$O(nlog(n))$，但是当基准选择不当时，会变成$O(n^2)$。当基准恰好为当前序列中最小数，意味着每次排序时都是对1和n-1个数进行排序，则效率大大降低。</p><ul><li>假设数组[1,7,8,9,4,2,5,3]，当选择1作为基准时，右边没有比1小的，则需要比较n-1次，则对n个数排序需要$O(n^2)$。</li><li>当原始数组本身有序时</li></ul><p>优化快排的这种情况，主要有2个方法：</p><ul><li>随机选择基准数</li><li>三数中取中法（将序列中的第一个，中间那个，最后一个比较大小，选择中间的数作为基准数）</li></ul><p>下面针对随机选择基准数进行说明，每次快排使用随机数作为基准数，大大降低了基准数选择不当，以为数据本身有序的情况</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_rand</span><span class="params">(i,j)</span>:</span></span><br><span class="line">    <span class="comment">#产生[i,j]的随机整数</span></span><br><span class="line">    <span class="keyword">import</span> random</span><br><span class="line">    <span class="keyword">return</span> random.randint(i, j)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">quick_sort1</span><span class="params">(nums)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> qsort(nums,<span class="number">0</span>,len(nums)<span class="number">-1</span>)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">qsort1</span><span class="params">(nums,left,right)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> left &gt;= right:<span class="comment">#结束条件</span></span><br><span class="line">        <span class="keyword">return</span> nums</span><br><span class="line"></span><br><span class="line">    lp = left <span class="comment">#左指针</span></span><br><span class="line">    rp = right <span class="comment">#右指针</span></span><br><span class="line">    pos = get_rand(lp,rp)<span class="comment">#随机生成基准下标</span></span><br><span class="line">    swap(nums,lp,pos)</span><br><span class="line">    key = nums[lp]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> lp &lt; rp:</span><br><span class="line">        <span class="comment">#直到遇到右边的数&lt;key，说明这个数需要交换</span></span><br><span class="line">        <span class="keyword">while</span> lp &lt; rp <span class="keyword">and</span> nums[rp] &gt;= key:</span><br><span class="line">            rp -= <span class="number">1</span></span><br><span class="line">        <span class="comment">#直到遇到左边的数&gt;key，说明这个数需要交换</span></span><br><span class="line">        <span class="keyword">while</span> lp &lt; rp <span class="keyword">and</span> nums[lp] &lt;= key:</span><br><span class="line">            lp += <span class="number">1</span></span><br><span class="line">        swap(nums,lp,rp)</span><br><span class="line">    <span class="comment">#当lp==rp时跳出while循环，此时lp和rp指向的数&lt;key</span></span><br><span class="line">    swap(nums,left,lp)</span><br><span class="line">    <span class="comment">#此时lp==rp，此位置存储key，下面对key左和右递归排序</span></span><br><span class="line">    qsort1(nums,left,lp<span class="number">-1</span>)</span><br><span class="line">    qsort1(nums,rp+<span class="number">1</span>,right)</span><br><span class="line">    <span class="keyword">return</span> nums</span><br></pre></td></tr></table></figure><h2><span id="53-三路快排">5.3. 三路快排</span></h2><p>二路快排对nums中数据有很多相等的元素不友好，三路排序是将nums分为3部分，小于pivot，等于pivot，大于pivot。<br>Java中的快排使用的就是三路</p><p>分成3个区间</p><ul><li>[left,lt]小于v</li><li>[lt+1,i]等于v</li><li>[rt,right]大于v</li></ul><p>在刚开始怎么给lt、gt、i初始化？<br>刚开始初始化，就是让以上3个区间全为空。<br>即lt=left-1，rt=right+1，i=left<br><img src="/2020/03/30/Leetcode之排序/3-quick-sort1.png" alt=""></p><p>遍历每一个i，</p><ul><li>当nums[i]==v时，则nums[i]不需要移动，直接移动i，遍历下一个元素，i+=1</li><li>当nums[i]&lt;v时，需要归到小于v的左边行列中。即nums[i]和等于v的第一个元素交换，即nums[i]和nums[lt+1]交换，然后lt需要扩大一位，包住刚刚挪过来的那个小于v的数，lt+=1，i右移到下一个未遍历的元素i+=1</li><li>当nums[i]&gt;v时，需要归到大于v的右边行列中。即nums[i]和nums[gt-1]交换，然后gt需要左移一位，包住挪过来的这个数，然后被交换的这个值在i这个位置，因为这个数还没有被检测，所有i不需要右移，还是当前的位置。</li></ul><p><img src="/2020/03/30/Leetcode之排序/3-quick-sort2.png" alt=""></p><p>当指针i和gt相等时，说明的元素都被检测完毕，这时退出while循环。<br>然后再把nums[left]的v值放在正确的位置，使得左边都是小于v的，即将nums[lt]和nums[left]交换，这样v所在的位置就是lt。</p><ul><li>[left,lt-1]都是小于v的</li><li>[lt,gt-1]都是等于v的</li><li>[gt,right]都是大于v的</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_rand</span><span class="params">(i,j)</span>:</span></span><br><span class="line">    <span class="comment">#产生[i,j]的随机整数</span></span><br><span class="line">    <span class="keyword">import</span> random</span><br><span class="line">    <span class="keyword">return</span> random.randint(i, j)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">quick_sort1</span><span class="params">(nums)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> qsort(nums,<span class="number">0</span>,len(nums)<span class="number">-1</span>)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">qsort1</span><span class="params">(nums,left,right)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> left &gt;= right:<span class="comment">#结束条件</span></span><br><span class="line">        <span class="keyword">return</span> nums</span><br><span class="line">    </span><br><span class="line">    pos = get_rand(left,right)</span><br><span class="line">    swap(nums,left,pos)</span><br><span class="line">    key = nums[left]</span><br><span class="line">    lp = left<span class="number">-1</span></span><br><span class="line">    rp = right+<span class="number">1</span></span><br><span class="line">    i = left<span class="comment">#指向未被遍历的数</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> i &lt; rp:</span><br><span class="line">        <span class="comment">#当前值小于key</span></span><br><span class="line">        <span class="keyword">if</span> nums[i]&lt;key:</span><br><span class="line">            <span class="comment">#和等于key的元素互换，并且将lp加1，将刚刚那个元素合并到小于key的行列</span></span><br><span class="line">            swap(nums,i,lp+<span class="number">1</span>)</span><br><span class="line">            lp+=<span class="number">1</span></span><br><span class="line">            i+=<span class="number">1</span></span><br><span class="line">        <span class="keyword">elif</span> nums[i]&gt;key:</span><br><span class="line">            <span class="comment">#将nums[i]和rp的前一个元素互换</span></span><br><span class="line">            swap(nums,i,rp<span class="number">-1</span>)</span><br><span class="line">            rp-=<span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>: </span><br><span class="line">            i+=<span class="number">1</span></span><br><span class="line">    <span class="comment">#现在lp指向小于key的最后一个元素</span></span><br><span class="line">    <span class="comment">#i==rp，指向第一个大于key的元素</span></span><br><span class="line">    swap(nums,left,lp)</span><br><span class="line">    <span class="comment">#现在key的位置就是lp</span></span><br><span class="line">    <span class="comment">#[left....lp-1] &lt; key</span></span><br><span class="line">    <span class="comment">#[lp....rp-1] == key</span></span><br><span class="line">    <span class="comment">#[rp....right] &gt; key</span></span><br><span class="line"></span><br><span class="line">    qsort1(nums,left,lp<span class="number">-1</span>)</span><br><span class="line">    qsort1(nums,rp,right)</span><br><span class="line">    <span class="keyword">return</span> nums</span><br></pre></td></tr></table></figure><h1><span id="6-归并排序">6. 归并排序</span></h1><p>归并排序采用递归分治。和选择排序一样，归并排序的性能不受输入数据的影响，时间复杂度始终是$O(nlogn)$，代价是需要额外的内存空间<br><strong>基本思想：</strong><br>归并排序就是将待排序序列分为前后两个子序列，然后分别对两个子序列继续调用归并排序，待两个子序列都排完序后，再将两个子序列合并，又称为2-路归并，可见归并排序是一个递归的过程。<br><strong>步骤：</strong></p><ol><li>将长度为n的输入序列划分为2个长度为n/2的子序列</li><li>对这2个子序列分别采用归并排序</li><li>将2个排序好的子序列合并成一个最终的排序序列</li><li>合并2个有序数组时，比较2个数组最前面的数，谁小先取谁，然后相应的指针向后移一位，然后再比较，直到一个数组为空，最后把另一个数组的剩余部分复制过来即可</li></ol><p><img src="/2020/03/30/Leetcode之排序/merge.gif" alt=""></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">merge_sort</span><span class="params">(nums)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> len(nums) &lt;= <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> nums</span><br><span class="line">    mid = int(len(nums) / <span class="number">2</span>)</span><br><span class="line">    left = merge_sort(nums[:mid])</span><br><span class="line">    right = merge_sort(nums[mid:])</span><br><span class="line">    <span class="keyword">return</span> merge(left,right)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">merge</span><span class="params">(left,right)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    将2个有序数组合并成1个大的有序数据</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    lp,rp = <span class="number">0</span>,<span class="number">0</span></span><br><span class="line">    result = []</span><br><span class="line">    <span class="keyword">while</span> lp &lt; len(left) <span class="keyword">and</span> rp &lt; len(right):</span><br><span class="line">        <span class="keyword">if</span> left[lp] &lt; right[rp]:</span><br><span class="line">            result.append(left[lp])</span><br><span class="line">            lp += <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            result.append(right[rp])</span><br><span class="line">            rp += <span class="number">1</span></span><br><span class="line">    result += left[lp:]</span><br><span class="line">    result += right[rp:]</span><br><span class="line">    <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure><ul><li>稳定，因为我们在遇到相等的数据时必然是按顺序抄写到大数组中，没有改变顺序</li><li>时间复杂度：$O(nlogn)$</li><li>空间复杂度：$O(n)$</li><li>适用场景：在数据量比较大时表现出色，但是因为空间复杂度$O(n)$在数据量特别大时（如1千万）也不可以接受，因此使用归并排序时一定要注意。</li></ul><h1><span id="7-堆排序">7. 堆排序</span></h1><h2><span id="71-堆排序">7.1. 堆排序</span></h2><p>堆排序是借助二叉树来实现，如果升序排列使用最大堆（根节点最大），反之使用最小堆（根节点最小）。以下以最大堆为例。<br><strong>堆排序在topK问题中使用频繁</strong>。<br>二叉堆具有以下性质：</p><ol><li>父节点的值总是大于或等于(小于或等于)子节点</li><li>每个节点的左右子树都是一个二叉堆</li></ol><p>堆是一个特殊的完全二叉树，除了最底层之外，每一层都是满的，这使得堆可以利用数组来表示（普通的二叉树通常用链表表示，有left和right指针），如下所示，堆和数组的相互关系</p><p><img src="/2020/03/30/Leetcode之排序/heap-sort.png" alt=""></p><p>给定某个节点，它在数组中的下标i，可以计算出它的父节点，左/右子节点的下标：<br>父节点下标：floor((i-1)/2)<br>左子节点：2i+1<br>右子节点：2(i+1)=2i+2</p><p>在堆排序中，我们首先就是找最后一个非叶子节点，例如上面的树，最后一个非叶子节点是7，其实就是最后一个叶子节点1的父节点。已知最后一个叶子节点的下标是n-1，其父节点下标就是floor(n/2-1)</p><p><strong>基本思想：</strong><br>堆排序就是把最大堆的堆顶的最大数取出来，将剩下的堆继续调整为最大堆，再次将堆顶的最大数取出来，一直到只剩下一个节点结束。</p><p>对于堆排序我们只关心2个问题：</p><ol><li>给定一个无序数组，如何建立堆？</li><li>删除堆顶元素后，如何调整数组称为新队</li></ol><p>第一个问题，可以先使用数组来表示堆。下标为0~n-1，首先找到最后一个非叶子节点，下标为floor(n/2-1)，作为需要调整的堆的根节点，将其调整为最大堆，然后根节点向前移，再调整前一个堆，直到nums[0]作为根节点，调整为最大堆。这样，一个完整的最大堆就建立起来了。堆顶就是最大的元素</p><p>第二个问题，假设我们已经有一个现成的最大堆，现在删除根元素，但并没有移动别的元素，则根元素空了，其他元素还保留着堆的性质，可以把最后一个元素(代号A)移动到根元素的位置，则堆的性质被破坏，A小于其某个左右子节点，于是，我们可以把A和它的子节点调换位置，如果A大于所有的子节点，则堆调整结束，否则，重复上述过程，A元素在树形结构中不断下沉，直到合适的位置，数组重新恢复堆的性质，上述过程一般称为“筛选”，自上而下。</p><p><strong>步骤：</strong></p><ol><li>建立最大堆，题目给定一个无序的数组，将其构建成最大堆。首先找到最后一个非叶子节点，即下标为int(n/2-1)。然后使用<code>heap_shift</code>函数这个堆调整为最大堆，然后下标i向前移动1位，再把这个树调整为最大堆。当i=0时，说明到了最上面的根节点，将这个树调整为最大堆。整个原始数组就变成了最大堆的数组。这个由原始数组变成最大堆的过程是从下往上。先把下面的子树调整为最大堆，然后一步步向上调整。</li><li>挨个输出：将最后一个节点和堆顶交换，重新调整堆为最大堆</li></ol><p><img src="/2020/03/30/Leetcode之排序/heap.gif" alt=""></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">heap_sort</span><span class="params">(nums)</span>:</span></span><br><span class="line">    n = len(nums)</span><br><span class="line">    first = int(n/<span class="number">2</span><span class="number">-1</span>)<span class="comment">#找到最后一个非叶子节点下标</span></span><br><span class="line">    <span class="comment">#建立堆,从最后一个非叶子节点开始调整</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(first,<span class="number">-1</span>,<span class="number">-1</span>):</span><br><span class="line">        <span class="comment">#这里的high始终为n-1，high本身应该是以nums[i]为根节点的最后一个节点，</span></span><br><span class="line">        <span class="comment">#但是这个堆最后一个节点不好求，所以就直接用n-1作为high，对这个堆的调整没有任何影响，</span></span><br><span class="line">        <span class="comment">#high本身的作用是防止数组越界</span></span><br><span class="line">        heap_shift(nums,i,n<span class="number">-1</span>)</span><br><span class="line">    <span class="comment">#经过上面的代码，nums已经是最大堆。此时nums[0]就是堆顶，即最大的元素。</span></span><br><span class="line">    <span class="comment">#倒序遍历堆，将最后一个元素和堆顶交换位置，</span></span><br><span class="line">    <span class="comment">#首先i=n-1，和堆顶交换位置，即最大的元素放在n-1的位置，</span></span><br><span class="line">    <span class="comment">#这时nums[0:i-1]的位置就不一定是最大堆了，需要再次调整nums[0:i-1]为最大堆。</span></span><br><span class="line">    <span class="comment">#此时堆顶的元素就是第二大的元素。然后再次进入到for循环中，i=n-2，再将第二大的元素放在n-2的位置上。</span></span><br><span class="line">    <span class="comment">#这样一直交换位置，一直调整，最后nums就会变成从小到大排序的数组。</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(n<span class="number">-1</span>,<span class="number">-1</span>,<span class="number">-1</span>):</span><br><span class="line">        <span class="comment">#i始终是堆的最后一个元素，将堆顶的最大值放在数组的后面</span></span><br><span class="line">        swap(nums,<span class="number">0</span>,i)</span><br><span class="line">        heap_shift(nums,<span class="number">0</span>,i<span class="number">-1</span>)</span><br><span class="line">    <span class="keyword">return</span> nums</span><br><span class="line"></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">例如</span></span><br><span class="line"><span class="string">          i--&gt;   4    </span></span><br><span class="line"><span class="string">               /   \</span></span><br><span class="line"><span class="string">      j--&gt;  10      3</span></span><br><span class="line"><span class="string">           /  \    / </span></span><br><span class="line"><span class="string">          5    1  2</span></span><br><span class="line"><span class="string">nums=[4,10,3,5,1,2]，对这个数组进行调整为最大堆。</span></span><br><span class="line"><span class="string">当前low=0，因为4的2个子树已经是最大堆了。</span></span><br><span class="line"><span class="string">首先找到2个孩子中较大的那个节点，即10，然后和根节点交换，变成</span></span><br><span class="line"><span class="string">                 10</span></span><br><span class="line"><span class="string">               /   \</span></span><br><span class="line"><span class="string">    i--&gt;     4      3</span></span><br><span class="line"><span class="string">           /  \    / </span></span><br><span class="line"><span class="string"> j--&gt;     5    1  2</span></span><br><span class="line"><span class="string">这时候发现，4这个树仍然不是最大堆，所以还需要继续调整。此时i指向下一层，即i=j，j指向左孩子，j=2*i+1，然后再交换孩子和根节点，变成下面这种</span></span><br><span class="line"><span class="string">                 10</span></span><br><span class="line"><span class="string">               /   \</span></span><br><span class="line"><span class="string">             5      3</span></span><br><span class="line"><span class="string">           /  \    / </span></span><br><span class="line"><span class="string">    i--&gt;  4    1  2</span></span><br><span class="line"><span class="string">    j--&gt;</span></span><br><span class="line"><span class="string">此时i指向最后一层，j已经大于high了，就退出while循环，此时输入的nums已经完全转换成最大堆了。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">heap_shift</span><span class="params">(nums,low,high)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    对某个子树进行调整，使其变成最大堆。这个子树的左右子树已经是最大堆。</span></span><br><span class="line"><span class="string">    其中被调整的数在nums中起始位置为low，</span></span><br><span class="line"><span class="string">    终止位置为high，即[low,high]</span></span><br><span class="line"><span class="string">    即调整以low为根节点的那棵树</span></span><br><span class="line"><span class="string">    nums:待调整的nums</span></span><br><span class="line"><span class="string">    low:堆的第一个元素</span></span><br><span class="line"><span class="string">    high:堆的最后一个元素</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    i = low<span class="comment">#堆顶</span></span><br><span class="line">    j = <span class="number">2</span>*i+<span class="number">1</span><span class="comment">#左孩子</span></span><br><span class="line">    tmp = nums[low]<span class="comment">#当前堆顶</span></span><br><span class="line">    <span class="keyword">while</span> j &lt;= high:</span><br><span class="line">        <span class="comment">#找出左右孩子中较大的那个元素</span></span><br><span class="line">        <span class="comment">#j为左孩子，j+1为右孩子</span></span><br><span class="line">        <span class="keyword">if</span> j+<span class="number">1</span>&lt;=high <span class="keyword">and</span> nums[j+<span class="number">1</span>]&gt;nums[j]:</span><br><span class="line">            j += <span class="number">1</span><span class="comment">#j指向右孩子</span></span><br><span class="line">        <span class="keyword">if</span> nums[j] &gt; tmp:<span class="comment">#孩子&gt;父节点</span></span><br><span class="line">            nums[i] = nums[j]<span class="comment">#将孩子放在根节点</span></span><br><span class="line">            i = j<span class="comment">#向下移动一层</span></span><br><span class="line">            j = <span class="number">2</span>*i+<span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:<span class="comment">#tmp比2个孩子都大,因为孩子已经是最大堆</span></span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    nums[i] = tmp</span><br></pre></td></tr></table></figure><ul><li>时间复杂度：$O(nlog(n))$</li></ul><h2><span id="72-应用topk问题">7.2. 应用：topK问题</span></h2><p>堆排序通常用来解决topK问题：有n个数，得到前k大的数</p><p>解决思路：</p><ul><li>排序后切片：$O(nlog(n))$</li><li>排序Low B三人组：$O(kn)$</li><li>堆排序：$O(nlog(k))$</li></ul><p>下面介绍使用堆排序</p><ul><li>取列表前k个元素建立一个最小堆，堆中只有k个元素，堆顶是最小的元素，下面的值都大于或等于堆顶。遍历完整个数组后，下面的值肯定是最大值，倒数第2大的值，…，堆顶就是倒数第k大的值。首先取列表前k个元素建立一个最小堆</li><li>然后再看剩下的n-k个数，如果这个数比堆顶小，则堆顶保持不变，如果这个数比堆顶大，用这个数把堆顶换掉，然后再调整一下这个堆把它变成最小堆</li><li>然后再看后面的数，如果这个数比堆顶小，则堆顶保持不变，如果这个数比堆顶大，用这个数把堆顶换掉，然后再调整一下这个堆把它变成最小堆</li><li>重复以上步骤，直到列表遍历完，则这k个数组成的最小堆就是前k个最大的数</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">heap_shift</span><span class="params">(nums,low,high)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    调整为最小堆</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    i = low<span class="comment">#堆顶</span></span><br><span class="line">    j = <span class="number">2</span>*i+<span class="number">1</span><span class="comment">#左孩子</span></span><br><span class="line">    tmp = nums[low]</span><br><span class="line">    <span class="keyword">while</span> j &lt;= high:</span><br><span class="line">        <span class="keyword">if</span> j+<span class="number">1</span>&lt;=high <span class="keyword">and</span> nums[j+<span class="number">1</span>]&lt;nums[j]:</span><br><span class="line">            j += <span class="number">1</span><span class="comment">#j指向右孩子</span></span><br><span class="line">        <span class="keyword">if</span> nums[j] &lt; tmp:</span><br><span class="line">            nums[i] = nums[j]</span><br><span class="line">            i = j</span><br><span class="line">            j = <span class="number">2</span>*i+<span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    nums[i] = tmp</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">topk</span><span class="params">(nums,k)</span>:</span></span><br><span class="line">    n = len(nums)</span><br><span class="line">    heap = nums[:k]<span class="comment">#先使用nums中的前k个元素构建小顶堆</span></span><br><span class="line">    first = int(k/<span class="number">2</span><span class="number">-1</span>)</span><br><span class="line">    <span class="comment">#将前k个元素建立堆</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(first,<span class="number">-1</span>,<span class="number">-1</span>):</span><br><span class="line">        heap_shift(heap,i,k<span class="number">-1</span>)</span><br><span class="line">    <span class="comment">#遍历nums中剩下的元素，加入到最小堆中</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(k,n<span class="number">-1</span>):</span><br><span class="line">        <span class="keyword">if</span> nums[i] &gt; heap[<span class="number">0</span>]:<span class="comment">#当前值比堆顶大，替换堆顶，然后调整堆</span></span><br><span class="line">            heap[<span class="number">0</span>] = nums[i]</span><br><span class="line">            heap_shift(heap,<span class="number">0</span>,k<span class="number">-1</span>)</span><br><span class="line">    <span class="comment">#现在最小堆中已经是前k大的数，只不过是从小到大排序</span></span><br><span class="line">    <span class="comment">#但是返回的数是从大到小</span></span><br><span class="line">    <span class="keyword">return</span> heap[::<span class="number">-1</span>]</span><br></pre></td></tr></table></figure><h1><span id="8-nb三人组小结">8. NB三人组小结</span></h1><ul><li>三种排序时间复杂度都是$O(nlog(n))$</li><li>一般情况下，运行时间：<ul><li>快排 &lt; 归并 &lt; 堆排序</li></ul></li><li>三种排序的缺点：<ul><li>快排：极端情况下效率低</li><li>归并排序：需要额外的内存开销</li><li>堆排序：在快的排序算法中相对较慢</li></ul></li></ul><h1><span id="9-希尔排序插入排序的改良版">9. 希尔排序(插入排序的改良版)</span></h1><p>与插入排序的不同在于：它会优先比较距离较远的元素，又叫做“缩小增量排序”<br><strong>基本思想：</strong><br>将记录按照一定的增量分组，对每组使用插入排序进行排序，随着增量的变小，每组包含的数字越来越多，当增量变成1时，所有的数字恰好被分为1组，算法终止。<br>在此我们选择增量gap=length/2，缩小增量继续以gap = gap/2的方式，这种增量选择我们可以用一个序列来表示，{n/2,(n/2)/2…1}，称为增量序列。希尔排序的增量序列的选择与证明是个数学难题，我们选择的这个增量序列是比较常用的，也是希尔建议的增量，称为希尔增量，但其实这个增量序列不是最优的。此处我们做示例使用希尔增量。<br><strong>步骤：</strong></p><ol><li>选择一个增量序列${t_1,t_2,…1}$</li><li>先选第一个增量$t_1$，将数据划分为$t_1$组，对每组进行插入排序</li><li>再选择增量$t_2$，将数据划分为$t_2$组，对每组进行插入排序</li><li>直到增量为1</li></ol><p><strong>【注意】</strong> 增量序列最后一个必须为1</p><p><img src="/2020/03/30/Leetcode之排序/shell.png" alt=""></p><p>当gap=2时，数组为[3,5,1,6,0,8,9,4,7,2],其中[3,1,0,9,7]为一组，[5,6,8,4,2]为一组，for循环i分为等于2,3,4,…9</p><ul><li>当i=2时，对第一个子数组排序，即当前待插入的值是1,和3比较，放在3前面，顺序变成[1,3,0,9,7]</li><li>当i=3时，对第二个子数组排序，当前待插入的值是6，大于5，顺序不变，依旧为[5,6,8,4,2]</li><li>当i=4时，对第一个子数组排序，当前待插入的值是0，前面已经排好序的是[1,3],分别和1,3比较，只要比0大，顺序就往后移，顺序变为[0,1,3,9,7]</li><li>当i=5时，对第二个子数组排序，待插入的值为8，前面已经排好序的是[5,6],和5,6比较，顺序不变，依旧为[5,6,8]</li><li>……</li></ul><p>由上可以看出，给定一个待排序的数字，和同组的数进行比较，然后交换，待排序的数字不是一步一步向前挪，而是跳跃式地往前挪。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">shell_sort</span><span class="params">(nums)</span>:</span></span><br><span class="line">    n = len(nums)</span><br><span class="line">    gap = round(n/<span class="number">2</span>)</span><br><span class="line">    <span class="keyword">while</span> gap &gt; <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(gap,n):</span><br><span class="line">            tmp = nums[i]</span><br><span class="line">            j = i</span><br><span class="line">            <span class="keyword">while</span>(j &gt;= gap <span class="keyword">and</span> nums[j-gap] &gt; tmp):</span><br><span class="line">                nums[j] = nums[j-gap]</span><br><span class="line">                j -= gap</span><br><span class="line">            nums[j] = tmp</span><br><span class="line">        gap = round(gap/<span class="number">2</span>)</span><br><span class="line">    <span class="keyword">return</span> nums</span><br></pre></td></tr></table></figure><ul><li>时间复杂度：很难分析，因为比较次数和移动次数和增量序列有关</li><li>空间复杂度：$O(1)$</li></ul><h1><span id="10-计数排序">10. 计数排序</span></h1><p>计数排序的核心在于将输入的数据值转化为键存储在额外开辟的数组空间中。 作为一种线性时间复杂度的排序，<strong>计数排序要求输入的数据必须是有确定范围的整数</strong>。</p><p>计数排序(Counting sort)是一种稳定的排序算法。计数排序使用一个额外的数组C，其中第i个元素是待排序数组A中值等于i的元素的个数。然后根据数组C来将A中的元素排到正确的位置。它只能对整数进行排序。</p><p><img src="/2020/03/30/Leetcode之排序/count.gif" alt=""></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">count_sort</span><span class="params">(nums)</span>:</span></span><br><span class="line">    max_value = max(nums)</span><br><span class="line">    count = [<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> range(max_value+<span class="number">1</span>)]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> nums:</span><br><span class="line">        count[i]+=<span class="number">1</span></span><br><span class="line">    nums.clear()</span><br><span class="line">    <span class="keyword">for</span> idx,value <span class="keyword">in</span> enumerate(count):</span><br><span class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> range(value):</span><br><span class="line">            nums.append(idx)</span><br><span class="line">    <span class="keyword">return</span> nums</span><br></pre></td></tr></table></figure><p>当输入的元素是n个0到k之间的整数时，它的运行时间是 O(n + k)。计数排序不是比较排序，排序的速度快于任何比较排序算法。由于用来计数的数组C的长度取决于待排序数组中数据的范围（等于待排序数组的最大值与最小值的差加上1），这使得计数排序对于数据范围很大的数组，需要大量时间和内存。</p><h1><span id="11-桶排序">11. 桶排序</span></h1><p>桶排序是计数排序的升级版。它利用了函数的映射关系，高效与否的关键就在于这个映射函数的确定。<br>桶排序 (Bucket sort)的工作的原理：假设输入数据服从均匀分布，将数据分到有限数量的桶里，每个桶再分别排序.</p><p><img src="/2020/03/30/Leetcode之排序/bucket.jpg" alt=""></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bucket_sort</span><span class="params">(nums,bucker_nums)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    nums:待排序数组</span></span><br><span class="line"><span class="string">    bucker_nums:一共有多少个桶</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="comment">#创建桶</span></span><br><span class="line">    min_value = min(nums)</span><br><span class="line">    max_value = max(nums)</span><br><span class="line">    buckets = [[] <span class="keyword">for</span> _ <span class="keyword">in</span> range(bucker_nums)]</span><br><span class="line">    <span class="comment">#每个桶放多少个数</span></span><br><span class="line">    bucker_size = int((max_value-min_value)/bucker_nums+<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> nums:</span><br><span class="line">        <span class="comment">#判断i放在哪个桶里</span></span><br><span class="line">        cur_id = int((i - <span class="number">1</span>) / bucker_size)</span><br><span class="line">        buckets[cur_id].append(i)</span><br><span class="line">        <span class="comment">#使用插入方法排序</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(len(buckets[cur_id])<span class="number">-1</span>,<span class="number">0</span>,<span class="number">-1</span>):</span><br><span class="line">            <span class="comment">#如果当前的值 &lt; 桶中的元素，和大的值交换</span></span><br><span class="line">            <span class="keyword">if</span> buckets[cur_id][j] &lt; buckets[cur_id][j<span class="number">-1</span>]:</span><br><span class="line">                swap(buckets[cur_id],j,j<span class="number">-1</span>)</span><br><span class="line">            <span class="comment">#当前值 &gt;= 桶中的元素，不用交换</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">    sorted_nums = []</span><br><span class="line">    <span class="comment">#每个桶已经排好序，遍历每个桶，放在sorted_nums中</span></span><br><span class="line">    <span class="keyword">for</span> bucket <span class="keyword">in</span> buckets:</span><br><span class="line">        sorted_nums.extend(bucket)</span><br><span class="line">    <span class="keyword">return</span> sorted_nums</span><br></pre></td></tr></table></figure><ul><li>桶排序的表现取决于数据的分布，也就是需要对不同数据排序时采取不同的分桶策略</li><li>空间复杂度：平均$O(nk)$，最坏$O(n^2k)$</li><li>时间复杂度：$O(n+k)$</li></ul><h1><span id="12-基数排序">12. 基数排序</span></h1><p>基数排序是按照低位先排序，然后收集，再按照高位排序，然后再收集，依次类推，直到最高位。</p><p><img src="/2020/03/30/Leetcode之排序/radix.gif" alt=""></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">radix_sort</span><span class="params">(nums)</span>:</span></span><br><span class="line">    max_value = max(nums)</span><br><span class="line">    max_digit = len(str(max_value))<span class="comment">#最大数的位数</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(max_digit):</span><br><span class="line">        buckets = [[] <span class="keyword">for</span> _ <span class="keyword">in</span> range(<span class="number">10</span>)]</span><br><span class="line">        <span class="comment">#假设最大数为786，i = 0,1,2</span></span><br><span class="line">        <span class="keyword">for</span> val <span class="keyword">in</span> nums:</span><br><span class="line">            <span class="comment">#取出个位数，十位数，百位数</span></span><br><span class="line">            <span class="comment">#958,</span></span><br><span class="line">            <span class="comment">#i = 0,8=958//1 %10,</span></span><br><span class="line">            <span class="comment">#i = 1,5=958//10 %10</span></span><br><span class="line">            <span class="comment">#i = 2,9=958//100 %10</span></span><br><span class="line">            digit = (val // <span class="number">10</span>**i) % <span class="number">10</span></span><br><span class="line">            buckets[digit].append(val)</span><br><span class="line">        <span class="comment">#分桶完成，再放回到nums中</span></span><br><span class="line">        nums.clear()</span><br><span class="line">        <span class="keyword">for</span> bucket <span class="keyword">in</span> buckets:</span><br><span class="line">            nums.extend(bucket)</span><br><span class="line">    <span class="keyword">return</span> nums</span><br></pre></td></tr></table></figure><ul><li>时间复杂度：$O(nk)$,k是最大数的位数</li><li>空间复杂度：$O(k+n)$</li></ul><h1><span id="13-leetcode题">13. LeetCode题</span></h1><h2><span id="131-合并两个有序数组">13.1. 合并两个有序数组</span></h2><p>给你两个有序整数数组 nums1 和 nums2，请你将 nums2 合并到 nums1 中，使 num1 成为一个有序数组。</p><p>说明:<br>初始化 nums1 和 nums2 的元素数量分别为 m 和 n 。<br>你可以假设 nums1 有足够的空间（空间大小大于或等于 m + n）来保存 nums2 中的元素。</p><p>合并2个有序数组是归并排序的子过程。</p><p><strong>【解法1】</strong><br>开辟一个新的数据nums3，将nums1和nums2排序到nums3中</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">merge</span><span class="params">(self, nums1, m, nums2, n)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums1: List[int]</span></span><br><span class="line"><span class="string">        :type m: int</span></span><br><span class="line"><span class="string">        :type nums2: List[int]</span></span><br><span class="line"><span class="string">        :type n: int</span></span><br><span class="line"><span class="string">        :rtype: None Do not return anything, modify nums1 in-place instead.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        nums3 = []</span><br><span class="line">        p1=<span class="number">0</span></span><br><span class="line">        p2=<span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> p1 &lt; m <span class="keyword">and</span> p2 &lt; n:</span><br><span class="line">            <span class="keyword">if</span> nums1[p1] &lt; nums2[p2]:</span><br><span class="line">                nums3.append(nums1[p1])</span><br><span class="line">                p1+=<span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                nums3.append(nums2[p2])</span><br><span class="line">                p2+=<span class="number">1</span></span><br><span class="line"></span><br><span class="line">        nums3 += nums1[p1:m]</span><br><span class="line">        nums3 += nums2[p2:n]</span><br><span class="line">        nums1[:]=nums3[:]</span><br><span class="line">        <span class="keyword">return</span> nums1</span><br></pre></td></tr></table></figure><p><strong>【解法2】</strong><br>题目中说nums1中的空间大小为m+n，就是说我们可以不用新的数组nums3，使用nums1就可以了。从后往前遍历，哪个数大就存到nums1的后面，直到有个数组遍历完。如果遍历完的数组是nums2，这是nums1已经是有序了，直接返回即可。如果nums1遍历完了，就要把nums2未遍历的数都复制到nums1中</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">merge</span><span class="params">(self, nums1, m, nums2, n)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums1: List[int]</span></span><br><span class="line"><span class="string">        :type m: int</span></span><br><span class="line"><span class="string">        :type nums2: List[int]</span></span><br><span class="line"><span class="string">        :type n: int</span></span><br><span class="line"><span class="string">        :rtype: None Do not return anything, modify nums1 in-place instead.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> m==<span class="number">0</span>:</span><br><span class="line">            nums1[:]=nums2[:]</span><br><span class="line">            <span class="keyword">return</span> nums1</span><br><span class="line">        cur_idx=m+n<span class="number">-1</span></span><br><span class="line">        p1 = m<span class="number">-1</span></span><br><span class="line">        p2 = n<span class="number">-1</span></span><br><span class="line">        <span class="keyword">while</span> p1&gt;=<span class="number">0</span> <span class="keyword">and</span> p2&gt;=<span class="number">0</span>:</span><br><span class="line">            <span class="keyword">if</span> nums1[p1]&gt;nums2[p2]:</span><br><span class="line">                nums1[cur_idx]=nums1[p1]</span><br><span class="line">                cur_idx -=<span class="number">1</span></span><br><span class="line">                p1-=<span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                nums1[cur_idx]=nums2[p2]</span><br><span class="line">                cur_idx-=<span class="number">1</span></span><br><span class="line">                p2-=<span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> p2 &lt; <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> nums1</span><br><span class="line">        <span class="keyword">if</span> p1 &lt; <span class="number">0</span>:</span><br><span class="line">            nums1[:cur_idx+<span class="number">1</span>] = nums2[:p2+<span class="number">1</span>]</span><br><span class="line">            <span class="keyword">return</span> nums1</span><br></pre></td></tr></table></figure><h2><span id="132-数组中的第k个最大元素">13.2. 数组中的第K个最大元素</span></h2><p>在未排序的数组中找到第 k 个最大的元素。请注意，你需要找的是数组排序后的第 k 个最大的元素，而不是第 k 个不同的元素。</p><p>示例 1:</p><p>输入: [3,2,1,5,6,4] 和 k = 2<br>输出: 5<br>示例 2:</p><p>输入: [3,2,3,1,2,4,5,5,6] 和 k = 4<br>输出: 4</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/kth-largest-element-in-an-array" target="_blank" rel="noopener">https://leetcode-cn.com/problems/kth-largest-element-in-an-array</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p><p><strong>【解法1】</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findKthLargest</span><span class="params">(self, nums, k)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :type k: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="comment">#对nums进行排序，从大到小，第4个元素</span></span><br><span class="line">        nums.sort(reverse=<span class="keyword">True</span>)</span><br><span class="line">        <span class="keyword">return</span> nums[k<span class="number">-1</span>]</span><br></pre></td></tr></table></figure><ul><li>时间复杂度：$O(nlogn)$</li><li>空间复杂度：O(1)</li></ul><p><strong>【解法2】</strong><br>使用小顶堆，堆中只有k个元素，小顶堆的堆顶是k个元素中的最小值，下面的值都比它大，即堆顶就是第k大的数</p><ul><li>时间复杂度：O(nlogk)，调整堆的时间复杂度为O(logk)，遍历整个数组一共有n个元素。</li><li>空间复杂度：O(k)</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findKthLargest</span><span class="params">(self, nums, k)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :type k: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        n = len(nums)</span><br><span class="line">        heap=nums[:k]<span class="comment">#前k个元素</span></span><br><span class="line">        first=int(k/<span class="number">2</span><span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(first,<span class="number">-1</span>,<span class="number">-1</span>):</span><br><span class="line">            self.heap_shift(heap,i,k<span class="number">-1</span>)</span><br><span class="line">        <span class="comment">#遍历k之后的所有元素</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(k,n):</span><br><span class="line">            <span class="keyword">if</span> nums[i]&gt;heap[<span class="number">0</span>]:</span><br><span class="line">                heap[<span class="number">0</span>]=nums[i]</span><br><span class="line">                self.heap_shift(heap,<span class="number">0</span>,k<span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">return</span> heap[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">heap_shift</span><span class="params">(self,nums,low,high)</span>:</span></span><br><span class="line">        <span class="comment">#只进行调整,把最小的数调整到上面</span></span><br><span class="line">        <span class="comment">#时间复杂度：O(logk)</span></span><br><span class="line">        tmp = nums[low]</span><br><span class="line">        i= low</span><br><span class="line">        j = <span class="number">2</span>*i+<span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> j &lt;= high:</span><br><span class="line">            <span class="keyword">if</span> j+<span class="number">1</span>&lt;=high <span class="keyword">and</span> nums[j+<span class="number">1</span>]&lt;nums[j]:</span><br><span class="line">                j+=<span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> nums[j]&lt;tmp:</span><br><span class="line">                nums[i]=nums[j]</span><br><span class="line">                i=j</span><br><span class="line">                j=<span class="number">2</span>*i+<span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        nums[i]=tmp</span><br></pre></td></tr></table></figure><p><strong>【解法3】</strong><br>第k大的元素，假设对nums按照从小到大排序，第k大的元素的下标为n-k<br>[1,2,2,3,5,6,6]，n=7，第2大的元素下标为5，第3大的元素下标为4。<br>即给定nums，我们要找的就是对nums从小到大排序后，下标为n-k的元素就是第k大的元素。</p><p>使用快速排序，快速排序是先给定一个pivot，然后将这个pivot放在nums中正确的位置，所谓正确的位置就是：左边的元素都小于pivot，右边的元素都大于等于pivot。经过一次排序，将pivot放在下标为i的位置，判断下标i和n-k的关系，如果i等于n-k，则返回。如果i小于n-k,说明第k大的元素在pivot的右边，更新left=i+1，否则更新right=i-1</p><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(1)，但是这种解法修改了原始数组，如果题目要求不能修改原始数组，这种方法不适用</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findKthLargest</span><span class="params">(self, nums, k)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :type k: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        n = len(nums)</span><br><span class="line">        left=<span class="number">0</span></span><br><span class="line">        right=n<span class="number">-1</span></span><br><span class="line">        target=n-k<span class="comment">#需要寻找元素的下标</span></span><br><span class="line">        <span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">            idx = self.quick_sort(nums,left,right)</span><br><span class="line">            <span class="keyword">if</span> idx==target:</span><br><span class="line">                <span class="keyword">return</span> nums[target]</span><br><span class="line">            <span class="keyword">if</span> idx &lt; target:<span class="comment">#说明target在右边</span></span><br><span class="line">                left=idx+<span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:<span class="comment">#说明target在左边</span></span><br><span class="line">                right=idx<span class="number">-1</span></span><br><span class="line">        <span class="keyword">return</span> nums[left]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">quick_sort</span><span class="params">(self,nums,left,right)</span>:</span></span><br><span class="line">        <span class="comment">#在nums中找一个pivot，使得左边都小于pivot，右边都大于等于pivot</span></span><br><span class="line">        <span class="comment">#返回pivot的位置下标</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">#随机选择一个数作为pivot</span></span><br><span class="line">        <span class="keyword">import</span> random</span><br><span class="line">        random_index = random.randint(left, right)</span><br><span class="line">        nums[random_index], nums[left] = nums[left], nums[random_index]</span><br><span class="line">        pivot = nums[left]</span><br><span class="line">        lp = left</span><br><span class="line">        rp = right</span><br><span class="line">        <span class="keyword">while</span> lp&lt;rp:</span><br><span class="line">            <span class="keyword">while</span> lp &lt; rp <span class="keyword">and</span> nums[rp]&gt;=pivot:</span><br><span class="line">                rp-=<span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> lp &lt; rp <span class="keyword">and</span> nums[lp]&lt;=pivot:</span><br><span class="line">                lp+=<span class="number">1</span></span><br><span class="line">            nums[lp],nums[rp] = nums[rp],nums[lp]</span><br><span class="line">        <span class="comment">#跳出循环时，lp==rp，指向的元素小于pivot</span></span><br><span class="line">        nums[left],nums[lp]=nums[lp],nums[left]</span><br><span class="line">        <span class="keyword">return</span> lp</span><br></pre></td></tr></table></figure><p><strong>【扩展】</strong></p><p>返回最大的k个数，<br>例如[1,2,3],k=2,则输出[3,2]<br>[1,1,1],k=2,则输出[1,1]</p><p>使用快速排序，第k个最大的数下标为n-k，使用快速排序，当返回的值为n-k时，说明找到第k个最大的数，且这个数的右边全是需要找的值，则返回的是一个数组。如果返回的值比n-k小，说明需要找的n-k在右边，更新left，否则更新right。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getLeastNumbers</span><span class="params">(self, arr, k)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type arr: List[int]</span></span><br><span class="line"><span class="string">        :type k: int</span></span><br><span class="line"><span class="string">        :rtype: List[int]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> k==<span class="number">0</span>:<span class="keyword">return</span> []</span><br><span class="line">        <span class="keyword">if</span> k&gt;=len(arr):<span class="keyword">return</span> arr</span><br><span class="line"></span><br><span class="line">        left = <span class="number">0</span></span><br><span class="line">        right = len(arr)<span class="number">-1</span></span><br><span class="line">        target = n-k<span class="comment">#先找到最大的第k个数</span></span><br><span class="line">        <span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">            idx = self.quick_sort(arr,left,right)</span><br><span class="line">            <span class="keyword">if</span> idx == target:<span class="comment">#说明左侧的数都比target小</span></span><br><span class="line">                <span class="keyword">return</span> arr[target:]</span><br><span class="line">            <span class="keyword">elif</span> idx &lt; target:</span><br><span class="line">                left = idx+<span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                right = idx<span class="number">-1</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">quick_sort</span><span class="params">(self,nums,left,right)</span>:</span></span><br><span class="line">        <span class="keyword">import</span> random</span><br><span class="line">        idx = random.randint(left,right)</span><br><span class="line">        nums[left],nums[idx] = nums[idx],nums[left]</span><br><span class="line">        pivot = nums[left]</span><br><span class="line">        lp,rp = left,right</span><br><span class="line">        <span class="keyword">while</span> lp &lt; rp:</span><br><span class="line">            <span class="keyword">while</span> lp&lt;rp <span class="keyword">and</span> nums[rp]&gt;=pivot:</span><br><span class="line">                rp-=<span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> lp&lt;rp <span class="keyword">and</span> nums[lp]&lt;=pivot:</span><br><span class="line">                lp+=<span class="number">1</span></span><br><span class="line">            nums[lp],nums[rp]=nums[rp],nums[lp]</span><br><span class="line">        nums[left],nums[lp] = nums[lp],nums[left]</span><br><span class="line">        <span class="keyword">return</span> lp</span><br></pre></td></tr></table></figure><h3><span id="1321-总结">13.2.1. 总结</span></h3><p>解决topK问题最常用的方法有2种</p><ol><li>使用快速排序，分治思想</li><li>使用最大(小)堆</li></ol><p><img src="/2020/03/30/Leetcode之排序/topk.png" alt=""></p><p>这2种方法各有优缺点，适用于不同的场合。做题之前，需要明确以下几个要求</p><ul><li>输入的数据量有多大，堆适用于海量数据</li><li>能否一次性载入内存</li><li>是否可以修改原数组</li></ul><h2><span id="133-前-k-个高频元素">13.3. 前 K 个高频元素</span></h2><p>给定一个非空的整数数组，返回其中出现频率前 k 高的元素。</p><p>示例 1:</p><p>输入: nums = [1,1,1,2,2,3], k = 2<br>输出: [1,2]</p><p><strong>【我的解法】</strong><br>使用字典保存每个元素和其出现的次数，</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">topKFrequent</span><span class="params">(self, nums, k)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :type k: int</span></span><br><span class="line"><span class="string">        :rtype: List[int]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        count_dict = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> nums:</span><br><span class="line">            <span class="keyword">if</span> i <span class="keyword">not</span> <span class="keyword">in</span> count_dict:</span><br><span class="line">                count_dict[i]=<span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                count_dict[i]+=<span class="number">1</span></span><br><span class="line">        <span class="comment">#对count_dict进行排序</span></span><br><span class="line">        count_dict=sorted(count_dict.items(),key=<span class="keyword">lambda</span> x:x[<span class="number">1</span>],reverse=<span class="keyword">True</span>)</span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">for</span> value,count <span class="keyword">in</span> count_dict[:k]:</span><br><span class="line">            res.append(value)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><p><strong>【解法2】</strong><br>使用大顶堆。首先使用字典count_dict记录每个数字及出现的次数，然后构造堆，堆中的值也可以是元组，(freq,value)分别是出现的次数和数字。然后使用nlargest从中取出前k的的值，取出的值也是(freq,value)的元组形式，最后返回所有的value值 </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="keyword">import</span> heapq</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">topKFrequent</span><span class="params">(self, nums, k)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :type k: int</span></span><br><span class="line"><span class="string">        :rtype: List[int]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        count_dict = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> nums:</span><br><span class="line">            <span class="keyword">if</span> i <span class="keyword">not</span> <span class="keyword">in</span> count_dict:</span><br><span class="line">                count_dict[i]=<span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                count_dict[i]+=<span class="number">1</span></span><br><span class="line">        h = []</span><br><span class="line">        <span class="keyword">for</span> value,freq <span class="keyword">in</span> count_dict.items():</span><br><span class="line">            <span class="comment">#heapq插入的值可以是元组，按照元组的第一个元素排序</span></span><br><span class="line">            heapq.heappush(h, (freq, value))</span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">for</span> freq,value <span class="keyword">in</span> heapq.nlargest(k, h):</span><br><span class="line">            res.append(value)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h2><span id="134-面试题39-数组中出现次数超过一半的数字">13.4. 面试题39. 数组中出现次数超过一半的数字</span></h2><p>数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。</p><p>你可以假设数组是非空的，并且给定的数组总是存在多数元素。</p><p>示例 1:</p><p>输入: [1, 2, 3, 2, 2, 2, 5, 4, 2]<br>输出: 2</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/shu-zu-zhong-chu-xian-ci-shu-chao-guo-yi-ban-de-shu-zi-lcof" target="_blank" rel="noopener">https://leetcode-cn.com/problems/shu-zu-zhong-chu-xian-ci-shu-chao-guo-yi-ban-de-shu-zi-lcof</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p><p><strong>【解法1】</strong><br>使用count存储数字及出现的频率，因为题目中说肯定存储多数元素，所以直接返回出现次数最多的数字。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">majorityElement</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="comment">#用count记录每个数出现的次数</span></span><br><span class="line">        count=&#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> nums:</span><br><span class="line">            <span class="keyword">if</span> i <span class="keyword">not</span> <span class="keyword">in</span> count:</span><br><span class="line">                count[i]=<span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                count[i]+=<span class="number">1</span></span><br><span class="line">            </span><br><span class="line">        count=sorted(count.items(),key=<span class="keyword">lambda</span> x:x[<span class="number">1</span>],reverse=<span class="keyword">True</span>)</span><br><span class="line">        print(count)</span><br><span class="line">        <span class="keyword">return</span> count[<span class="number">0</span>][<span class="number">0</span>]</span><br></pre></td></tr></table></figure><p><strong>【解法2】</strong><br>将nums进行排序，多数元素肯定出现在中位数的位置</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">majorityElement</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        n=len(nums)</span><br><span class="line">        nums.sort()</span><br><span class="line">        <span class="keyword">return</span> nums[n/<span class="number">2</span>]</span><br></pre></td></tr></table></figure><p><strong>【解法3】</strong><br>使用摩尔投票，首先记nums[0]为众数，如果vote=0，则将当前值i设置为众数，然后再遍历下一个数，如果下一个数等于候选众数，vote则加1，否则减1.最终的vote肯定大于0，而mode也就是最终的众数。<br>超过一半的众数，和任何数抵消，最终的vote都&gt;0</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">majorityElement</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        vote=<span class="number">0</span></span><br><span class="line">        mode=nums[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> nums:</span><br><span class="line">            <span class="keyword">if</span> vote==<span class="number">0</span>:</span><br><span class="line">                mode=i</span><br><span class="line">            <span class="keyword">if</span> mode==i:</span><br><span class="line">                vote+=<span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                vote-=<span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> mode</span><br></pre></td></tr></table></figure><h2><span id="135-颜色分类">13.5. 颜色分类</span></h2><p>给定一个包含红色、白色和蓝色，一共 n 个元素的数组，原地对它们进行排序，使得相同颜色的元素相邻，并按照红色、白色、蓝色顺序排列。</p><p>此题中，我们使用整数 0、 1 和 2 分别表示红色、白色和蓝色。</p><p>注意:<br>不能使用代码库中的排序函数来解决这道题。</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/sort-colors" target="_blank" rel="noopener">https://leetcode-cn.com/problems/sort-colors</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p><blockquote><p>输入: [2,0,2,1,1,0]<br>输出: [0,0,1,1,2,2]</p></blockquote><p><strong>【我的解法】</strong><br>参考三路快排，这里比三路快排要简单，因为这里只有3个数，将pivot选为1，将小于1的放在左边，等于1的放在中间，大于1的放在右边。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sortColors</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: None Do not return anything, modify nums in-place instead.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        n = len(nums)</span><br><span class="line">        <span class="keyword">if</span> n &lt; <span class="number">2</span>:</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        lp = <span class="number">-1</span> </span><br><span class="line">        rp = n</span><br><span class="line">        i = <span class="number">0</span> <span class="comment">#指向未被遍历的数</span></span><br><span class="line">        <span class="keyword">while</span> i &lt; rp:</span><br><span class="line">            <span class="keyword">if</span> nums[i]&lt;<span class="number">1</span>:</span><br><span class="line">                self.swap(nums,i,lp+<span class="number">1</span>)</span><br><span class="line">                lp+=<span class="number">1</span></span><br><span class="line">                i+=<span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> nums[i]&gt;<span class="number">1</span>:</span><br><span class="line">                self.swap(nums,i,rp<span class="number">-1</span>)</span><br><span class="line">                rp-=<span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>: </span><br><span class="line">                i+=<span class="number">1</span></span><br><span class="line">        print(nums)  </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">swap</span><span class="params">(self,nums,i,j)</span>:</span></span><br><span class="line">        tmp=nums[i]</span><br><span class="line">        nums[i]=nums[j]</span><br><span class="line">        nums[j]=tmp</span><br></pre></td></tr></table></figure><h2><span id="136-两个数组的交集-ii">13.6. 两个数组的交集 II</span></h2><p>给定两个数组，编写一个函数来计算它们的交集。</p><p>示例 1:</p><p>输入: nums1 = [1,2,2,1], nums2 = [2,2]<br>输出: [2,2]</p><p>【我的解法】<br>首先将nums1中的值和出现的次数存储在count字典中，然后遍历nums2，从中找出交集。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">intersect</span><span class="params">(self, nums1, nums2)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums1: List[int]</span></span><br><span class="line"><span class="string">        :type nums2: List[int]</span></span><br><span class="line"><span class="string">        :rtype: List[int]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        count = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> nums1:</span><br><span class="line">            <span class="keyword">if</span> i <span class="keyword">not</span> <span class="keyword">in</span> count:</span><br><span class="line">                count[i]=<span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                count[i]+=<span class="number">1</span></span><br><span class="line">        res=[]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> nums2:</span><br><span class="line">            <span class="keyword">if</span> i <span class="keyword">in</span> count <span class="keyword">and</span> count[i]&gt;<span class="number">0</span>:</span><br><span class="line">                res.append(i)</span><br><span class="line">                count[i]-=<span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><p><strong>【解法2】</strong><br>使用双指针，如果2个元素相等,将相等元素加入到res中，然后将2个元素同时向前移一位,如果2个元素不等，将小的元素指针向前移一位。<br>还可以对这个算法改进一下，这里我们使用额外数据res保存最终的结果，其实可以不用额外空间，我们在nums1[p1]==nums2[p2]时，将相同的元素放在nums1[k]中，然后k+=1，因为nums1前面的元素已经遍历过了，就没用了，可以覆盖。返回nums1[:k]</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">intersect</span><span class="params">(self, nums1, nums2)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums1: List[int]</span></span><br><span class="line"><span class="string">        :type nums2: List[int]</span></span><br><span class="line"><span class="string">        :rtype: List[int]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="comment">#分别对nums1和nums2排序</span></span><br><span class="line">        nums1.sort()</span><br><span class="line">        nums2.sort()</span><br><span class="line">        p1=<span class="number">0</span></span><br><span class="line">        p2=<span class="number">0</span></span><br><span class="line">        res=[]</span><br><span class="line">        <span class="keyword">while</span> p1&lt;len(nums1) <span class="keyword">and</span> p2&lt;len(nums2):</span><br><span class="line">            print(p1,p2)</span><br><span class="line">            <span class="keyword">if</span> nums1[p1] == nums2[p2]:</span><br><span class="line">                res.append(nums1[p1])</span><br><span class="line">                p1+=<span class="number">1</span></span><br><span class="line">                p2+=<span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> nums1[p1]&lt;nums2[p2]:</span><br><span class="line">                p1+=<span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                p2+=<span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h2><span id="137-摆动排序-ii">13.7. 摆动排序 II</span></h2><p>给定一个无序的数组 nums，将它重新排列成 nums[0] &lt; nums[1] &gt; nums[2] &lt; nums[3]… 的顺序。</p><p>示例 1:</p><p>输入: nums = [1, 5, 1, 1, 6, 4]<br>输出: 一个可能的答案是 [1, 4, 1, 5, 1, 6]</p><p>说明:<br>你可以假设所有输入都会得到有效的结果。</p><p>进阶:<br>你能用 O(n) 时间复杂度和 / 或原地 O(1) 额外空间来实现吗？</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/wiggle-sort-ii" target="_blank" rel="noopener">https://leetcode-cn.com/problems/wiggle-sort-ii</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wiggleSort</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: None Do not return anything, modify nums in-place instead.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="comment">#先找到nums的中位数，即下标为</span></span><br><span class="line">        n = len(nums)</span><br><span class="line">        left,right=<span class="number">0</span>,n<span class="number">-1</span></span><br><span class="line">        mid_idx=(left+right)//<span class="number">2</span></span><br><span class="line">        nums.sort()</span><br><span class="line">        mid=nums[mid_idx]<span class="comment">#中位数</span></span><br><span class="line">        <span class="comment"># 交叉合并，划分为2部分[0...mid_idx],[]</span></span><br><span class="line">        small,big ,_nums = mid_idx,n<span class="number">-1</span>,nums[:]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">            <span class="keyword">if</span> i%<span class="number">2</span> == <span class="number">0</span>:</span><br><span class="line">                nums[i] = _nums[small]</span><br><span class="line">                small -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:<span class="comment">#big</span></span><br><span class="line">                nums[i] = _nums[big]</span><br><span class="line">                big -= <span class="number">1</span></span><br></pre></td></tr></table></figure><p><strong>【解法2】</strong></p><ul><li>先寻找nums中的中位数，即寻找第k大的数，k=n/2，</li><li>找到中位数后，然后对nums进行三路快排，小于mid放在左边，大于mid放在右边</li><li>然后把nums划分为small和big列表，倒序排列</li></ul><h1><span id="数据流的中位数">数据流的中位数</span></h1><p>中位数是有序列表中间的数。如果列表长度是偶数，中位数则是中间两个数的平均值。</p><p>例如，</p><p>[2,3,4] 的中位数是 3</p><p>[2,3] 的中位数是 (2 + 3) / 2 = 2.5</p><p>设计一个支持以下两种操作的数据结构：</p><p>void addNum(int num) - 从数据流中添加一个整数到数据结构中。<br>double findMedian() - 返回目前所有元素的中位数。</p><p>链接：<a href="https://leetcode-cn.com/problems/find-median-from-data-stream" target="_blank" rel="noopener">https://leetcode-cn.com/problems/find-median-from-data-stream</a></p><p><strong>【分析一】</strong></p><p>我们只关心中位数，其他的数没必要有序。可以利用大顶堆和小顶堆，每次从堆中取出最值，其他元素无序排序。这样就可以在O(logN)复杂度从堆中取出最值。</p><p><img src="/2020/03/30/Leetcode之排序/heap.png" alt=""></p><p>当读入的数据为奇数个时，中位数在前面的有序数组。当读入的数据为偶数个时，中位数在前有序数组的最后一个和后有序数组的第一个。因为需要找出中位数，即从前有序数组中找出最大的，在后有序数组中找出最小的。因为前有序数据用大顶堆存储，后有序数组用小顶堆存储。</p><ul><li>大顶堆：存储前有序数组，个数&gt;=小顶堆</li><li><p>小顶堆：存储后有序数组，个数&lt;=大顶堆<br>当2个堆中个数为偶数时，2个堆中个数平分<br>当2个堆中个数为奇数时，大顶堆的个数比小顶堆个数多1<br>因此不管当前堆中个数为奇数还是偶数，当进来一个数时，都要先进入到大顶堆中，才能保证大顶堆个数&gt;=小顶堆个数。</p></li><li><p>当进来一个数后，堆中总数为偶数，比如原先大顶堆中为[3,4,7,9],小顶堆中为[11,13,16],进来一个数为8，说明进来的数本来需要进入到小顶堆中,才能使大小顶堆个数相等。但是这个数不能直接进入到小顶堆中，需要进行以下操作：先把这个数放入大顶堆中，大顶堆变成[3,4,7,8,9],在大顶堆中找出最大的数，然后把这个数给小顶堆,大顶堆变成[3,4,7,8],小顶堆变成[9,11,13,16],这样才能保证大顶堆和小顶堆个数相等。</p></li><li>当进来一个数后，堆中总数为奇数，比如原先大顶堆中为[3,4,7,9],小顶堆中为[11,13,16,17],进来一个数为20，先把这个数放入大顶堆中，大顶堆变成[3,4,7,9,20],此时大顶堆的最大值比小顶堆大，需要把20交换到小顶堆中，把20这个数给小顶堆,大顶堆变成[3,4,7,9],小顶堆变成[11,13,16,17,20]，但是此时小顶堆的个数又比大顶堆多1个，这是不允许的，所以需要把对顶堆的数移到大顶堆中，大顶堆变成[3,4,7,9,11]，小顶堆变成[13,16,17,20]，这样才正确。</li><li>总结如下：当堆中总数为偶数时，数据流向为：大顶堆—&gt;小顶堆。当堆中总数为奇数时，数据流向为：大顶堆—&gt;小顶堆—&gt;大顶堆。2者的共同之处都是大顶堆—&gt;小顶堆。所以进来一个数，先进大顶堆，然后再从大顶堆中弹出最大值到小顶堆。然后判断堆中总数为奇数还是偶数，如果为奇数，再从小顶堆中弹出最小值到大顶堆中。</li></ul><p>python中自带的堆是小顶堆，在push时根据item的第一个元素进行比较大小，将item小的元素放在栈顶。为了让小顶堆实现大顶堆(将最大值放在栈顶)的功能，item的第一个元素为其相反数，即最大值的相反数最小，按照相反数进行排序，这样最大数就放在了栈顶。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MedianFinder</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="comment"># 当前大顶堆和小顶堆的元素个数之和</span></span><br><span class="line">        self.count = <span class="number">0</span></span><br><span class="line">        self.max_heap = []</span><br><span class="line">        self.min_heap = []</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">addNum</span><span class="params">(self, num: int)</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        self.count += <span class="number">1</span></span><br><span class="line">        <span class="comment"># 因为 Python 中的堆默认是小顶堆，所以要传入一个 tuple，用于比较的元素需是相反数，</span></span><br><span class="line">        <span class="comment"># 才能模拟出大顶堆的效果</span></span><br><span class="line">        heapq.heappush(self.max_heap, -num)</span><br><span class="line">        max_heap_top = heapq.heappop(self.max_heap)</span><br><span class="line">        heapq.heappush(self.min_heap, -max_heap_top)</span><br><span class="line">        <span class="keyword">if</span> self.count &amp; <span class="number">1</span>:</span><br><span class="line">            min_heap_top = heapq.heappop(self.min_heap)</span><br><span class="line">            heapq.heappush(self.max_heap, -min_heap_top)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findMedian</span><span class="params">(self)</span> -&gt; float:</span></span><br><span class="line">        <span class="keyword">if</span> self.count &amp; <span class="number">1</span>:</span><br><span class="line">            <span class="comment"># 如果两个堆合起来的元素个数是奇数，数据流的中位数大顶堆的堆顶元素</span></span><br><span class="line">            <span class="keyword">return</span> -self.max_heap[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment"># 如果两个堆合起来的元素个数是偶数，数据流的中位数就是各自堆顶元素的平均值</span></span><br><span class="line">            <span class="keyword">return</span> (self.min_heap[<span class="number">0</span>] - self.max_heap[<span class="number">0</span>]) / <span class="number">2</span></span><br></pre></td></tr></table></figure><h1><span id="14-总结">14. 总结</span></h1><ol><li>选数组中的第k大或第k小的元素，使用堆排序或快速排序<ul><li>堆排序：使用小顶堆(第k大)和大顶堆(第k小)</li><li>快速排序：因为每一轮快速排序，都会确定pivot的位置，比较pivot的位置是否等于k或n-k，然后调整left或right的位置。</li></ul></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;开始刷题了，首先整理并实现经典的排序算法并对其优化，使用Python实现。所有的排序默认从小到大排序&lt;/p&gt;
    
    </summary>
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
      <category term="排序" scheme="http://yoursite.com/tags/%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>图神经网络研讨会</title>
    <link href="http://yoursite.com/2020/03/29/%E5%9B%BE%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E7%A0%94%E8%AE%A8%E4%BC%9A/"/>
    <id>http://yoursite.com/2020/03/29/图神经网络研讨会/</id>
    <published>2020-03-29T05:40:52.000Z</published>
    <updated>2020-03-31T15:15:44.158Z</updated>
    
    <content type="html"><![CDATA[<p>在线图神经网络研讨会<br><a id="more"></a><br><img src="/2020/03/29/图神经网络研讨会/intro.png" alt=""></p><h1><span id="网络表示学习">网络表示学习</span></h1><ul><li>网络表示的关键问题：<br>如何定义图中节点的相似性</li></ul><h1><span id="图神经网络及认知推理">图神经网络及认知推理</span></h1><p><strong>网络上的学习任务：</strong></p><ul><li>节点分类：给定一个点，预测其类别</li><li>链接预测：给2个点，预测这2个点是否相连</li><li>community detection：找子图</li><li>网络相似度：2个网络或子网络的相似度</li></ul><h2><span id="回顾网络表示学习">回顾网络表示学习</span></h2><p>给定一个网络，学习节点的低维表示，如果2个节点距离很近，那这2个节点的表示也要相似。<br><strong>挑战：</strong></p><ol><li>CNN只适用于网格(二维)，但是网络是一个拓扑机构</li><li>RNN适用于文本/序列，这种都有先后关系，但是网络没有先后关系</li><li>网络是动态的，节点有属性，并且网络还有结构属性</li></ol><p><strong>网络表示学习发展：</strong></p><ol><li>使用word2vec来做网络表示学习，即DeepWalk</li><li>根据DeepWalk进行扩展：<ul><li>LINE：一阶和二阶相似性</li><li>PTE：异构网络</li><li>Node2vec：biased random walk</li></ul></li></ol><p><strong>网络表示学习的本质：</strong><br>都是在做矩阵分解，SVD分解，只是分解的形式不一样。<br>图表示学习结合的是context信息，用上下文信息来做网络表示学习。</p><p><img src="/2020/03/29/图神经网络研讨会/1.png" alt=""></p><p><strong>问题：</strong></p><h2><span id="gnn">GNN</span></h2><p><img src="/2020/03/29/图神经网络研讨会/2.png" alt=""></p><p><img src="/2020/03/29/图神经网络研讨会/3.png" alt=""></p><h2><span id="异质图">异质图</span></h2><p>同质网络：网络中只有一种类型的节点或边<br>异质网络：网络中有多类节点或边</p><p>首先分解出网络中的对象，以及对象之间的关系。<br>例如：作者-论文-会议，一个网络中有3类节点。<br>其中对象之间的关系（Meta path）有：</p><ul><li>作者1-论文-作者2（2个作者共同合作一篇论文）</li><li>作者1-论文-引用论文1，作者1写论文，引用了其他论文</li><li>……</li></ul><h3><span id="模型">模型</span></h3><ol><li>Metapath2Vec<br>基于meta path的随机游走，</li><li>HERec<br>解决异质图中节点的表示，将异质图变成同质图，在同质图中用DeepWalk或LINE学习节点表示</li><li>HIN2Vec<br>随机游走抽取出点边序列</li><li>MCRec</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在线图神经网络研讨会&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Deep Learning" scheme="http://yoursite.com/categories/Deep-Learning/"/>
    
    
      <category term="Graph" scheme="http://yoursite.com/tags/Graph/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode之二分法</title>
    <link href="http://yoursite.com/2020/03/27/Leetcode%E4%B9%8B%E4%BA%8C%E5%88%86%E6%B3%95/"/>
    <id>http://yoursite.com/2020/03/27/Leetcode之二分法/</id>
    <published>2020-03-27T14:34:31.000Z</published>
    <updated>2020-06-18T02:34:35.282Z</updated>
    
    <content type="html"><![CDATA[<p>列表查找：从列表中查找指定元素</p><ul><li>输出：列表</li><li>输出：元素下标，找不到返回None或-1</li></ul><a id="more"></a><!-- TOC --><ul><li><a href="#1-顺序查找">1. 顺序查找</a></li><li><a href="#2-二分查找">2. 二分查找</a><ul><li><a href="#21-二分查找拓展问题">2.1. 二分查找拓展问题</a></li></ul></li><li><a href="#3-leetcode例题">3. LeetCode例题</a><ul><li><a href="#31-查找target的索引">3.1. 查找target的索引</a><ul><li><a href="#311-二分查找">3.1.1. 二分查找</a></li><li><a href="#312-搜索旋转排序数组">3.1.2. 搜索旋转排序数组</a></li><li><a href="#313-搜索旋转排序数组-ii">3.1.3. 搜索旋转排序数组 II</a></li><li><a href="#314-寻找旋转排序数组中的最小值">3.1.4. 寻找旋转排序数组中的最小值</a></li><li><a href="#315-寻找旋转排序数组中的最小值-ii">3.1.5. 寻找旋转排序数组中的最小值 II</a></li><li><a href="#316-h指数-ii">3.1.6. H指数 II</a></li><li><a href="#317-最长上升子序列">3.1.7. 最长上升子序列</a></li><li><a href="#318-山脉数组中查找目标值">3.1.8. 山脉数组中查找目标值</a></li><li><a href="#319-寻找两个有序数组的中位数">3.1.9. 寻找两个有序数组的中位数</a></li></ul></li><li><a href="#32-在一个有上下界的区间中搜索一个整数">3.2. 在一个有上下界的区间中搜索一个整数</a><ul><li><a href="#321-x-的平方根">3.2.1. x 的平方根</a></li><li><a href="#322-寻找重复数">3.2.2. 寻找重复数</a></li></ul></li><li><a href="#33-判断条件是一个函数">3.3. 判断条件是一个函数</a><ul><li><a href="#331-第一个错误的版本">3.3.1. 第一个错误的版本</a></li><li><a href="#332-分割数组的最大值">3.3.2. 分割数组的最大值</a></li><li><a href="#333-爱吃香蕉的珂珂">3.3.3. 爱吃香蕉的珂珂</a></li><li><a href="#334-找到-k-个最接近的元素">3.3.4. 找到 K 个最接近的元素</a></li><li><a href="#335-转变数组后最接近目标值的数组和">3.3.5. 转变数组后最接近目标值的数组和</a></li></ul></li></ul></li><li><a href="#4-总结">4. 总结</a></li></ul><!-- /TOC --><p>python中内置列表查找函数：index(),用的是线性查找，因为二分查找要求列表是有序的。</p><h1><span id="1-顺序查找">1. 顺序查找</span></h1><p>也叫做线性查找，从一个元素开始，依次遍历，直到找到指定元素或到最后一个元素</p><ul><li>时间复杂度：$O(n)$</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">linear_search</span><span class="params">(nums,val)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> idx,v <span class="keyword">in</span> enumerate(nums):</span><br><span class="line">        <span class="keyword">if</span> v == val:</span><br><span class="line">            <span class="keyword">return</span> idx</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span></span><br></pre></td></tr></table></figure><h1><span id="2-二分查找">2. 二分查找</span></h1><p>从有序列表中，比较列表中间的数和val比较，然后向左或向右查找。<br>对于有序数组或者部分有序数组，基本都是使用二分法</p><ul><li>时间复杂度：$O(logn)$</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">binary_search</span><span class="params">(nums,val)</span>:</span></span><br><span class="line">    left = <span class="number">0</span></span><br><span class="line">    right = len(nums)<span class="number">-1</span></span><br><span class="line">    <span class="keyword">while</span> left &lt;= right:<span class="comment">#说明候选区有值</span></span><br><span class="line">        mid = (left+right)//<span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> nums[mid] == val:</span><br><span class="line">            <span class="keyword">return</span> mid</span><br><span class="line">        <span class="keyword">elif</span> nums[mid] &gt; val:</span><br><span class="line">            right = mid - <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            left = mid + <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span></span><br></pre></td></tr></table></figure><p>参考资料</p><p><a href="https://www.liwei.party/2019/06/19/leetcode-solution-new/search-insert-position/" target="_blank" rel="noopener">特别好用的二分查找法模板（Python 代码、Java 代码）</a></p><p><a href="https://leetcode-cn.com/problems/search-insert-position/solution/te-bie-hao-yong-de-er-fen-cha-fa-fa-mo-ban-python-/" target="_blank" rel="noopener">二分查找模板</a></p><p><a href="https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/solution/er-fen-cha-zhao-suan-fa-xi-jie-xiang-jie-by-labula/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/solution/er-fen-cha-zhao-suan-fa-xi-jie-xiang-jie-by-labula/</a><br>用排除法来写二分查找，将nums分为2个区间</p><ul><li>循环继续的条件是<code>while (left &lt; right):</code>，这样写的好处是：退出循环时，一定是<code>left=right</code>,不用纠结返回是left还是right</li><li><p>在写if和else语句是，在if()中写nums[mid]满足什么性质时，nums[mid]肯定不是目标元素，则真正的目标元素肯定在mid的左边或右边，分别在if和else中更新left或right。根据以下2种情况，考虑怎么更新left和right</p><ul><li>如果mid分到左区间，则更新left=mid+1，更新right=mid</li><li>如果mid分到右区间，则更新left=mid，更新right=mid-1</li></ul><p><img src="/2020/03/27/Leetcode之二分法/查找算法/binary.png" alt=""></p></li><li><p>更新mid（重难点）</p><ul><li><code>mid = (left+mid)/2</code>,最常用，但是在left和right较大时，会发生整形溢出</li><li><code>mid = left+(right-left)/2</code>,推荐写法</li><li><code>/</code>是整除，如果是小数，向下取整，当left和rigth相邻时，即rigth-left=1时，使用mid = left+(right-left)/2，得到的mid始终等于left，永远取不到right，可能会出现死循环。<br>例如nums=[1,2]，target=2，刚开始left=0，right=1，mid=0，if(nums[mid]&lt;target)，说明target在mid后面，更新left=mid，此时left还是等于0，然后就出现死循环，left一直都是0。</li><li><p>解决死循环的方案是：将mid划分到左边区间中，在更新时left=mid+1，right=mid，就不会出现left一直等于mid死循环。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(left &lt; right):</span><br><span class="line">    mid = left+(right-left)/<span class="number">2</span></span><br><span class="line">    <span class="keyword">if</span>(nums[mid] &lt; target):</span><br><span class="line">        left=mid+<span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        right=mid</span><br></pre></td></tr></table></figure><p>或者将mid划分到右区间，这时出现left=mid，将mid的取值从左中位数，改为右中位数，即<code>mid = left+(right-left+1)/2</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(left &lt; right):</span><br><span class="line">    mid = left+(right-left+<span class="number">1</span>)/<span class="number">2</span></span><br><span class="line">    <span class="keyword">if</span>(nums[mid] &lt; target):</span><br><span class="line">        left=mid</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        right=mid<span class="number">-1</span></span><br></pre></td></tr></table></figure></li></ul></li></ul><ul><li>退出while时，一定是left=right，需要判断下<code>if(nums[left])==target</code>。<ul><li>如果题目中说了target一定存在于nums中，则不必执行上述操作，因为在while中已经把不是target的元素排除了，退出while时的left==right，一定是target元素，直接返回left就行。</li><li>如果题目中没有说target一定存在于nums，即要找的target在nums中可能不存在，我们需要执行<code>if(nums[left]==target)</code>，如果满足返回left，不满足说明target在nums中不存在，返回-1</li></ul></li></ul><p><strong>【总结】</strong></p><ul><li>如果把mid分到左区间，<code>mid=left+(right-left)//2</code></li><li>如果把mid分到右区间，<code>mid=left+(right-left+1)//2</code></li><li>在nums中找第一个出现target的下标，需要把mid分到左边，不符合条件写成<code>if nums[mid] &lt; target</code></li><li>在nums中找最后一个出现target的下标，需要把mid分到右边，不符合条件写成<code>if nums[mid] &gt; target</code></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#找左侧边界</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">find_first</span><span class="params">(nums,target)</span>:</span></span><br><span class="line">    left = <span class="number">0</span></span><br><span class="line">    right = len(nums)<span class="number">-1</span></span><br><span class="line">    <span class="keyword">while</span> left &lt; right:</span><br><span class="line">        mid = left+(right-left)//<span class="number">2</span><span class="comment">#取左中位数</span></span><br><span class="line">        <span class="comment">#从左边缩小搜索空间</span></span><br><span class="line">        <span class="keyword">if</span> nums[mid] &lt; target:</span><br><span class="line">            left = mid+<span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            right = mid</span><br><span class="line">    <span class="keyword">if</span> nums[left] == target:</span><br><span class="line">        <span class="keyword">return</span> left</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#找右侧边界</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">find_last</span><span class="params">(nums,target)</span>:</span></span><br><span class="line">    left = <span class="number">0</span></span><br><span class="line">    right = len(nums)<span class="number">-1</span></span><br><span class="line">    <span class="keyword">while</span> left &lt; right:</span><br><span class="line">        mid = left+(right-left+<span class="number">1</span>)//<span class="number">2</span><span class="comment">#取右中位数</span></span><br><span class="line">        <span class="keyword">if</span> nums[mid] &gt; target:</span><br><span class="line">            right = mid - <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            left = mid</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">if</span> nums[left] == target:</span><br><span class="line">        <span class="keyword">return</span> left</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span></span><br></pre></td></tr></table></figure><h2><span id="21-二分查找拓展问题">2.1. 二分查找拓展问题</span></h2><ol><li>在有序数组中查找等于目标元素的第1个或最后1个下标</li><li>在有序数组中查找第1个大于(等于)目标元素的下标</li><li>在有序数组中查找第1个小于(等于)目标元素的下标</li><li>在有序数组中查找最后1个大于(等于)目标元素的下标</li><li>在有序数组中查找最后1个小于(等于)目标元素的下标</li></ol><p>Leetcode上的二分问题主要分为以下三类</p><h1><span id="3-leetcode例题">3. LeetCode例题</span></h1><h2><span id="31-查找target的索引">3.1. 查找target的索引</span></h2><p>一般而言，这个数组是有序的，也可能是半有序，但不大可能是无序的</p><h3><span id="311-二分查找">3.1.1. 二分查找</span></h3><p>给定一个 n 个元素有序的（升序）整型数组 nums 和一个目标值 target  ，写一个函数搜索 nums 中的 target，如果目标值存在返回下标，否则返回 -1。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">search</span><span class="params">(self, nums, target)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :type target: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        left = <span class="number">0</span></span><br><span class="line">        right = len(nums)<span class="number">-1</span></span><br><span class="line">        <span class="keyword">while</span> left &lt; right:</span><br><span class="line">            mid = left+(right-left)/<span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> nums[mid] &lt; target:</span><br><span class="line">                left = mid+<span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                right=mid</span><br><span class="line">        <span class="keyword">if</span> nums[left]==target:</span><br><span class="line">            <span class="keyword">return</span> left</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span></span><br></pre></td></tr></table></figure><h3><span id="312-搜索旋转排序数组">3.1.2. 搜索旋转排序数组</span></h3><p>假设按照升序排序的数组在预先未知的某个点上进行了旋转。</p><p>( 例如，数组 [0,1,2,4,5,6,7] 可能变为 [4,5,6,7,0,1,2] )。</p><p>搜索一个给定的目标值，如果数组中存在这个目标值，则返回它的索引，否则返回 -1 。</p><p>你可以假设数组中不存在重复的元素。</p><p>你的算法时间复杂度必须是 O(log n) 级别。</p><p>这道题有多种解法：</p><ol><li>中间元素和右边界比较，使用右中位数</li><li>中间元素和右边界比较，使用左中位数</li><li>中间元素和左边界比较，使用右中位数</li><li>中间元素和左边界比较，使用左中位数</li><li>分三个区间</li></ol><p>下面只给出前2种的解法：<br>讨论mid元素和右边界的关系，因为nums不存在重复元素，所以要么大于，要么小于</p><ul><li><p><code>nums[mid] &lt; nums[right]</code><br>例如[7,8,2,3,4,5,6],nums[mid]=3,nums[right]=6,此时[mid,right]一定是有序的，那么target要不在有序区间[mid,right]中，要么在不一定有序的[left,mid-1]中。</p><ul><li>假设target在[mid,right]中，即<code>nums[mid] &lt;= target and target &lt;= nums[right]</code>，因为该区间已经有序，比较简单，更新<code>left=mid</code></li><li>假设target落在[left,mid-1]中，就是上一个情况的反面，即<code>right=mid-1</code></li><li>因为这里出现了<code>left=mid</code>的情况，所有需要使用<code>mid=left+(right-left+1)//2</code>的方式来计算mid</li></ul></li><li><p><code>nums[mid] &gt; nums[right]</code><br>例如[5,6,7,8,9,2,3,4],nums[mid]=8,nums[right]=4,此时[left,mid]一定是有序的，那么target要不在有序区间[left,mid]中，要么在不一定有序的[mid+1,left]中。</p><ul><li>假设target在[left,mid]中，即<code>nums[left] &lt;= target and target &lt;= nums[mid]</code>，因为该区间已经有序，比较简单，更新<code>right=mid</code></li><li>假设target落在[mid+1,right]中，就是上一个情况的反面，即<code>left=mid+1</code></li><li>为了和上一种情况，在计算<code>mid=left+(right-left+1)//2</code>的方式保持一致，这里，我们认为target在[left,mid-1]中有序，这样更新right=mid-1,更新left=mid，并且放区间中只有2个元素时，mid始终等于right，此时在更新right=mid-1时也不会越界</li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">search</span><span class="params">(self, nums, target)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :type target: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="comment">#方式1：中间元素和右边界比较，使用右中位数</span></span><br><span class="line">        <span class="keyword">if</span> len(nums) == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">        left= <span class="number">0</span></span><br><span class="line">        right = len(nums)<span class="number">-1</span></span><br><span class="line">        <span class="keyword">while</span> left &lt; right:</span><br><span class="line">            mid = left+(right-left+<span class="number">1</span>)//<span class="number">2</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> nums[mid] &lt; nums[right]:</span><br><span class="line">                <span class="keyword">if</span> nums[mid] &lt;= target <span class="keyword">and</span> target &lt;= nums[right]:</span><br><span class="line">                    <span class="comment">#[mid,right]一定是有序的</span></span><br><span class="line">                    left = mid</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    right = mid - <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">if</span> nums[left] &lt;= target <span class="keyword">and</span> target &lt;= nums[mid<span class="number">-1</span>]:</span><br><span class="line">                    <span class="comment">#[left,mid-1]一定是有序的</span></span><br><span class="line">                    right = mid - <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    left = mid </span><br><span class="line">        <span class="keyword">if</span> nums[left] == target:</span><br><span class="line">            <span class="keyword">return</span> left</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">#方法2：中间元素和右边界比较，使用左中位数</span></span><br><span class="line">        <span class="keyword">if</span> len(nums) == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">        left= <span class="number">0</span></span><br><span class="line">        right = len(nums)<span class="number">-1</span></span><br><span class="line">        <span class="keyword">while</span> left &lt; right:</span><br><span class="line">            mid = left+(right-left)//<span class="number">2</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> nums[mid] &lt; nums[right]:</span><br><span class="line">                <span class="keyword">if</span> nums[mid+<span class="number">1</span>] &lt;= target <span class="keyword">and</span> target &lt;= nums[right]:</span><br><span class="line">                    left = mid + <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    right = mid</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">if</span> nums[left] &lt;= target <span class="keyword">and</span> target &lt;= nums[mid]:</span><br><span class="line">                    right = mid</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    left = mid + <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> nums[left] == target:</span><br><span class="line">            <span class="keyword">return</span> left</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">#方法5：三段区间</span></span><br><span class="line">        left = <span class="number">0</span></span><br><span class="line">        right = len(nums)<span class="number">-1</span></span><br><span class="line">        <span class="keyword">while</span> left &lt;= right:<span class="comment">#注意</span></span><br><span class="line">            mid = left + (right-left)//<span class="number">2</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> nums[mid] == target:</span><br><span class="line">                <span class="keyword">return</span> mid</span><br><span class="line">            <span class="keyword">if</span> nums[left] &lt;= nums[mid]:<span class="comment">#注意是&lt;=</span></span><br><span class="line">                <span class="comment">#因为上面已经判断nums[mid]==target，这里就不用=</span></span><br><span class="line">                <span class="keyword">if</span> nums[left] &lt;= target <span class="keyword">and</span> target &lt; nums[mid]:</span><br><span class="line">                    right = mid - <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    left = mid+<span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">if</span> nums[mid] &lt; target <span class="keyword">and</span> target &lt;= nums[right]:</span><br><span class="line">                    left = mid+<span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    right = mid<span class="number">-1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span></span><br></pre></td></tr></table></figure><h3><span id="313-搜索旋转排序数组-ii">3.1.3. 搜索旋转排序数组 II</span></h3><p>假设按照升序排序的数组在预先未知的某个点上进行了旋转。</p><p>( 例如，数组 [0,0,1,2,2,5,6] 可能变为 [2,5,6,0,0,1,2] )。</p><p>编写一个函数来判断给定的目标值是否存在于数组中。若存在返回 true，否则返回 false。</p><p>进阶:<br>这是 搜索旋转排序数组 的延伸题目，本题中的 nums  可能包含重复元素。<br>这会影响到程序的时间复杂度吗？会有怎样的影响，为什么？</p><p>这道题和上一题的区别是nums中存在重复元素。那nums[mid]和右边界比较来举例，上一题只考虑了2种情况，if nums[mid] &lt; nums[right]和nums[mid] &gt; nums[right]，但在这一题中，因为有重复元素，所以就需要考虑相等的情况。当nums[mid] == nums[right]，先判断是否等于target，如果等于返回True，否则当前的right被排除，right向前移一位。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">search</span><span class="params">(self, nums, target)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :type target: int</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="comment">#中间元素和右边界比较，使用右中位数</span></span><br><span class="line">        <span class="keyword">if</span> len(nums) == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">        left= <span class="number">0</span> </span><br><span class="line">        right = len(nums)<span class="number">-1</span></span><br><span class="line">        <span class="keyword">while</span> left &lt; right:</span><br><span class="line">            mid = left+(right-left+<span class="number">1</span>)//<span class="number">2</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> nums[mid] &lt; nums[right]:</span><br><span class="line">                <span class="keyword">if</span> nums[mid] &lt;= target <span class="keyword">and</span> target &lt;= nums[right]:</span><br><span class="line">                    <span class="comment">#[mid,right]一定是有序的</span></span><br><span class="line">                    left = mid</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    right = mid - <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> nums[mid] &gt; nums[right]:</span><br><span class="line">                <span class="keyword">if</span> nums[left] &lt;= target <span class="keyword">and</span> target &lt;= nums[mid<span class="number">-1</span>]:</span><br><span class="line">                    <span class="comment">#[left,mid-1]一定是有序的</span></span><br><span class="line">                    right = mid - <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    left = mid</span><br><span class="line">            <span class="keyword">else</span>:<span class="comment">#nums[mid] == nums[right]</span></span><br><span class="line">                <span class="keyword">if</span> nums[mid] == target:</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    right -= <span class="number">1</span> </span><br><span class="line">        <span class="keyword">if</span> nums[left] == target:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">False</span></span><br></pre></td></tr></table></figure><h3><span id="314-寻找旋转排序数组中的最小值">3.1.4. 寻找旋转排序数组中的最小值</span></h3><p>假设按照升序排序的数组在预先未知的某个点上进行了旋转。</p><p>( 例如，数组 [0,1,2,4,5,6,7] 可能变为 [4,5,6,7,0,1,2] )。</p><p>请找出其中最小的元素。</p><p><strong>你可以假设数组中不存在重复元素。</strong></p><p>虽然是要找最小数，但是数据部分有序，可以使用二分法。有2种情况，nums[mid]和左边界比较，nums[mid]和右边界比较</p><ul><li>nums[mid]和左边界比较<ul><li>例如[1,2,3,4,5]，中间数nums[mid]=3,比左边界大，最小值存在于左区间</li><li>[2,3,4,5,6,1],中间数nums[mid]=4比左边界大，说明左边界有序，最小值一定存在于右区间</li></ul></li></ul><p>根据上面2种情况，可以看出当nums[mid]大于左边界时，不知道最小值一定存在于哪个区间，所以不能用mid和左边界比较。</p><ul><li><p>nums[mid]和右边界比较</p><ul><li>当nums[mid] &lt; nums[right],说明最小值一定在左边</li><li>当nums[mid] &gt; nums[right],说明最小值一定在右边</li><li>当nums[mid] = nums[right],因为题目中说不存在重复元素，所以不会出现相等的情况</li></ul></li><li><p>时间复杂度：O(logN)</p></li><li>空间复杂度：O(1)</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findMin</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="comment">#中间元素和右边元素比较</span></span><br><span class="line">        left = <span class="number">0</span></span><br><span class="line">        right = len(nums)<span class="number">-1</span></span><br><span class="line">        <span class="keyword">while</span> left &lt; right:</span><br><span class="line">            mid = left+(right-left)//<span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> nums[mid] &lt; nums[right]:<span class="comment">#说明右边有序，右边递增</span></span><br><span class="line">                <span class="comment">#说明最小值肯定在左区间</span></span><br><span class="line">                right = mid</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment">#mid大于右边，说明左边有序，左边递增，那左边的值比mid小，右边的值也比mid小，到底哪边的值更小呢？</span></span><br><span class="line">            <span class="comment">#答案是：右边的值更小，因为如果左边的值更小的话，那说明右边的值比左边的最小值大，比mid小，那这个值肯定在min和mid之间，</span></span><br><span class="line">            <span class="comment">#但现在这个值在右边，推翻前面的假设，即右边的值更小</span></span><br><span class="line">                left = mid+<span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> nums[left]</span><br><span class="line"></span><br><span class="line">        <span class="comment">#尝试使用nums[mid]和左边界比较，失败</span></span><br><span class="line">        <span class="comment"># left = 0</span></span><br><span class="line">        <span class="comment"># right = len(nums)-1</span></span><br><span class="line">        <span class="comment"># while left &lt; right:</span></span><br><span class="line">        <span class="comment">#     mid = left+(right-left)//2</span></span><br><span class="line">        <span class="comment">#     if nums[mid] &lt; nums[left]:#说明右边有序,右边递增，最小值一定在做区间</span></span><br><span class="line">        <span class="comment">#         right = mid</span></span><br><span class="line">        <span class="comment">#     else:#mid比左边大，说明左边有序，左边递增，但是最小值不一定在左边</span></span><br><span class="line">        <span class="comment">#     #[1,2,3,4,5,6,7]最小值在左区间，</span></span><br><span class="line">        <span class="comment">#     #[8,9,10,11,1,2]最小值在右区间</span></span><br><span class="line">        <span class="comment">#     #不确定该缩小到哪个区间，该方法不可行</span></span><br></pre></td></tr></table></figure><h3><span id="315-寻找旋转排序数组中的最小值-ii">3.1.5. 寻找旋转排序数组中的最小值 II</span></h3><p>假设按照升序排序的数组在预先未知的某个点上进行了旋转。</p><p>( 例如，数组 [0,1,2,4,5,6,7] 可能变为 [4,5,6,7,0,1,2] )。</p><p>请找出其中最小的元素。</p><p><strong>注意数组中可能存在重复的元素</strong>。</p><ul><li>时间复杂度：O(logN),但在最坏情况下，即nums[mid]==nums[right]，需要逐个遍历数组，复杂度为O(N)</li><li>空间复杂度：O(1)<br>上个问题是这个问题的特例，只是上个问题永远不会进入到nums[mid]==nums[right]的分支。</li></ul><p>在本题中如果nums[mid]==nums[right]，会将right减1，那是否可以变成left+1呢？答案是：不可以，例如[1,3,3]，left=1，mid=3，right=3，如果变成left+1，就会跳过最小值。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findMin</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        left = <span class="number">0</span></span><br><span class="line">        right = len(nums)<span class="number">-1</span></span><br><span class="line">        <span class="keyword">while</span> left &lt; right:</span><br><span class="line">            mid = left+(right-left)//<span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> nums[mid] &lt; nums[right]:<span class="comment">#说明右边有序，最小值一定在左区间</span></span><br><span class="line">                right = mid</span><br><span class="line">            <span class="keyword">elif</span> nums[mid] &gt; nums[right]:<span class="comment">#说明左边有序，最小值一定在右区间</span></span><br><span class="line">                left = mid + <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:<span class="comment">#nums[mid] == nums[right]</span></span><br><span class="line">                right -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> nums[left]</span><br></pre></td></tr></table></figure><h3><span id="316-h指数-ii">3.1.6. H指数 II</span></h3><p>给定一位研究者论文被引用次数的数组（被引用次数是非负整数），数组已经按照升序排列。编写一个方法，计算出研究者的 h 指数。</p><p>h 指数的定义: “h 代表“高引用次数”（high citations），一名科研人员的 h 指数是指他（她）的 （N 篇论文中）有 h 篇论文分别被引用了至少 h 次。（其余的 N - h 篇论文每篇被引用次数不多于 h 次。）”</p><p>我们先举一个例子，<br>[1,2,3,7,9]，假设一个文章下标为i，则需要满足<code>citation[i] &gt;= n - i</code>,有h个文章的引用次数大于等于h，即当前的引用次数为citation[i]，引用次数大于等于它的文章有n-i个。h的值就是n-i<br>该问题可以简化为：给定一个长度为n的升序数组，找到满足<code>citation[i]&gt;=n-i</code>的citation[i]<br>用二分法来解决这个问题<br>我们要找i，先找到不符合citation[i] &gt;= n-i的情况，就是citation[i] &lt; n -i，即i太小了，需要变大到右区间找，更新left=mid+1，否则去左区间right=mid。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hIndex</span><span class="params">(self, citations)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type citations: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        n = len(citations)</span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">0</span> <span class="keyword">or</span> citations[n<span class="number">-1</span>] == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        left = <span class="number">0</span></span><br><span class="line">        right = n<span class="number">-1</span></span><br><span class="line">        <span class="comment">#要找citation[i] &gt;= n -i</span></span><br><span class="line">        <span class="keyword">while</span> left &lt; right:</span><br><span class="line">            mid = left+(right-left)//<span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> citations[mid] &lt; n - mid:<span class="comment">#说明mid小了，需要移到右区间</span></span><br><span class="line">                left = mid+<span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                right = mid</span><br><span class="line">        <span class="keyword">return</span> n-left</span><br></pre></td></tr></table></figure><h3><span id="317-最长上升子序列">3.1.7. 最长上升子序列</span></h3><p>动态规划+二分，以后再看</p><h3><span id="318-山脉数组中查找目标值">3.1.8. 山脉数组中查找目标值</span></h3><p>给你一个 山脉数组 mountainArr，请你返回能够使得 mountainArr.get(index) 等于 target 最小 的下标 index 值。</p><p>如果不存在这样的下标 index，就请返回 -1。</p><p>山脉数组：[1,2,4,7,4,2,1]先上升后下降的数组<br>使用3次二分</p><ul><li>使用二分，找出最大元素的下标</li><li>使用二分，找出左边升序数组中第一个等于target的下标</li><li>使用二分，找出右边降序数组中第一个等于target的下标</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findInMountainArray</span><span class="params">(self, target, mountain_arr)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type target: integer</span></span><br><span class="line"><span class="string">        :type mountain_arr: MountainArray</span></span><br><span class="line"><span class="string">        :rtype: integer</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        n = mountain_arr.length()<span class="number">-1</span></span><br><span class="line">        max_idx = self.findTop(mountain_arr,<span class="number">0</span>,n)</span><br><span class="line">        <span class="comment">#[0,max_idx+1]升序，[max_idx+1,n]降序</span></span><br><span class="line">        first_idx = self.sorted_first(mountain_arr,<span class="number">0</span>,max_idx,target)</span><br><span class="line">        <span class="keyword">if</span> first_idx != <span class="number">-1</span>:</span><br><span class="line">            <span class="keyword">return</span> first_idx</span><br><span class="line">        first_idx = self.reverse_first(mountain_arr,max_idx+<span class="number">1</span>,n,target)</span><br><span class="line">        <span class="keyword">return</span> first_idx</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findTop</span><span class="params">(self,mountain_arr,left,right)</span>:</span></span><br><span class="line">        <span class="comment">#找到mountain_arr中最大值的下标</span></span><br><span class="line">        <span class="keyword">while</span> left &lt; right:</span><br><span class="line">            mid = left+(right-left)//<span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> mountain_arr.get(mid) &lt; mountain_arr.get(mid+<span class="number">1</span>):<span class="comment">#说明最大值在右边</span></span><br><span class="line">                left = mid+<span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                right = mid</span><br><span class="line">        <span class="keyword">return</span> left</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sorted_first</span><span class="params">(self,mountain_arr,left,right,target)</span>:</span></span><br><span class="line">        <span class="comment">#nums升序，从nums中找到第一个等于target的下标，找不到返回-1</span></span><br><span class="line">     </span><br><span class="line">        <span class="keyword">while</span> left &lt; right:</span><br><span class="line">            mid=left+(right-left)//<span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> mountain_arr.get(mid) &lt; target:</span><br><span class="line">                left = mid+<span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                right = mid</span><br><span class="line">        <span class="keyword">if</span> mountain_arr.get(left)==target:</span><br><span class="line">            <span class="keyword">return</span> left</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverse_first</span><span class="params">(self,mountain_arr,left,right,target)</span>:</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> left &lt; right:</span><br><span class="line">            mid = left+(right-left+<span class="number">1</span>)//<span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> mountain_arr.get(mid) &lt; target:<span class="comment">#说明target在左边</span></span><br><span class="line">                right = mid<span class="number">-1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                left = mid</span><br><span class="line">        <span class="keyword">if</span> mountain_arr.get(left) == target:</span><br><span class="line">            <span class="keyword">return</span> left</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span></span><br></pre></td></tr></table></figure><h3><span id="319-寻找两个有序数组的中位数">3.1.9. 寻找两个有序数组的中位数</span></h3><p>给定两个大小为 m 和 n 的有序数组 nums1 和 nums2。</p><p>请你找出这两个有序数组的中位数，并且要求算法的时间复杂度为 O(log(m + n))。</p><p>你可以假设 nums1 和 nums2 不会同时为空</p><p><strong>【解法1】</strong><br>最简单的方法是：将2个数组拼接，重排序。这种方法很常规，但是不符合题目要求。<strong>这个方法的优点是：2个数组不需要有序</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findMedianSortedArrays</span><span class="params">(self, nums1, nums2)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums1: List[int]</span></span><br><span class="line"><span class="string">        :type nums2: List[int]</span></span><br><span class="line"><span class="string">        :rtype: float</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        m = len(nums1)</span><br><span class="line">        n = len(nums2)</span><br><span class="line">        nums1.extend(nums2)</span><br><span class="line">        nums1.sort()</span><br><span class="line">        <span class="keyword">if</span> (m+n)%<span class="number">2</span>==<span class="number">0</span>:</span><br><span class="line">            mid = (m+n)//<span class="number">2</span></span><br><span class="line">            <span class="keyword">return</span> (nums1[mid]+nums1[mid<span class="number">-1</span>])/<span class="number">2.0</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            mid = (m+n)//<span class="number">2</span></span><br><span class="line">            <span class="keyword">return</span> nums1[mid]</span><br></pre></td></tr></table></figure><ul><li>时间复杂度：$O((m+n)log(m+n))$</li><li>空间复杂度：$O(m+n)$</li></ul><p><strong>【解法2】</strong><br>不用把2个数组排序放在一起，直到遍历2个数组，找到中位数就可以了。</p><ul><li>当m+n为奇数时，[1,2,5,7],[3,6,8],一共7个数，中位数的下标为3，即7//2</li><li>当m+n为偶数时，[1,2,5,7],[3,6,8,9],一共8个数，中位数的下标为3,4，即8//2-1,8//2<br>即不管总数是奇数还是偶数，都要遍历到(m+n)//2这个下标。</li><li>使用2个变量left和right来标记当前遍历到的2个数，right表示当前遍历的数，left为前一个数。</li><li>使用2个指针p1和p2来标记nums1和nums2遍历到的位置。当nums1没有完，且当前nums1的值小于nums2的值，移动p1，或者nums1没有完，但是nums2遍历完了，移动p1， 其余情况都是移动p2。</li><li>在最后返回值的时候判断一下当前m+n奇偶情况。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findMedianSortedArrays</span><span class="params">(self, nums1, nums2)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums1: List[int]</span></span><br><span class="line"><span class="string">        :type nums2: List[int]</span></span><br><span class="line"><span class="string">        :rtype: float</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="comment">#不管m+n是奇数还是偶数，都遍历到下标为(m+n)/2的位置</span></span><br><span class="line">        m,n=len(nums1),len(nums2)</span><br><span class="line">        mid_idx = (m+n)//<span class="number">2</span></span><br><span class="line"></span><br><span class="line">        left_val,right_val = <span class="number">-1</span>,<span class="number">-1</span></span><br><span class="line">        p1,p2=<span class="number">0</span>,<span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>,mid_idx+<span class="number">1</span>):</span><br><span class="line">            left_val = right_val</span><br><span class="line">            <span class="keyword">if</span> p1 &lt; m <span class="keyword">and</span> (p2 &gt;= n <span class="keyword">or</span> nums1[p1] &lt; nums2[p2]):</span><br><span class="line">                right_val = nums1[p1]</span><br><span class="line">                p1 += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                right_val = nums2[p2]</span><br><span class="line">                p2+=<span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> (m+n)%<span class="number">2</span>==<span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> (left_val+right_val)/<span class="number">2.0</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> right_val</span><br></pre></td></tr></table></figure><ul><li>时间复杂度：$O(m+n)$<br>还是没有达到log的时间复杂度</li></ul><p><strong>【解法3】</strong></p><h2><span id="32-在一个有上下界的区间中搜索一个整数">3.2. 在一个有上下界的区间中搜索一个整数</span></h2><h3><span id="321-x-的平方根">3.2.1. x 的平方根</span></h3><p>实现 int sqrt(int x) 函数。</p><p>计算并返回 x 的平方根，其中 x 是非负整数。</p><p>由于返回类型是整数，结果只保留整数的部分，小数部分将被舍去。</p><p>【我的解法】<br>首先找到不符合条件的值，即mid*mid&gt;x，一定不符合条件。在更新left会出现left=mid，这时就需要把mid取右中位数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">mySqrt</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type x: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> x==<span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        left,right = <span class="number">1</span>,x//<span class="number">2</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># while left &lt; right:</span></span><br><span class="line">        <span class="comment">#     mid = left+(right-left)//2</span></span><br><span class="line">        <span class="comment">#     if mid*mid &lt; x:#mid的平方&lt;x,也是符合条件的，例如8的结果为2,2*2=4&lt;8</span></span><br><span class="line">        <span class="comment">#         left = mid+1</span></span><br><span class="line">        <span class="comment">#     else:</span></span><br><span class="line">        <span class="comment">#         right=mid</span></span><br><span class="line">        <span class="keyword">while</span> left &lt; right:</span><br><span class="line">            mid = left+(right-left+<span class="number">1</span>)//<span class="number">2</span><span class="comment">#取右中位数</span></span><br><span class="line">            <span class="keyword">if</span> mid*mid &gt; x:</span><br><span class="line">                right = mid <span class="number">-1</span><span class="comment">#有边界不包括中位数</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                left = mid<span class="comment">#左边界可以是中位数，</span></span><br><span class="line">        <span class="keyword">return</span> left</span><br></pre></td></tr></table></figure><h3><span id="322-寻找重复数">3.2.2. 寻找重复数</span></h3><p>给定一个包含 n + 1 个整数的数组 nums，其数字都在 1 到 n 之间（包括 1 和 n），可知至少存在一个重复的整数。假设只有一个重复的整数，找出这个重复的数。</p><p>说明：</p><ol><li>不能更改原数组（假设数组是只读的）。</li><li>只能使用额外的 O(1) 的空间。</li><li>时间复杂度小于 O(n2) 。</li><li>数组中只有一个重复的数字，但它可能不止重复出现一次。</li></ol><p>先不管上面这些限制条件，看有什么解法</p><p>【解法1】<br>先对nums排序，然后判断每个数和它后面的数是否相同，若相同则说明重复，直接返回</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findDuplicate</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        nums.sort()</span><br><span class="line">        n = len(nums)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n<span class="number">-1</span>):</span><br><span class="line">            <span class="keyword">if</span> nums[i] == nums[i+<span class="number">1</span>]:</span><br><span class="line">                <span class="keyword">return</span> nums[i]</span><br></pre></td></tr></table></figure><ul><li>时间复杂度：$O(nlogn)$</li><li>改变原数组，不符合题目要求</li></ul><p>【解法2】<br>使用字典保存每个数字出现的次数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findDuplicate</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        count = dict()</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> nums:</span><br><span class="line">            <span class="keyword">if</span> i <span class="keyword">not</span> <span class="keyword">in</span> count:</span><br><span class="line">                count[i] = <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                count[i]+=<span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> count[i] &gt; <span class="number">1</span>:</span><br><span class="line">                <span class="keyword">return</span> i</span><br></pre></td></tr></table></figure><ul><li>时间复杂度：$O(n)$,只遍历一次数组</li><li>空间复杂度：$O(n)$,不符合题目要求</li></ul><p>【解法3】<br>使用二分法，[1,3,3,2,4,5],例如有6个数，范围在1~5之间，其中小于等于3的有4个数，说明重复的数肯定在3的左边，要么是3,2,1中的1个数，更新right到左区间。<br>这里的mid表示当前重复的数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findDuplicate</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        n = len(nums)</span><br><span class="line">        left = <span class="number">0</span></span><br><span class="line">        right = n <span class="number">-1</span></span><br><span class="line">        <span class="keyword">while</span> left &lt; right:</span><br><span class="line">            mid = left + (right-left) // <span class="number">2</span></span><br><span class="line">            count=<span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> nums:</span><br><span class="line">                <span class="keyword">if</span> i&lt;=mid:</span><br><span class="line">                    count+=<span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> count &gt; mid:<span class="comment">#说明小于等于mid的元素有重复的，转到左区间</span></span><br><span class="line">                right = mid</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                left = mid + <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> left</span><br></pre></td></tr></table></figure><ul><li>时间复杂度：$O(nlogn)$，因为二分的复杂度为logn，在内部又遍历一次数组</li><li>空间复杂度：$O(1)$</li></ul><h2><span id="33-判断条件是一个函数">3.3. 判断条件是一个函数</span></h2><p>在二分法中if语句中，判断条件是一个函数</p><h3><span id="331-第一个错误的版本">3.3.1. 第一个错误的版本</span></h3><p>你是产品经理，目前正在带领一个团队开发新的产品。不幸的是，你的产品的最新版本没有通过质量检测。由于每个版本都是基于之前的版本开发的，所以错误的版本之后的所有版本都是错的。</p><p>假设你有 n 个版本 [1, 2, …, n]，你想找出导致之后所有版本出错的第一个错误的版本。</p><p>你可以通过调用 bool isBadVersion(version) 接口来判断版本号 version 是否在单元测试中出错。实现一个函数来查找第一个错误的版本。你应该尽量减少对调用 API 的次数。</p><p><strong>【我的解法】</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># The isBadVersion API is already defined for you.</span></span><br><span class="line"><span class="comment"># @param version, an integer</span></span><br><span class="line"><span class="comment"># @return a bool</span></span><br><span class="line"><span class="comment"># def isBadVersion(version):</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">firstBadVersion</span><span class="params">(self, n)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type n: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        left=<span class="number">1</span></span><br><span class="line">        right=n</span><br><span class="line">        <span class="keyword">while</span> left &lt; right:</span><br><span class="line">            mid=left+(right-left)//<span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> isBadVersion(mid):</span><br><span class="line">                left=mid+<span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                right=mid</span><br><span class="line">        <span class="keyword">return</span> left</span><br></pre></td></tr></table></figure><h3><span id="332-分割数组的最大值">3.3.2. 分割数组的最大值</span></h3><p>给定一个非负整数数组和一个整数 m，你需要将这个数组分成 m 个非空的连续子数组。设计一个算法使得这 m 个子数组各自和的最大值最小。</p><p>注意:<br>数组长度 n 满足以下条件:</p><p>1 ≤ n ≤ 1000<br>1 ≤ m ≤ min(50, n)</p><p><strong>【题解】</strong><br>子数组的最大值是有范围的，在[max(nums),sum(nums)]之间。令left=max(nums)，right=sum(nums)，mid=left+(right-left)//2,计算子数组和最大为mid时，所划分的子数组个数sub_arr_count</p><ul><li>如果sub_arr_count &gt; m，说明子数组划分多了，mid值应该变大，left=mid+1</li><li>否则，说明子数组少了，mid大了，减少mid的值，right=mid</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">splitArray</span><span class="params">(self, nums, m)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :type m: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="comment">#数组最大的范围在max(nums)和sum(nums)之间，首先找到nums的max和sum</span></span><br><span class="line">        <span class="comment">#将max(nums)作为最大值的left，sum(nums)作为最大值的right</span></span><br><span class="line">        left,right=nums[<span class="number">0</span>],<span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> nums:</span><br><span class="line">            right+=i</span><br><span class="line">            <span class="keyword">if</span> i&gt;left:</span><br><span class="line">                left=i</span><br><span class="line">        <span class="keyword">while</span> left &lt; right:</span><br><span class="line">            mid=left+(right-left)//<span class="number">2</span><span class="comment">#子数组的max</span></span><br><span class="line">            sub_sum = <span class="number">0</span><span class="comment">#子数组之和</span></span><br><span class="line">            sub_arr_count=<span class="number">1</span><span class="comment">#注意初始子数组个数为1</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> nums:</span><br><span class="line">                sub_sum += i</span><br><span class="line">                <span class="keyword">if</span> sub_sum &gt; mid:</span><br><span class="line">                    sub_sum = i</span><br><span class="line">                    sub_arr_count += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> sub_arr_count &gt; m:<span class="comment">#说明子数组个数多，增大mid</span></span><br><span class="line">                left = mid+<span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                right=mid</span><br><span class="line">        <span class="keyword">return</span> left</span><br></pre></td></tr></table></figure><h3><span id="333-爱吃香蕉的珂珂">3.3.3. 爱吃香蕉的珂珂</span></h3><p>珂珂喜欢吃香蕉。这里有 N 堆香蕉，第 i 堆中有 piles[i] 根香蕉。警卫已经离开了，将在 H 小时后回来。</p><p>珂珂可以决定她吃香蕉的速度 K （单位：根/小时）。每个小时，她将会选择一堆香蕉，从中吃掉 K 根。如果这堆香蕉少于 K 根，她将吃掉这堆的所有香蕉，然后这一小时内不会再吃更多的香蕉。  </p><p>珂珂喜欢慢慢吃，但仍然想在警卫回来前吃掉所有的香蕉。</p><p>返回她可以在 H 小时内吃掉所有香蕉的最小速度 K（K 为整数）。</p><p><strong>【我的解法】</strong><br>这一题和上一题<a href="https://leetcode-cn.com/problems/split-array-largest-sum/" target="_blank" rel="noopener">410. 分割数组的最大值</a>很像。首先明确left，right，mid代表什么意思。这里的mid表示吃的速度。根据当前mid来吃香蕉，看看需要多少小时，如果hours&gt;H,说明吃慢了，mid要变大，更新left，否则更新right</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minEatingSpeed</span><span class="params">(self, piles, H)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type piles: List[int]</span></span><br><span class="line"><span class="string">        :type H: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">import</span> math</span><br><span class="line">        <span class="comment">#最小速度的范围是1,max</span></span><br><span class="line">        left=<span class="number">1</span></span><br><span class="line">        right=piles[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> piles:</span><br><span class="line">            <span class="keyword">if</span> i&gt;right:</span><br><span class="line">                right=i</span><br><span class="line">        <span class="keyword">while</span> left&lt;right:</span><br><span class="line">            mid=left+(right-left)//<span class="number">2</span><span class="comment">#表示当前吃的速度</span></span><br><span class="line">            <span class="comment">#计算以当前的速度，需要吃几个小时</span></span><br><span class="line">            hours=<span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> piles:</span><br><span class="line">                hours+=math.ceil(i*<span class="number">1.0</span>/mid)</span><br><span class="line">            <span class="keyword">if</span> hours &gt; H:<span class="comment">#说明吃的太慢了，mid需要向右移</span></span><br><span class="line">                left=mid+<span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                right=mid</span><br><span class="line">        <span class="keyword">return</span> left</span><br></pre></td></tr></table></figure><h3><span id="334-找到-k-个最接近的元素">3.3.4. 找到 K 个最接近的元素</span></h3><p>给定一个排序好的数组，两个整数 k 和 x，从数组中找到最靠近 x（两数之差最小）的 k 个数。返回的结果必须要是按升序排好的。如果有两个数与 x 的差值一样，优先选择数值较小的那个数。</p><p><strong>【解法1】</strong><br>遍历整个数组，记录每个数和x的差值，然后取出前k小的差值，范湖其原始值。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findClosestElements</span><span class="params">(self, arr, k, x)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type arr: List[int]</span></span><br><span class="line"><span class="string">        :type k: int</span></span><br><span class="line"><span class="string">        :type x: int</span></span><br><span class="line"><span class="string">        :rtype: List[int]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        delta = &#123;&#125;<span class="comment">#存储每个数和x的差值</span></span><br><span class="line">        <span class="keyword">for</span> idx,val <span class="keyword">in</span> enumerate(arr):</span><br><span class="line">            delta[idx]=abs(val-x)</span><br><span class="line">        <span class="comment">#按照差值排序</span></span><br><span class="line">        delta1 = sorted(delta.items(),key=<span class="keyword">lambda</span> x:x[<span class="number">1</span>])</span><br><span class="line">        k_res = delta1[:k]<span class="comment">#取出差值在前k个的数据</span></span><br><span class="line">        k_res.sort(key= operator.itemgetter(<span class="number">0</span>))<span class="comment">#对这k个数按照下标排序</span></span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">for</span> idx,delta <span class="keyword">in</span> k_res:</span><br><span class="line">            res.append(arr[idx])</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><p><strong>【解法2】</strong><br>在arr中找到离x最近的k个数，因为arr已经是升序，所有删除的数一定在边界。使用2个指针，一个指向left，一个指向right。一共要保留k个数，即要删除n-k个数，while循环的条件是<code>while del_cnt &lt; n-k</code>,保证在退出循环时，<code>del_cnt=n-k</code>。如果左边数的差值&gt;右边数的差值，移动left，否则移动right。在else中其中有2种情况：</p><ul><li>右边数的差值&gt;左边的差值，移动right</li><li>右边数的差值=左边的差值，因为题目中说了，差值一样时，优先选择数值较小的那个数，即保留left，移动right</li></ul><p>退出循环时，left和right就是我们要保留的数，因为列表切片时，左闭右开，所以右边要写成right+1</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findClosestElements</span><span class="params">(self, arr, k, x)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type arr: List[int]</span></span><br><span class="line"><span class="string">        :type k: int</span></span><br><span class="line"><span class="string">        :type x: int</span></span><br><span class="line"><span class="string">        :rtype: List[int]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="comment">#使用双指针</span></span><br><span class="line">        n = len(arr)</span><br><span class="line">        left = <span class="number">0</span></span><br><span class="line">        right = n<span class="number">-1</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">#要保留k个数，即要删除n-k个数</span></span><br><span class="line">        del_cnt=<span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> del_cnt &lt; n-k:</span><br><span class="line">            <span class="keyword">if</span> abs(arr[left]-x) &gt; abs(arr[right]-x):</span><br><span class="line">               <span class="comment">#左边元素差值更大时，删除左边的元素</span></span><br><span class="line">                left+=<span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                right-=<span class="number">1</span></span><br><span class="line">            del_cnt+=<span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> arr[left:right+<span class="number">1</span>]</span><br></pre></td></tr></table></figure><p><strong>【题解3】</strong><br>利用二分法来找到长度为k的区间，这里我们只要确定左边界就可以了，因为知道区间长度为k，右边界为left+k-1。<br>首先确定左边界的范围[0,n-k]，比如[0,1,2,3,4,5,6]，一共7个数，n=7，假设k=3，那么左区间最大为4，如果更大的话，就不够3个数了。<br>所以现在要做的是在[0,n-k]这个区间中，找到一个合适的左边界。这就类似在一个有序数组中，查找一个数，可以使用二分法。<br>设定2个指针，一个left=0，指向左边界的最小值，right=n-k，指向左边界的最大值。<code>mid=left+(right-left)//2</code></p><p>解读以下代码：<br>在if语句中<code>abs(arr[mid]-x) &gt; abs(arr[mid+k]-x)</code>,如果左边界是mid，那整个区间是[mid,mid+k-1],下一个左区间范围是[mid+1,mid+k]，这2个区间除了arr[mid]和nums[mid+k]这2个数不一样，其余都一样，那就比较这2个数哪个数离x更远，假设nums[mid]离x更远，就要把left往右移，即left=mid+1，否则right=mid</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findClosestElements</span><span class="params">(self, arr, k, x)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type arr: List[int]</span></span><br><span class="line"><span class="string">        :type k: int</span></span><br><span class="line"><span class="string">        :type x: int</span></span><br><span class="line"><span class="string">        :rtype: List[int]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        n=len(arr)</span><br><span class="line">        left=<span class="number">0</span></span><br><span class="line">        right=n-k</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> left&lt;right:</span><br><span class="line">            mid=left+(right-left)//<span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> abs(arr[mid]-x) &gt; abs(arr[mid+k]-x):<span class="comment">#说明右边的元素离x更近，向右移</span></span><br><span class="line">                left=mid+<span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                right=mid</span><br><span class="line">        <span class="keyword">return</span> arr[left:left+k]</span><br></pre></td></tr></table></figure><h3><span id="335-转变数组后最接近目标值的数组和">3.3.5. 转变数组后最接近目标值的数组和</span></h3><p>给你一个整数数组 arr 和一个目标值 target ，请你返回一个整数 value ，使得将数组中所有大于 value 的值变成 value 后，数组的和最接近  target （最接近表示两者之差的绝对值最小）。</p><p>如果有多种使得和最接近 target 的方案，请你返回这些整数中的最小值。</p><p>请注意，答案不一定是 arr 中的数字。</p><p><strong>【我的解法】</strong><br>首先确定left，right，value表示什么。这里mid表示需要求的value。然后找到left和right的范围。value的范围最小为0，最大为arr中的最大值。然后开始写二分，给定mid，然后我们计算替换后的sum和target的差值。<br>在if语句中，需要有一个比较条件，但是我们不知道和谁比较，受下面2个题的启发<br><a href="https://leetcode-cn.com/problems/find-in-mountain-array/" target="_blank" rel="noopener">1095山脉数组中查找目标值</a>和<a href="https://leetcode-cn.com/problems/find-k-closest-elements/" target="_blank" rel="noopener">658. 找到 K 个最接近的元素</a>：不知道和谁比较时，一般和mid+1比较。如果mid的差值比mid+1的差值大，说明mid小了，应该变大，更新left=mid+1，否则更新right</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findBestValue</span><span class="params">(self, arr, target)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type arr: List[int]</span></span><br><span class="line"><span class="string">        :type target: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="comment">#mid表示要找的这个数value</span></span><br><span class="line">        <span class="comment">#它的范围是：0~arr中的最大值</span></span><br><span class="line">        left=<span class="number">0</span></span><br><span class="line">        right=arr[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> arr:</span><br><span class="line">            <span class="keyword">if</span> i&gt;right:</span><br><span class="line">                right=i</span><br><span class="line">        <span class="keyword">while</span> left&lt;right:</span><br><span class="line">            mid=left+(right-left)//<span class="number">2</span></span><br><span class="line">            <span class="comment">#计算当value=mid时，所有数据的和</span></span><br><span class="line">            mid_sum = self.get_sum(arr,mid)</span><br><span class="line">            mid_plus_sum = self.get_sum(arr,mid+<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">if</span> abs(mid_sum-target) &gt; abs(mid_plus_sum-target):</span><br><span class="line">                <span class="comment">#说明mid小了，向右移</span></span><br><span class="line">                left = mid+<span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                right=mid</span><br><span class="line">        <span class="keyword">return</span> left</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_sum</span><span class="params">(self,arr,value)</span>:</span></span><br><span class="line">        all_sum = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> arr:</span><br><span class="line">            <span class="keyword">if</span> i &gt; value:</span><br><span class="line">                all_sum+=value</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                all_sum+=i</span><br><span class="line">        <span class="keyword">return</span> all_sum</span><br></pre></td></tr></table></figure><h1><span id="4-总结">4. 总结</span></h1><ol><li>首先明确left，right，mid表示什么意思，确定了表示含义后，才可以确定left和right的范围</li><li>一般来说mid的含义要么是题目中要求的值，要么是下标。</li><li>在if语句中的条件时，mid的值或mid对应的函数值，需要和一个值进行比较，如果很容易发现和谁比较，就和谁比较，如果找不到就和mid+1的函数值比较</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;列表查找：从列表中查找指定元素&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;输出：列表&lt;/li&gt;
&lt;li&gt;输出：元素下标，找不到返回None或-1&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode之Array</title>
    <link href="http://yoursite.com/2020/03/13/Leetcode%E4%B9%8BArray/"/>
    <id>http://yoursite.com/2020/03/13/Leetcode之Array/</id>
    <published>2020-03-13T07:02:20.000Z</published>
    <updated>2020-06-18T02:36:55.999Z</updated>
    
    <content type="html"><![CDATA[<p>最近要开始准备刷Leetcode了，在这里记录下刷题的心得</p><a id="more"></a><!-- TOC --><ul><li><a href="#1-双指针">1. 双指针</a><ul><li><a href="#11-删除排序数组中的重复项">1.1. 删除排序数组中的重复项</a></li><li><a href="#12-移除元素">1.2. 移除元素</a></li><li><a href="#13-删除排序数组中的重复项-ii">1.3. 删除排序数组中的重复项 II</a></li><li><a href="#14-缺失的第一个正数">1.4. 缺失的第一个正数</a></li></ul></li><li><a href="#2-其他">2. 其他</a><ul><li><a href="#21-find-the-celebrity">2.1. Find the Celebrity</a></li><li><a href="#22-旋转数组">2.2. 旋转数组</a></li><li><a href="#23-猜数字游戏">2.3. 猜数字游戏</a></li><li><a href="#24-加油站">2.4. 加油站</a></li><li><a href="#25-多数元素">2.5. 多数元素</a></li><li><a href="#26-求众数-ii">2.6. 求众数 II</a></li><li><a href="#27-h指数">2.7. H指数</a></li><li><a href="#28-最短单词距离">2.8. 最短单词距离</a></li><li><a href="#29-最短单词距离-ii">2.9. 最短单词距离 II</a></li><li><a href="#210-最短单词距离之iii">2.10. 最短单词距离之III</a></li><li><a href="#211-存在重复元素">2.11. 存在重复元素</a></li><li><a href="#212-存在重复元素-ii">2.12. 存在重复元素 II</a></li><li><a href="#213-存在重复元素-iii">2.13. 存在重复元素 III</a></li><li><a href="#214-跳跃游戏">2.14. 跳跃游戏</a></li></ul></li></ul><!-- /TOC --><h1><span id="1-双指针">1. 双指针</span></h1><h2><span id="11-删除排序数组中的重复项">1.1. 删除排序数组中的重复项</span></h2><p>给定一个<strong>排序数组</strong>，你需要在 原地 删除重复出现的元素，使得每个元素只出现一次，返回移除后数组的新长度。</p><p>不要使用额外的数组空间，你必须在 原地 修改输入数组 并在使用 <strong>O(1) 额外空间</strong>的条件下完成。</p><p><strong>【我的解法】</strong><br>用一个变量<code>i_first</code>表示待验证是否重复的值，因为该数据已经排好序，所以已经验证不重复的元素后面不会再次出现。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">removeDuplicates</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        delete_num = <span class="number">0</span></span><br><span class="line">        len_nums = len(nums)</span><br><span class="line">        i_first = <span class="keyword">None</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len_nums):</span><br><span class="line">            i-=delete_num</span><br><span class="line">            <span class="keyword">if</span> i == <span class="number">0</span>: </span><br><span class="line">                i_first = nums[i]</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">if</span> nums[i] == i_first:</span><br><span class="line">                nums.pop(i)</span><br><span class="line">                delete_num += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                i_first = nums[i]</span><br><span class="line">        <span class="keyword">return</span> len(nums)</span><br></pre></td></tr></table></figure><p><strong>【改进1】</strong><br>如果数组长度为1，可以直接返回。其余情况使用快慢双指针，快指针用来遍历数据，注意快指针从下标1开始遍历，慢指针指向非重复的值，如果快指针和慢指针不相等，快指针后移，如果相等，将快指针的值拷贝到慢指针+1的位置</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">removeDuplicates</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> len(nums) == <span class="number">1</span>:<span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        slow = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> fast <span class="keyword">in</span> range(<span class="number">1</span>,len(nums)):</span><br><span class="line">            <span class="keyword">if</span> nums[fast] != nums[slow]:</span><br><span class="line">                slow+=<span class="number">1</span></span><br><span class="line">                nums[slow] = nums[fast]</span><br><span class="line">        <span class="keyword">return</span> slow+<span class="number">1</span></span><br></pre></td></tr></table></figure><h2><span id="12-移除元素">1.2. 移除元素</span></h2><p>给你一个数组 nums 和一个值 val，你需要 原地 移除所有数值等于 val 的元素，并返回移除后数组的新长度。</p><p>不要使用额外的数组空间，你必须仅使用 <strong>O(1) 额外空间</strong>并 原地 修改输入数组。</p><p><strong>元素的顺序可以改变</strong>。你不需要考虑数组中超出新长度后面的元素。</p><p><strong>【我的解法】</strong>:<br>使用remove函数从原始数组中删除元素，但是每调用一次remove函数，数组的中元素会向前移，时间复杂度大</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">removeElement</span><span class="params">(self, nums, val)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :type val: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        delete_count = <span class="number">0</span></span><br><span class="line">        nums_len = len(nums)</span><br><span class="line">        <span class="keyword">for</span> idx <span class="keyword">in</span> range(nums_len):</span><br><span class="line">            idx -= delete_count</span><br><span class="line">            <span class="keyword">if</span> nums[idx] == val:</span><br><span class="line">                nums.remove(nums[idx])</span><br><span class="line">                delete_count +=<span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> len(nums)</span><br></pre></td></tr></table></figure><p><strong>【改进1】</strong>：<br>使用快慢双指针，拷贝覆盖，快指针依次遍历nums数组，慢指针指向不等于val的元素，如果fast的元素不等于val，则拷贝到nums[slow]位置，否则fast++</p><ul><li>这种思路在移除元素较多时更适合使用，最极端的情况是全部元素都需要移除，遍历一遍结束即可</li><li>时间复杂度：O(n)，空间复杂度：O(1)</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">removeElement</span><span class="params">(self, nums, val)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :type val: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        slow = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> fast <span class="keyword">in</span> range(len(nums)):</span><br><span class="line">            <span class="keyword">if</span> nums[fast] != val:</span><br><span class="line">                nums[slow] = nums[fast]</span><br><span class="line">                slow +=<span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> slow</span><br></pre></td></tr></table></figure><h2><span id="13-删除排序数组中的重复项-ii">1.3. 删除排序数组中的重复项 II</span></h2><p>给定一个排序数组，你需要在原地删除重复出现的元素，使得每个元素最多出现两次，返回移除后数组的新长度。</p><p>不要使用额外的数组空间，你必须在原地修改输入数组并在使用 O(1) 额外空间的条件下完成。</p><p><strong>【我的解法】</strong></p><p>经过上面2道题，本题也使用快慢双指针。fast用来遍历数组，slow用来表示当前需要验证的值，如果fast=slow，则slow的count+1，如果不相等，则更新slow并将fast的值拷贝到slow中。但是这种方案总是在一些边界时出现问题，例如[1,1,1,2,2,3,3]其中后两个值相等，但是在处理最后一个3时，if条件判断fast和slow相等，count+1，然后就直接return，这样输出的结果将是[1,1,2,2,3],为了解决这个问题，加了对边界条件的处理，如下，但是这样[1,1,1]会出错，返回[1]，调了很久都没有想出来怎么满足所有的条件。。。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">removeDuplicates</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        slow,count = <span class="number">0</span>,<span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> fast <span class="keyword">in</span> range(<span class="number">1</span>,len(nums)):</span><br><span class="line">            <span class="keyword">if</span> nums[fast] == nums[slow]:</span><br><span class="line">                count+=<span class="number">1</span></span><br><span class="line">                <span class="comment">#处理边界</span></span><br><span class="line">                <span class="keyword">if</span> fast == len(nums) - <span class="number">1</span> <span class="keyword">and</span> count ==<span class="number">2</span>:</span><br><span class="line">                    slow += <span class="number">1</span></span><br><span class="line">                    nums[slow] = nums[fast]</span><br><span class="line">                    count = <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                slow += <span class="number">2</span> <span class="keyword">if</span> count&gt;<span class="number">2</span> <span class="keyword">else</span> count</span><br><span class="line">                nums[slow] = nums[fast]</span><br><span class="line">                count = <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> slow+<span class="number">1</span></span><br></pre></td></tr></table></figure><p><strong>【改进1】</strong><br>思路：</p><ul><li>快指针：遍历整个数组；</li><li>慢指针：记录可以覆写数据的位置；</li><li>题目中规定每个元素最多出现两次，因此，应检查快指针指向的元素和慢指针前一个元素是否相等。相等只更新快指针；不相等时，先将慢指针后移一位，再将快指针指向的元素覆写入慢指针指向的单元，最后更新快指针。</li></ul><p>边界：</p><ul><li>当数组的长度小于等于 2 时，不需要操作，直接返回原数组即可。</li></ul><p>初始化：</p><ul><li>快指针用于遍历数组，但算法不可能操作序号小于 2 的元素，因此快指针初始值为 2；</li><li>初始状态下，慢指针应紧随快指针之后，因此初始值为 1；</li></ul><p>结束条件：</p><ul><li>快指针达到数组结尾。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">removeDuplicates</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> len(nums) == <span class="number">2</span>:<span class="keyword">return</span> <span class="number">2</span></span><br><span class="line">        slow = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> fast <span class="keyword">in</span> range(<span class="number">2</span>,len(nums)):</span><br><span class="line">            <span class="keyword">if</span> nums[fast] != nums[slow<span class="number">-1</span>]:</span><br><span class="line">                slow+=<span class="number">1</span></span><br><span class="line">                nums[slow] = nums[fast]</span><br><span class="line">        <span class="keyword">return</span> slow+<span class="number">1</span></span><br></pre></td></tr></table></figure><p><strong>【改进2】</strong></p><ul><li>使用count来记录每一个元素出现的次数，初始值为1</li><li>当fast和slow相等时，说明fast出现了多次，count+1，否则说明fast是新出现的，count重置为1</li><li>如果count小于等于2，满足条件，slow+1,把fast的值拷贝到slow中，如果 count大于2，fast的值舍弃，不要拷贝到slow中</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">removeDuplicates</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> len(nums) == <span class="number">2</span>:<span class="keyword">return</span> <span class="number">2</span></span><br><span class="line">        slow,count = <span class="number">0</span>,<span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> fast <span class="keyword">in</span> range(<span class="number">1</span>,len(nums)):</span><br><span class="line">            <span class="keyword">if</span> nums[fast] == nums[slow]:</span><br><span class="line">                count+=<span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                count = <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> count &lt;= <span class="number">2</span>:</span><br><span class="line">                slow += <span class="number">1</span></span><br><span class="line">                nums[slow] = nums[fast]</span><br><span class="line">        <span class="keyword">return</span> slow+<span class="number">1</span></span><br></pre></td></tr></table></figure><h2><span id="14-缺失的第一个正数">1.4. 缺失的第一个正数</span></h2><p>给定一个未排序的整数数组，找出其中没有出现的最小的正整数。<br><strong>【我的解法】</strong><br>首先找到nums中的最大值和最小值，然后遍历min和max之间的所有数，判断是否在数组中。但是这样会出现内存溢出的问题</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">firstMissingPositive</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> len(nums) == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        <span class="comment">#先遍历数组找max和min</span></span><br><span class="line">        nums_min,nums_max = min(nums),max(nums)</span><br><span class="line">        <span class="keyword">if</span> nums_max &lt; <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        <span class="keyword">elif</span> nums_min &lt; <span class="number">0</span>:</span><br><span class="line">            nums_min = <span class="number">1</span></span><br><span class="line">        <span class="keyword">elif</span> nums_min &gt; <span class="number">0</span> <span class="keyword">and</span> nums_min != <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span> </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(nums_min,nums_max):</span><br><span class="line">            <span class="keyword">if</span> i <span class="keyword">not</span> <span class="keyword">in</span> nums:</span><br><span class="line">                <span class="keyword">return</span> i</span><br><span class="line">        <span class="keyword">return</span> nums_max+<span class="number">1</span></span><br></pre></td></tr></table></figure><p><strong>【改进1】</strong><br>使用快慢指针。</p><ul><li>先对nums排序</li><li>对特征情况处理：nums为空或最小值大于1，返回1</li><li>快指针遍历数组，慢指针表示最小的正整数，初始化为1</li><li>遍历数组，如果fast小于等于0，继续；如果fast和slow相等，说明slow在数组中，slow加1。遍历完之后返回slow，即最小的正整数。</li><li>不能在for循环的else中返回slow，如果list中有重复元素会报错，例如[0,1,1,2,2]</li><li>为了解决nums中有重复元素问题，使用set(sorted(nums))，但是这样也报错，因为set会让原先已经排好序的数组又变得乱序，改成sorted(set(nums))就可以了</li><li>但是排序的时间复杂度不符合题目要求</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">firstMissingPositive</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        nums = sorted(nums)</span><br><span class="line">        <span class="keyword">if</span> len(nums) ==<span class="number">0</span> <span class="keyword">or</span> nums[<span class="number">0</span>] &gt; <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        slow = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> fast <span class="keyword">in</span> nums:</span><br><span class="line">            <span class="keyword">if</span> fast &lt;= <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">if</span> fast == slow:</span><br><span class="line">                slow+=<span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> slow</span><br></pre></td></tr></table></figure><p><strong>【改进2】</strong><br>要返回丢失的最小正整数，该正整数一定在[1,n+1]之间。题目要求常数空间，所以将原始数组当做哈希表使用。</p><ul><li>最终返回的数在[1,n+1]之间，当[1,n]都在数组中，才会返回n+1</li><li>对[1,n]之间的数重新找位置。<br>数字1放在下标为0的位置<br>数字2放在下标为1的位置<br>…<br>数字n放在下标为n-1的位置<br>如果遇到的数不在[1,n]之间，不用换位置</li><li>在遍历一次数组，遇到第一个数字不等于下标+1的值，就是丢失的正整数，返回即可。如果遍历完整个数组，都没有return，说明[1,n]的所有数都在数组中，返回n+1</li><li>空间复杂度$O(1)$</li><li>时间复杂度$O(n)$</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">firstMissingPositive</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        n = len(nums)<span class="comment">#一共有n个数</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">            <span class="keyword">while</span> (nums[i] &gt;= <span class="number">1</span> <span class="keyword">and</span> nums[i] &lt;= n <span class="keyword">and</span> nums[i] != nums[nums[i] - <span class="number">1</span>]):</span><br><span class="line">                self.swap(nums,i,nums[i]<span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">            <span class="keyword">if</span> nums[i] != i + <span class="number">1</span>:</span><br><span class="line">                <span class="keyword">return</span> i+<span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> n+<span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">swap</span><span class="params">(self,nums,src,des)</span>:</span></span><br><span class="line">        temp = nums[des]</span><br><span class="line">        nums[des] = nums[src]</span><br><span class="line">        nums[src] = temp</span><br></pre></td></tr></table></figure><h1><span id="2-其他">2. 其他</span></h1><h2><span id="21-find-the-celebrity">2.1. Find the Celebrity</span></h2><p>在n个人中寻找名人，所谓名人就是每个人都认识他，他却不认识任何人，限定了只有1个或0个名人，给定了一个 API 函数，输入a和b，<code>bool know(a,b)</code>用来判断a是否认识b，让我们尽可能少的调用这个函数，来找出人群中的名人,能找到名人返回名人的下标，否则返回-1</p><p><strong>【解法1】</strong><br>遍历所有的人，判断i是否是名人，就要看i是否满足名人的条件，如果剩下的n-1个人中有i认识的人，或者有人不认识i，则i不是名人，使用break跳出内循环，继续遍历下一个i。如果剩下的n-1个人中i都不认识并且n-1个人都认识i，则返回i，否则返回-1。找出一种解法最可能少的调用<code>know</code>函数<br>时间复杂度$O(n^2)$</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">findCelebrity</span><span class="params">(n)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(n):</span><br><span class="line">            <span class="keyword">if</span>(i!=j <span class="keyword">and</span> (know(i,j) <span class="keyword">or</span> <span class="keyword">not</span> know(j,i))):</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">if</span>(j==n):</span><br><span class="line">            <span class="keyword">return</span> i</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span></span><br></pre></td></tr></table></figure><p><strong>【解法2】</strong><br>先找出名人的candidate，然后再验证这个candidate是否合理。</p><ul><li>第一步：找candidate,先初始化candidate为0，然后遍历所有人，如果candidate认识i，则candidate不符合，将candidate换成i。遍历完所有的人，最终选出一个candidate，这个candidate不认识它后面所有的人</li><li>第二步：验证candidate。先验证candicate前面的人，如果前面的人中不认识candicate，或candicate认识某人，则candicate不是名人，返回-1。再验证candidate后面的人，因为在选择candidate时已经知道candidate不认识后面的人，所以这里只需要验证后面的人是否认识candidate就可以了</li><li>时间复杂度$O(n)$</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">findCelebrity</span><span class="params">(n)</span>:</span></span><br><span class="line">    candidate = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">        <span class="keyword">if</span>(i != candicate <span class="keyword">and</span> know(candidate,i)):</span><br><span class="line">            candicate = i</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(candicate):</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">not</span> know(i,candidate) <span class="keyword">or</span> know(candidate,i)):</span><br><span class="line">            retur</span><br><span class="line">            n <span class="number">-1</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(candicate+<span class="number">1</span>,n):</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">not</span> know(i,candidate)):</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">    <span class="keyword">return</span> candidate</span><br></pre></td></tr></table></figure><h2><span id="22-旋转数组">2.2. 旋转数组</span></h2><p>给定一个数组，将数组中的元素向右移动 k 个位置，其中 k 是非负数。</p><p><strong>【我的解法】</strong><br>当时使用找规律的方法，旋转k步，原先下标为i的元素，旋转之后下标变成多少，然后赋值。但是有个问题赋值完后数组原先的值就丢失了，所以一直在纠结这个问题，下面的解法没有实现</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">rotate</span><span class="params">(self, nums, k)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :type k: int</span></span><br><span class="line"><span class="string">        :rtype: None Do not return anything, modify nums in-place instead.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        n = len(nums)</span><br><span class="line">        k = k % n</span><br><span class="line">        nums_0 = nums[<span class="number">0</span>] <span class="comment">#将来放在(0+k)%n的位置</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>,k):</span><br><span class="line">            <span class="keyword">if</span> i == <span class="number">0</span>:</span><br><span class="line">                nums[i] = nums[(n+i-k)%n]</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                tmp = nums[i]</span><br><span class="line">                nums[i] = nums[(n+i-k)%n]</span><br><span class="line">                nums[(n+i-k)%k] = tmp</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(k+<span class="number">1</span>,n):</span><br><span class="line">            nums[i] = 。。。</span><br><span class="line">        nums[k] = nums_0</span><br><span class="line">        <span class="keyword">return</span> nums</span><br></pre></td></tr></table></figure><p><strong>【改进1】</strong><br>利用python中数组的特性，pop()每次弹出最后一个元素，然后使用insert将其插入到开头</p><ul><li>空间复杂度：$O(1)$</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">rotate</span><span class="params">(self, nums, k)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :type k: int</span></span><br><span class="line"><span class="string">        :rtype: None Do not return anything, modify nums in-place instead.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        k %= len(nums)</span><br><span class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> range(k):</span><br><span class="line">            nums.insert(<span class="number">0</span>,nums.pop())</span><br><span class="line">        <span class="keyword">return</span> nums</span><br></pre></td></tr></table></figure><p><strong>【改进2】</strong><br>例如<code>1,2,3,4,5,6,7</code>，当k=3时，旋转后的数组为<code>5,6,7,1,2,3,4</code>，就是将原先数据中[-k:]的元素前移，将[:-k]的元素后移</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">rotate</span><span class="params">(self, nums, k)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :type k: int</span></span><br><span class="line"><span class="string">        :rtype: None Do not return anything, modify nums in-place instead.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        k %= len(nums)</span><br><span class="line">        nums[:] = nums[-k:]+nums[:-k]</span><br><span class="line">        <span class="keyword">return</span> nums</span><br></pre></td></tr></table></figure><p>【优秀题解3】<br>使用3次翻转，先翻转所有数据，再翻转前k个，再翻转后n-k个。</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">k = <span class="number">3</span></span><br><span class="line">原始数据：<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span></span><br><span class="line">翻转全部：<span class="number">7</span>,<span class="number">6</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span></span><br><span class="line">翻转前k个：<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span></span><br><span class="line">翻转后n-k个：<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">rotate</span><span class="params">(self, nums, k)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :type k: int</span></span><br><span class="line"><span class="string">        :rtype: None Do not return anything, modify nums in-place instead.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        k %= len(nums)</span><br><span class="line">        nums[:] = nums[-k:]+nums[:-k]</span><br><span class="line">        <span class="keyword">return</span> nums</span><br></pre></td></tr></table></figure><p>【总结】以上3种解法都是利用Python的特征，非常简单！人生苦短，我用Python！</p><h2><span id="23-猜数字游戏">2.3. 猜数字游戏</span></h2><p>你正在和你的朋友玩 猜数字（Bulls and Cows）游戏：你写下一个数字让你的朋友猜。每次他猜测后，你给他一个提示，告诉他有多少位数字和确切位置都猜对了（称为“Bulls”, 公牛），有多少位数字猜对了但是位置不对（称为“Cows”, 奶牛）。你的朋友将会根据提示继续猜，直到猜出秘密数字。</p><p>请写出一个根据秘密数字和朋友的猜测数返回提示的函数，用 A 表示公牛，用 B 表示奶牛。</p><p>请注意秘密数字和朋友的猜测数都可能含有重复数字。</p><blockquote><p>输入: secret = “1807”, guess = “7810”<br>输出: “1A3B”<br>解释: 1 公牛和 3 奶牛。公牛是 8，奶牛是 0, 1 和 7。</p></blockquote><p><strong>【我的解法】</strong><br>首先找出A的个数，然后找出B的个数。</p><ul><li>先找到A的个数，并记录这些数字的下标</li><li>除去A的数字，记录剩下的secret中每个数字及下标。</li><li>找B的个数。遍历guess中的数字，如果该数字在secret中，并且该数字验证的个数小于secret中该数字的个数，B的个数加一</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getHint</span><span class="params">(self, secret, guess)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type secret: str</span></span><br><span class="line"><span class="string">        :type guess: str</span></span><br><span class="line"><span class="string">        :rtype: str</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="comment">#先找到A</span></span><br><span class="line">        A = <span class="number">0</span></span><br><span class="line">        A_index = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(secr  et)):</span><br><span class="line">            <span class="keyword">if</span> secret[i] == guess[i]:</span><br><span class="line">                A +=<span class="number">1</span></span><br><span class="line">                A_index.append(i)</span><br><span class="line">        <span class="comment">#记录secret中剩下的数字及下标</span></span><br><span class="line">        other_index = [i <span class="keyword">for</span> i <span class="keyword">in</span> list(range(len(secret))) <span class="keyword">if</span> i <span class="keyword">not</span> <span class="keyword">in</span> A_index]</span><br><span class="line">        secret_dict = &#123;&#125;</span><br><span class="line">        secret_verify = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> other_index:</span><br><span class="line">            <span class="keyword">if</span> secret[i] <span class="keyword">not</span> <span class="keyword">in</span> secret_dict:</span><br><span class="line">                secret_dict[secret[i]] = [i]</span><br><span class="line">                secret_verify[secret[i]] = <span class="number">0</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                secret_dict[secret[i]].append(i)</span><br><span class="line">        <span class="comment">#找B的个数</span></span><br><span class="line">        B = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> other_index:</span><br><span class="line">            current = guess[i]</span><br><span class="line">            <span class="keyword">if</span> (current <span class="keyword">in</span> secret_dict) <span class="keyword">and</span> secret_verify[current] &lt; len(secret_dict[current]):</span><br><span class="line">                B += <span class="number">1</span></span><br><span class="line">                secret_verify[current] += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> str(A)+<span class="string">'A'</span>+str(B)+<span class="string">'B'</span></span><br></pre></td></tr></table></figure><h2><span id="24-加油站">2.4. 加油站</span></h2><p>在一条环路上有 N 个加油站，其中第 i 个加油站有汽油 gas[i] 升。</p><p>你有一辆油箱容量无限的的汽车，从第 i 个加油站开往第 i+1 个加油站需要消耗汽油 cost[i] 升。你从其中的一个加油站出发，开始时油箱为空。</p><p>如果你可以绕环路行驶一周，则返回出发时加油站的编号，否则返回 -1。</p><p>说明: </p><p>如果题目有解，该答案即为唯一答案。<br>输入数组均为非空数组，且长度相同。<br>输入数组中的元素均为非负数。</p><p><strong>【我的解法】</strong><br>暴力搜索</p><ul><li>先找出能够作为起始点的加油站，作为候选集。即gas[i] &gt;= cost[i]，从当前加油站出发能够走到下一个加油站</li><li><p>遍历所有的候选集。对于某一个候选加油站。终止的条件是：</p><ul><li>if cur_idx != start的前一个加油站，cur_gas-cost[cur_idx]+gas[next_idx] &lt; cost[next_idx]，即当前加油站出发走到下一个加油站加上油，不够走到下下一个加油站。则当前候选加油站失效，遍历下一个候选集</li><li>if cur_idx == start的前一个加油站，cur_gas &lt; cost[cur_idx],当前的油不够走到下一个加油站。则当前候选加油站失效，遍历下一个候选集</li></ul></li><li>空间复杂度$O(1)$</li><li>时间复杂度$O(N^2)$</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">canCompleteCircuit</span><span class="params">(self, gas, cost)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type gas: List[int]</span></span><br><span class="line"><span class="string">        :type cost: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        n = len(gas)</span><br><span class="line">        candidate = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">            <span class="keyword">if</span> gas[i] &gt;= cost[i]:</span><br><span class="line">                candidate.append(i)</span><br><span class="line">        <span class="keyword">for</span> start <span class="keyword">in</span> candidate:</span><br><span class="line">            cur_index = start</span><br><span class="line">            cur_gas = gas[cur_index]</span><br><span class="line">            next_index = (cur_index+<span class="number">1</span>)%n</span><br><span class="line">            tmp = n<span class="number">-1</span> <span class="keyword">if</span> start==<span class="number">0</span> <span class="keyword">else</span> start<span class="number">-1</span></span><br><span class="line">            <span class="keyword">while</span> cur_index != tmp:</span><br><span class="line">                <span class="keyword">if</span> cur_gas - cost[cur_index] + gas[next_index] &gt;= cost[next_index]:</span><br><span class="line">                    cur_gas = cur_gas - cost[cur_index] + gas[next_index]</span><br><span class="line">                    cur_index = next_index</span><br><span class="line">                    next_index = (cur_index+<span class="number">1</span>)%n</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">if</span> cur_index == tmp <span class="keyword">and</span> cur_gas &gt;= cost[cur_index]:</span><br><span class="line">                <span class="keyword">return</span> start</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span></span><br></pre></td></tr></table></figure><p>【改进1】</p><ul><li>时间复杂度$O(N)$</li><li>空间复杂度$O(1)$<br>这个题解还没有看懂，以后再看</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">canCompleteCircuit</span><span class="params">(self, gas, cost)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type gas: List[int]</span></span><br><span class="line"><span class="string">        :type cost: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        cur_gas = <span class="number">0</span><span class="comment">#当前剩余油量</span></span><br><span class="line">        delta_gas = <span class="number">0</span><span class="comment">#整个过程中油量和消耗的delta</span></span><br><span class="line">        start = <span class="number">0</span><span class="comment">#起始位置</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(gas)):</span><br><span class="line">            cur_gas += gas[i] - cost[i]</span><br><span class="line">            delta_gas += gas[i] - cost[i]</span><br><span class="line">            <span class="keyword">if</span> cur_gas &lt; <span class="number">0</span>:</span><br><span class="line">                <span class="comment">#当前i不满足时，start为什么跳到i+1，而不是start+1?</span></span><br><span class="line">                start = i+<span class="number">1</span></span><br><span class="line">                cur_gas = <span class="number">0</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span> <span class="keyword">if</span> delta_gas &lt; <span class="number">0</span> <span class="keyword">else</span> start</span><br></pre></td></tr></table></figure><h2><span id="25-多数元素">2.5. 多数元素</span></h2><p>给定一个大小为 n 的数组，找到其中的多数元素。多数元素是指在数组中出现次数大于 ⌊ n/2 ⌋ 的元素。</p><p>你可以假设数组是非空的，并且给定的数组总是存在多数元素。</p><p><strong>【我的解法】</strong><br>使用字典保存每个数字出现的个数，然后按照出现排序，找到出现次数最多的key</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">majorityElement</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        count = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> nums:</span><br><span class="line">            <span class="keyword">if</span> i <span class="keyword">not</span> <span class="keyword">in</span> count:</span><br><span class="line">                count[i] = <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                count[i]+=<span class="number">1</span></span><br><span class="line">        count = sorted(count.items(),key=<span class="keyword">lambda</span> x:x[<span class="number">1</span>],reverse=<span class="keyword">True</span>)</span><br><span class="line">        <span class="keyword">return</span> count[<span class="number">0</span>][<span class="number">0</span>]</span><br></pre></td></tr></table></figure><p><strong>【改进1】</strong><br>摩尔投票法的详细步骤：</p><ul><li>我们维护一个候选众数 major 和它出现的次数 count。初始时 major 可以为任意值，count 为 0；</li><li><p>遍历数组 nums 中的所有元素，对于每个元素 x，在判断 x 之前，如果 count 的值为 0，我们先将 x 的值赋予major，随后我们判断 x：</p><ul><li>如果 x 与 major 相等，那么计数器 count 的值增加 1；</li><li>如果 x 与 major 不等，那么计数器 count 的值减少 1。</li></ul></li><li><p>在遍历完成后，major 即为整个数组的众数。</p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">majorityElement</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="comment">#摩尔投票法</span></span><br><span class="line">        major = <span class="number">0</span></span><br><span class="line">        count = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> nums:</span><br><span class="line">            <span class="keyword">if</span> count == <span class="number">0</span>:</span><br><span class="line">                major = i</span><br><span class="line">            <span class="keyword">if</span> i == major:</span><br><span class="line">                count += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                count -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> major</span><br></pre></td></tr></table></figure><h2><span id="26-求众数-ii">2.6. 求众数 II</span></h2><p>给定一个大小为 n 的数组，找出其中所有出现超过 ⌊ n/3 ⌋ 次的元素。</p><p>说明: 要求算法的时间复杂度为 O(n)，空间复杂度为 O(1)。</p><p>同样使用摩尔投票法，参考<br><a href="https://leetcode-cn.com/problems/majority-element-ii/solution/liang-fu-dong-hua-yan-shi-mo-er-tou-piao-fa-zui-zh/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/majority-element-ii/solution/liang-fu-dong-hua-yan-shi-mo-er-tou-piao-fa-zui-zh/</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">majorityElement</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: List[int]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        cand1,count1 = <span class="number">0</span>,<span class="number">0</span></span><br><span class="line">        cand2,count2 = <span class="number">0</span>,<span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> nums:</span><br><span class="line">            <span class="keyword">if</span> i == cand1:</span><br><span class="line">                count1 +=<span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> i == cand2:</span><br><span class="line">                count2 += <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> count1 == <span class="number">0</span>:</span><br><span class="line">                cand1 = i</span><br><span class="line">                count1 +=<span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> count2 == <span class="number">0</span>:</span><br><span class="line">                cand2 = i</span><br><span class="line">                count2 += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                count1 -= <span class="number">1</span></span><br><span class="line">                count2 -= <span class="number">1</span></span><br><span class="line">        count1,count2 = <span class="number">0</span>,<span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> nums:</span><br><span class="line">            <span class="keyword">if</span> i == cand1:</span><br><span class="line">                count1 += <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> i == cand2:</span><br><span class="line">                count2 += <span class="number">1</span></span><br><span class="line">        result = []</span><br><span class="line">        <span class="keyword">if</span> count1 &gt; int(len(nums)/<span class="number">3</span>):</span><br><span class="line">            result.append(cand1)</span><br><span class="line">        <span class="keyword">if</span> count2 &gt; int(len(nums)/<span class="number">3</span>):</span><br><span class="line">            result.append(cand2)</span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure><h2><span id="27-h指数">2.7. H指数</span></h2><p>给定一位研究者论文被引用次数的数组（被引用次数是非负整数）。编写一个方法，计算出研究者的 h 指数。</p><p>h 指数的定义: “h 代表“高引用次数”（high citations），一名科研人员的 h 指数是指他（她）的 （N 篇论文中）有 h 篇论文分别被引用了至少 h 次。（其余的 N - h 篇论文每篇被引用次数不多于 h 次。）”</p><p><strong>【题解】</strong><br>先将数组从大到小排序，使用直方图表示，直方图上最大正方形的变长h就是最终的答案。<code>citations[i]&gt;i</code></p><ul><li>时间复杂度:$nlog(n)$，排序的下限</li></ul><p><a href="https://leetcode-cn.com/problems/h-index/solution/hzhi-shu-by-leetcode/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/h-index/solution/hzhi-shu-by-leetcode/</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hIndex</span><span class="params">(self, citations)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type citations: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> len(citations) == <span class="number">0</span> <span class="keyword">or</span> (len(citations)==<span class="number">1</span> <span class="keyword">and</span> citations[<span class="number">0</span>]==<span class="number">0</span>):</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> len(citations) == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        citations = sorted(citations,reverse=<span class="keyword">True</span>)</span><br><span class="line">        j = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(citations)):</span><br><span class="line">            <span class="keyword">if</span> citations[i] &gt; j:</span><br><span class="line">                j+=<span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> j</span><br></pre></td></tr></table></figure><h2><span id="28-最短单词距离">2.8. 最短单词距离</span></h2><p>Given a list of words and two words word1 and word2, return the shortest distance between these two words in the list.</p><p>Example:<br>Assume that words = [“practice”, “makes”, “perfect”, “coding”, “makes”].</p><p>Input: word1 = “coding”, word2 = “practice”<br>Output: 3<br>Input: word1 = “makes”, word2 = “coding”<br>Output: 1<br>Note:<br>You may assume that word1 does not equal to word2, and word1 and word2 are both in the list.<br>2个词不相同，并且都在list中</p><p><strong>【我的解法】</strong><br>首先遍历words数据，分别记录word1和word2的位置，然后遍历这些位置数组，找出最短的距离</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">shortestDistance</span><span class="params">(words,word1,word2)</span>:</span></span><br><span class="line">    idx1,idx2 = [],[]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(words)):</span><br><span class="line">        <span class="keyword">if</span> words[i] == word1:</span><br><span class="line">            idx1.append(i)</span><br><span class="line">        <span class="keyword">if</span> words[i] == word2:</span><br><span class="line">            idx2.append(i)</span><br><span class="line">    result = float(<span class="string">"inf"</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> idx1:</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> idx2:</span><br><span class="line">            result = min(result,abs(i-j))</span><br><span class="line">    <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure><p><strong>【改进1】</strong><br>不再使用数组来保存2个词的位置，只遍历一遍数组。用2个变量idx1和idx2来记录word1和word2的位置。如果idx1和idx2都不为-1时，更新result</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">shortestDistance</span><span class="params">(words,word1,word2)</span>:</span></span><br><span class="line">    idx1,idx2 = <span class="number">-1</span>,<span class="number">-1</span></span><br><span class="line">    result = float(<span class="string">"inf"</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(words)):</span><br><span class="line">        <span class="keyword">if</span> words[i] == word1:</span><br><span class="line">            idx1 = i</span><br><span class="line">        <span class="keyword">if</span> words[i] == word2:</span><br><span class="line">            idx2 = i</span><br><span class="line">        <span class="keyword">if</span> idx1 != <span class="number">-1</span> <span class="keyword">and</span> idx2 != <span class="number">-1</span>:</span><br><span class="line">            result = min(result,abs(idx1-idx2))</span><br><span class="line">    <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure><h2><span id="29-最短单词距离-ii">2.9. 最短单词距离 II</span></h2><p>This is a follow up of Shortest Word Distance. The only difference is now you are given the list of words and your method will be called repeatedly many times with different parameters. How would you optimize it?</p><p>Design a class which receives a list of words in the constructor, and implements a method that takes two words word1 and word2 and return the shortest distance between these two words in the list.</p><p>For example,<br>Assume that words = [“practice”, “makes”, “perfect”, “coding”, “makes”].</p><p>Given word1 = “coding”, word2 = “practice”, return 3.<br>Given word1 = “makes”, word2 = “coding”, return 1.</p><p>Note:<br>You may assume that word1 does not equal to word2, and word1 and word2 are both in the list.<br>这道题和上一道的区别：给定一个words列表，求最短距离函数会被调用很多次，算是对上一题的优化</p><p><strong>【解法1】</strong><br>因为最短距离函数会被调用很多次，所以我们可以提前讲words中每个单词的位置记录在dict中，在计算距离时，取出这2个单词的位置计算最短距离。</p><ul><li>时间复杂度：$O(M*N)$，其中M和N是2个单词的个数</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WordDistance</span><span class="params">(object)</span>:</span></span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, words)</span>:</span></span><br><span class="line">        <span class="keyword">from</span> collections <span class="keyword">import</span> defaultdict</span><br><span class="line">        self.words = words</span><br><span class="line">        self.dict= defaultdict(list)</span><br><span class="line">        <span class="keyword">for</span> i, word <span class="keyword">in</span> enumerate(words):</span><br><span class="line">            self.dict[word].append(i)</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">shortest</span><span class="params">(self, word1, word2)</span>:</span></span><br><span class="line">        res = float(<span class="string">'inf'</span>)</span><br><span class="line">        <span class="keyword">for</span> l1 <span class="keyword">in</span> self.dict[word1]:</span><br><span class="line">            <span class="keyword">for</span> l2 <span class="keyword">in</span> self.dict[word2]:</span><br><span class="line">                res = min(res, abs(l1 - l2))</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><p><strong>【解法2】</strong><br>将上述的时间复杂度$O(M*N)$变成$O(M+N)$<br>使用2个指针记录word1和word2的位置，每次让位置较小的指针加1</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WordDistance</span><span class="params">(object)</span>:</span></span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, words)</span>:</span></span><br><span class="line">        <span class="keyword">from</span> collections <span class="keyword">import</span> defaultdict</span><br><span class="line">        self.words = words</span><br><span class="line">        self.dict= defaultdict(list)</span><br><span class="line">        <span class="keyword">for</span> i, word <span class="keyword">in</span> enumerate(words):</span><br><span class="line">            self.dict[word].append(i)</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">shortest</span><span class="params">(self, word1, word2)</span>:</span></span><br><span class="line">        res = float(<span class="string">'inf'</span>)</span><br><span class="line">        p1,p2 = <span class="number">0</span>,<span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> p1 &lt; len(self.dict[word1]) <span class="keyword">and</span> p2 &lt; len(self.dict[word2]):</span><br><span class="line">            result = min(result,abs(self.dict[word1][p1] - self.dict[word2][p2]))</span><br><span class="line">            <span class="keyword">if</span> self.dict[word1][p1] &lt; self.dict[word2][p2]:</span><br><span class="line">                p1 += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                p2 += <span class="number">2</span></span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure><h2><span id="210-最短单词距离之iii">2.10. 最短单词距离之III</span></h2><p>Given a list of words and two words word1 and word2, return the shortest distance between these two words in the list.</p><p>word1 and word2 may be the same and they represent two individual words in the list.</p><p>Example:<br>Assume that words = [“practice”, “makes”, “perfect”, “coding”, “makes”].</p><p>Input: word1 = “makes”, word2 = “coding”<br>Output: 1<br>Input: word1 = “makes”, word2 = “makes”<br>Output: 3<br>Note:<br>You may assume word1 and word2 are both in the list.<br>对第一道题的区别：word1和word2可能相同</p><p><strong>【解法1】</strong><br>word1和word2可能相等，使用pre_idx1记录上一个idx1的位置。接下来分为2种情况，word1和word2相等时，根据pre_idx1和idx1来更新result，不相等时，根据idx1和idx2来更新result</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">shortestDistance</span><span class="params">(words,word1,word2)</span>:</span></span><br><span class="line">    idx1,idx2 = <span class="number">-1</span>,<span class="number">-1</span></span><br><span class="line">    result = float(<span class="string">"inf"</span>)</span><br><span class="line">    pre_idx1 = <span class="number">-1</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(words)):</span><br><span class="line">        <span class="keyword">if</span> words[i] == word1:</span><br><span class="line">            idx1 = i</span><br><span class="line">        <span class="keyword">if</span> words[i] == word2:</span><br><span class="line">            idx2 = i</span><br><span class="line">        <span class="keyword">if</span> idx1 != <span class="number">-1</span> <span class="keyword">and</span> idx2 != <span class="number">-1</span>:</span><br><span class="line">            <span class="keyword">if</span> word1 == word2:</span><br><span class="line">                <span class="keyword">if</span> pre_idx1 == <span class="number">-1</span> <span class="keyword">or</span> pre_idx1 == idx1:</span><br><span class="line">                    pre_idx1 = idx1</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="comment">#如果pre_idx1和idx1不相等，更新result</span></span><br><span class="line">                    result = min(result,abs(pre_idx1-idx1))</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                result = min(result,abs(idx1-idx2))</span><br><span class="line">    <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">shortestDistance</span><span class="params">(words,word1,word2)</span>:</span></span><br><span class="line">    idx1,idx2 = <span class="number">-1</span>,<span class="number">-1</span></span><br><span class="line">    result = float(<span class="string">"inf"</span>)</span><br><span class="line">    <span class="keyword">if</span> word1 != word2:</span><br><span class="line">        <span class="keyword">if</span> words[i] == word1:</span><br><span class="line">            idx1 = i</span><br><span class="line">        <span class="keyword">if</span> words[i] == word2:</span><br><span class="line">            idx2 = i</span><br><span class="line">        <span class="keyword">if</span> idx1 != <span class="number">-1</span> <span class="keyword">and</span> idx2 != <span class="number">-1</span>:</span><br><span class="line">            result = min(result,abs(idx1-idx2))</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        pre_idx1 = <span class="number">-1</span></span><br><span class="line">        <span class="keyword">for</span> i,word <span class="keyword">in</span> enumerate(words):</span><br><span class="line">            <span class="keyword">if</span> word == word1:</span><br><span class="line">                <span class="keyword">if</span> pre_idx1 != <span class="number">-1</span>:</span><br><span class="line">                    result = min(result,abs(i-pre_idx1))</span><br><span class="line">                pre_idx1 = i</span><br><span class="line">    <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure><h2><span id="211-存在重复元素">2.11. 存在重复元素</span></h2><p>给定一个整数数组，判断是否存在重复元素。</p><p>如果任何值在数组中出现至少两次，函数返回 true。如果数组中每个元素都不相同，则返回 false。</p><blockquote><p>示例 1:<br>输入: [1,2,3,1]<br>输出: true</p></blockquote><p>【我的解法】<br>使用字典</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">containsDuplicate</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        counts = dict()</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> nums:</span><br><span class="line">            <span class="keyword">if</span> i <span class="keyword">not</span> <span class="keyword">in</span> counts:</span><br><span class="line">                counts[i] = <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">False</span></span><br></pre></td></tr></table></figure><h2><span id="212-存在重复元素-ii">2.12. 存在重复元素 II</span></h2><p>给定一个整数数组和一个整数 k，判断数组中是否存在两个不同的索引 i 和 j，使得 nums [i] = nums [j]，并且 i 和 j 的差的 绝对值 至多为 k。</p><blockquote><p>示例 1:<br>输入: nums = [1,2,3,1], k = 3<br>输出: true</p></blockquote><p><strong>【我的解法】</strong><br>首先找到重复的元素，然后再遍历重复元素的下标，其差值是否&lt;=k，时间复杂度高</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">containsNearbyDuplicate</span><span class="params">(self, nums, k)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :type k: int</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="comment">#首先找出重复的元素</span></span><br><span class="line">        counts = collections.defaultdict(list)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums)):</span><br><span class="line">            counts[nums[i]].append(i)</span><br><span class="line">        <span class="keyword">for</span> value <span class="keyword">in</span> list(counts.values()):</span><br><span class="line">            <span class="keyword">if</span> len(value) &gt;= <span class="number">2</span>:</span><br><span class="line">                <span class="comment">#找出下标差最大的值</span></span><br><span class="line">                <span class="keyword">for</span> i <span class="keyword">in</span> range(len(value)):</span><br><span class="line">                    <span class="keyword">for</span> j <span class="keyword">in</span> range(len(value)):</span><br><span class="line">                        <span class="keyword">if</span> i!=j <span class="keyword">and</span> abs(value[i]-value[j]) &lt;= k:</span><br><span class="line">                            <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">False</span></span><br></pre></td></tr></table></figure><p><strong>【改进1】</strong><br>使用集合，集合的长度始终是k，如果集合中的k个元素存在相同元素，则说明这2个元素的距离&lt;=k,返回True。如果集合中没有当前元素，将其加入到set中，判断set中长度是否&gt;k,如果超过k，则将set中的第一个元素删掉。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">containsNearbyDuplicate</span><span class="params">(self, nums, k)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :type k: int</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="comment">#使用一个长度为k的set</span></span><br><span class="line">        k_set = set()</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums)):</span><br><span class="line">            <span class="keyword">if</span> nums[i] <span class="keyword">in</span> k_set:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line"></span><br><span class="line">            k_set.add(nums[i])</span><br><span class="line">            <span class="keyword">if</span> len(k_set) &gt; k:</span><br><span class="line">                k_set.remove(nums[i-k])</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">False</span></span><br></pre></td></tr></table></figure><h2><span id="213-存在重复元素-iii">2.13. 存在重复元素 III</span></h2><p>给定一个整数数组，判断数组中是否有两个不同的索引 i 和 j，使得 nums [i] 和 nums [j] 的差的绝对值最大为 t，并且 i 和 j 之间的差的绝对值最大为 ķ。</p><blockquote><p>示例 1:<br>输入: nums = [1,2,3,1], k = 3, t = 0<br>输出: true</p></blockquote><p><strong>【题解1】</strong><br>找出2个数，其下标之差&lt;=k,数之差&lt;=t<br>将数据放在桶中，每个桶放t+1个数，假设t=2<br>桶编号-1: [-3,-2,-1]<br>桶编号0：[0,1,2]<br>桶编号1：[3,4,5]<br>桶编号2：[6,7,8]<br>桶编号i：[i<em>(t+1),i</em>(t+1)+1,i*(t+1)+2]<br>首先编写一个分配桶的函数，根据数字i，计算被分配到哪个桶中。<br>dict中最多有k+1个元素，看做滑动窗口，保证元素下标之差&lt;=k。如果i&gt;k，说明当前滑动窗口中已经有k+1个元素了，装不下了，则将第一个元素nums[i-k-1]所在的桶清空，腾出一个位置。<br>dict[key]=value，其中key是桶id，value是nums中的值。</p><ul><li>如果2个元素的桶id一样，说明这2个值之差&lt;=t，返回True</li><li>如果该元素所在的桶没有其他值，那就看和它左右邻近的桶，看差值是否&lt;=t,如果是返回True</li><li>如果自己的桶和邻居桶都没有符合条件，则将该元素放在自己的桶内</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">containsNearbyAlmostDuplicate</span><span class="params">(self, nums, k, t)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :type k: int</span></span><br><span class="line"><span class="string">        :type t: int</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> t &lt; <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">        <span class="comment">#滑动窗口中有k+1个元素</span></span><br><span class="line">        <span class="comment">#每个桶中有t+1个元素</span></span><br><span class="line">        buckets = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums)):</span><br><span class="line">            <span class="keyword">if</span> i &gt; k:</span><br><span class="line">                buckets.pop(self.getBucket(nums[i-k<span class="number">-1</span>],t+<span class="number">1</span>))</span><br><span class="line"></span><br><span class="line">            cur_id = self.getBucket(nums[i],t+<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> cur_id <span class="keyword">in</span> buckets:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">            <span class="keyword">elif</span> cur_id+<span class="number">1</span> <span class="keyword">in</span> buckets <span class="keyword">and</span> abs(buckets[cur_id+<span class="number">1</span>] - nums[i]) &lt;= t:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">            <span class="keyword">elif</span> cur_id<span class="number">-1</span> <span class="keyword">in</span> buckets <span class="keyword">and</span> abs(buckets[cur_id<span class="number">-1</span>] - nums[i]) &lt;= t:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                buckets[cur_id] = nums[i]</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getBucket</span><span class="params">(self,x,w)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        一个桶中有w个数</span></span><br><span class="line"><span class="string">        返回数字x被分配的桶编号</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> x &gt; <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> int(x/w)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> (x+<span class="number">1</span>)/w<span class="number">-1</span></span><br></pre></td></tr></table></figure><h2><span id="214-跳跃游戏">2.14. 跳跃游戏</span></h2><p>给定一个非负整数数组，你最初位于数组的第一个位置。<br>数组中的每个元素代表你在该位置可以跳跃的最大长度。<br>判断你是否能够到达最后一个位置。</p><blockquote><p>示例 1:<br>输入: [2,3,1,1,4]<br>输出: true<br>解释: 我们可以先跳 1 步，从位置 0 到达 位置 1, 然后再从位置 1 跳 3 步到达最后一个位置</p><p>示例 2:<br>输入: [3,2,1,0,4]<br>输出: false<br>解释: 无论怎样，你总会到达索引为 3 的位置。但该位置的最大跳跃长度是 0 ， 所以你永远不可能到达最后一个位置。</p></blockquote><p>【题解1】<br>i表示当前节点，k表示当前节点的前面所有节点能达到的最远节点。<br>例如[3,2,1,0,4]</p><ul><li>k=0，i=0：当前节点i=0，前面能到达的最远节点下标为0</li><li>k=3，i=1：当前节点i=1，前面能到达的最远节点下标为3</li><li>k=3，i=2：当前节点i=2，前面能到达的最远节点下标为3</li><li>k=3，i=3：当前节点i=3，前面能到达的最远节点下标为3</li><li>k=3，i=4：当前节点i=4，前面能到达的最远节点下标为3</li><li>当前节点为4，但是前面的节点最远只能到达下标为3的位置，说明i=4达不到，即返回false</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">canJump</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        k = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums)):</span><br><span class="line">            <span class="keyword">if</span> i &gt; k:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">            k = max(k,i+nums[i])<span class="comment">#更新节点[0,i]能到达的最远节点</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">True</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近要开始准备刷Leetcode了，在这里记录下刷题的心得&lt;/p&gt;
    
    </summary>
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>argparse不支持bool类型</title>
    <link href="http://yoursite.com/2020/03/09/argparse%E4%B8%8D%E6%94%AF%E6%8C%81bool%E7%B1%BB%E5%9E%8B/"/>
    <id>http://yoursite.com/2020/03/09/argparse不支持bool类型/</id>
    <published>2020-03-09T08:28:29.000Z</published>
    <updated>2020-03-09T08:57:46.605Z</updated>
    
    <content type="html"><![CDATA[<p>在Python中通过下列方式向程序传递bool参数时，其中<code>neg</code>参数指定类型为bool，但是无论传入的值是什么，<code>neg</code>始终为<code>True</code></p><p>解决方法：<br><a href="https://blog.csdn.net/yaokai_assultmaster/article/details/77928629" target="_blank" rel="noopener">使用Python中的argparse从命令行接收boolean类型的参数</a><br><a id="more"></a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">parser = argparse.ArgumentParser()</span><br><span class="line">parser.add_argument(<span class="string">"--config"</span>, type=str, help=<span class="string">'configuration file'</span>)</span><br><span class="line">parser.add_argument(<span class="string">"--gpus"</span>, type=str,help=<span class="string">"test program"</span>)<span class="comment">#如果</span></span><br><span class="line">parser.add_argument(<span class="string">"--neg"</span>, type=bool, help=<span class="string">"test program"</span>)</span><br><span class="line">parser.add_argument(<span class="string">"--test"</span>, action=<span class="string">"store_true"</span>, help=<span class="string">"test program"</span>)</span><br></pre></td></tr></table></figure><p>【注意】类似于上文中<code>gpus</code>这种参数，指定也可以，不指定也可以</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在Python中通过下列方式向程序传递bool参数时，其中&lt;code&gt;neg&lt;/code&gt;参数指定类型为bool，但是无论传入的值是什么，&lt;code&gt;neg&lt;/code&gt;始终为&lt;code&gt;True&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;解决方法：&lt;br&gt;&lt;a href=&quot;https://blog.csdn.net/yaokai_assultmaster/article/details/77928629&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;使用Python中的argparse从命令行接收boolean类型的参数&lt;/a&gt;&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Python" scheme="http://yoursite.com/categories/Python/"/>
    
    
      <category term="Python" scheme="http://yoursite.com/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>深度学习优秀代码示例</title>
    <link href="http://yoursite.com/2020/03/03/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E4%BC%98%E7%A7%80%E4%BB%A3%E7%A0%81%E7%A4%BA%E4%BE%8B/"/>
    <id>http://yoursite.com/2020/03/03/深度学习优秀代码示例/</id>
    <published>2020-03-03T03:30:18.000Z</published>
    <updated>2020-03-07T05:14:24.731Z</updated>
    
    <content type="html"><![CDATA[<p>&ensp;&ensp;&ensp;&ensp;曾经一段时间很苦恼，对于深度学习算法不知道怎么上手，看了很多深度学习教程，依然不会写。后来就看论文公开的源代码，对照着论文模型，一点点看，多看几篇代码，逐渐有种开窍的感觉。其次是看Mxnet和Pytorch的源代码(我主要用这2个框架)，Mxnet和Pytorch的Github上给了很多示例代码，写的非常规范，从中可以学到用法，从而也可以规范自己的代码。<br>&ensp;&ensp;&ensp;&ensp;下面整理一下，在我学习过程中，对我帮助很大的教程和代码。</p><a id="more"></a><ol><li><a href="http://zh.gluon.ai/" target="_blank" rel="noopener">《动手学深度学习》Mxnet版</a><br>Mxnet的入门教程，沐神写的，来来回回看了2~3遍，每次看都有新的收货</li><li><a href="https://tangshusen.me/Dive-into-DL-PyTorch/#/" target="_blank" rel="noopener">《动手学深度学习》Pytorch版</a><br>将Mxnet改写为Pytorch版本，非常好的Pytorch入门教程</li><li><a href="https://github.com/Davidham3/ASTGCN" target="_blank" rel="noopener">ASTGCN</a><br>AAAI2019论文公开代码，用Mxnet写的</li><li><a href="https://yjucho1.github.io/spatio-temporal%20data/deep%20learning%20paper/ST-resnet/" target="_blank" rel="noopener">ST-ResNet</a><br>AAAI2017论文公开代码，用Keras，看这篇代码主要是学习模型架构，然后自己用mxnet复现了一下</li><li><a href="https://github.com/panzheyi/ST-MetaNet" target="_blank" rel="noopener">ST-MetaNet</a><br>KDD2019论文公开代码，用Mxnet写的，学到了很多高级用法，例如EarlyStopping，Encoder和Decoder，getattr，DGL</li><li><p><a href="https://github.com/pytorch/examples/tree/master/word_language_model" target="_blank" rel="noopener">Pytorch Transformer</a><br>学习怎么使用Transformer，Dropout和BN在训练和测试的不同，PositionEmbedding，getattr等用法。学习Transformer最好去看Pytorch关于Tranformer的源代码。</p></li><li><p><a href="https://github.com/pytorch/examples" target="_blank" rel="noopener">Pytorch示例代码</a><br>Pytorch Github中的示例代码</p></li><li><a href="https://github.com/apache/incubator-mxnet/tree/master/example" target="_blank" rel="noopener">Mxnet示例代码</a><br>Mxnet Github中的示例代码</li></ol><p>觉得自己最大的变化是喜欢去读源代码了，遇到问题去官网看教程，读源码，帮助很大。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;ensp;&amp;ensp;&amp;ensp;&amp;ensp;曾经一段时间很苦恼，对于深度学习算法不知道怎么上手，看了很多深度学习教程，依然不会写。后来就看论文公开的源代码，对照着论文模型，一点点看，多看几篇代码，逐渐有种开窍的感觉。其次是看Mxnet和Pytorch的源代码(我主要用这2个框架)，Mxnet和Pytorch的Github上给了很多示例代码，写的非常规范，从中可以学到用法，从而也可以规范自己的代码。&lt;br&gt;&amp;ensp;&amp;ensp;&amp;ensp;&amp;ensp;下面整理一下，在我学习过程中，对我帮助很大的教程和代码。&lt;/p&gt;
    
    </summary>
    
      <category term="Deep Learning" scheme="http://yoursite.com/categories/Deep-Learning/"/>
    
    
      <category term="Mxnet" scheme="http://yoursite.com/tags/Mxnet/"/>
    
      <category term="Pyotrch" scheme="http://yoursite.com/tags/Pyotrch/"/>
    
  </entry>
  
  <entry>
    <title>时空论文阅读笔记</title>
    <link href="http://yoursite.com/2020/02/27/%E6%97%B6%E7%A9%BA%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/2020/02/27/时空论文阅读笔记/</id>
    <published>2020-02-27T12:03:53.000Z</published>
    <updated>2020-06-18T02:36:57.665Z</updated>
    
    <content type="html"><![CDATA[<p>因为疫情推迟开学，在家把以前看的论文又看了一遍，每重新看一次都有新的收获，在此整理下。</p><a id="more"></a><!-- TOC --><ul><li><a href="#1-流量速度预测">1. 流量/速度预测</a><ul><li><a href="#11-deep-spatio-temporal-residual-networks-for-citywide-crowd-flows-predictionaaai2017">1.1. Deep Spatio-Temporal Residual Networks for Citywide Crowd Flows Prediction(AAAI2017)</a></li><li><a href="#12-deepstn-context-aware-spatial-temporal-neural-network-for-crowd-flow-prediction-in-metropolisaaai2019">1.2. DeepSTN+: Context-aware Spatial-Temporal Neural Network for Crowd Flow Prediction in Metropolis(AAAI2019)</a></li><li><a href="#13-urbanfm-inferring-fine-grained-urban-flowskdd2019">1.3. UrbanFM: Inferring Fine-Grained Urban Flows(KDD2019)</a></li><li><a href="#14-attention-based-spatial-temporal-graph-convolutional-networks-for-traffic-flow-forecastingaaai2019">1.4. Attention Based Spatial-Temporal Graph Convolutional Networks for Traffic Flow Forecasting(AAAI2019)</a></li><li><a href="#15-spatial-temporal-synchronous-graph-convolutional-networks-a-new-framework-for-spatial-temporal-network-data-forecastingaaai2020">1.5. Spatial-Temporal Synchronous Graph Convolutional Networks: A New Framework for Spatial-Temporal Network Data Forecasting(AAAI2020)</a></li><li><a href="#16-hyperst-net-hypernetworks-for-spatio-temporal-forecasting2019aaai">1.6. HyperST-Net: Hypernetworks for Spatio-Temporal Forecasting(2019AAAI)</a></li><li><a href="#17-urban-traffic-prediction-from-spatio-temporal-data-using-deep-meta-learning2019kdd">1.7. Urban Traffic Prediction from Spatio-Temporal Data Using Deep Meta Learning(2019KDD)</a></li><li><a href="#18-stepdeep-a-novel-spatial-temporal-mobility-event-prediction-framework-based-on-deep-neural-networkkdd2018">1.8. StepDeep: A Novel Spatial-temporal Mobility Event Prediction Framework based on Deep Neural Network(KDD2018)</a></li><li><a href="#19-stgrat-a-spatio-temporal-graph-attention-network-for-traffic-forecastingaaai2020">1.9. STGRAT: A Spatio-Temporal Graph Attention Network for Traffic Forecasting(AAAI2020)</a></li><li><a href="#110-connecting-the-dots-multivariate-time-series-forecasting-with-graph-neural-networks">1.10. Connecting the Dots: Multivariate Time Series Forecasting with Graph Neural Networks</a></li></ul></li><li><a href="#2-eta预测">2. ETA预测</a><ul><li><a href="#21-when-will-you-arrive-estimating-travel-time-based-on-deep-neural-networksaaai20">2.1. When Will You Arrive? Estimating Travel Time Based on Deep Neural Networks(AAAI20)</a></li></ul></li><li><a href="#3-出租车需求预测">3. 出租车需求预测</a><ul><li><a href="#31-deep-multi-view-spatial-temporal-network-for-taxi-demand-predictionaaai2018">3.1. Deep Multi-View Spatial-Temporal Network for Taxi Demand Prediction(AAAI2018)</a></li><li><a href="#32-revisiting-spatial-temporal-similarity-a-deep-learning-framework-for-traffic-predictionaaai2019">3.2. Revisiting Spatial-Temporal Similarity: A Deep Learning Framework for Traffic Prediction(AAAI2019)</a></li><li><a href="#33-spatiotemporal-multi-graph-convolution-network-for-ride-hailing-demand-forecastingaaai2019">3.3. Spatiotemporal Multi-Graph Convolution Network for Ride-hailing Demand Forecasting(AAAI2019)</a></li><li><a href="#34-passenger-demand-forecasting-with-multi-task-convolutional-recurrent-neural-networkspakdd2019">3.4. Passenger Demand Forecasting with Multi-Task Convolutional Recurrent Neural Networks(PAKDD2019)</a></li><li><a href="#35-stg2seq-spatial-temporal-graph-to-sequence-model-for-multi-step-passenger-demand-forecasting2019ijcai">3.5. STG2Seq: Spatial-temporal Graph to Sequence Model for Multi-step Passenger Demand Forecasting(2019IJCAI)</a></li></ul></li><li><a href="#4-时间序列预测">4. 时间序列预测</a><ul><li><a href="#41-restful-resolution-aware-forecasting-of-behavioral-time-series-data2018cikm">4.1. RESTFul: Resolution-Aware Forecasting of Behavioral Time Series Data(2018CIKM)</a></li><li><a href="#42-multi-horizon-time-series-forecasting-with-temporal-attention-learningkdd2019">4.2. Multi-Horizon Time Series Forecasting with Temporal Attention Learning(KDD2019)</a></li></ul></li><li><a href="#5-总结">5. 总结</a><ul><li><a href="#51-网格--图">5.1. 网格—&gt;图</a></li><li><a href="#52-动态图">5.2. 动态图</a></li><li><a href="#53-计算2个区域的相似性">5.3. 计算2个区域的相似性</a></li><li><a href="#54-poi">5.4. POI</a></li><li><a href="#55-时间相关性">5.5. 时间相关性</a></li><li><a href="#56-lstm共t个隐藏状态整合">5.6. LSTM共T个隐藏状态整合</a></li><li><a href="#57-外部因素嵌入">5.7. 外部因素嵌入</a></li><li><a href="#58-mask">5.8. mask</a></li><li><a href="#59-max-min归一化">5.9. Max-min归一化</a></li></ul></li></ul><!-- /TOC --><h1><span id="1-流量速度预测">1. 流量/速度预测</span></h1><h2><span id="11-deep-spatio-temporal-residual-networks-for-citywide-crowd-flows-predictionaaai2017">1.1. Deep Spatio-Temporal Residual Networks for Citywide Crowd Flows Prediction(AAAI2017)</span></h2><blockquote><p>张钧波(京东)<br>郑宇(京东)<br><a href="https://github.com/lucktroy/DeepST" target="_blank" rel="noopener">https://github.com/lucktroy/DeepST</a> Keras</p></blockquote><ul><li>给定所有区域历史T个时间段的inflow和outflow，预测下一个时间段所有区域的inflow和outflow</li></ul><p><img src="/2020/02/27/时空论文阅读笔记/ST-ResNet.png" alt=""></p><ul><li>每个时间段所有区域的输入是$I<em>J</em>2$,将输入分为recent，daily，weekly周期，预测第t个时间段的infow和outflow：<ul><li>recent：当天前r个时间段</li><li>daily：前d天该时间段</li><li>weekly：前w周该天该时间段</li></ul></li><li>外部特征包括：天气，节假日，dayOfWeek。用2层FCN对外部特征进行嵌入，第一层FCN作为嵌入层，第二层FCN转换维度和$X_{Res}$一致。</li><li>在融合阶段，先将3个时间周期的输出融合，再和外部因素拼接。</li><li>数据集：北京出租车和NYC自行车流量</li><li>将flow使用Max-Min归一化到[-1,1]，FCN最后一层使用tanh激活函数</li></ul><h2><span id="12-deepstn-context-aware-spatial-temporal-neural-network-for-crowd-flow-prediction-in-metropolisaaai2019">1.2. DeepSTN+: Context-aware Spatial-Temporal Neural Network for Crowd Flow Prediction in Metropolis(AAAI2019)</span></h2><blockquote><p>Ziqian Lin(清华大学)<br>Jie Feng(清华大学)<br>Ziyang Lu(清华大学)<br>Yong Li(清华大学)<br>Depeng Jin(清华大学)<br><a href="https://github.com/FIBLAB/DeepSTN" target="_blank" rel="noopener">https://github.com/FIBLAB/DeepSTN</a>  Keras</p></blockquote><ul><li>crowd flow预测是给定历史T个时间段，预测区域的inflow和outflow</li><li>现有研究的缺点：<ul><li>不能捕获长距离空间依赖</li><li>忽略区域功能对人流的影响(POI)</li></ul></li><li>提出DeeoSTN+，有3个组件<ul><li>ConvPlus：解决长距离区域的空间依赖</li><li>SemanticPlus：解决区域POI对人流的影响</li><li>early-fusuion模块</li></ul></li></ul><p><img src="/2020/02/27/时空论文阅读笔记/DeepSTN+.png" alt=""></p><ul><li><p>假设预测周四第5个时间段的flow，输入的数据有：</p><ul><li>recent：周四2,3,4个时间段</li><li>day：周一，周二，周三第5个时间段</li><li>week：上上上周四，上上周四，上周四第5个时间段</li><li>time：周四第5个时间段的时间向量</li><li>poi：(C,W,H)所有区域的poi信息</li></ul></li><li>【<strong>ConvPlus</strong>】传统的Conv中kernel的大小远小于网格大小，通常是$3 \times 3$,然后在人流量预测中通常有一些长距离的依赖，例如人们去很远的地方上班。在ConvPlus中，假设原始输入维度是(C,W,H),其中plus维用来捕获长距离依赖<ul><li>正常Conv2D：将原始输入(C,W,H)输入到正常Conv2D中,卷积核有C-plus个，输出维度(C-plus,W,H)，</li><li>ConvPlus：再将原始(C,W,H)输入到ConvPlus中，卷积核有plus<em>W\</em>H个，卷积大小为W*H,则输出维度(plus*W*H,1,1),reshape为(plus,W,H)</li><li>将上面2个卷积的输出拼接成(C,W,H)</li></ul></li><li><strong>计算POI在时间上的分布权重</strong><ul><li>POI维度$C \times W \times H$,表示每个网格有C类POI</li><li>时间维度$T \times W \times H$，T=24+7, 首先对时间进行嵌入，通过2D卷积，将31个数变成一个数$1 \times W \times H$，然后将时间repeat成$C \times W \times H$</li><li>时间和POI逐元素相乘，得到$C \times W \times H$</li><li>如果需要，还可以再通过K个2D卷积，变成$K \times W \times H$</li><li>将该张量和3个周期的输出在通道维上拼接。</li></ul></li><li>crowd flow使用Max-Min归一化到[-1,1]，最后一层使用Tanh，范围[-1,1]</li><li>POI使用Max-Min归一化到[0,1]</li></ul><h2><span id="13-urbanfm-inferring-fine-grained-urban-flowskdd2019">1.3. UrbanFM: Inferring Fine-Grained Urban Flows(KDD2019)</span></h2><blockquote><p>Yuxuan Liang(XiDian)<br>Kun Ouyang(新加坡国立)<br>张钧波(京东)<br>郑宇(京东)<br><a href="https://github.com/yoshall/UrbanFM" target="_blank" rel="noopener">https://github.com/yoshall/UrbanFM</a></p></blockquote><ul><li>基于粗粒度级的flow，实时推测整个城市细粒度级的flow，提出模型<strong>Urban</strong> <strong>F</strong>low <strong>M</strong>agnifier (<strong>UrbanFM</strong>)</li><li>有2个挑战：粗粒度和细粒度的flow在空间上的相关性、复杂的外部因素。</li></ul><p><img src="/2020/02/27/时空论文阅读笔记/UrbanFM1.png" alt=""></p><p><img src="/2020/02/27/时空论文阅读笔记/UrbanFM.png" alt=""></p><h2><span id="14-attention-based-spatial-temporal-graph-convolutional-networks-for-traffic-flow-forecastingaaai2019">1.4. Attention Based Spatial-Temporal Graph Convolutional Networks for Traffic Flow Forecasting(AAAI2019)</span></h2><blockquote><p>郭晟楠(北京交通大学)<br>冯宁(北京交通大学)<br>宋超(北京交通大学)<br>万怀宇(北京交通大学)<br><a href="https://github.com/Davidham3/ASTGCN" target="_blank" rel="noopener">https://github.com/Davidham3/ASTGCN</a> Mxnet</p></blockquote><p>根据所有节点历史T个时间段traffic flow，occupy，speed，预测所有节点未来T_p个时间段的traffic flow。</p><p><img src="/2020/02/27/时空论文阅读笔记/ASTGCN.png" alt=""></p><ul><li>三个独立的组件，分别对recent，daily，weekly周期进行建模</li><li>比如说预测6.14 8:00-8:55的flow，传入的样本是<br>时：6.14号6:00~7:55（前2个小时）的数据，<br>天：6.13和6.12（前2天）的8:00-8:55，<br>周：上周6.17，上上周5.31（前2周）的8:00-8:55</li></ul><h2><span id="15-spatial-temporal-synchronous-graph-convolutional-networks-a-new-framework-for-spatial-temporal-network-data-forecastingaaai2020">1.5. Spatial-Temporal Synchronous Graph Convolutional Networks: A New Framework for Spatial-Temporal Network Data Forecasting(AAAI2020)</span></h2><blockquote><p>宋超(北京交通大学)<br>郭晟楠(北京交通大学)<br>万怀宇(北京交通大学)<br><a href="https://github.com/Davidham3/STSGCN" target="_blank" rel="noopener">https://github.com/Davidham3/STSGCN</a> Mxnet</p></blockquote><ul><li>给定所有节点历史T个时间段的车流量，预测所有节点未来$T’$个时间段的车流量，</li><li>原先的研究通常使用分开的组件捕获时间和空间的相关性，并且忽略了时空数据的异构性。</li><li>提出<strong>S</strong>patial-<strong>T</strong>emporal <strong>S</strong>ynchronous <strong>G</strong>raph <strong>C</strong>onvolutional <strong>N</strong>etworks (<strong>STSGCN</strong>)</li><li><strong>对于图中的每个节点，它的影响范围有3种</strong>，这是该文章提出的一个新观点，以前的研究中通常只考虑前2种。</li></ul><p><img src="/2020/02/27/时空论文阅读笔记/STSGCN1.png" alt=""></p><ul><li>本文强调的内容有2点：<ul><li>局部的时空关系，称作localized spatial-temporal correlations</li><li>时空数据的异质性，居住区和商业区，早上和晚上</li></ul></li><li><strong>使用连续3个时间步的图数据来构建localized spatial-temporal graph，local指的是在时间上局部</strong><br>假设原先一个图中有N个节点，图信号矩阵为$N \times C$,邻接矩阵为$N \times N$，现在3个图来构建一个局部时空图，图信号矩阵为$3N \times C$,邻接矩阵为$3N \times 3N$,邻接矩阵中非0即1</li></ul><p><img src="/2020/02/27/时空论文阅读笔记/STSGCN2.png" alt=""></p><ul><li>但是把3个图构成1个图失去了图之间的时间关系，模型可能会认为这是一个有3N个节点在一个时间步的信息，为了区域这3个图的时间关系，受ConvS2S启发，为时空网络序列$N \times C \times T$添加位置嵌入，增加时间嵌入矩阵$C \times T$,空间嵌入矩阵$N \times C$,这2个矩阵是通过模型学习的，当模型训练好之后，这2个矩阵可以包含图的时间和空间信息。然后把这2个嵌入矩阵和原始的图信号矩阵相加，这样图中就包含了时间和位置信息。</li></ul><p><img src="/2020/02/27/时空论文阅读笔记/STSGCN.png" alt=""></p><ul><li>图中模型框架：多个STSGCM构成STSGCL，多个STSGCL构成STSGCN。STSGCN就是多层图卷积，从局部时空图中捕获邻居信息。STSGCL一层中有多个STSGCM，一个样本中每个时间段的局部时空图都用一个STSGCM来建模。</li><li><strong>第一个FCN成将输入转换到高维空间，提高模型的表示能力</strong></li><li>【<strong>STSGCM</strong>】中包含多层图卷积，使用GLU作为激活函数，其中sigmoid作为门控机制，控制哪个节点的信息可以流入到下一层。<strong>图卷积计算定义在顶点域，意味着不需要计算图的拉普拉斯矩阵</strong><br><img src="/2020/02/27/时空论文阅读笔记/STSGCN3.png" alt=""><br>STSGCM的架构如下：参考JK-net，一共有L个图卷积层，每一层的输出都输入到AGG层中，AGG层将接收到的L个输出进行max聚合，最终得到一个输出$3N \times C_{out}$,然后进行裁剪，将前中后3个时间步的数据只保留中间时间步，即$N \times C_out$<br><img src="/2020/02/27/时空论文阅读笔记/STSGCN4.png" alt=""></li><li>【<strong>STSGCL</strong>】多个STSGCM组成一个STSGCL层，其输入维度$T \times N \times C$,使用滑动窗口每次取3个时间段段的图构成$3N \times C$,一共构成$T-2$个局部时空图，然后需要$T-2$个STSGCM，最终输出$T-2个N \times C_{out}$，将其拼接为$(T-2) \times N \times C_{out}$，再输入到下一个STSGCL中。<strong>【注意】每个局部时空图是通过滑动窗口获得，每个时空局部图的邻接矩阵是不变的，而不是提前处理好局部图输入到模型中，这样会省空间</strong></li><li>上面使用的邻接矩阵$3N \times 3N$中的值非0即1，每个邻居聚合的权重相等，聚合能力会受到限制，这里对此做出改进，将邻接矩阵乘上一个Mask矩阵，对每个邻居赋予不同的权重，其中Mask矩阵是可学习参数，维度$3N \times 3N$<script type="math/tex; mode=display">A_{\text {adjusted}}^{\prime}=W_{\text {mask}} \otimes A^{\prime} \in \mathbb{R}^{3 N \times 3 N}</script></li><li>最后的FCN将STSGCL的输出转换成预测的格式。STSGCL的输出格式为$T \times N \times C$,reshape成$N \times TC$,然后使用$T’$个2层全连接，每个全连接输出维度为$(N,1)$,然后将$T’$个全连接的输出拼接成$N \times T’$</li><li><strong>损失函数使用Huber Loss，对异常值不敏感</strong><script type="math/tex; mode=display">L(Y, \hat{Y})=\left\{\begin{array}{ll}\frac{1}{2}(Y-\hat{Y})^{2} & |Y-\hat{Y}| \leq \delta \\\delta|Y-\hat{Y}|-\frac{1}{2} \delta^{2} & \text { otherwise }\end{array}\right.</script></li><li>使用mean-std归一化，训练集:验证集:测试集=6:2:2，模型包含4个STSGCL，每个STSGCM包含3个图卷积</li></ul><h2><span id="16-hyperst-net-hypernetworks-for-spatio-temporal-forecasting2019aaai">1.6. HyperST-Net: Hypernetworks for Spatio-Temporal Forecasting(2019AAAI)</span></h2><blockquote><p>潘哲逸(上海交通大学)<br>梁宇轩(西安电子科技大学)<br>张钧波(京东)<br>易修文(京东)<br>郑宇(京东)</p></blockquote><p>论文声称第一个考虑<strong>空间和时间内在因果关系</strong>的深度框架。</p><p><img src="/2020/02/27/时空论文阅读笔记/HyperST_Net.png" alt=""></p><ul><li>该论文提出的只是一个HyperNetwork框架，并不是一个具体的模型。</li><li><strong>HyperNetwork</strong>：和以往不同，以前都是一个网络的输出，输入到下一个网络中，<strong>超网络是一个网络的输出作为另一个网络的参数</strong>。</li><li>该模型有3个模块：空间模块，时间模块，推理模块。将空间模块的输出经过推理模块，得到的输出作为时间模块的权重参数，以此捕获时间和空间的内在因果关系。</li><li>这只是一个框架，可以变换成多种模型。在空间模块中如果使用全连接就是HyperST-Dense，使用卷积就是HyperST-Conv。</li></ul><h2><span id="17-urban-traffic-prediction-from-spatio-temporal-data-using-deep-meta-learning2019kdd">1.7. Urban Traffic Prediction from Spatio-Temporal Data Using Deep Meta Learning(2019KDD)</span></h2><blockquote><p>潘哲逸(上海交通大学)<br>梁宇轩(西安电子科技大学)<br>张钧波(京东)<br>郑宇(京东)<br><a href="https://github.com/panzheyi/ST-MetaNet" target="_blank" rel="noopener">https://github.com/panzheyi/ST-MetaNet</a> Mxnet</p></blockquote><ul><li>使用图中所有节点历史T个时间段的flow或speed，预测所有节点未来</li></ul><p><img src="/2020/02/27/时空论文阅读笔记/ST-MetaNet.png" alt=""></p><p><img src="/2020/02/27/时空论文阅读笔记/ST-MetaNet1.png" alt=""></p><p><img src="/2020/02/27/时空论文阅读笔记/ST-MetaNet2.png" alt=""></p><ul><li>本论文用的图，但是实验中有一个$I \times J$的网格数据，将网格数据构建成图</li><li>本论文来表示1张图有2个矩阵：图信号矩阵(N,D)和边特征矩阵(N,N,C)。对于网格数据来说，图信号矩阵表示每个网格POI个数，道路个数。边特征表示2个两个网格的道路个数。这都是静态数据，不随着时间变化。</li></ul><p>【总结】发现上面这2个论文都是一个网络生成另一个网络的参数，查阅资料发现这叫做<code>meta-learning</code>，先记录一下以后再自己看<br><img src="/2020/02/27/时空论文阅读笔记/Meta-learning.png" alt=""></p><h2><span id="18-stepdeep-a-novel-spatial-temporal-mobility-event-prediction-framework-based-on-deep-neural-networkkdd2018">1.8. StepDeep: A Novel Spatial-temporal Mobility Event Prediction Framework based on Deep Neural Network(KDD2018)</span></h2><blockquote><p>Bilong Shen(清华大学)<br>梁晓丹(卡耐基梅隆)</p></blockquote><ul><li><strong>S</strong>patial-<strong>T</strong>emporal mobility <strong>E</strong>vent <strong>P</strong>rediction framework based on <strong>Deep</strong> neural network (<strong>StepDeep</strong>)同时考虑时间和空间模式，给定所有区域历史T个时间段的出租车流量和外部因素，预测所有区域在下一个时间段出租车的inflow和outflow。</li><li>网格区域中的flow随时间变化，可以看做一个视频(T,C,W,H)，进而看做是视频预测任务</li><li>数据集NYC出租车轨迹数据，将NYC网格划分，计算每个区域的inflow和outflow，</li></ul><p><img src="/2020/02/27/时空论文阅读笔记/StepDeep.png" alt=""></p><p><img src="/2020/02/27/时空论文阅读笔记/StepDeep1.png" alt=""></p><ul><li>提出3种卷积：时间卷积，空间卷积，时空卷积。将输入(T,C,H,W)输入到以上7层卷积中，最终输出(C,H,W)表示下一个时间段所有区域的inflow和outflow，</li></ul><h2><span id="19-stgrat-a-spatio-temporal-graph-attention-network-for-traffic-forecastingaaai2020">1.9. STGRAT: A Spatio-Temporal Graph Attention Network for Traffic Forecasting(AAAI2020)</span></h2><blockquote><p>Cheonbok Park(韩国大学)<br>Chunggi Lee(韩国大学)<br>Hyojin Bahng(韩国大学)</p></blockquote><ul><li>根据所有节点历史T个时间段的交通速度，预测所有节点未来T个时间段的交通速度(T=12)，时间多预测多，Seq2Seq架构</li></ul><p><img src="/2020/02/27/时空论文阅读笔记/STGRAT.png" alt=""></p><ul><li>Encoder layer中有3个sublayer：空间Attention层，时间Attention层和point-wise FCN。<ul><li>空间Attention：关注每个时间步上空间邻近的节点</li><li>时间Attention：关注单个节点，输入时间序列的不同时间步</li></ul></li><li>整个Encoder = 1个嵌入层 + 4个Encoder layer，使用LINE对图节点进行嵌入</li></ul><p><img src="/2020/02/27/时空论文阅读笔记/STGRAT1.png" alt=""></p><ul><li>空间Attention层：参考Transformer，中心结点作为query，其邻居作为key和value，计算每个节点新的表示。</li><li>时间Attention==Transformer，输入维度(batch_size,T,N,D),计算时间步之间的attention分数，输出维度(batch_size,T,N,D)</li><li>Point-wise FFN和Transformer中一样，使用2层FCN，中间使用GELU激活函数，Transformer使用的是ReLU激活函数。</li><li>Decoder layer有4个sublayer：空间Attention层，mask时间Attention层，Encoder-Decoder Attention层，point-wise FFN层。整个Decoder层=1个嵌入层+4个Decoder层。</li><li><strong>本模型比Transformer多了一个空间Attention层，其余都一样，因为时间Attention层、FFN和Transformer的一样</strong></li></ul><h2><span id="110-connecting-the-dots-multivariate-time-series-forecasting-with-graph-neural-networks">1.10. Connecting the Dots: Multivariate Time Series Forecasting with Graph Neural Networks</span></h2><p>该模型使用图网络模型捕获交通数据或其他领域数据中的时间和空间相关性。</p><p><img src="/2020/02/27/时空论文阅读笔记/论文总结/MTGNN-1.png" alt=""></p><p>该模型有2个模块，图卷积模块和时间模块。其中图卷积模块主要解决4个问题：</p><ol><li>节点间的空间相关性</li><li>如何构造图</li><li>如何解决图卷积过度平滑问题</li><li>大图如何训练问题</li></ol><p><img src="/2020/02/27/时空论文阅读笔记/论文总结/MTGNN-2.png" alt=""></p><p>首先图信号矩阵，输入到图结构学习模块，构造图的邻接矩阵。注意这里的邻接矩阵不是预先定义好的，而是根据网络模块学习得到，据此构建图，然后输入到GCN中捕获时间相关性，然后输入到时间卷积捕获时间相关性，最后预测结果。</p><p><img src="/2020/02/27/时空论文阅读笔记/论文总结/MTGNN-3.png" alt=""></p><p>在构造图时，通过模型学习节点的嵌入矩阵，然后根据嵌入矩阵计算节点的相似性，为每个节点选取相似性前k的节点作为其一阶邻居。邻接矩阵不随着时间变化。</p><script type="math/tex; mode=display">\begin{array}{l}\mathbf{M}_{1}=\tanh \left(\alpha \mathrm{E}_{1} \Theta_{1}\right) \\ \mathbf{M}_{2}=\tanh \left(\alpha \mathrm{E}_{2} \mathbf{\Theta}_{2}\right) \\ \mathbf{A}=\operatorname{ReL} U\left(\tanh \left(\alpha\left(\mathbf{M}_{1} \mathbf{M}_{2}^{T}-\mathbf{M}_{2} \mathbf{M}_{1}^{T}\right)\right)\right) \\ \text { for } i=1,2, \cdots, N \\ \text { idx }=\operatorname{argtop} k(\mathrm{A}[i,:]) \\ \quad \mathrm{A}[i,-\mathrm{idx}]=0\end{array}</script><p>在图卷积模块，参考Min-hop架构，每个GCN层的输入会加上原始的图信号矩阵，避免图过度平滑问题，然后再将所有GCN层的输出加起来，进行融合。为了解决大图训练的问题，在进行GCN时，每次随机选取几个节点进行GCN运算，而不是使用所有的节点。</p><script type="math/tex; mode=display">\mathbf{H}^{(k)}=\beta \mathbf{H}_{i n}+(1-\beta) \tilde{\mathbf{A}} \mathbf{H}^{(k-1)}</script><script type="math/tex; mode=display">\mathbf{H}_{o u t}=\sum_{i=0}^{K} \mathbf{H}^{(k)} \mathbf{W}^{(k)}</script><p><img src="/2020/02/27/时空论文阅读笔记/论文总结/MTGNN-4.png" alt=""></p><p>在时间模块，使用一维空洞卷积，捕获长期的时间依赖，同时参照Inception结构，设置不同的卷积核，来捕获不同力度的周期性，例如小时周期，天周期，周周期。</p><p>总结：</p><ol><li>根据模型学习节点嵌入，由此构建邻接矩阵，构建相似性图</li><li>使用一维空洞卷积捕获时间相似性，使用不同的卷积核捕获不同粒度的周期性。</li></ol><h1><span id="2-eta预测">2. ETA预测</span></h1><h2><span id="21-when-will-you-arrive-estimating-travel-time-based-on-deep-neural-networksaaai20">2.1. When Will You Arrive? Estimating Travel Time Based on Deep Neural Networks(AAAI20)</span></h2><blockquote><p>王东(杜克大学)<br>张钧波(京东)<br>郑宇(京东)<br><a href="https://github.com/UrbComp/DeepTTE" target="_blank" rel="noopener">https://github.com/UrbComp/DeepTTE</a> Pytorch</p><ul><li>端到端<strong>Deep</strong> learning framework for <strong>T</strong>ravel <strong>T</strong>ime <strong>E</strong>stimation(<strong>DeepTTE</strong>)，给定路径P和外部因素(weather，day of week，开始时间)预测整个path的时间</li><li>原先的工作都是预测travel中单个路段的耗时，然后再把每个路段的时间加起来，缺点是没有考虑到道路交叉口，红绿灯等影响，错误累积</li></ul></blockquote><p><img src="/2020/02/27/时空论文阅读笔记/DeepTTE.png" alt=""></p><ul><li>DeepTTE提出geo-convolution，将地理信息加入到传统Conv中，捕获空间相关性</li><li>多任务学习，同时预测local path和entir path的时间，在loss中限制2者的权重</li><li><strong>在生成测试数据时，将历史轨迹点中的时间戳都去掉</strong>(因为要预测出行时间，所以测试数据不能带有事件信息)，从轨迹中抽样等距离的点组成路径P</li><li><p>DeepTTE一共有3个组件</p><ul><li>Attribute组件：外部因素：天气(one-hot)，司机ID(one-hot)，weekID和timeID(one-hot)，都是类别值，不能直接输入到网络中，需要先嵌入层低维向量，参考<a href="https://arxiv.org/abs/1512.05287" target="_blank" rel="noopener">(2016NIPS)A Theoretically Grounded Application of Dropout in Recurrent Neural Networks</a>,然后再和整个path的距离拼接作为该组件的输出</li><li>Geo-Conv层，历史轨迹是一个GPS序列，为了捕获空间依赖使用1D卷积，将历史轨迹序列先经过FCN变成一个矩阵$T \times V$,T个轨迹点，每个轨迹点有V个特征，然后使用C个k*V的1D卷积，卷积输出的时间维度变成$T-k+1$,将C个卷积核输出的结果拼接，然后再拼接上local path的距离,输出结果为$T-k+1 \times D$</li></ul><p><img src="/2020/02/27/时空论文阅读笔记/DeepTTE2.png" alt=""></p><ul><li>然后将$T-k+1 \times D$的序列拼接外部因素输入到LSTM中，每个时间步表示一个local path，将<strong>隐藏状态用来预测每个local path的时间作为辅助任务</strong></li><li>LTSM输出$T-k+1$个时间步，将其整合成1个向量，通过和外部因素做Attention，对每个local path赋予不同的权重，然后再和外部因素拼接，用来预测entir path的时间</li></ul></li><li><p><strong>训练阶段预测local path和entir path的时间，在测试阶段只预测entir path的时间</strong></p></li><li><p>在训练时，使用MAPE作为loss，包含辅助任务和主任务的loss<br><img src="/2020/02/27/时空论文阅读笔记/DeepTTE-loss.png" alt=""></p></li><li><p>这篇文章也是经典的CNN+LSTM的架构，只是这里的CNN是1D卷积。在融合外部因素上也是CNN的输出和外部因素拼接，送入到LSTM中。</p></li></ul><h1><span id="3-出租车需求预测">3. 出租车需求预测</span></h1><h2><span id="31-deep-multi-view-spatial-temporal-network-for-taxi-demand-predictionaaai2018">3.1. Deep Multi-View Spatial-Temporal Network for Taxi Demand Prediction(AAAI2018)</span></h2><blockquote><p>姚骅修(Pennsylvania State University)<br>吴飞(Pennsylvania State University)<br>柯金涛(香港科技大学)<br>Xianfeng Tang(Pennsylvania State University)<br>叶杰平(滴滴出行)<br><a href="https://github.com/huaxiuyao/DMVST-Net" target="_blank" rel="noopener">https://github.com/huaxiuyao/DMVST-Net</a> Keras</p></blockquote><ul><li><strong>出租车需求预测</strong>，根据S<em>S的小区域，历史T个时间段的出租车订单数据，预测下一个时间段中心区域的订单。<em>*空间和时间都是多预测一</em></em></li></ul><p><img src="/2020/02/27/时空论文阅读笔记/DMVST_Net.png" alt=""></p><ul><li>现有的研究都是使用CNN对空间建模，LSTM对时间建模，时间和空间分开建模，本文的模型是对时间和空间同时建模</li><li>本文提出DMVST-Net，有3个view：<strong>时间view</strong>（通过LSTM建模时间关系），<strong>空间view</strong>（使用local CNN建模邻近空间关系），<strong>语义view</strong>（建模功能相似的区域）</li><li>local CNN只考虑空间邻近的区域，但是不能考虑离得较远，但出租车需求模型相似的区域，所以又加了语义view</li><li><img src="/2020/02/27/时空论文阅读笔记/DMVST_Net-1.jpg" alt=""></li><li><strong>输入是S*S的邻居区域，如果是边界区域，其邻居用0填充</strong></li><li>在LSTM每个时间步的特征中拼接天气等外部因素</li><li>local CNN和LSTM对时间和空间建模，然后再构建图，表示区域之间需求相似性(功能相似性)。求出2个区域每周的需求量，形成一个时间序列，使用DTW计算2个序列的相似性，即<strong>2个区域的相似性，作为图中的边，创建一个全连接图(任意2个区域都相连)</strong>,使用LINE对图中节点进行嵌入。</li><li><img src="/2020/02/27/时空论文阅读笔记/DMVST_Net-2.png" alt=""><br>损失函数由MSE和MAPE组成，MSE更关注大值，为了避免模型偏向大值的方向训练，又添加了MAPE，但是使用MAPE时，真实值中不能有0</li><li>Max-Min激活，最终输出值在[0,1]之间，反归一化</li><li>最后一层FCN用sigmoid激活，其余的FCN用ReLU激活</li></ul><h2><span id="32-revisiting-spatial-temporal-similarity-a-deep-learning-framework-for-traffic-predictionaaai2019">3.2. Revisiting Spatial-Temporal Similarity: A Deep Learning Framework for Traffic Prediction(AAAI2019)</span></h2><blockquote><p>姚骅修(Pennsylvania State University)<br>Xianfeng Tang(Pennsylvania State University)<br><a href="https://github.com/tangxianfeng/STDN" target="_blank" rel="noopener">https://github.com/tangxianfeng/STDN</a> Keras</p></blockquote><ul><li>主要问题是：原先研究中的空间相关性都是静态的，本次建模<strong>动态的空间相关性</strong>。<strong>时间有天和周周期，且有时间偏移</strong>。</li><li>提出模型<strong>S</strong>patial-<strong>T</strong>emporal <strong>D</strong>ynamic <strong>N</strong>etwork(<strong>STDN</strong>)来traffic prediction</li><li>根据S<em>S小区域历史T个时间段的volume和flow，预测下一个时间段中心区域的volume，<em>*空间和时间都是多预测一</em></em></li></ul><p><img src="/2020/02/27/时空论文阅读笔记/STDN.png" alt=""></p><ul><li>将交通量分为2种<ul><li>traffic volume：无方向，一个区域进来和出去的流量。</li><li>traffic flow：有方向，从区域i到区域j的流量</li></ul></li><li>flow-gated local CNN每次输入S*S区域的volume和flow，其中flow起到门控作用，值在[0,1]之间，如果2个区域之间flow大，即门控的值大，2个区域的相关性强。每个时间段经过local CNN输出的值，再拼接上该时间段的天气等外部因素送入LSTM中</li><li><strong>时间偏移Attention</strong>：比如预测第t+1个时间段的volume，用到当天前t=7个时间段的数据(短期依赖)，前P=3天(长期依赖)，每天Q=3个时间段(解决时间偏移问题)。</li><li>先将短期的t个时间段数据输入LSTM中，得到隐藏状态h做Attention。前P天，每天Q个时间段输入到LSTM中，每天得到Q个隐藏状态，和h做attention，将Q个整合成1个，最终生成P个隐藏状态，再输入到LSTM，得到长期依赖的隐藏状态，然后再和短期的隐藏状态h拼接，输入到FCN中。</li><li><strong>短期的隐藏状态和长期的隐藏状态做Attention</strong></li><li><strong>短期的隐藏状态和长期的隐藏状态拼接</strong></li><li>数据集：出租车流量和自行车流量</li></ul><blockquote><ul><li>STDN和DMVST-Net是同一作者发的</li><li>两者都是：空间和时间<strong>多预测一</strong></li><li><strong>STDN</strong>：local CNN + LSTM</li><li><strong>DMVST-Net</strong>：flow-gated local CNN + Periodically Shifted Attention LSTM</li></ul></blockquote><h2><span id="33-spatiotemporal-multi-graph-convolution-network-for-ride-hailing-demand-forecastingaaai2019">3.3. Spatiotemporal Multi-Graph Convolution Network for Ride-hailing Demand Forecasting(AAAI2019)</span></h2><blockquote><p>Xu Geng(香港大学)<br>Yaguang Li(南加利福尼亚)<br>Lingyu Zhang(滴滴AI)<br>杨强(香港大学)<br>叶杰平(滴滴)</p></blockquote><p><img src="/2020/02/27/时空论文阅读笔记/ST_MGCN.png" alt=""></p><ul><li>问题：根据所有区域历史T个时间段的订单数，预测所有区域下一个时间段的订单数</li><li>将研究区域划分为网格，根据网格构建3个图，这3个图的图信号矩阵一样，只是邻接矩阵不一样。分别<ul><li><strong>邻居图</strong>（3*3网格，每个区域有8个邻居，2个区域是邻居，邻接矩阵为1，否则为0）；</li><li><strong>区域功能相似图</strong>（根据每个区域的POI，计算相似性，值在0&lt;=sim&lt;=1）；</li><li><strong>交通连通图</strong>（看2个区域是否在高速公路，公共交通等方式相连，相连为1，否则为0）</li></ul></li><li><strong>Channel-wise attention</strong>参考CV领域，图像输入$X \in \mathbb{R}^{W\times H \times C}$，计算每一个通道的权重$s$,然后再把输入和通道权重相乘$\tilde{\boldsymbol{X}}_{:,:,c}=\boldsymbol{X}_{:,:, c} \circ s_{c} \quad for \quad c=1,2, \cdots C$</li><li>一共有3类图，每类图的邻接矩阵不一样，图信号矩阵一样，表示该区域的订单数，图信号矩阵是动态的，每个时间段的图信号矩阵都不一样，一共有T个时间段。拿一个图距离，输入为(T,V,P),根据通道维的attention，<strong>这里将时间维作为通道维，对T个时间段做Attention</strong>，最终得到attention后的输入(T,V,P),然后输入到RNN中，因为RNN一次只能输入一个节点T个时间段的数据，但是这里有V个节点，这里V个节点共享一个RNN，最终得到隐藏状态，然后在把3个图的输出融合，得到最终的预测结果(所有区域下一个时间段的订单数)</li><li>T为5，根据ST_ResNet，其中3个邻近，1个天周期，1个周周期。</li></ul><h2><span id="34-passenger-demand-forecasting-with-multi-task-convolutional-recurrent-neural-networkspakdd2019">3.4. Passenger Demand Forecasting with Multi-Task Convolutional Recurrent Neural Networks(PAKDD2019)</span></h2><blockquote><p>Lei Bai1(University of New South Wales)<br>Lina Yao(University of New South Wales)<br>Salil S. Kanhere(University of New South Wales)</p></blockquote><ul><li>根据历史T个时间段<strong>相似区域</strong>出租车demand和人流量，预测下一个时间段中心区域的出租车demand。<strong>时间和空间都是多预测一</strong></li></ul><p><img src="/2020/02/27/时空论文阅读笔记/MT-CRNN.png" alt=""></p><ul><li>根据路网来划分区域</li><li>多任务预测：<ul><li><strong>主任务(回归)</strong>：预测中心区域的订单需求数</li><li><strong>辅助任务(分类)</strong>：预测中心区域的订单需求等级(高、中、低)</li></ul></li><li>主任务输入的是相似区域的订单数据和人流量数据，其中<strong>根据POI和taxi demand来计算2个区域的相似性</strong>，为中心区域选择m=3个最相似区域</li><li>使用外部信息(天气等)来预测订单需求等级(辅助任务)</li></ul><h2><span id="35-stg2seq-spatial-temporal-graph-to-sequence-model-for-multi-step-passenger-demand-forecasting2019ijcai">3.5. STG2Seq: Spatial-temporal Graph to Sequence Model for Multi-step Passenger Demand Forecasting(2019IJCAI)</span></h2><blockquote><p>Lei Bai1(University of New South Wales)<br>Lina Yao(University of New South Wales)<br>Salil S. Kanhere(University of New South Wales)</p></blockquote><ul><li>基于GCN，提出<strong>Seq2Seq的模型</strong>，来进行<strong>多步预测</strong>。本文说这是第一篇使用GCN来进行多步预测</li><li><p>大部分的研究只预测下一个时间段，本文预测多个时间段。以前的研究预测多个时间段使用seq2seq架构，里面是RNN或者其变体(ConvLSTM)，有个问题是：在decoder中，将前一个时间步的预测结果作为输入，会出现错误累积</p></li><li><p>将城市划分为N个小区域，基于网格或道路划分都可以</p></li><li><p>给定历史h个时间段的D(需求量，维度$N \times D_{in}$)和所有时间段的时间信息E，预测未来$\tau$个时间段的需求量<br><img src="/2020/02/27/时空论文阅读笔记/STG2Seq1.png" alt=""></p></li><li><p>图中每个节点表示一个小区域，图的邻接矩阵A中非0即1，根据区域demand的模式，计算2个区域的皮尔森相似度，如果相似度大于某个阈值，邻接矩阵为1，否则设置为0</p></li><li><p>模型主要有3个模块，假设预测时间段为$t+1,t+1,…,t+\tau$</p><ul><li>长期encoder：历史长期h个时间段，(h,N,D)</li><li>短期encoder：最近的q个时间段，(q,N,D)</li><li>Attention模块：在历史时间段中，找出对预测时间段的重要性</li></ul></li><li><p>长期encoder和短期encoder都是由GGCM组成，一个GGCM中有多个GCN。拿长期encoder举例，输入维度(h,N,D),每k个时间段(k,N,D)输入到GCN中，h个时间段一共有h-k+1个GCN，即经过一个GGCM，输入维度变成(h-k+1,N,D1)，每经过一个GGCM，时间维度都会变小，为了防止时间维度变小，会拼接上一个(k-1,N,D1)的全0padding，让其变成(h,N,D1)的维度，然后再输入到下一个GGCM中。<br>  <img src="/2020/02/27/时空论文阅读笔记/STG2Seq3.png" alt=""><br>  <img src="/2020/02/27/时空论文阅读笔记/STG2Seq4.png" alt=""></p></li><li>对于一个GCN中，输入维度是(k,N,D),reshape成(N,k*D),然后使用下面的公式。下面这个公式用到了残差连接，在经过GCN后，加上原来的$X^l$，同时和后面的sigmoid逐元素相乘，控制线性转换的哪部分可以通过门。<br><img src="/2020/02/27/时空论文阅读笔记/STG2Seq2.png" alt=""></li><li>在经过长期encoder和短期encoder后，将输出拼接，得到$(h+q,N,d_{out})$</li><li><strong>时间Attention</strong>：历史h+q个时间段对target时间段的影响不同，为了求出不同的影响程度，使用Attention机制。将$Y_{h+q}$reshape成$(h+q) \times (N \times d_{out})$<script type="math/tex; mode=display">\boldsymbol{\alpha}=\operatorname{softmax}\left(\tanh \left(Y_{h+q} W_{3}^{Y}+E_{T} W_{4}^{E}+b_{1}\right)\right)</script>其中$W_{3}^{Y} \in \mathbb{R}^{(h+q) \times\left(N \times d_{\text {out }}\right) \times 1}, W_{4}^{E} \in \mathbb{R}^{d_{e} \times(h+q)}$，$b_{1} \in \mathbb{R}^{(h+q)}$ 得到的Attention分数$\boldsymbol{\alpha} \in \mathbb{R}^{(h+q)}$<script type="math/tex; mode=display">Y_{\alpha}=\sum_{i=1}^{h+q} \alpha^{i} y_{i} \quad \in \mathbb{R}^{N \times d_{o u t}}</script></li><li><strong>通道Attention</strong>：经过上一步的时间Attention，得到的结果$Y_{\alpha}$维度为$N \times d_{out}$，然后再经过通道Attention，将$Y_{\alpha}$reshape成$N \times d_{out}$<script type="math/tex; mode=display">\boldsymbol{\beta}=\operatorname{softmax}\left(\tanh \left(Y_{\alpha} W_{5}^{Y}+E_{T} W_{6}^{E}+b_{2}\right)\right)</script>其中$W_{5}^{Y} \in \mathbb{R}^{d_{\text {out}} \times N \times 1}, W_{6}^{E} \in \mathbb{R}^{d_{e} \times d_{\text {out}}}, b_{2} \in \mathbb{R}^{d_{out}}$，$\boldsymbol{\beta} \in \mathbb{R}^{d_{\text {out }}}$<script type="math/tex; mode=display">Y_{\beta}=\sum_{i=1}^{d_{\text {out}}} \beta^{i} \mathscr{Y}_{i} \in \mathbb{R}^{N}</script></li><li>经过通道Attention，求得$Y_{\beta}$就是一个时间段的预测值</li></ul><p><strong>- 总结：</strong></p><ul><li>图的邻接矩阵非0即1，计算2个区域的相似度，大于阈值为1，否则为0</li><li>将历史时间段分为<strong>长期和短期</strong>，在历史时间段上设置一个<strong>长度为k的滑动窗口</strong>，每k个时间段都用不同的GCN来<strong>捕获空间关系</strong></li><li><strong>时间Attention</strong>：经过encoder后，将长期和短期的输出拼接，形成h+q个时间段，计算对target的时间段的时间Attention</li><li><strong>通道Attention</strong>：借鉴CV领域的思想《(CVPR2017)-Spatial and channel-wise attention in convolutional networks for image captioning》</li><li>使用GCN捕获空间相关性，然后分别使用时间Attention和通道Attention</li></ul><h1><span id="4-时间序列预测">4. 时间序列预测</span></h1><h2><span id="41-restful-resolution-aware-forecasting-of-behavioral-time-series-data2018cikm">4.1. RESTFul: Resolution-Aware Forecasting of Behavioral Time Series Data(2018CIKM)</span></h2><blockquote><p>吴宪(University of Notre Dame)<br>史宝旭(University of Notre Dame)<br>Yuxiao Dong(微软)<br>黄超(University of Notre Dame)</p></blockquote><p>本文使用<strong>多种时间粒度</strong>的<strong>时间序列数据</strong>来预测。<br>模型为<strong>RES</strong>olution-aware <strong>T</strong>ime <strong>S</strong>eries Forecasting (RESTFul)<br>第一个使用多种时间粒度来进行行为时间序列预测</p><p><img src="/2020/02/27/时空论文阅读笔记/RESTFul.png" alt=""></p><ul><li>有2个参数$\alpha和\beta$，取值{day,week}，限制α&gt;=β，<br>$\alpha$=1week,$\beta$=1day,表示1周测量1次，1次测1天。<br>$\alpha$=1week,$\beta$=1week,表示1周测量1次，1次测1周。<br>有一个完整的时间序列，要从中隔抽取不同时间粒度的时间序列。$X=\left[x_{1}, \ldots, x_{t}, \ldots, x_{T-1}, x_{T}\right]$，不同的$\alpha和\beta$就构成不同时间粒度的序列，序列长度为k，这里设置为5。</li><li>对于每一个时间序列都用GRU来捕获时间相关性，得到一个隐藏状态，那么n个时间序列就有n个隐藏状态</li><li>将所有的隐藏状态reshape成$\alpha <em> \beta </em> d$的张量，然后使用卷积融合不同粒度。</li><li>使用数据集：销售数据，311投诉数据</li></ul><h2><span id="42-multi-horizon-time-series-forecasting-with-temporal-attention-learningkdd2019">4.2. Multi-Horizon Time Series Forecasting with Temporal Attention Learning(KDD2019)</span></h2><blockquote><p>Chenyou Fan(京东金融)<br>Yuze Zhang(京东金融)<br>Yi Pan(京东金融)</p></blockquote><ul><li>使用前T个时间段的销售数据，预测未来<code>T&#39;</code>个时间段的销售数据</li><li>传统的encoder-decoder架构使用rnn,本文的一个改进是在decoder中使用BiLSTM</li></ul><p><img src="/2020/02/27/时空论文阅读笔记/BiLSTM-Enc-Dec.png" alt=""></p><p><img src="/2020/02/27/时空论文阅读笔记/BiLSTM-Enc-Dec1.png" alt=""></p><ul><li><strong>时间Attention</strong>:在decoder中第$t+1$个时间步生成的隐藏状态，对encoder中的隐藏状态进行attention，这里并不是对所有的历史时间段做attention，而是对历史$T_h$个时间段(可划分为M个period)做attention。例如上图中M=2，然后形成M个$c$向量，再经过FCN转换成$d$，然后再将M个$d$向量融合，这里使用attention融合，通过decoder的隐藏状态$h_{t+1}$对M个向量d做attention，将其融合成1个向量，然后再和$h_{t+1}$拼接，输入到FCN中预测第$t+1$个时间步的$y_{t+1}$，decoder中每个时间步都输出该时间步的预测值$y$。</li><li>本文的创新点就是：BILSTM和时间local Attention(只和局部时间段做Attention)</li></ul><h1><span id="5-总结">5. 总结</span></h1><h2><span id="51-网格gt图">5.1. 网格—&gt;图</span></h2><p>图用2个矩阵表示：图信号矩阵和邻接矩阵。由网格构建图时，节点表示区域，图信号矩阵就是区域的特征。重点是怎么构建邻接矩阵。</p><ul><li>《Spatiotemporal Multi-Graph Convolution Network for Ride-hailing Demand Forecasting》(AAAI2019)这篇文章构建了3个图：邻居图，POI功能相似图，交通连通图</li><li>《RiskOracle: A Minute-level Citywide Traffic Accident Forecasting Framework》(AAAI2020)有27*27个网格，但只有354个网格有道路，所以构建图中有354个节点。根据区域之间的道路静态信息和交通动态信息(flow和speed)来计算区域之间的相似性，构建邻接矩阵。由于动态交通信息随时间变化，所有每个时间段的相似性都不同，即每个时间段的邻接矩阵都不一样。<ul><li>图信号矩阵：区域的flow，speed、和前一个时间段的差值</li><li>邻接矩阵：区域之间的相似性，在[0,1]之间</li></ul></li></ul><p><strong>邻接矩阵的构造</strong></p><ul><li><p>邻接矩阵，非0即1，如果2个区域相邻，为1，否则为0<br>《Spatial-Temporal Synchronous Graph Convolutional Networks: A New Framework for Spatial-Temporal Network Data Forecasting》（AAAI2020）</p></li><li><p>计算2个区域的相似性，如果2个区域的相似度大于某个阈值，设置为1，否则为0<br>《STG2Seq: Spatial-temporal Graph to Sequence Model for Multi-step Passenger Demand Forecasting》（2019IJCAI）</p></li><li>计算2个区域的相似性，使用相似性作为邻接矩阵的值<br>《RiskOracle: A Minute-level Citywide Traffic Accident Forecasting Framework》（AAAI2020）</li><li>计算2个节点的相似性，为每个节点选取相似性前k的节点作为其一阶邻居，其余节点的相似性设置为0，例如《Connecting the Dots: Multivariate Time Series Forecasting with Graph Neural Networks》2020KDD</li></ul><h2><span id="52-动态图">5.2. 动态图</span></h2><p>一般的图卷积的输入维度是<code>(batch_size,N,C)</code>，即只有一个时间段，但如果输入的是动态图即<code>(batch_size,T,N,C)</code>，该怎么办？</p><script type="math/tex; mode=display">h^{(l)}=\left(\hat{A} h^{(l-1)} W_{1}+b_{1}\right)</script><ul><li><code>(batch_size,T,N,C)--&gt;(batch_size,T*N,C)--&gt;(T*N,batch_size,C)</code>,例如《Spatial-Temporal Synchronous Graph Convolutional Networks: A New Framework for Spatial-Temporal Network Data Forecasting》（AAAI2020）,将时间T乘到节点N上，需要对邻接矩阵进行变换成<code>(TN,TN)</code>的形式，才可以和h相乘。不常用，除非对邻接矩阵A进行变换</li><li><code>(batch_size,T,N,C)--&gt;(batch_size,N,T*C)</code>，可以先经过一个FCN，将其转换为<code>(batch_size,N,D)</code>,然后再输出到GCN中，也可以不经过FCN，直接输入到GCN中。较常用，例如：<br>《RiskOracle: A Minute-level Citywide Traffic Accident Forecasting Framework》（AAAI2020）<br>《STG2Seq: Spatial-temporal Graph to Sequence Model for Multi-step Passenger Demand Forecasting》（2019IJCAI）</li></ul><h2><span id="53-计算2个区域的相似性">5.3. 计算2个区域的相似性</span></h2><ul><li><p>用<strong>出租车需求量</strong>计算2个区域的<strong>相似性</strong>，用2个区域<strong>训练集</strong>中出租车需求量组成时间序列</p><ul><li>使用DTW计算2个序列的相似性，2个时间序列越相似，说明2个区域越相似。例如：《Deep Multi-View Spatial-Temporal Network for Taxi Demand Prediction》(AAAI2018)</li><li>使用皮尔森度量函数Pearson Correlation Coefficient，<br>《Passenger Demand Forecasting with Multi-Task Convolutional Recurrent Neural Networks》(2019PAKDD)<br>《STG2Seq: Spatial-temporal Graph to Sequence Model for Multi-step Passenger Demand Forecasting》（2019IJCAI）</li></ul></li><li><p>计算2个区域之间的<strong>相关性</strong>，使用<strong>区域间带有方向的traffic flow</strong>，如果2个区域之间的traffic flow越大，说明这2个区域越相关。但是《R evisiting Spatial-Temporal Similarity: A Deep Learning Framework for Traffic Prediction》(AAAI2019)说这种相关性也是相似性。我觉得有问题，例如工作区和住宅区，2个区域的traffic flow很大，有很强的相关性，但是相似性并不强。</p></li><li>根据<strong>POI</strong>计算2个区域的相似性<ul><li>例如《Passenger Demand Forecasting with Multi-Task Convolutional Recurrent Neural Networks》(2019PAKDD)</li><li>《Spatiotemporal Multi-Graph Convolution Network for Ride-hailing Demand Forecasting》(2019AAAI)但是这篇文章没有提到使用什么函数来计算相似度</li></ul></li><li>《RiskOracle: A Minute-level Citywide Traffic Accident Forecasting Framework》(AAAI2020)根据区域的道路静态信息和交通动态信息(flow和speed)计算2个区域的相似性。使用JS散度</li></ul><h2><span id="54-poi">5.4. POI</span></h2><p>很多论文中都习惯将POI成为Semantic</p><ul><li>《Deep Multi-View Spatial-Temporal Network for Taxi Demand Prediction》(AAAI2018)</li><li>《DeepSTN+: Context-aware Spatial-Temporal Neural Network for Crowd Flow Prediction in Metropolis》(AAAI2019)</li></ul><h2><span id="55-时间相关性">5.5. 时间相关性</span></h2><p>像dayOfWeek，monthOfYear等时间信息，在论文中称作<strong>time meta feature</strong></p><ul><li>使用RNN来捕获时间相关性</li><li>使用1D卷积来捕获时间相关性，或者使用1D空洞卷积，来捕获长期的时间相关性。或者参照Inception结构，使用不同大小的卷积核来捕获不同粒度的周期性，例如WaveNet，MTGNN</li><li>使用不同的模块捕获不同粒度的周期性，例如ST-ResNet，DeepSTN，ASTGCN</li></ul><h2><span id="56-lstm共t个隐藏状态整合">5.6. LSTM共T个隐藏状态整合</span></h2><p>LSTM一共有T个时间步，将输出T个隐藏状态，怎么将其整合成1个，有3种方法：</p><ul><li>只取最后一个时间步的隐藏状态，例如<br>《Deep Multi-View Spatial-Temporal Network for Taxi Demand Prediction》(AAAI2018)</li><li>将T个时间步的隐藏状态拼接或平均或加和</li><li>将T个时间步的隐藏状态和被预测时间步的某个向量(e.g.外部因素)做Attention，对每个时间步赋予不同的权重，整合成1个向量。例如<br>《Revisiting Spatial-Temporal Similarity: A Deep Learning Framework for Traffic Prediction》(AAAI2019)<br>《When Will You Arrive? Estimating Travel Time Based on Deep Neural Networks》(AAAI20)</li></ul><h2><span id="57-外部因素嵌入">5.7. 外部因素嵌入</span></h2><p>外部因素包括：天气，时间，holiday等信息，</p><ul><li>外部因素中<strong>类别值</strong>(dayOfWeek，weather等)用one-hot表示，<strong>连续值</strong>(温度，风速)等用float表示，将这些外部因素拼接在一起，送入FCN中做嵌入。<br>例如《 Deep Spatio-Temporal Residual Networks for Citywide Crowd Flows Prediction(AAAI2017)》</li><li>外部因素中<strong>类别值</strong>(dayOfWeek，weather等)直接用数字表示，例如周一用0表示，周日用6表示。<strong>连续值</strong>(温度，风速)等用float表示，然后将每个类别值用对应的Embedding嵌入，然后再把嵌入的结果拼接<br>例如《When Will You Arrive? Estimating Travel Time Based on Deep Neural Networks(AAAI20)》<br><code>Embedding</code>相关知识参考<a href="https://echohhhhhh.github.io/2020/02/24/Pytorch%E4%B9%8B%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB/#12-embedding" target="_blank" rel="noopener">Pytorhc之Embedding</a></li></ul><h2><span id="58-mask">5.8. mask</span></h2><p>有时候mask是舍弃一些不想关注的值，比如预测车流量时，真实车流量小于5的值则舍弃，即不关注那些车流量小的值预测结果，只关注大约5的值的预测结果。一般在评价指标中mask</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">mask_mae_np</span><span class="params">(y_true,y_pred,region_mask,null_val=None)</span>:</span></span><br><span class="line">    <span class="string">"""计算MAE</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    Arguments:</span></span><br><span class="line"><span class="string">        y_true &#123;np.ndarray&#125; -- 真实值,维度(samples,pre_len,W,H)</span></span><br><span class="line"><span class="string">        y_pred &#123;np.ndarray&#125; -- 预测值,维度(samples,pre_len,W,H)</span></span><br><span class="line"><span class="string">        region_mask &#123;np.ndarray&#125; -- mask矩阵,维度(W,H)</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    Returns:</span></span><br><span class="line"><span class="string">        np.float64 -- MAE值</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    y_true,y_pred = transfer_dtype(y_true,y_pred)</span><br><span class="line">    <span class="keyword">if</span> null_val <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span>:</span><br><span class="line">        label_mask = np.where(y_true &gt; <span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>).astype(<span class="string">'float32'</span>)</span><br><span class="line">        <span class="comment"># label_mask = np.not_equal(y_true, null_val).astype('float32')</span></span><br><span class="line">        mask = region_mask * label_mask</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        mask = region_mask</span><br><span class="line">    mask /= mask.mean()</span><br><span class="line">    <span class="keyword">return</span> np.mean(np.abs(y_true-y_pred)*mask)</span><br></pre></td></tr></table></figure><h2><span id="59-max-min归一化">5.9. Max-min归一化</span></h2><p>使用Max-Min将数据归一化到[0,1]，但是也有论文归一化成[-1,1]，如下所示：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MinMaxNormalization</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="string">'''MinMax Normalization --&gt; [-1, 1]</span></span><br><span class="line"><span class="string">       x = (x - min) / (max - min).</span></span><br><span class="line"><span class="string">       x = x * 2 - 1</span></span><br></pre></td></tr></table></figure><p>【注意】对特征和y归一化有2种方式：</p><ol><li><strong>只对特征进行归一化，y不进行归一化</strong>，模型预测的结果和真实y是同一量纲，模型的loss会偏大，计算评价指标时，不需要反归一化</li><li><strong>对特征和y都归一化</strong>，y归一化到[0,1]之间，在计算loss时，不需要反归一化，loss相对方法1会偏小，在计算评价指标时，需要对真实y和预测y进行反归一化，再计算MAE等指标</li><li><p>关于上面是否需要对y进行归一化。如果模型收敛(loss一直在下降)，可以不对y进行归一化。如果模型不收敛(数值过大)，则需要对y进行归一化。</p><p><img src="/2020/02/27/时空论文阅读笔记/神经网络踩坑/y-norm.png" alt=""><br>如果对y进行归一化，loss初始值很小，模型训练时很快就会收敛loss不再下降。不对y归一化，loss初始值很大，在训练过程中，训练很多轮loss才开始收敛，可能还会造成训练过程不稳定，loss上下震荡。</p></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;因为疫情推迟开学，在家把以前看的论文又看了一遍，每重新看一次都有新的收获，在此整理下。&lt;/p&gt;
    
    </summary>
    
      <category term="论文阅读笔记" scheme="http://yoursite.com/categories/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="时空领域" scheme="http://yoursite.com/tags/%E6%97%B6%E7%A9%BA%E9%A2%86%E5%9F%9F/"/>
    
  </entry>
  
  <entry>
    <title>VSCode连接服务器太慢</title>
    <link href="http://yoursite.com/2020/02/26/VSCode%E8%BF%9E%E6%8E%A5%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%A4%AA%E6%85%A2/"/>
    <id>http://yoursite.com/2020/02/26/VSCode连接服务器太慢/</id>
    <published>2020-02-26T09:59:55.000Z</published>
    <updated>2020-02-26T12:26:38.519Z</updated>
    
    <content type="html"><![CDATA[<p>使用VSCode远程连接服务器太慢，是因为需要远程下载vscode-server-linux-x64.tar.gz，下载太慢，下面是解决方案</p><a id="more"></a><p><img src="/2020/02/26/VSCode连接服务器太慢/vscode.png" alt=""></p><p><a href="https://blog.csdn.net/bcfd_yundou/article/details/96135456" target="_blank" rel="noopener">vscode搭建远程开发</a></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">先将vscode-server-linux-x64.tar.gz拷贝到/data/WangBeibei/.vscode-server/bin/xxx下面，并解压</span></span><br><span class="line">tar -xzvf vscode-server-linux-x64.tar.gz</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">删掉压缩包</span></span><br><span class="line">rm -r vscode-server-linux-x64.tar.gz</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">将vscode-server-linux-x64目录中所有内容移到/data/WangBeibei/.vscode-server/bin/xxx下面</span></span><br><span class="line">mv /data/WangBeibei/.vscode-server/bin/xxx/vscode-server-linux-x64/* /data/WangBeibei/.vscode-server/bin/xxx</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">删掉vscode-server-linux-x64</span></span><br><span class="line">rm -r vscode-server-linux-x64</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;使用VSCode远程连接服务器太慢，是因为需要远程下载vscode-server-linux-x64.tar.gz，下载太慢，下面是解决方案&lt;/p&gt;
    
    </summary>
    
      <category term="工具" scheme="http://yoursite.com/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="VSCode" scheme="http://yoursite.com/tags/VSCode/"/>
    
  </entry>
  
  <entry>
    <title>对loss进行mask</title>
    <link href="http://yoursite.com/2020/02/25/%E5%AF%B9loss%E8%BF%9B%E8%A1%8Cmask/"/>
    <id>http://yoursite.com/2020/02/25/对loss进行mask/</id>
    <published>2020-02-25T05:37:12.000Z</published>
    <updated>2020-03-06T16:32:42.950Z</updated>
    
    <content type="html"><![CDATA[<h1><span id="简介">简介</span></h1><p>在计算loss和评价指标时，对一些不关注的值进行mask。下面介绍mask的使用。</p><a id="more"></a><h1><span id="对loss进行mask">对loss进行mask</span></h1><p>在NLP中的Seq2Seq中经常会对loss进行mask，因为一个batch中句子的长度通常不一样，一个batch中不足长度的位置用0填充，最后生成句子计算loss时需要忽略掉原先那些padding的值，即只保留mask中值为1的位置，忽略值为0的位置。在计算loss时，将那些本不应该计算的mask掉，使其loss为0，这样就不会反向传播了。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">masked_predicts = torch.masked_select(predicts, mask)</span><br><span class="line">masked_targets = torch.masked_select(targets, mask)</span><br><span class="line">loss = my_criterion(masked_predicts, masked_targets)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">diff2 = (torch.flatten(input) - torch.flatten(target)) ** <span class="number">2.0</span> * torch.flatten(mask)</span><br><span class="line">loss = torch.sum(diff2) / torch.sum(mask)</span><br><span class="line">out.backward()</span><br></pre></td></tr></table></figure><p>有时候mask是舍弃一些不想关注的值，比如预测车流量时，真实车流量小于5的值则舍弃，即不关注那些车流量小的值预测结果，只关注大约5的值的预测结果。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">masked_mean_squared_error</span><span class="params">(y_true, y_pred)</span>:</span></span><br><span class="line">    idx = (y_true &gt; <span class="number">5</span>).nonzero()</span><br><span class="line">    <span class="keyword">return</span> K.mean(K.square(y_pred[idx] - y_true[idx]))</span><br></pre></td></tr></table></figure><h1><span id="pytorch的mask_select函数">Pytorch的mask_select函数</span></h1><p><code>torch.masked_select(input, mask, out=None) → Tensor</code><br>返回1-D的Tensor</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>x = torch.randn(<span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x</span><br><span class="line">tensor([[ <span class="number">0.3552</span>, <span class="number">-2.3825</span>, <span class="number">-0.8297</span>,  <span class="number">0.3477</span>],</span><br><span class="line">        [<span class="number">-1.2035</span>,  <span class="number">1.2252</span>,  <span class="number">0.5002</span>,  <span class="number">0.6248</span>],</span><br><span class="line">        [ <span class="number">0.1307</span>, <span class="number">-2.0608</span>,  <span class="number">0.1244</span>,  <span class="number">2.0139</span>]])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>mask = x.ge(<span class="number">0.5</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>mask</span><br><span class="line">tensor([[<span class="keyword">False</span>, <span class="keyword">False</span>, <span class="keyword">False</span>, <span class="keyword">False</span>],</span><br><span class="line">        [<span class="keyword">False</span>, <span class="keyword">True</span>, <span class="keyword">True</span>, <span class="keyword">True</span>],</span><br><span class="line">        [<span class="keyword">False</span>, <span class="keyword">False</span>, <span class="keyword">False</span>, <span class="keyword">True</span>]])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>torch.masked_select(x, mask)</span><br><span class="line">tensor([ <span class="number">1.2252</span>,  <span class="number">0.5002</span>,  <span class="number">0.6248</span>,  <span class="number">2.0139</span>])</span><br></pre></td></tr></table></figure><p>【参考资料】</p><p><a href="http://www.linzehui.me/2018/10/12/%E7%A2%8E%E7%89%87%E7%9F%A5%E8%AF%86/%E6%B5%85%E8%B0%88mask%E7%9F%A9%E9%98%B5/" target="_blank" rel="noopener">浅谈mask矩阵</a><br><a href="https://github.com/xlwang233/pytorch-DCRNN/blob/master/lib/metrics.py" target="_blank" rel="noopener">pytorch-DCRNN</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h1&gt;&lt;p&gt;在计算loss和评价指标时，对一些不关注的值进行mask。下面介绍mask的使用。&lt;/p&gt;
    
    </summary>
    
      <category term="Deep Learning" scheme="http://yoursite.com/categories/Deep-Learning/"/>
    
    
      <category term="Deep Learning" scheme="http://yoursite.com/tags/Deep-Learning/"/>
    
  </entry>
  
  <entry>
    <title>Pytorch之知识点汇总</title>
    <link href="http://yoursite.com/2020/02/24/Pytorch%E4%B9%8B%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB/"/>
    <id>http://yoursite.com/2020/02/24/Pytorch之知识点汇总/</id>
    <published>2020-02-24T09:08:12.000Z</published>
    <updated>2020-06-17T07:53:06.914Z</updated>
    
    <content type="html"><![CDATA[<h1><span id="1-简介">1. 简介</span></h1><p>汇总Pytorch的一些知识点</p><a id="more"></a><!-- TOC --><ul><li><a href="#1-简介">1. 简介</a></li><li><a href="#2-查看网络参数">2. 查看网络参数</a></li><li><a href="#3-分类问题">3. 分类问题</a></li><li><a href="#4-crossentropyloss和nllloss-区别">4. CrossEntropyLoss()和NLLLoss() 区别</a></li><li><a href="#5-模型训练示例">5. 模型训练示例</a></li><li><a href="#6-关闭梯度">6. 关闭梯度</a></li><li><a href="#7-gpu">7. GPU</a></li><li><a href="#8-多gpu运行程序">8. 多GPU运行程序</a></li><li><a href="#9-tensor">9. Tensor</a></li><li><a href="#10-bn和dropout在训练和测试的不同">10. BN和Dropout在训练和测试的不同</a></li><li><a href="#11-linear">11. Linear</a></li><li><a href="#12-embedding">12. Embedding</a></li></ul><!-- /TOC --><h1><span id="2-查看网络参数">2. 查看网络参数</span></h1><ul><li><p>方法1</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> param <span class="keyword">in</span> network.parameters():</span><br><span class="line">  print(param.shape)</span><br></pre></td></tr></table></figure></li><li><p>方法2<br>可以查看参数的名称</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> name, param <span class="keyword">in</span> network.named_parameters():</span><br><span class="line">  print(name, <span class="string">'\t\t'</span>, param.shape)</span><br></pre></td></tr></table></figure></li></ul><h1><span id="3-分类问题">3. 分类问题</span></h1><p>例如Fashion-MNIST分类任务中，一共有10类。假设batch_size=16,每个batch的feature维度为(16,1,28,28)，label的维度(16,)，经过模型最终输出的预测结果维度(16,10)，然后我们使用<code>argmax()</code>来得出最终的预测类别。然后可以和真实label比较，看预测结果的正确性,计算预测正确的个数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&gt; preds.argmax(dim=<span class="number">1</span>)</span><br><span class="line">tensor([<span class="number">5</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">4</span>])</span><br><span class="line"></span><br><span class="line">&gt; labels</span><br><span class="line">tensor([<span class="number">9</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">3</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">7</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">5</span>])</span><br><span class="line"></span><br><span class="line">&gt; preds.argmax(dim=<span class="number">1</span>).eq(labels)</span><br><span class="line">tensor([<span class="keyword">False</span>, <span class="keyword">False</span>, <span class="keyword">False</span>, <span class="keyword">False</span>, <span class="keyword">False</span>, <span class="keyword">False</span>, <span class="keyword">False</span>, <span class="keyword">False</span>, <span class="keyword">True</span>, <span class="keyword">False</span>], dtype=torch.bool)</span><br><span class="line"></span><br><span class="line">&gt; preds.argmax(dim=<span class="number">1</span>).eq(labels).sum()</span><br><span class="line">tensor(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">&gt; preds.argmax(dim=<span class="number">1</span>).eq(labels).sum().item()</span><br><span class="line"><span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#得到每个batch预测正确的样本</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_num_correct</span><span class="params">(preds, labels)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> preds.argmax(dim=<span class="number">1</span>).eq(labels).sum().item()</span><br></pre></td></tr></table></figure><h1><span id="4-crossentropyloss和nllloss-区别">4. CrossEntropyLoss()和NLLLoss() 区别</span></h1><p><a href="https://blog.csdn.net/zwqjoy/article/details/96282788" target="_blank" rel="noopener">Pytorch nn.CrossEntropyLoss()和nn.NLLLoss() 区别</a></p><p><a href="https://www.cnblogs.com/marsggbo/p/10401215.html" target="_blank" rel="noopener">Pytorch里的CrossEntropyLoss详解</a>  </p><p><a href="https://www.zhihu.com/question/66782101" target="_blank" rel="noopener">PyTorch 中，nn 与 nn.functional 有什么区别</a></p><h1><span id="5-模型训练示例">5. 模型训练示例</span></h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">network = Network()</span><br><span class="line"></span><br><span class="line">train_loader = torch.utils.data.DataLoader(train_set, batch_size=<span class="number">100</span>)</span><br><span class="line">optimizer = optim.Adam(network.parameters(), lr=<span class="number">0.01</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> epoch <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">    </span><br><span class="line">    total_loss = <span class="number">0</span></span><br><span class="line">    total_correct = <span class="number">0</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> batch <span class="keyword">in</span> train_loader: <span class="comment"># Get Batch</span></span><br><span class="line">        images, labels = batch </span><br><span class="line"></span><br><span class="line">        preds = network(images) <span class="comment"># Pass Batch</span></span><br><span class="line">        loss = F.cross_entropy(preds, labels) <span class="comment"># Calculate Loss</span></span><br><span class="line"></span><br><span class="line">        optimizer.zero_grad()</span><br><span class="line">        loss.backward() <span class="comment"># Calculate Gradients</span></span><br><span class="line">        optimizer.step() <span class="comment"># Update Weights</span></span><br><span class="line"></span><br><span class="line">        total_loss += loss.item()</span><br><span class="line">        total_correct += get_num_correct(preds, labels)</span><br><span class="line"></span><br><span class="line">    print(</span><br><span class="line">        <span class="string">"epoch"</span>, epoch, </span><br><span class="line">        <span class="string">"total_correct:"</span>, total_correct, </span><br><span class="line">        <span class="string">"loss:"</span>, total_loss</span><br><span class="line">    )</span><br></pre></td></tr></table></figure><h1><span id="6-关闭梯度">6. 关闭梯度</span></h1><p>关闭梯度有2种方法</p><ul><li><p>方法1：在模型训练的时候，需要计算梯度，但是在测试的时候不需要计算梯度，那我们就可以使用<code>@torch.no_grad()</code>。下面代码示例求所有的预测结果</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@torch.no_grad()</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_all_preds</span><span class="params">(model, loader)</span>:</span></span><br><span class="line">    all_preds = torch.tensor([])</span><br><span class="line">    <span class="keyword">for</span> batch <span class="keyword">in</span> loader:</span><br><span class="line">        images, labels = batch</span><br><span class="line">        preds = model(images)</span><br><span class="line">        all_preds = torch.cat(</span><br><span class="line">            (all_preds, preds),dim=<span class="number">0</span>)</span><br><span class="line">  <span class="keyword">return</span> all_preds</span><br></pre></td></tr></table></figure></li></ul><p>使用<code>@torch.no_grad()</code>就不用再记录梯度的轨迹(不用再保存动态图的计算轨迹)，省内存。</p><ul><li><p>方法2：<br>使用<code>with torch.no_grad()</code>在函数内部</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> torch.no_grad():</span><br><span class="line">  prediction_loader = torch.utils.data.DataLoader(train_set, batch_size=<span class="number">10000</span>)</span><br><span class="line">  train_preds = get_all_preds(network, prediction_loader)</span><br></pre></td></tr></table></figure></li></ul><h1><span id="7-gpu">7. GPU</span></h1><p>在这里原先一直有个误区，误认为<code>device = torch.device(&quot;cuda&quot;)</code>获取所有的GPU，<code>device = torch.device(&quot;cuda:0&quot;)</code>获取第一个GPU。下面是正解：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#程序只能看到1,2,3序号的GPU，然后重新给它们编号为：0,1,2</span></span><br><span class="line">&gt; os.environ[<span class="string">"CUDA_VISIBLE_DEVICES"</span>] = <span class="string">'1,2,3'</span></span><br><span class="line"></span><br><span class="line">&gt; device = torch.device(<span class="string">"cuda:0"</span>)<span class="comment">#获取下标为0的GPU</span></span><br><span class="line">device(type=<span class="string">'cuda'</span>, index=<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#如果不指定cuda编号，其实有一个默认编号，</span></span><br><span class="line"><span class="comment">#默认为torch.cuda.current_device()，该值默认为0</span></span><br><span class="line">&gt; device = torch.device(<span class="string">"cuda"</span>)</span><br><span class="line">device(type=<span class="string">'cuda'</span>)</span><br><span class="line"></span><br><span class="line">&gt; torch.cuda.current_device()</span><br><span class="line"><span class="number">0</span></span><br></pre></td></tr></table></figure><p>也就是说<code>device = torch.device(&quot;cuda&quot;)</code>还是1个GPU，等价于<code>device = torch.device(&quot;cuda:X&quot;)</code>,其中<code>X = torch.cuda.current_device()</code>  </p><p>【<strong>参考资料</strong>】</p><p><a href="https://pytorch.apachecn.org/docs/1.0/tensor_attributes.html" target="_blank" rel="noopener">torch.device</a></p><p><a href="https://pytorch.org/docs/stable/notes/cuda.html" target="_blank" rel="noopener">CUDA SEMANTICS</a></p><h1><span id="8-多gpu运行程序">8. 多GPU运行程序</span></h1><p><a href="https://echohhhhhh.github.io/2020/01/06/Pytorch%E4%B9%8BGPU%E7%A8%8B%E5%BA%8F/" target="_blank" rel="noopener">Pytorch之GPU程序</a></p><p><a href="https://echohhhhhh.github.io/2019/12/29/%E8%BF%90%E8%A1%8CGPU%E7%A8%8B%E5%BA%8F/" target="_blank" rel="noopener">运行GPU程序</a></p><h1><span id="9-tensor">9. Tensor</span></h1><p><a href="https://echohhhhhh.github.io/2020/02/17/Pytorch%E4%B9%8BTensor%E5%AD%A6%E4%B9%A0/" target="_blank" rel="noopener">Pytorch之Tensor学习</a></p><h1><span id="10-bn和dropout在训练和测试的不同">10. BN和Dropout在训练和测试的不同</span></h1><p><code>model.train()</code>:启用 BatchNormalization 和 Dropout<br><code>model.eval()</code>:不启用 BatchNormalization 和 Dropout<br>训练完train样本后，生成的模型model要用来测试样本。在model(test)之前，需要加上model.eval()，否则的话，有输入数据，即使不训练，它也会改变权值。这是model中含有batch normalization层所带来的的性质。</p><p>参考资料<br><a href="https://zhuanlan.zhihu.com/p/54986509" target="_blank" rel="noopener">Pytorch model.train 与 model.eval</a><br><a href="https://discuss.pytorch.org/t/model-eval-vs-with-torch-no-grad/19615/19" target="_blank" rel="noopener">‘model.eval()’ vs ‘with torch.no_grad()’</a><br><a href="https://github.com/pytorch/examples/blob/master/word_language_model/main.py" target="_blank" rel="noopener">https://github.com/pytorch/examples/word_language_model</a></p><h1><span id="11-linear">11. Linear</span></h1><p>原先误以为Pytorch中的Linear的输入只能接受二维数据，实际上Linear的输入数据可以是三维、四维等更多维。但是<strong>输入数据的最后一维一定要和<code>in_dim</code>一致，输出数据维度就是把<code>in_dim</code>换成了<code>out_dim</code>，前面所有的维度都不变</strong>。<br>例如定义一个全连接<code>nn.Linear(10,5)</code>，输入数据维度为(3,6,10),输出维度为(3,6,5)。即输入数据最后一个维度一定要和<code>in_dim</code>一致，也不用纠结到底3是batch_size,还是6是batch_size，因为最终输出的数据只有最后一个维度变化，前面维度都不变。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dense = nn.Linear(in_dim,out_dim)</span><br></pre></td></tr></table></figure><hr><p>2020.3.7更新</p><h1><span id="12-embedding">12. Embedding</span></h1><p><code>Embedding</code>层常用在词嵌入中，目的是将高维数据变成稠密的低维数据。例如：字典共9个字：[我,你,看,吃,吧,吗,饭,了,的]，例句：吃饭了吗，对这句话用向量表示有2种方式：</p><ul><li>one-hot表示<br>[0,0,0,1,0,0,0,0,0],<br>[0,0,0,0,0,0,1,0,0],<br>[0,0,0,0,0,0,0,1,0],<br>[0,0,0,0,0,1,0,0,0]<br>one-hot表示过于稀疏，如果字典中的层变大，维度会非常高</li><li><p>使用<code>Embedding</code>,字典中共有9个字，下标从0~8，例句被表示为[3,6,7,5],但是只用数字并不能表示字的含义和相似度，下面使用Embedding对其嵌入。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># example with padding_idx</span></span><br><span class="line">embedding = nn.Embedding(<span class="number">9</span>, <span class="number">3</span>)</span><br><span class="line">input = torch.LongTensor([[<span class="number">3</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">5</span>]])</span><br><span class="line">embedding(input)</span><br><span class="line">tensor([[[ <span class="number">0.0000</span>,  <span class="number">0.0000</span>,  <span class="number">0.0000</span>],</span><br><span class="line">       [ <span class="number">0.1535</span>, <span class="number">-2.0309</span>,  <span class="number">0.9315</span>],</span><br><span class="line">       [ <span class="number">0.0000</span>,  <span class="number">0.0000</span>,  <span class="number">0.0000</span>],</span><br><span class="line">       [<span class="number">-0.1655</span>,  <span class="number">0.9897</span>,  <span class="number">0.0635</span>]]])</span><br></pre></td></tr></table></figure><blockquote><p>CLASS torch.nn.Embedding(num_embeddings, embedding_dim, padding_idx=None, max_norm=None, norm_type=2.0, scale_grad_by_freq=False, sparse=False, _weight=None)</p></blockquote><p><strong>num_embeddings</strong>：原始数据维度，例如字典中有9个字，该值为9<br><strong>embedding_dim</strong>：嵌入维度，每个字用3维向量表示，该值为3<br><strong>输入维度</strong>：(<em>)任意维度<br><strong>输出维度</strong>：(\</em>,embedding_dim)，*表示输入维度<br>例如输入维度(16,100),输出为(16,100,3)，表示有16个句子，每个句子100个字，经过Embedding层后，有16个句子，每个句子100个字，每个字用3维特征表示。</p><p>在时空领域中，经常需要考虑外部因素，例如时间，天气，holiday等，需要对外部因素进行Embedding，例如<a href="https://github.com/UrbComp/DeepTTE" target="_blank" rel="noopener">https://github.com/UrbComp/DeepTTE</a></p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;1-简介&quot;&gt;&lt;a href=&quot;#1-简介&quot; class=&quot;headerlink&quot; title=&quot;1. 简介&quot;&gt;&lt;/a&gt;1. 简介&lt;/h1&gt;&lt;p&gt;汇总Pytorch的一些知识点&lt;/p&gt;
    
    </summary>
    
      <category term="Deep Learning" scheme="http://yoursite.com/categories/Deep-Learning/"/>
    
    
      <category term="Pytorch" scheme="http://yoursite.com/tags/Pytorch/"/>
    
  </entry>
  
  <entry>
    <title>RiskOracle-A Minute-level Citywide Traffic Accident Forecasting Framework</title>
    <link href="http://yoursite.com/2020/02/18/RiskOracle-A-Minute-level-Citywide-Traffic-Accident-Forecasting-Framework/"/>
    <id>http://yoursite.com/2020/02/18/RiskOracle-A-Minute-level-Citywide-Traffic-Accident-Forecasting-Framework/</id>
    <published>2020-02-18T03:34:20.000Z</published>
    <updated>2020-04-03T16:06:10.102Z</updated>
    
    <content type="html"><![CDATA[<p>AAAI2020原文链接：<a href="https://github.com/zzyy0929/AAAI2020-RiskOracle" target="_blank" rel="noopener">RiskOracle-A Minute-level Citywide Traffic Accident Forecasting Framework</a><br>中国科大发<br><a id="more"></a></p><!-- TOC --><ul><li><a href="#1-%e6%91%98%e8%a6%81">1. 摘要</a></li><li><a href="#2-%e4%bb%8b%e7%bb%8d">2. 介绍</a></li><li><a href="#%e8%b4%a1%e7%8c%ae">贡献</a></li><li><a href="#3-%e9%97%ae%e9%a2%98%e5%ae%9a%e4%b9%89">3. 问题定义</a></li><li><a href="#4-minute-level-real-time-traffic-accident-forecasting">4. Minute-level Real-time Traffic Accident Forecasting</a><ul><li><a href="#41-framework-overview">4.1. Framework Overview</a></li><li><a href="#42-data-preprocessing">4.2. Data Preprocessing</a></li><li><a href="#43-multi-task-dtgn-for-accident-risk-prediction">4.3. Multi-task DTGN for Accident Risk Prediction</a></li></ul></li><li><a href="#5-%e5%ae%9e%e9%aa%8c">5. 实验</a><ul><li><a href="#51-%e6%95%b0%e6%8d%ae%e5%87%86%e5%a4%87">5.1. 数据准备</a></li><li><a href="#52-%e5%ae%9e%e7%8e%b0%e7%bb%86%e8%8a%82">5.2. 实现细节</a></li><li><a href="#53-%e8%af%84%e4%bb%b7%e6%8c%87%e6%a0%87">5.3. 评价指标</a></li><li><a href="#54-baseline">5.4. Baseline</a></li><li><a href="#55-%e5%ae%9e%e9%aa%8c%e7%bb%93%e6%9e%9c">5.5. 实验结果</a></li><li><a href="#56-%e8%b6%85%e5%8f%82%e6%95%b0">5.6. 超参数</a></li><li><a href="#57-%e6%a1%88%e4%be%8b%e5%88%86%e6%9e%90">5.7. 案例分析</a></li></ul></li><li><a href="#6-%e6%80%bb%e7%bb%93">6. 总结</a></li><li><a href="#7-%e7%9f%a5%e8%af%86%e8%a1%a5%e5%85%85">7. 知识补充</a></li></ul><!-- /TOC --><p>论文总结：</p><ol><li>根据网格构建图，将NYC划分了27*27个网格，但是其中只有354个网格有道路，所以图中有354个节点。</li><li>根据网格之间道路相似性和历史一周交通的动态相似性来构建图中边的权重。构建的是全连通图，计算任意2个子区域的相似性</li><li>多任务学习。主任务：预测m个子区域的risk，辅助任务1：预测m个子区域的flow，辅助任务2：预测q个中等区域的事故次数count</li><li>在训练时，将risk=0替换为对应的负值，使用全部的数据。在测试时，只计算高频时间段和高频区域的评价指标</li></ol><h1><span id="1-摘要">1. 摘要</span></h1><p>&ensp;&ensp;&ensp;&ensp;实时交通事故预测对公共安全和城市管理意义重大（例如.实时路径规划和应急响应部署）。之前的事故预测是在小时级别上，利用神经网络和静态的区域关系。然而，随着道路网络的高度动态性和交通师傅的稀有性，提高预测的粒度仍然是一个挑战，这将会导致结果偏差和零膨胀问题。在这篇论文中，我们提出一个新颖的RiskOracle框架，提高预测的粒度到分钟级别。具体来说，我们首先将0风险值转换为适合网络训练的值，然后，我们提出差分时变图神经网络(DTGN)来捕获交通状态的即时变化和子区间之间的动态相关性，并且，我们采用多任务和区域选择方案来突出显示全市范围内最可能发生事故的子区域，弥合了偏差的风险值和稀疏的事故分布。在2个真实数据集上做了大量实验证明了我们的RiskOracle框架的有效性和可扩展性。</p><h1><span id="2-介绍">2. 介绍</span></h1><p>&ensp;&ensp;&ensp;&ensp;交通事故预测对城市安全非常重要。构建一个细粒度级的事故预测模型，为乘客提供及时的安全路径规划，为新兴应用(智能交通和自动驾驶)提供准确的应急响应的需求越来越大。<br>&ensp;&ensp;&ensp;&ensp;关于事故预测周期的长短，现有的工作主要分为2类：长期（天级别预测）和中期（小时级别预测）。我们在表1中总结了所有相关的工作。即使最近关于天级别的预测模型通过建模时空异质数据取得了很好的效果，但是对于紧急的情况并没有意义。<br>&ensp;&ensp;&ensp;&ensp;在小时级别上的中期事故预测可以进一步划分为：传统方法和深度学习。传统方法包括：基于聚类，基于频率树，基于非负矩阵分解。但是，这些方法忽略了时间关系，不能建模复杂非线性的时空关系。深度学习方法例如，仅仅将历史交通事故数据输入到模型中，利用LSTM学习时间相关性，缺少了多源实时交通数据，效果不好。还有一些工作利用深度学习框架SDAE/SDCAE和ConvLSTM，结合人类实时移动数据，来学习交通事故模式，但是它们都不能提取区域间和区域内随时间变化的关系。<br>&ensp;&ensp;&ensp;&ensp;即使深度学习模型的进展为小时级别的事故预测带了可喜的结果，但是我们认为其忽略了3个重要的问题，使得在分钟级别的预测效果较差。第一，在2019中提到的，当预测任务的时空分辨率提高时，会出现零膨胀问题，将预测所有的结果都为0。由于没有方法来解决这个问题，稀少的非零值在训练时使模型无法生效。第二，尽管CNN可以学习静态的子区域相关性，但是随时间变化的子区域相关性在城市短期事故预测有着重要的作用，例如，由于潮汐流，2个子区域在早上相关性强，在下午相关性弱。第三，在同一子区域相邻时间段内交通状况的异常变化通常会诱发交通事故或其他事件。没有考虑以上3个时空因素，小时级别的预测模型能力将受到严重阻碍。</p><p><img src="/2020/02/18/RiskOracle-A-Minute-level-Citywide-Traffic-Accident-Forecasting-Framework/Summarization.png" alt=""></p><p>表中的论文<br><a href="https://echohhhhhh.github.io/2019/07/21/traffic-accident/#11-learning-deep-representation-from-big-and-heterogeneous-data-for-traffic-accident-inference2016aaai" target="_blank" rel="noopener">Learning Deep Representation from Big and Heterogeneous Data for Traffic Accident Inference(2016AAAI)</a></p><p><a href="https://echohhhhhh.github.io/2019/07/21/traffic-accident/#14-a-deep-learning-approach-to-the-citywide-traffic-accident-risk-prediction2018ieee-itsc" target="_blank" rel="noopener">A Deep Learning Approach to the Citywide Traffic Accident Risk Prediction(2018IEEE-ITSC)</a></p><p><a href="http://tony.9shi.cf/index.php?q=aHR0cHM6Ly93d3cua2RkLm9yZy9rZGQyMDE4L2FjY2VwdGVkLXBhcGVycy92aWV3L2hldGVyby1jb252bHN0bS1hLWRlZXAtbGVhcm5pbmctYXBwcm9hY2gtdG8tdHJhZmZpYy1hY2NpZGVudC1wcmVkaWN0aW9uLW9uLQ" target="_blank" rel="noopener">Hetero-ConvLSTM: A Deep Learning Approach to Traffic Accident Prediction on Heterogeneous Spatio-Tem(2018KDD)</a></p><p>&ensp;&ensp;&ensp;&ensp;这篇论文，我们研究了分钟级别的全市交通事故预测，提出了三阶段RiskOracle框架，该框架基于多任务差分时变图卷积(Multi-task DTGN)。三个阶段分别是：数据预处理阶段，训练阶段，预测阶段。在数据预处理阶段，我们提出一个感知策略以最大程度地推断全球交通状况，然后设计基于数据增强的先验知识来解决短期预测中的零膨胀问题。在训练阶段，我们提出Multi-task DTGN，其中时变总体上建模了短期子区域的动态相关性，差分特征生成器在交通状态即时变化和交通事故之间建立了高级联系。正如我们所知，交通事故和交通量在城市中通常分布不均衡，因此多任务方案旨在解决事故预测中的空间异质性，然后在预测阶段，我们利用学到的多尺度事故分布，获取到一组离散的最可能发生事故的子区域。在2个真实数据集上的实验证明了我们的框架在10-min和30-min级别的预测任务上都超过了state-of-the-art。</p><h1><span id="贡献">贡献</span></h1><ul><li>提升实时事故预测的时间粒度，从小时—&gt;分钟</li><li>提出多任务STDN来解决短期事故预测的挑战。这是第一篇使用图卷积来解决事故预测问题</li><li>距离远但是有潜在关系的区域在图中可以被动态连接</li><li>通过差分特征生成器，交通状况的异常变化可以被捕获</li><li>多任务学习用来解决稀疏和空间异质性问题。多尺度的事故分布可以突出强调最可能发生交通事故的子区域</li><li>提出数据增强策略来解决零膨胀问题</li><li>提出协同感知策略来处理稀疏的感知数据</li></ul><h1><span id="3-问题定义">3. 问题定义</span></h1><p>&ensp;&ensp;&ensp;&ensp;在这一节，介绍基本定义，使用公式定义问题。<br>&ensp;&ensp;&ensp;&ensp;在我们的工作中，如果直接将整个研究区域作为方形区域，使用CNN进行时空特征提取，尤其在实时事故预测中，则会导致不必要的冗余，因为城市轮廓通常是不规则的。如图2(a)所示，我们首先将路网中研究区域划分为<code>q</code>个中等大小的矩形区域，每一个矩形区域包含一些小的方形子区域。一共有<code>m</code>个子区域(subregion)，我们通过城市图对<code>m</code>个子区域建模。</p><p><strong>定义1：Urban Graph</strong>：研究区域可以定义成无向图，用$G(\mathcal{V},\mathcal{E})$表示。顶点集$\mathcal{V}=\{v_1,v_2,…,v_m\}$，其中$v_i$表示第$i$个方形子区域，给定2个节点$v_i,v_j\in \mathcal{V}$,边$e_{ij} \in \mathcal{E}$表示2个subregion的连接，边非0即1。</p><script type="math/tex; mode=display">e_{i j}=\left\{\begin{array}{ll}{1} & {\text { if the traffic elements within two }} \\ {} & {\text { subregions have strong correlations }} \\ {0} & {\text { otherwise }}\end{array}\right.</script><blockquote><p>上面邻接矩阵的定义只是为了图定义的完整性，本文用到的邻接矩阵并不是非0即1的</p></blockquote><p>&ensp;&ensp;&ensp;&ensp;在该论文中，1个节点的<code>traffic element</code>包括2方面，静态的道路特征和动态的traffic特征。$\rho$来控制<code>affinity matrix</code>$\mathcal{A}_s$和$\mathcal{A}^{\Delta t}_o$的稀疏性，表示整个<code>urban graph</code>的连通性，在<code>affinity matrix</code>中的非0值表示subregion之间有很强的相关性。<br>&ensp;&ensp;&ensp;&ensp;在一个时间段$\Delta t$中<code>subregion</code> $v_i$的动态traffic特征包括3部分，(a)人流量，用<code>traffic volume</code>$TV_{v_i}(\Delta t)$表示;(b)交通状况，用平均交通速度$a_{v_i}(\Delta t)$表示;(c)交通事故风险等级$r_{v_i}(\Delta t)$。</p><p><strong>定义2：Static Road Network Features</strong>：一个城市<code>subregion</code>节点$v_i \in \mathcal{V}$,它的静态路网特征包括道路个数，道路类型，道路长度和宽度，除雪等级，红绿灯个数，<code>subregion</code> $v_i$中的所有道路使用一个固定长度的向量$s_i$表示。整个<code>urban graph</code>的静态道路特征使用$S=\{s_1,s_2,…,s_m\}$表示。静态特征，不随着时间变化，没有时间下标。</p><p><strong>定义3：Dynamic Traffic Features</strong>：对一个<code>subregion</code>节点$v_i \in \mathcal{V}$,在时间段$\Delta t$中，它的动态交通特征被表示为$f_{v_i}(\Delta t)=\left\{T V_{v_{i}}(\Delta t), a_{v_{i}}(\Delta t), r_{v_{i}}(\Delta t)\right\}$，即该时间段的车流量，车平均速度，事故风险，$r_{v_i}(\Delta t)$是交通事故的risk求和，将交通事故分为3类：轻度，中度，重度，risk值分别是1,2,3.所有子区域在时间段$\Delta t$的交通事故风险分布表示为$\mathcal{R}(\Delta t)=\left\{r_{v_{1}}(\Delta t), r_{v_{2}}(\Delta t), \cdots, r_{v_{m}}(\Delta t)\right\}$，动态交通特征表示为$\mathcal{F}(\Delta t)=\left\{f_{v_{1}}(\Delta t), f_{v_{2}}(\Delta t), \cdots, f_{v_{m}}(\Delta t)\right\}$。动态交通特征随着时间变化，所以有区域和时间2个变量，动态特征包括：人流量，交通平均速度，事故风险</p><p><strong>定义4:Traffic Accident Prediction</strong>：给定所有子区域的静态道路特征$S$和所有子区域历史$T$个时间段的动态交通特征$\mathcal{F}(\Delta t)(\Delta t=1,2,…,T)$,目标是预测下一个时间段全市的事故风险$\mathcal{R}(T+1)$和选出高风险的子区域$\mathcal{V}_{acc}(T+1)$</p><blockquote><p>总结：根据m个子区域构建无向图，节点表示子区域，边表示2个子区域特征之间的相关性。子区域的特征包括2类：静态道路特征和动态交通特征。静态道路特征包括：道路个数，道路类型，长宽，道路除雪等级，红绿灯个数。动态交通特征包括：在该时间段内的车流量，车平均速度，该子区域事故风险。</p></blockquote><h1><span id="4-minute-level-real-time-traffic-accident-forecasting">4. Minute-level Real-time Traffic Accident Forecasting</span></h1><p>&ensp;&ensp;&ensp;&ensp;在这一节，先整体看一下我们的<code>RiskOracle</code>框架，然后再详细介绍。</p><p><img src="/2020/02/18/RiskOracle-A-Minute-level-Citywide-Traffic-Accident-Forecasting-Framework/RiskOracle.png" alt=""></p><h2><span id="41-framework-overview">4.1. Framework Overview</span></h2><p>&ensp;&ensp;&ensp;&ensp;如图1所示，<code>RiskOracle</code>框架包括3个阶段：数据预处理阶段，训练阶段，预测阶段。</p><h2><span id="42-data-preprocessing">4.2. Data Preprocessing</span></h2><p><strong>解决事故预测中的空间异质</strong>。高风险的值通常出现在城市区域，由于市中心发生事故多且车流量大，导致风险值在空间上不均衡，会忽略农村地区相对高风险的区域。为了实现全市预测，选择最有可能发生事故的区域来解决空间异质性是非常必要的。如图2(a)所示,按照层次结构组织这个子区域，中等大小区域用来收集粗粒度的事故分布，小的子区域用来收集细粒度的事故分布，然后进一步突出显示每个中等区域中的子区域。多尺度分布也可以看做分层事故分布。<br><strong>解决零膨胀问题</strong>。深度神经网络在训练中，如果非零值非常少的话，受到零膨胀的影响，将会预测出无效的值。如图2(b)所示，在选定的10min中，整个NYC只有6个交通事故，说明在短期事故的内在稀有性。为了解决这个问题实现实时事故预测，我们设计基于先验知识的数据增强(PKDE)策略来区分训练数据集中标签的风险值。具体来说，对时间段$\Delta t$,我们将所有区域在该时间段内的风险值$\mathcal{R}(\Delta t)$中的0转换为具有区分度的负值。转换分为2步：a)风险中的0值通过等式2转换为事故风险指标；b)指标值通过等式3转换为静态事故强度。给定子区域$v_i$，我们计算它的事故风险指标$\varepsilon_{v_i}$  ，事故风险指标是个比例值，在[0,1]之间</p><script type="math/tex; mode=display">\varepsilon_{v_{i}}=\frac{1}{N_{\text {week}}} \sum_{j=1}^{N_{\text {week}}} \frac{r_{v_{i}}(j)}{\sum_{k=1}^{m} r_{v_{k}}(j)}</script><p>其中$N_{week}$是训练集中总共的周数，$r_{v_{i}}(j)$是区域$v_i$在第$j$周总的风险值。然后，根据该子区域的事故风险指标$\varepsilon_{v_i}$,我们通过以下公式计算子区域$v_i$的统计事故强度。  </p><script type="math/tex; mode=display">\pi_{v_{i}}=b_{1} \log _{2} \varepsilon_{v_{i}}+b_{2}</script><blockquote><p>总结：给定时间段$\Delta t$，将子区域中的riks 0值转换为负值，先计算事故风险指标，再计算事故强度。有m个子区域，每个子区域都有一个固定的事故强度，将该子区域risk=0值用该子区域的事故强度替换</p></blockquote><p>其中$b_1$和$b_2$是算子，用来保持绝对值$\pi_{v_{i}}$的范围和真实风险值的范围对称。我们通过对数在0和1之间的区分性质，可以使转换后的数据易于区分并适合于训练网络。转换的方式为：1)事故风险为0的子区域的事故强度为负，小于非零风险的子区域，反映了零风险子区域有较低的事故风险;2)具有较低事故风险指标的子区域有较低的事故概率，保留了实际事故风险的等级。<br>事故风险指数$\varepsilon_{v_{i}}$值在[0,1]之间，取对数值在$(-\infin,0]%$，如果一个子区域的风险值为0，则事故风险指数为0，则事故强度$\pi_{v_{i}}$为负。</p><blockquote><p>其中b1和b2的值是反复试出来的。为了保证事故强度的绝对值和真实风险范围对称。假设真实风险在1至25之间，那事故强度的值要在-25至-1之间，通过设置b1和b2强度值在-25~-1</p></blockquote><p><img src="/2020/02/18/RiskOracle-A-Minute-level-Citywide-Traffic-Accident-Forecasting-Framework/nyc-map.png" alt=""></p><p><strong>补充稀疏的传感数据</strong>。实时交通信息的通常收集不足来进行事故预测，动态交通信息通常和静态空间路网结构相互影响，因此，我们提出了一个协同感知策略，利用FM的交互操作，修改<code>xDeepFM</code>为时空深度因式分解(ST-DFM)。<br>我们首先通过静态关联矩阵$\mathcal{A}_s$来提取2个子区域间的路网相似性和连接性。其中关联矩阵affinity matrix中的元素$\alpha_s(i,j)$表示子区域$v_i和v_j$间的静态相关性。</p><script type="math/tex; mode=display">\alpha_{s}(i, j)=\left\{\begin{array}{cc}{1} & {\text { if subregion } v_{i} \text { and }} {v_{j}} {\text { are adjacent }} \\{e^{-J S\left(s_{i} \| s_{j}\right)}} & {\text { otherwise }}\end{array}\right.</script><p>其中，$JS$函数是Jensen-Shannon divergence（散度），$s_{i}和s_{j}$是子区域$i,j$的静态道路特征，包括道路个数，类型，长宽，除雪等级，红绿灯个数。</p><script type="math/tex; mode=display">J S\left(s_{i} \| s_{j}\right)=\frac{1}{2} \sum_{k}\left(\begin{array}{c}{s_{i}(k) \log \frac{2 s_{i}(k)}{s_{i}(k)+s_{j}(k)}+} \\{s_{j}(k) \log \frac{2 s_{j}(k)}{s_{i}(k)+s_{j}(k)}}\end{array}\right)</script><p>和xDeepFM一样，ST-DFM包含压缩交互网络模块和DNN模块。在ST-DFM中嵌入了3个时空字段，即静态空间特征，动态交通特征和时间戳。然后ST-DFM通过CIN模块学习矢量级别不同时空特征间的交互关系，通过DNN模块学习特征的高级表示，最后获取高级特征的组合。我们将对应子区间的交通量输入到ST-DFM中来推断速度值，反之亦然。然后通过训练2个实时交通数据的交集数据，来最大程度推断交通信息，以此获取全局交通状态。</p><blockquote><p>补充：JS散度是一个衡量距离的函数，JS散度的值域在[0,1]之间，相同为0，反之为1。静态affinity matrix $\mathcal{A}_s \in R^{m \times m}$，如果2个子区域相邻，值为1，不相邻则计算2个子区域的静态道路特征的相似度，值在$[\frac{1}{e},1]$之间，越相似，值越靠近1，越不相似，值越靠近$\frac{1}{e}$<br>通过静态道路特征构建一个全连接图，任意2个节点都有边相连，只是权重不同。如果2个子区域相邻，边权重为1，如果子区域不相邻，计算2个子区域间的JS散度</p></blockquote><h2><span id="43-multi-task-dtgn-for-accident-risk-prediction">4.3. Multi-task DTGN for Accident Risk Prediction</span></h2><p><strong>时空DTGN</strong>.事故和交通拥堵在路网中通常相互影响，特别是节假日和高峰。由于GCN对非欧式空间很好的建模，我们提出了DTGN，通过time-varying overall affinity和differential feature generator来修改GCN，解决分钟级别预测事故的挑战。</p><p><strong>Time-varying overall affinity matrix with dynamic traffic features involved</strong>. 不同城市分区之间的交通状况有很强的时变相关性。并且，交通事故和交通状况有很强的时空相关性。因此，对于分钟级别的事故预测，需要通过动态affinity matrix $\mathcal{A}^{\Delta t}_o$捕获子区域间在时间段$\Delta t$的时间交通相关性。在$\mathcal{A}^{\Delta t}_o$中的元素$\alpha^{\Delta t}_o(i,j)$表示子区域$i,j$的动态相似性。</p><script type="math/tex; mode=display">\alpha_{O}^{\Delta t}(i, j)=e^{-J S\left(s_{i}^{*} \| s_{j}^{*}\right)}+\gamma * e^{-J S\left(C_{i}^{\Delta t} \| C_{j}^{\Delta t}\right)}</script><p>其中$C_{i}^{\Delta t}$表示子区域$v_i$上周每一天相同时间段的交通量$TV_{v_i}(\Delta t)$和平均速度$a_{v_i}(\Delta t)$。注意我们使用Attention机制，根据子区域的静态空间特征对事故的影响，修改了子区域静态空间特征的权重。并且子区域的静态特征表示为$s^*_i$.权重$\gamma$用来调节动态交通affinity占overall affinity matrix的比例。通过overall affinity matrix，距离较远但有潜在事故相关的子区域可以被动态连接。为了在谱域运行GCN，我们需要计算动态affinity matrix $\mathcal{A}^{\Delta t}_o$的拉普拉斯矩阵$L^{\Delta t}$，其中$\mathcal{A}^{\Delta t}_o$可以被看做邻接矩阵。首先定义$\mathcal{B}^{\Delta t}$</p><script type="math/tex; mode=display">\mathcal{B}^{\Delta t}=\mathcal{A}_{o}^{\Delta t}+I_{m}</script><p>其中$I_{m}$是维度$m \times m$的单位矩阵。然后计算度矩阵$\Phi^{\Delta t}$</p><script type="math/tex; mode=display">\Phi^{\Delta t}=\left[\begin{array}{cccc}{\varphi_{11}} & {0} & {\cdots} & {0} \\{0} & {\varphi_{22}} & {\cdots} & {0} \\{\vdots} & {\vdots} & {\ddots} & {\vdots} \\{0} & {0} & {\cdots} & {\varphi_{m m}}\end{array}\right]</script><p>其中$\varphi_{i i}=\sum_{j=1}^{m} b_{i j}$，将矩阵$\mathcal{B}^{\Delta t}$每一行的元素相加组成度矩阵。然后获取时间段$\Delta t$的拉普拉斯矩阵。</p><script type="math/tex; mode=display">L^{\Delta t}=\left(\Phi^{\Delta t}\right)^{-\frac{1}{2}} \mathcal{B}^{\Delta t}\left(\Phi^{\Delta t}\right)^{-\frac{1}{2}}</script><blockquote><p>补充：原始GCN中，拉普拉斯矩阵为$\hat{D}^{-\frac{1}{2}}\hat{A}\hat{D}^{-\frac{1}{2}}$，其中$\hat{A}=A+I$</p><p>总结：文中提到的affinity matrix有2类：静态affinity matrix $\mathcal{A}_s$和动态overall affinity matrix $\mathcal{A}_o^{\Delta t}$，这2个矩阵的维度都是$R^{m \times m}$，其中静态affinity matrix不随着时间变化，根据子区域的静态道路特征计算得到。动态overall affinity matrix随着时间变化，由子区域的静态道路特征和上周每一天同时间段的动态交通特征(车流量和车平均速度)计算得来。这里将动态overall affinity matrix看做邻接矩阵，计算拉普拉斯矩阵，每个时间段都有一个拉普拉斯矩阵，用在GCN中。</p></blockquote><p><strong>Differential GCN for extracting spatiotemporal features</strong>和常规的交通状况相比，事故或事件预测和交通状况的异常变化更相关。因此，我们引入了差分特征生成器来计算相邻时间段的差分图片。将差分动态交通特征输入到GCN中，可以对交通状况的异常变化的传播和相互作用进行建模，并且可以学习即时的交通状态变化和事故之间的高层关系，可以更好地用来分钟级的事故预测。给定时间段$\Delta t$,差分向量$\vec{\Theta}^{\Delta t}$计算如下：</p><script type="math/tex; mode=display">\vec{\Theta}^{\Delta t}=\mathcal{D}(\Delta t)-\mathcal{D}(\Delta t-1)</script><p>其中$\mathcal{D}(\Delta t)=\left\{d_{v_{1}}(\Delta t), d_{v_{2}}(\Delta t), \cdots, d_{v_{m}}(\Delta t)\right\}$,$d_{v_{i}}(\Delta t)=\left\{T V_{v_{i}}(\Delta t), a_{v_{i}}(\Delta t)\right\}$，差分不涉及到事故风险的计算。在时间段$\Delta t$中所有的子区域通过结合它们的动态交通特征和对应的差分向量，生成了统一的特征元组$\mathcal{U}(\Delta t)=\left\{\mathcal{F}(\Delta t), \vec{\Theta}^{\Delta t}\right\}$,在郑宇AAAI2017 ST-ResNet文中提到的，城市交通有3个时间周期：小时，天，长期趋势。所以，预测时间段$\Delta t$，我们选取$\mathcal{k}$个统一特征元组，按照ST-ResNet，设置$\mathcal{k}=3$,作为DTGN的输入。具体来说，选取时间段$\Delta t$的前$\mathcal{k}$个时间段作为小时周期，选取连续前$\mathcal{k}$天中相同的时间段作为天周期，至于长期趋势，向前每10天取1天，一共取$\mathcal{k}$天,在这$\mathcal{k}$天种，取相同的时间段作为长期趋势。即hour周期有$\mathcal{k}$个时间段,天周期有$\mathcal{k}$个时间段，长期区域有$\mathcal{k}$个时间段。如图1所示，将这3个时间周期的二元组分别输入到3个DTGN中。其中DTGN的模型细节在图3(a)中。对于每一个时间周期，将它的特征二元组用$\mathbb{U}_{<em>} \Delta t$表示，将$\mathbb{U}_{</em>} \Delta t$输入到FCN中，将特征嵌入成低维特征，然后输入到GCN中。</p><script type="math/tex; mode=display">\mathcal{H}^{n+1}=\text{Leaky-ReLU}(L^*  \mathcal{H}^{n} \mathcal{W}^{n}),\text { where } \mathcal{H}^{0}=\mathbb{U}_{*}^{\Delta t}</script><p>其中$\mathcal{H}^{n}$表示第n层GCN输入的特征，$\mathcal{W}^{n}$表示第n层GCN的卷积核参数。因为每个时间周期会输出多个时间段的数据，在做GCN操作时，需要用到拉普拉斯矩阵，这里的$L^*$是输入所有时间段的拉普拉斯矩阵$L^{\Delta t}$的平均。每2个GCN后使用1次BN，防止梯度爆炸。考虑到转换后的risk中有负值，使用Leaky_ReLU激活。同时，对应时间段的外部数据(时间戳和天气)经过嵌入层变成定长的向量，再和GCN的输入融合。因为有3个时间周期，DTGN有3个输出，分别用$\mathcal{O}_{h c}^{\Delta t}, \mathcal{O}_{d p}^{\Delta t}$ and $\mathcal{O}_{d t}^{\Delta t}$表示。</p><p><img src="/2020/02/18/RiskOracle-A-Minute-level-Citywide-Traffic-Accident-Forecasting-Framework/DTGN.png" alt=""></p><blockquote><p>总结：每一个时间段有一个差分向量，是该时间段所有区域的车流量和车平均速度减去上一时间段的值，得到差分向量。然后将该时间段所有子区域的动态交通特征$\mathcal{F}(\Delta t)$和该时间段的差分向量$\vec{\Theta}^{\Delta t}$组成一个统一的特征元组$\mathcal{U}(\Delta t)$。那么每个时间段都有一个特征元组，存储所有子区域的特征。受郑宇2017AAAI ST-ResNet的启发，事故的发生有小时，天，长期的周期性，假设预测时间段是t，为其找出小时，天，长期的时间段。小时周期：[t-1,t-2,t-3]，天周期：[昨天t,前天t,大前天t]，长期周期[10天前t,20天前t,30天前t],然后分别输入到3个DTGN中。这个拿1个DTGN举例。输入的图信号矩阵维度是(batch_size,N,T<em>D)=(batch_size,N,3\</em>5)将时间维度乘到特征上，先经过FCN对特征进行嵌入，变成低维特征。然后输入到GCN中，GCN操作需要使用拉普拉斯矩阵。上节中提到拉普拉斯矩阵是动态的，每一个时间段都有一个L，这里每个周期都有3个时间段，使用的拉普拉斯矩阵是3个时间段拉普拉斯矩阵的平均值。<br>预测第t时间段的risk，输入的图信号矩阵：<br>小时周期：<br>t-1,t-2,t-3时刻：车流，车速，risk，$\Delta$车流，$\Delta$车速<br>天周期：<br>昨天t，前天t，大前天t时刻：车流，车速，risk，$\Delta$车流，$\Delta$车速<br>周周期：<br>10天前t，20天前t，30天前t时刻：车流，车速，risk，$\Delta$车流，$\Delta$车速<br>一共有3个组件，每个组件输入的维度是(batch_size,N,3*5)</p></blockquote><p><strong>多任务学习来事故风险预测</strong>设计多任务学习方案，不仅可以增强深度学习的表示能力，还可以学到分层事故分布，为最可能发生事故区域的选取提供指导。为了预测子区域的事故风险，我们首先<strong>将事故风险分布作为主任务</strong>。考虑到交通事故和人类活动强度有关，我们将<strong>区域交通量预测作为第一个辅助任务</strong>，用来提高深度学习的表示能，。为了给分层事故区域的选取提供指导，将<strong>预测中等区域发生的事故总数作为第二个辅助任务</strong>。<br>具体地，我们将DTGN的3个输出$\mathcal{O}_{h c}^{\Delta t}, \mathcal{O}_{d p}^{\Delta t}$ and $\mathcal{O}_{d t}^{\Delta t}$输入到卷积融合模块中，然后进行多任务学习，如图3(b)所示，3个多任务shared是3个DTGN的输出结果。将3个输出结果分别输入到3个融合模块中，3个融合模块的参数是$\mathcal{W}_{risk}^{\Delta t},\mathcal{W}_{vol}^{\Delta t},\mathcal{W}_{count}^{\Delta t}$，首先生成每个子区域的预测风险$\mathcal{O}_{\text {risk}}^{\Delta t}$,使用$Leaky_ReLU$激活是因为label中的risk值有负值，其余都使用$ReLU$激活。然后生成每个子区域的预测流量$\mathcal{O}_{v o l}^{\Delta t}$，然后预测每个中等区域的风险次数，先经过融合模块，再经过全连接，生成$\mathcal{O}_{\text {count}}^{\Delta t}$</p><script type="math/tex; mode=display">\mathcal{O}_{r i s k}^{\Delta t}=\text { Leaky } \operatorname{ReLU}\left(\mathcal{W}_{risk}^{\Delta t} *\left[\mathcal{O}_{h c}^{\Delta t}, \mathcal{O}_{d p}^{\Delta t}, \mathcal{O}_{d t}^{\Delta t}\right]\right)</script><script type="math/tex; mode=display">\mathcal{O}_{v o l}^{\Delta t}=\operatorname{ReLU}\left(\mathcal{W}_{v o l}^{\Delta t} *\left[\mathcal{O}_{h c}^{\Delta t}, \mathcal{O}_{d p}^{\Delta t}, \mathcal{O}_{d t}^{\Delta t}\right]\right)</script><script type="math/tex; mode=display">\mathcal{O}_{\text {count}}^{\Delta t}=\operatorname{ReLU}\left(\mathcal{W}_{f c}^{\Delta t} *\left(\mathcal{W}_{\text {count}}^{\Delta t} *\left[\mathcal{O}_{h c}^{\Delta t}, \mathcal{O}_{d p}^{\Delta t}, \mathcal{O}_{d t}^{\Delta t}\right]\right)\right)</script><p>$\mathcal{O}_{\text {count}}^{\Delta t}$是中等区域的事故次数，将其输入到另一个全连接中，reshape成和$\mathcal{O}_{\text {risk}}^{\Delta t}$相同维度，和原先的细粒度事故分布相加，迫使学习粗粒度和细粒度的事故分布之间的关系。最终$\mathcal{O}_{\text {risk}}^{\Delta t}$被更新为</p><script type="math/tex; mode=display">\mathcal{O}_{risk*}^{\Delta t}=\text { Leaky } \operatorname{ReLU}\left(\mathcal{W}_{f c *} * \mathcal{O}_{c o u n t}^{\Delta t}+\mathcal{O}_{r i s k}^{\Delta t}\right)</script><p>其中$\mathcal{O}_{risk*}^{\Delta t}$是最终主任务的输出。</p><p><img src="/2020/02/18/RiskOracle-A-Minute-level-Citywide-Traffic-Accident-Forecasting-Framework/multitask.png" alt=""></p><p>多任务的总loss如下：</p><script type="math/tex; mode=display">\operatorname{Loss}(\theta)=m s e_{r i s k}+\lambda_{1} * m s e_{v o l}+\lambda_{2} * m s e_{c o u n t}+\lambda_{3} * L_{2}</script><p>其中$m s e_{r i s k}, m s e_{v o l},m s e_{c o u n t}$是主任务和2个辅助任务的loss，这里使用L2正则化来避免过拟合。$\lambda_{1},\lambda_{2},\lambda_{3}$是损失函数的超参数。$\lambda_{1}=0.8,\lambda_{2}=1,\lambda_{3}=1e-4$。</p><blockquote><p>只根据risk，count，flow的MSELoss进行反向传播，训练模型。在预测时，根据这3个输出，求出评价指标</p></blockquote><p><strong>分层最可能发生事故区域选择</strong>.交通事故和交通量在城市和农村经常不均衡，导致空间异质性问题。因此，用统一的风险阈值来选择最可能发生事故的区域是不合理的，我们基于多任务中预测出的risk，提出一个分层的最可能发生事故区域选择的方法。<br>输入数据是中等区域的事故次数和子区域的risk值，对每个中等区域$i$，我们从中选出$k_i(i=1,2,…,q)$个风险最高的子区域，其中参数$k_i$等于第二个辅助任务学到的$\mathcal{O}_{\text {count}}^{\Delta t}$中对应的值。因此，我们获得了一组最可能发生事故的子区域。并且通过这种方式获得的$k_i$可以减少区域的过度预测，并且模型符合时间和天气的变化。</p><blockquote><p>对于$k_i$的选择这里解释下：在测试阶段，根据q个中等区域的事故数和m个子区域的risk值来选择$k_i$，假设q=5，预测出来5个中等区域发生的事故次数为[0,2,4,1,6],那就从5个中等区域中，分别选0,2,4,1,6个子区域，选risk最高的$k_i$个对应的子区域，就是模型预测的事故高发子区域</p><p>在模型训练阶段，只预测子区域的risk，子区域的flow，中等区域的count来计算loss，训练模型。在训练阶段，并不预测发生事故最高的区域。预测发生事故最高的区域，只在测试集上进行。在训练集和验证集上，将risk中的0替换掉训练模型，在测试集上，不需要将risk=0替换掉，因为在测试集上我们只需要找出topK就可以了。</p></blockquote><h1><span id="5-实验">5. 实验</span></h1><p>分钟级别的事故预测模型，设置时间段分别为10min和30min</p><h2><span id="51-数据准备">5.1. 数据准备</span></h2><p>在2个真实数据集上做实验：NYC Opendata和苏州工业园区(SIP)。对于NYC数据集，由于缺少实时的交通流量数据，这里利用每个子区域的出租车流量来代表人流量。对于SIP数据集，它包含交通流量和速度。我们将其从新浪收集的交通事故数据集集成。2个数据集的统计信息在表2中。</p><p><img src="/2020/02/18/RiskOracle-A-Minute-level-Citywide-Traffic-Accident-Forecasting-Framework/dataset.png" alt=""></p><h2><span id="52-实现细节">5.2. 实现细节</span></h2><p>训练集:验证集:测试集=6:1:3，划分子区域参照AAAI2019<a href="https://echohhhhhh.github.io/2019/03/05/Spatiotemporal-Multi-Graph-Convolution-Network-for-Ride-hailing-Demand-Forecasting/" target="_blank" rel="noopener">Spatiotemporal Multi-Graph Convolution Network for Ride-hailing Demand Forecasting</a>和实际情况。堆叠9层GCN，每层有384个filter。损失函数中$\lambda_{1}=0.8,\lambda_{2}=1,\lambda_{3}=1e-4$。优化器使用Adam。</p><p>在训练阶段，动态交通数据和affinity matrix被划分为小时，天，长期共3组，2种scale的事故分布输入到多任务DTGN中。在测试阶段，将数据组织成以上格式并输入到模型中，最有可能发生事故的子区域可以从主任务和辅助任务2中得到。高风险子区域被突出显示，并与实际的事故记录比较。</p><h2><span id="53-评价指标">5.3. 评价指标</span></h2><p>从2个角度验证RiskOracle模型，回归角度：MSE，分类角度：a)Acc@M，常用于时空排名任务中，表示m个子区域中，预测的前M个风险最高的子区域中正确的比例。NYC数据集中，在30min预测时，M=20，在10min预测时，M=6。在SIP数据集中，M=5。b)Acc@K,其中K是第二个辅助任务学到的$k_i$的总和。其中Acc1表示发生事故频率较高时间段的准确率，例如早上7~9点，下午12~4点。</p><blockquote><p>测试时，$Acc@M$：每个时间步从m个子区域中选出M个事故高发的区域，然后看选对了多少。M是全局选M个，每个中等子区域选多少个并不限制。$Acc@K$，只针对高频时间段计算该指标。假设在一个时间段中辅助任务2预测结果为[0,2,4,1,6],即K=13，从m个子区域中选出13个，但是每个中等子区域要选$k_i$个。</p></blockquote><h2><span id="54-baseline">5.4. Baseline</span></h2><ol><li>ARIMA，用于时间序列预测</li><li>Hetero-ConvLSTM(2018KDD),调整超参数为4,blocks with 16 filters, and a size of 12x12 moving window with step=6.</li><li>ST-ResNet(2017AAAI郑宇)用来预测车流量</li><li>SDAE(2016AAAI)使用人流量来预测risk</li><li>SDCAE最新的小时级别风险预测模型</li></ol><h2><span id="55-实验结果">5.5. 实验结果</span></h2><p><strong>性能比较</strong><br>实验结果如表3.RiskOracle获得了最高的准确率，且MSE优于大部分baseline。使用分层事故区域选择HARS，我们的模型解决了空间异质性和过度预测的问题。尤其在NYC数据集上，我们模型在Acc@20比最好的模型高22.49%。对于稀疏的传感数据和短期的时空预测，可扩展性高。并且，我们的模型在高峰期的预测更好，在现实应用中有用。所有的指标NYC的都比SIP的要好，可能因为SIP数据中事故标签不完整。<br>总体上，随着时间粒度变小，我们的模型性能稍微下降，而其他的模型急剧下降因为遇到零膨胀问题。这表明我们的模型在短期事故预测中的有效性和可扩展性。在实际应用中有很少的事故记录时，2个数据集上的提升验证了我们模型的健壮性和普适性。</p><p><img src="/2020/02/18/RiskOracle-A-Minute-level-Citywide-Traffic-Accident-Forecasting-Framework/result.png" alt=""></p><p><strong>Acc@K和消融实验</strong>.如图4所示。Acc@20和Acc@6的结果略高于Acc@K，这是合理的，因为统一阈值无法适应实时条件，并且往往会高估事故率。相反，我们的框架具有使用多尺度事故分布预测，近似估计每个矩形区域中事故数量，具有灵活性。与表3中的结果相比，我们的框架胜过其他baseline，并在Acc@K达到可接受的准确性水平。<br>为了验证哪个组件起作用，做了消融实验，从模型中去掉一些组件。</p><ul><li>RO-1：去掉基于先验知识的数据增强PKDE，无法解决零膨胀问题。priori knowledge-based data enhancement</li><li>RO-2：去掉ST-DFM，无法解决实时交通数据缺失问题</li><li>RO-3：去掉overall affinity，无法实现时变的GCN,即图的邻接矩阵是静态的</li><li>RO-4：去掉差分特征生成器，在输入到GCN中没有差分特征</li><li>RO-5：去掉带有HARS的多任务</li><li>Integrated model：完整模型<br>其中最重要的组件是overall affinity和PKED，说明零膨胀和时变GCN是重要的。</li></ul><p><img src="/2020/02/18/RiskOracle-A-Minute-level-Citywide-Traffic-Accident-Forecasting-Framework/ablation.png" alt=""></p><h2><span id="56-超参数">5.6. 超参数</span></h2><p>在NYC数据集的30min展示超参数实验。</p><ul><li>9层GCN，每层有384个filter</li><li>损失函数中$\lambda_{1}=0.8,\lambda_{2}=1,\lambda_{3}=1e-4$</li><li>计算overall affinity时动态元素占的比重$\gamma=0.5$</li><li>中等区域个数$q=18$</li></ul><h2><span id="57-案例分析">5.7. 案例分析</span></h2><p>可视化NYC2017.5.22这一天中选取的3个30min时间段。上面是预测值，下面是真实值。可以看到预测的高风险子区域和真实值相似。由于在周日上午很少人外出，因此早晨7:00预测发生的事故很少。但是，下午事故数量会增加，而到了晚上，事故更加严重，由于当晚大雨，路况易发生事故。结果证明，辅助任务和HARS通过捕获外部因素，来学习事故分布的动态模式，调整推理，比统一阈值解决方案具有更好的适应性。</p><p><img src="/2020/02/18/RiskOracle-A-Minute-level-Citywide-Traffic-Accident-Forecasting-Framework/case.png" alt=""></p><h1><span id="6-总结">6. 总结</span></h1><p>在这篇论文中，我们提出了基于多任务DTGN的RiskOracle框架，解决分钟级的事故预测问题。首先提出2个方法来解决零膨胀和稀疏感知的问题。在多任务DTGN中，结合差分特征生成器和时间overall affinity，模型可以建模稀疏的时空数据，捕获短期的子区域相关性。学习多尺度事故分布，突出显示最可能发生事故的子区域来解决空间异质性。在2个真实数据集上的实验验证模型的优越性。</p><h1><span id="7-知识补充">7. 知识补充</span></h1><p><strong>【Factorization Machine】</strong> FM (Factorization Machine) 主要是为了解决数据稀疏的情况下，特征怎样组合的问题。<br><a href="https://zhuanlan.zhihu.com/p/80726100" target="_blank" rel="noopener">【推荐系统】Factorization Machine</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;AAAI2020原文链接：&lt;a href=&quot;https://github.com/zzyy0929/AAAI2020-RiskOracle&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;RiskOracle-A Minute-level Citywide Traffic Accident Forecasting Framework&lt;/a&gt;&lt;br&gt;中国科大发&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="论文阅读笔记" scheme="http://yoursite.com/categories/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="时空领域" scheme="http://yoursite.com/tags/%E6%97%B6%E7%A9%BA%E9%A2%86%E5%9F%9F/"/>
    
  </entry>
  
  <entry>
    <title>时空论文列表</title>
    <link href="http://yoursite.com/2020/02/18/%E6%97%B6%E7%A9%BA%E8%AE%BA%E6%96%87%E5%88%97%E8%A1%A8/"/>
    <id>http://yoursite.com/2020/02/18/时空论文列表/</id>
    <published>2020-02-17T16:17:25.000Z</published>
    <updated>2020-02-18T08:32:08.173Z</updated>
    
    <content type="html"><![CDATA[<h1><span id="简介">简介</span></h1><p>以下列出AAAI2020和ICLR2020关于时空领域的论文<br><a id="more"></a></p><h1><span id="aaai2020">AAAI2020</span></h1><p><strong>[1]. RiskOracle: A Minute‐level Citywide Traffic Accident Forecasting Framework</strong><br><a href="https://github.com/zzyy0929/AAAI2020-RiskOracle" target="_blank" rel="noopener">https://github.com/zzyy0929/AAAI2020-RiskOracle</a></p><blockquote><p>Zhengyang Zhou (University of Science and Technology of China); Yang Wang (University of Science and<br>Technology of China)*; Xike Xie (University of Science and Technology of China); Lianliang Chen (University of<br>Science and Technology of China); Hengchang Liu (USTC)</p></blockquote><p><strong>[2]. GMAN: A Graph Multi-­Attention Network for Traffic Prediction</strong><br><a href="https://github.com/zhengchuanpan/GMAN" target="_blank" rel="noopener">https://github.com/zhengchuanpan/GMAN</a></p><blockquote><p>Chuanpan Zheng (Xiamen University); Xiaoliang Fan (Xiamen University)*; Cheng Wang (Xiamen University);<br>Jianzhong Qi (The University of Melbourne)</p></blockquote><p><strong>[3]. Multi-­Range Attentive Bicomponent Graph Convolutional Network for Traffic Forecasting</strong><br><a href="https://github.com/naganandy/graph-based-deep-learning-literature/blob/master/conference-publications/folders/publications_aaai20/mrabgcn_aaai20/README.md" target="_blank" rel="noopener">https://github.com/naganandy/graph-based-deep-learning-literature/blob/master/conference-publications/folders/publications_aaai20/mrabgcn_aaai20/README.md</a><br><a href="https://arxiv.org/abs/1911.12093?context=cs" target="_blank" rel="noopener">https://arxiv.org/abs/1911.12093?context=cs</a></p><blockquote><p>Weiqi Chen (Zhejiang University); Ling Chen (Zhejiang University)*; Yu Xie (Alibaba Cloud); Wei Cao (Alibaba);<br>Yusong Gao (Alibaba Cloud); Xiaojie Feng (Alibaba Cloud)</p></blockquote><p><strong>[4]. Spatio­‐Temporal Graph Structure Learning for Traffic Forecasting</strong></p><blockquote><p>Qi Zhang (institute of automation, Chinese academy of science)*; Jianlong Chang (National Laboratory of Pattern<br>Recognition, Institute of Automation, Chinese Academy of Sciences); Gaofeng Meng (Chinese Academy of<br>Sciences); SHIMING XIANG (Chinese Academy of Sciences, China); Chunhong Pan (Institute of Automation, Chinese<br>Academy of Sciences)</p></blockquote><p><strong>[5]. Pay Your Trip for Traffic Congestion: Dynamic Pricing in Traffic­‐Aware Road Networks</strong></p><blockquote><p>Lisi Chen (HKBU)*; Shuo Shang (KAUST); Bin Yao (“Shanghai Jiaotong University, China”); Jing Li (Inception Institute<br>of Artificial Intelligence)</p></blockquote><p><strong>[6]. Self­‐Attention ConvLSTM for Spatiotemporal Prediction</strong></p><blockquote><p>Zhihui Lin (Tsinghua University)*; Maomao Li (Tsinghua university); Zhuobin Zheng ( Tsinghua University);<br>Yangyang Cheng (Tsinghua University); Chun Yuan (Tsinghua University)</p></blockquote><p><strong>[7]. An Attentional Recurrent Neural Network for Personalized Next Location Recommendation</strong></p><blockquote><p>Qing Guo (Nanyang Technological University)*; Zhu Sun (Nanyang Technological University); Jie Zhang (Nanyang<br>Technological University); Yin-­‐Leng Theng (Nanyang Technological University)</p></blockquote><p><strong>[8]. Spatial­‐Temporal Synchronous Graph Convolutional Networks: A New Framework for Spatial-­‐Temporal Network Data Forecasting</strong><br><a href="https://github.com/Davidham3/STSGCN" target="_blank" rel="noopener">https://github.com/Davidham3/STSGCN</a></p><blockquote><p>Chao Song (Beijing Jiaotong University)*; Youfang Lin (Beijing Jiaotong University); Shengnan Guo (Beijing Jiaotong<br>University); Huaiyu Wan (Beijing Jiaotong University)</p></blockquote><p><strong>[9]. STGRAT: A Spatio-Temporal Graph Attention Network for Traffic Forecasting</strong><br><a href="https://arxiv.org/abs/1911.13181" target="_blank" rel="noopener">https://arxiv.org/abs/1911.13181</a></p><blockquote><p>Cheonbok Park1, Chunggi Lee2, Hyojin Bahng1, Taeyun won1,<br>Kihwan Kim2, Seungmin Jin2, Sungahn Ko2, Jaegul Choo1<br>1 Korea University , 2 UNIST</p></blockquote><p><strong>[10]. Semi-Supervised Hierarchical Recurrent Graph Neural Network for City-Wide Parking Availability Prediction</strong><br><a href="https://arxiv.org/abs/1911.10516" target="_blank" rel="noopener">https://arxiv.org/abs/1911.10516</a></p><blockquote><p>Weijia Zhang (University of Science and Technology of China); Hao LIU (Business Intelligence Lab, Baidu<br>Research)*; Yanchi Liu (Rutgers University); Jingbo Zhou (Baidu Inc.); Hui Xiong (Rutgers University)</p></blockquote><p><strong>[11]. RoadTagger: Robust Road Attribute Inference with Graph Neural Networks</strong><br><a href="https://arxiv.org/abs/1912.12408" target="_blank" rel="noopener">https://arxiv.org/abs/1912.12408</a></p><blockquote><p>Songtao He (MIT CSAIL)*; Favyen Bastani (MIT CSAIL); Satvat Jagwani (MIT CSAIL); Edward Park (MIT CSAIL);<br>Sofiane Abbar (Qatar Computing Research Institute); Mohammad Alizadeh (MIT CSAIL); Dr.Hari Balakrishnan<br>(Massachusetts institute of technology); Sanjay Chawla (QCRI); Samuel Madden (MIT); Mohammad Amin Sadeghi<br>(MIT)  </p></blockquote><h1><span id="iclr2020">ICLR2020</span></h1><p><a href="http://tony.9shi.cf/index.php?q=aHR0cHM6Ly93d3cuZW5kdG9lbmQuYWkvYmxvZy9pY2xyMjAyMC8" target="_blank" rel="noopener">ICLR2020 Accepted Papers</a></p><p><strong>[1]. Geom-gcn: Geometric Graph Convolutional Networks</strong><br>Spotlight paper<br><a href="https://github.com/graphdml-uiuc-jlu/geom-gcn" target="_blank" rel="noopener">https://github.com/graphdml-uiuc-jlu/geom-gcn</a></p><blockquote><p>Hongbin Pei, Bingzhe Wei, Kevin Chen-Chuan Chang, Yu Lei, Bo Yang<br>Jilin University</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h1&gt;&lt;p&gt;以下列出AAAI2020和ICLR2020关于时空领域的论文&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="论文阅读笔记" scheme="http://yoursite.com/categories/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="时空领域" scheme="http://yoursite.com/tags/%E6%97%B6%E7%A9%BA%E9%A2%86%E5%9F%9F/"/>
    
  </entry>
  
</feed>
