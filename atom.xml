<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Echo&#39;s blog</title>
  
  <subtitle>远方到底有多远</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2020-05-24T12:36:20.586Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Echo</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Leetcode之链表</title>
    <link href="http://yoursite.com/2020/05/24/Leetcode%E4%B9%8B%E9%93%BE%E8%A1%A8/"/>
    <id>http://yoursite.com/2020/05/24/Leetcode之链表/</id>
    <published>2020-05-24T08:19:04.000Z</published>
    <updated>2020-05-24T12:36:20.586Z</updated>
    
    <content type="html"><![CDATA[<p>链表遍历数据时，需要从头遍历。链表只需要给出头指针就可以</p><a id="more"></a><!-- TOC -->autoauto- [1. 找链表的中间节点](#1-找链表的中间节点)auto- [2. 总结](#2-总结)autoauto<!-- /TOC --><h1><span id="1-找链表的中间节点">1. 找链表的中间节点</span></h1><p>给定一个带有头结点 head 的非空单链表，返回链表的中间结点。</p><p>如果有两个中间结点，则返回第二个中间结点。</p><p><strong>【分析】</strong></p><ul><li>当链表中个数为奇数时，返回中间的节点。例如1-&gt;2-&gt;3-&gt;4-&gt;5，返回节点3</li><li>当链表中个数为偶数时，返回右节点。例如1-&gt;2-&gt;3-&gt;4，中间的节点有2和3，返回右节点3</li><li>当链表中个数为偶数时，返回左节点。例如1-&gt;2-&gt;3-&gt;4，中间的节点有2和3，返回右节点2</li></ul><p>使用双指针，慢指针一次走一步，快指针一次走两步</p><p><img src="/2020/05/24/Leetcode之链表/876-1.png" alt=""></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">middleNode</span><span class="params">(self, head)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type head: ListNode</span></span><br><span class="line"><span class="string">        :rtype: ListNode</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        fast,low = head,head</span><br><span class="line">        <span class="comment">#返回右节点</span></span><br><span class="line">        <span class="keyword">while</span> fast <span class="keyword">and</span> fast.next:</span><br><span class="line">            fast = fast.next.next</span><br><span class="line">            low = low.next</span><br><span class="line">        <span class="keyword">return</span> low</span><br></pre></td></tr></table></figure><p><img src="/2020/05/24/Leetcode之链表/876-2.png" alt=""></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">middleNode</span><span class="params">(self, head)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type head: ListNode</span></span><br><span class="line"><span class="string">        :rtype: ListNode</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        fast,low = head,head</span><br><span class="line">        <span class="comment">#返回左节点</span></span><br><span class="line">        <span class="keyword">while</span> fast.next <span class="keyword">and</span> fast.next.next:</span><br><span class="line">            fast = fast.next.next</span><br><span class="line">            low = low.next</span><br><span class="line">        <span class="keyword">return</span> low</span><br></pre></td></tr></table></figure><h1><span id="倒数第k个节点">倒数第K个节点</span></h1><p>输入一个链表，输出该链表中倒数第k个节点。尾节点是倒数第1个节点。</p><p>例如：给定一个链表: 1-&gt;2-&gt;3-&gt;4-&gt;5, 和 k = 2.<br>返回链表 4-&gt;5</p><p><strong>【分析】</strong><br>使用快慢指针，快指针先向前移动k个节点，慢指针指向head，然后快慢指针一起向前走，当快指针指向null时，此时慢指针指向倒数第k个节点，返回即可。<br>举例：1-&gt;3-&gt;9-&gt;7-&gt;6-&gt;12，k=3，首先fast和low都指向1，然后fast向前移动3步指向7，然后fast和low同时向前走，当fast指向null时，此时low指向7，返回即可。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getKthFromEnd</span><span class="params">(self, head, k)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type head: ListNode</span></span><br><span class="line"><span class="string">        :type k: int</span></span><br><span class="line"><span class="string">        :rtype: ListNode</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> head:<span class="keyword">return</span> head</span><br><span class="line">        fast,low = head,head</span><br><span class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> range(k):</span><br><span class="line">            fast = fast.next</span><br><span class="line">        <span class="keyword">while</span> fast:<span class="comment">#当fast为None时，退出循环</span></span><br><span class="line">            fast = fast.next</span><br><span class="line">            low = low.next</span><br><span class="line">        <span class="keyword">return</span> low</span><br></pre></td></tr></table></figure><h1><span id="环形链表">环形链表</span></h1><p><a href="https://leetcode-cn.com/problems/linked-list-cycle/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/linked-list-cycle/</a><br>给定一个链表，判断链表中是否有环。</p><ul><li><p><strong>使用set</strong><br>使用set保存节点的引用，而不是节点的值</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">hasCycle</span><span class="params">(self, head)</span>:</span></span><br><span class="line">      <span class="string">"""</span></span><br><span class="line"><span class="string">      :type head: ListNode</span></span><br><span class="line"><span class="string">      :rtype: bool</span></span><br><span class="line"><span class="string">      """</span></span><br><span class="line">      <span class="comment">#使用set，这里set保存的是节点的引用，而不是节点的值</span></span><br><span class="line">      nodes = set()</span><br><span class="line">      <span class="keyword">while</span> head:</span><br><span class="line">          <span class="keyword">if</span> head <span class="keyword">in</span> nodes:</span><br><span class="line">              <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">          nodes.add(head)</span><br><span class="line">          head = head.next</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">False</span></span><br></pre></td></tr></table></figure></li><li><p><strong>快慢指针</strong><br>快指针每次走2步，慢指针每次走1步，如果链表中有环，两者迟早会碰上，如果始终碰不上，则链表中没有环。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">hasCycle</span><span class="params">(self, head)</span>:</span></span><br><span class="line">      <span class="string">"""</span></span><br><span class="line"><span class="string">      :type head: ListNode</span></span><br><span class="line"><span class="string">      :rtype: bool</span></span><br><span class="line"><span class="string">      """</span></span><br><span class="line">      <span class="keyword">if</span> <span class="keyword">not</span> head:<span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">      fast,low = head,head</span><br><span class="line">      <span class="keyword">while</span> fast.next <span class="keyword">and</span> fast.next.next:</span><br><span class="line">          fast = fast.next.next</span><br><span class="line">          low = low.next</span><br><span class="line">          <span class="keyword">if</span> fast == low:</span><br><span class="line">              <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">False</span></span><br></pre></td></tr></table></figure></li></ul><h1><span id="环形链表ii">环形链表II</span></h1><p>给定一个链表，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。<br>说明：不允许修改给定的链表。<br>链接：<a href="https://leetcode-cn.com/problems/linked-list-cycle-ii" target="_blank" rel="noopener">https://leetcode-cn.com/problems/linked-list-cycle-ii</a></p><p><strong>【分析】</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">detectCycle</span><span class="params">(self, head)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type head: ListNode</span></span><br><span class="line"><span class="string">        :rtype: ListNode</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> head:<span class="keyword">return</span> <span class="keyword">None</span></span><br><span class="line">        fast,slow = head,head</span><br><span class="line">        <span class="keyword">while</span> fast.next <span class="keyword">and</span> fast.next.next:</span><br><span class="line">            fast = fast.next.next</span><br><span class="line">            slow = slow.next</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> fast == slow:</span><br><span class="line">                slow = head</span><br><span class="line">                <span class="keyword">while</span> slow != fast:</span><br><span class="line">                    slow = slow.next</span><br><span class="line">                    fast = fast.next</span><br><span class="line">                <span class="keyword">return</span> fast</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">None</span></span><br></pre></td></tr></table></figure><h1><span id="2-总结">2. 总结</span></h1><ol><li>使用快慢指针<br>链表中间节点，链表倒数K个元素</li><li>长度</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;链表遍历数据时，需要从头遍历。链表只需要给出头指针就可以&lt;/p&gt;
    
    </summary>
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
      <category term="链表" scheme="http://yoursite.com/tags/%E9%93%BE%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>排序算法</title>
    <link href="http://yoursite.com/2020/03/30/Leetcode%E4%B9%8B%E6%8E%92%E5%BA%8F/"/>
    <id>http://yoursite.com/2020/03/30/Leetcode之排序/</id>
    <published>2020-03-30T02:38:24.000Z</published>
    <updated>2020-04-16T01:14:52.690Z</updated>
    
    <content type="html"><![CDATA[<p>开始刷题了，首先整理并实现经典的排序算法并对其优化，使用Python实现。所有的排序默认从小到大排序</p><a id="more"></a><!-- TOC --><ul><li><a href="#1-术语说明">1. 术语说明</a></li><li><a href="#2-冒泡排序">2. 冒泡排序</a><ul><li><a href="#21-冒泡排序">2.1. 冒泡排序</a></li><li><a href="#22-优化1">2.2. 优化1</a></li><li><a href="#23-优化2">2.3. 优化2</a></li></ul></li><li><a href="#3-选择排序">3. 选择排序</a></li><li><a href="#4-插入排序">4. 插入排序</a></li><li><a href="#5-快速排序">5. 快速排序</a><ul><li><a href="#51-快速排序">5.1. 快速排序</a></li><li><a href="#52-优化1">5.2. 优化1</a></li><li><a href="#三路快排">三路快排</a></li></ul></li><li><a href="#6-归并排序">6. 归并排序</a></li><li><a href="#7-堆排序">7. 堆排序</a><ul><li><a href="#71-堆排序">7.1. 堆排序</a></li><li><a href="#72-应用topk问题">7.2. 应用：topK问题</a></li></ul></li><li><a href="#8-nb三人组小结">8. NB三人组小结</a></li><li><a href="#9-希尔排序插入排序的改良版">9. 希尔排序(插入排序的改良版)</a></li><li><a href="#10-计数排序">10. 计数排序</a></li><li><a href="#11-桶排序">11. 桶排序</a></li><li><a href="#12-基数排序">12. 基数排序</a></li><li><a href="#leetcode题">LeetCode题</a><ul><li><a href="#88-合并两个有序数组">88. 合并两个有序数组</a></li><li><a href="#215-数组中的第k个最大元素">215. 数组中的第K个最大元素</a></li><li><a href="#347-前-k-个高频元素">347. 前 K 个高频元素</a></li><li><a href="#面试题39-数组中出现次数超过一半的数字">面试题39. 数组中出现次数超过一半的数字</a></li><li><a href="#75-颜色分类">75. 颜色分类</a></li><li><a href="#350-两个数组的交集-ii">350. 两个数组的交集 II</a></li><li><a href="#324-摆动排序-ii">324. 摆动排序 II</a></li></ul></li><li><a href="#总结">总结</a></li></ul><!-- /TOC --><p>一共有10种排序算法，先给出排序算法的性能<br><img src="/2020/03/30/Leetcode之排序/排序算法/conclusion.png" alt=""></p><ul><li>low B 三人组：冒泡，选择，插入</li><li>NB 三人组：快排，归并，堆排序</li><li>其他排序：计数排序，基数，希尔排序，桶排序</li></ul><h1><span id="1-术语说明">1. 术语说明</span></h1><ul><li>稳定：原始数据中a=b，并且a在b的前面，排序后a仍然在b的前面</li><li>不稳定：原始数据中a=b，并且a在b的前面，排序后a可能会出现在b的后面</li><li>内排序：所有排序操作都在内存中完成</li><li>外排序：由于数据太大，需要把数据放在磁盘中，而排序通过磁盘和内存的数据传输才能进行</li><li>比较排序：每个数必须和其他数进行比较，才能确定自己的位置。比较排序的优势：适用于各种规模的数据，不管数据分布什么样，都可以进行排序。可以说比较排序适用于一切需要排序的情况</li><li>非比较排序：通过确定每个元素之前，应该有多少元素来排序，针对arr[i]，计算arr[i]之前有多少个元素，则唯一确定了arr[i]在排序后数组中的位置，一次遍历即可解决，算法时间复杂度$O(N)$。非比较排序时间复杂度低，但由于需要占用空间来确定唯一位置，所以对数据规模和数据分布有一定要求</li></ul><p><strong>【交换函数】</strong><br>在比较排序中，需要用到交换函数，先在此定义下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">swap</span><span class="params">(nums,i,j)</span>:</span></span><br><span class="line">    tmp = nums[i]</span><br><span class="line">    nums[i] = nums[j]</span><br><span class="line">    nums[j] = tmp</span><br></pre></td></tr></table></figure><h1><span id="2-冒泡排序">2. 冒泡排序</span></h1><p>最简单的排序之一</p><h2><span id="21-冒泡排序">2.1. 冒泡排序</span></h2><p><strong>基本思想：</strong><br>每个数和它后面的数比较，小的数放在前面，大的数放在后面，最终越小的元素经过交换慢慢浮到数组的顶端，类似于水泡上升一样。<br><strong>步骤：</strong></p><ol><li>2重循环，第一次循环控制比较的次数，假设有n个数，第一次需要比较n-1次，选出n个数中最大的数；第二次需要比较n-2次，选出n-1个数中最大的数，…，剩下2个数，需要比较1次，选出最大的数</li><li>外层循环一共需要比较i=n-1,n-2,…1次，range(n-1,0,-1)</li><li>内存循环j=0,1,2,…i-1，range(0,i)</li><li>将数组分为有序和无序，每一次外循环，都将无序数组的最大值放在后面。首先整个数组都是无序的，经过一次外循环，有序数组个数加1，无序数组减1。然后再经过一次外循环，有序数组个数再加1，无序数组减1，直到所有数据全变成有序。</li></ol><p><img src="/2020/03/30/Leetcode之排序/排序算法/bubble.gif" alt=""><br><strong>实现：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bubble_sort</span><span class="params">(nums)</span>:</span></span><br><span class="line">    n = len(nums)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(n<span class="number">-1</span>,<span class="number">0</span>,<span class="number">-1</span>):<span class="comment">#排序的趟数，一共n-1趟</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">0</span>,i):<span class="comment">#对0~i-1个数进行排序</span></span><br><span class="line">            <span class="comment">#每个数和后面比较，只有当前面数&gt;后面数才交换，相等不会交换，体现稳定性</span></span><br><span class="line">            <span class="keyword">if</span> nums[j] &gt; nums[j+<span class="number">1</span>]:</span><br><span class="line">                swap(nums,j,j+<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> nums</span><br></pre></td></tr></table></figure><ul><li>空间复杂性：$O(1)$</li><li>时间复杂性：$0(n^2)$</li><li>使用场景：适合小数据的排序，因为算法复杂度高，在数据量大不适用</li></ul><h2><span id="22-优化1">2.2. 优化1</span></h2><p>冒泡排序的关键是与后面的元素进行比较，然后交换，但是当我们发现某次排序过程中没有发生过交换行为，便可以认为，剩下的元素都是有序的，所以也不用比较了。例如：1,2,3,4,5，进行第一次排序时我们就发现后面的2大于1，3大于2…5大于4，此时便可以认为数据有序，不必再进行后面的排序和比较。<br>每次进入内部循环前，设置flag来标记前面0~i-1个数中是否发生交换，没有发生交换，说明前面的数已经是有序的，不用再排序了。<br>在数据完全有序的时候，最好时间复杂度$O(n)$,其他情况总是$O(n^2)$，因此算法在数据基本有序的情况下，性能最好。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bubble_sort1</span><span class="params">(nums)</span>:</span></span><br><span class="line">    n = len(nums)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(n<span class="number">-1</span>,<span class="number">0</span>,<span class="number">-1</span>):</span><br><span class="line">        flag = <span class="keyword">False</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">0</span>,i):</span><br><span class="line">            <span class="keyword">if</span> nums[j] &gt; nums[j+<span class="number">1</span>]:</span><br><span class="line">                swap(nums,j,j+<span class="number">1</span>)</span><br><span class="line">                flag = <span class="keyword">True</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> flag:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">return</span> nums</span><br></pre></td></tr></table></figure><h2><span id="23-优化2">2.3. 优化2</span></h2><p>在交换时，记录最后一次交换的位置，下次内循环时，只用遍历到这个位置就可以了，因为这个位置后的元素已经有序了</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bubble_sort2</span><span class="params">(nums)</span>:</span></span><br><span class="line">    n = len(nums)</span><br><span class="line">    k = n - <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(n<span class="number">-1</span>,<span class="number">0</span>,<span class="number">-1</span>):</span><br><span class="line">        flag = <span class="keyword">False</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">0</span>,k):</span><br><span class="line">            <span class="keyword">if</span> nums[j] &gt; nums[j+<span class="number">1</span>]:</span><br><span class="line">                swap(nums,j,j+<span class="number">1</span>)</span><br><span class="line">                flag = <span class="keyword">True</span></span><br><span class="line">                k = j</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> flag:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">return</span> nums</span><br></pre></td></tr></table></figure><h1><span id="3-选择排序">3. 选择排序</span></h1><p>表现最稳定的排序算法之一，无论什么数据，都是$O(n^2)$的时间复杂度，数据规模越小越好。<br>选择排序和冒泡排序的区别是：选择排序只有在确定了最小值的前提下，才进行交换，大大减少交换的次数。<br><strong>基本思想：</strong></p><ul><li>首先在未排序的数组中找到最小/大元素，放在数组的第一个位置，</li><li>然后再从剩下未排序数组中找最小/大元素，放在第二个位置</li><li>此次类推，直到所有的元素排序完成。</li></ul><p><img src="/2020/03/30/Leetcode之排序/排序算法/select.gif" alt=""></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">select_sort</span><span class="params">(nums)</span>:</span></span><br><span class="line">    n = len(nums)</span><br><span class="line">    <span class="comment">#每一趟选出无序中最小的数</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">        min_idx = i</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(i+<span class="number">1</span>,n):</span><br><span class="line">            <span class="keyword">if</span> nums[j] &lt; nums[min_idx]:</span><br><span class="line">                min_idx = j</span><br><span class="line">        <span class="keyword">if</span> min_idx != i:<span class="comment">#下标不同才交换</span></span><br><span class="line">            swap(nums,i,min_idx)</span><br><span class="line">    <span class="keyword">return</span> nums</span><br></pre></td></tr></table></figure><ul><li>不稳定</li><li>在各种情况下，复杂度波动小，因此一般优于冒泡排序，在所有的完全交换排序中，选择排序是不错的算法</li><li>时间复杂度$O(n^2)$，使用于简单数据</li></ul><h1><span id="4-插入排序">4. 插入排序</span></h1><p><strong>基本思想：</strong><br>将数组分成2部分：有序数组和无序数组，给无序数组中的一个数，从后向前遍历有序数组，放在特定的位置上，然后再遍历下一个无序数据，再插入到有序数组中。</p><p><strong>步骤：</strong></p><ol><li>从第一个元素开始，该元素认为已经排好序</li><li>取下一个元素，在有序数组中从后向前扫描</li><li>如果该元素(已排序)大于新元素，将该元素(已排序)后移一位</li><li>重复步骤3，直到找到有序数组中 &lt;= 新元素</li><li>将新元素插入到该元素后面</li></ol><p><img src="/2020/03/30/Leetcode之排序/排序算法/insert.gif" alt=""></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">insert_sort</span><span class="params">(nums)</span>:</span></span><br><span class="line">    n = len(nums)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,n):</span><br><span class="line">        <span class="comment">#只有当nums[i]&lt;有序数据时，才将有序数组中的元素后移</span></span><br><span class="line">        <span class="keyword">if</span> nums[i] &lt; nums[i<span class="number">-1</span>]:</span><br><span class="line">            tmp = nums[i]</span><br><span class="line">            insert_idx = i</span><br><span class="line">            <span class="comment">#遍历nums[i-1,...0]找出nums[i]插入位置</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(i<span class="number">-1</span>,<span class="number">-1</span>,<span class="number">-1</span>):</span><br><span class="line">                <span class="comment">#只有有序数据&gt;无序数据时，才将有序数据后移，</span></span><br><span class="line">                <span class="comment">#有序&lt;=无序，有序数组不用后移，所以插入排序是稳定的</span></span><br><span class="line">                <span class="keyword">if</span> nums[j] &gt; tmp:</span><br><span class="line">                    nums[j+<span class="number">1</span>] = nums[j]</span><br><span class="line">                    insert_idx = j</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">            nums[insert_idx] = tmp</span><br><span class="line">    <span class="keyword">return</span> nums</span><br></pre></td></tr></table></figure><ul><li>在有序数组中找到&lt;=无序数据，不交换位置，所以插入排序是稳定的</li><li>时间复杂度：$O(n^2)$，如果数据已经有序，那么比较次数为$O(n)$，不需要移动。</li><li>适用场景：在数组较大时不适用，但是在数据比较少时，一般作为快排的扩充，例如在JDK 7 java.util.Arrays所用的sort方法的实现中，当待排数组长度小于47时，会使用插入排序。</li></ul><h1><span id="5-快速排序">5. 快速排序</span></h1><h2><span id="51-快速排序">5.1. 快速排序</span></h2><p>在实际运用中冒泡排序很少使用，因为每次排序都要经过大量的交换，费时。快读排序通常比同为$nlog(n)$算法快，在实际应用中是表现最好的算法，因此常被采用，快排采用了分治思想。<br>快排虽然高端，但其思想来自于冒泡排序，冒泡排序通过相邻元素的比较和交换，把最小的元素冒泡在顶端，而快排是比较和交换大数和小数，不仅把小数冒泡到上面，同时把大数沉到下面。<br><strong>基本思想：</strong><br>找出一个基准，通过一趟排序，将待排序数据分割成独立的2部分，一部分基准大，一部分比基准小。快排使用分治法将一串分为2个子串</p><p><strong>步骤：</strong></p><ol><li>从数组中找出一个元素，作为基准（通常选择待排序数组中的第一个或最后一个元素）</li><li>在分区过程中，右指针找比基准小的，左指针找比基准小的，将这2个数交换，即比基准大的放在右边，小于或等于基准的放在左边</li><li>再对左右区间递归执行第二步，直到区间中只有一个数</li></ol><p>举例：5,4,1,8,10,7,9,2,4,3（刚开始）<br>基准值选：5</p><ul><li>首先lp指向5，rp指向3，在右边找小于5的数，说明该数需要交换，此时rp指向3，待交换。在左边找大于5的数，lp指向8，交换8和3，变成[5,4,1,3,10,7,9,2,4,8]</li><li>此时rp指向8，lp指向3，在右边找小于5的数，rp指向4，左边lp指向10，交换4和10变成[5,4,1,3,4,7,9,2,10,8]</li><li>此时rp指向10，lp指向4，在右边找小于5的数，rp指向2，lp指向7，交换2和7，变成[5,4,1,3,4,2,9,7,10,8]</li><li>此时rp指向7，lp指向2，在右边找小于5的数，rp指向2，此时lp也指向2，2个指针相遇，rp==lp，跳出while循环</li><li>交换left的5和相遇位置的2，变成[2,4,1,3,4,5,9,7,10,8]，此时5左边的数全小于5，右边的数全大于5，然后递归对[2,4,1,3,4]和[9,7,10,8]进行排序</li></ul><p>注意以下几个点：</p><ul><li>右指针先扫描，首先这也不是绝对的，这取决于基准数的位置，因为在最后两个指针相遇的时候，要交换基准数到相遇的位置。一般选取第一个数作为基准数，那么就是在左边，所以最后相遇的数要和基准数交换，那么相遇的数一定要比基准数小。所以j指针先移动才能先找到比基准数小的数。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">quick_sort</span><span class="params">(nums)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> qsort(nums,<span class="number">0</span>,len(nums)<span class="number">-1</span>)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">qsort</span><span class="params">(nums,left,right)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> left &gt;= right:<span class="comment">#结束条件</span></span><br><span class="line">        <span class="keyword">return</span> nums</span><br><span class="line">    key = nums[left]<span class="comment">#最左边为基准数</span></span><br><span class="line">    lp = left <span class="comment">#左指针</span></span><br><span class="line">    rp = right <span class="comment">#右指针</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> lp &lt; rp:</span><br><span class="line">        <span class="comment">#直到遇到右边的数&lt;key，说明这个数需要交换</span></span><br><span class="line">        <span class="keyword">while</span> lp &lt; rp <span class="keyword">and</span> nums[rp] &gt;= key:</span><br><span class="line">            rp -= <span class="number">1</span></span><br><span class="line">        <span class="comment">#直到遇到左边的数&gt;key，说明这个数需要交换</span></span><br><span class="line">        <span class="keyword">while</span> lp &lt; rp <span class="keyword">and</span> nums[lp] &lt;= key:</span><br><span class="line">            lp += <span class="number">1</span></span><br><span class="line">        swap(nums,lp,rp)</span><br><span class="line">    <span class="comment">#当lp==rp时跳出while循环，此时lp和rp指向的数&lt;key，交换相遇位置和基准数，此时key的位置就在lp上</span></span><br><span class="line">    swap(nums,left,lp)</span><br><span class="line">    <span class="comment">#此时lp==rp，此位置存储key，下面对key左和右递归排序</span></span><br><span class="line">    qsort(nums,left,lp<span class="number">-1</span>)</span><br><span class="line">    qsort(nums,rp+<span class="number">1</span>,right)</span><br><span class="line">    <span class="keyword">return</span> nums</span><br></pre></td></tr></table></figure><ul><li>快排不稳定</li><li>时间复杂度：$O(nlog(n))$</li><li>使用场景：在大多情况下都适用，尤其在数据量大时优越性更明显，但是在必要时，需要考虑下优化以提高在最坏情况下的性能</li></ul><h2><span id="52-优化1">5.2. 优化1</span></h2><p>时间复杂度：$O(nlog(n))$，但是当基准选择不当时，会变成$O(n^2)$。当基准恰好为当前序列中最小数，意味着每次排序时都是对1和n-1个数进行排序，则效率大大降低。</p><ul><li>假设数组[1,7,8,9,4,2,5,3]，当选择1作为基准时，右边没有比1小的，则需要比较n-1次，则对n个数排序需要$O(n^2)$。</li><li>当原始数组本身有序时</li></ul><p>优化快排的这种情况，主要有2个方法：</p><ul><li>随机选择基准数</li><li>三数中取中法（将序列中的第一个，中间那个，最后一个比较大小，选择中间的数作为基准数）</li></ul><p>下面针对随机选择基准数进行说明，每次快排使用随机数作为基准数，大大降低了基准数选择不当，以为数据本身有序的情况</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_rand</span><span class="params">(i,j)</span>:</span></span><br><span class="line">    <span class="comment">#产生[i,j]的随机整数</span></span><br><span class="line">    <span class="keyword">import</span> random</span><br><span class="line">    <span class="keyword">return</span> random.randint(i, j)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">quick_sort1</span><span class="params">(nums)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> qsort(nums,<span class="number">0</span>,len(nums)<span class="number">-1</span>)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">qsort1</span><span class="params">(nums,left,right)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> left &gt;= right:<span class="comment">#结束条件</span></span><br><span class="line">        <span class="keyword">return</span> nums</span><br><span class="line"></span><br><span class="line">    lp = left <span class="comment">#左指针</span></span><br><span class="line">    rp = right <span class="comment">#右指针</span></span><br><span class="line">    pos = get_rand(lp,rp)<span class="comment">#随机生成基准下标</span></span><br><span class="line">    swap(nums,lp,pos)</span><br><span class="line">    key = nums[lp]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> lp &lt; rp:</span><br><span class="line">        <span class="comment">#直到遇到右边的数&lt;key，说明这个数需要交换</span></span><br><span class="line">        <span class="keyword">while</span> lp &lt; rp <span class="keyword">and</span> nums[rp] &gt;= key:</span><br><span class="line">            rp -= <span class="number">1</span></span><br><span class="line">        <span class="comment">#直到遇到左边的数&gt;key，说明这个数需要交换</span></span><br><span class="line">        <span class="keyword">while</span> lp &lt; rp <span class="keyword">and</span> nums[lp] &lt;= key:</span><br><span class="line">            lp += <span class="number">1</span></span><br><span class="line">        swap(nums,lp,rp)</span><br><span class="line">    <span class="comment">#当lp==rp时跳出while循环，此时lp和rp指向的数&lt;key</span></span><br><span class="line">    swap(nums,left,lp)</span><br><span class="line">    <span class="comment">#此时lp==rp，此位置存储key，下面对key左和右递归排序</span></span><br><span class="line">    qsort1(nums,left,lp<span class="number">-1</span>)</span><br><span class="line">    qsort1(nums,rp+<span class="number">1</span>,right)</span><br><span class="line">    <span class="keyword">return</span> nums</span><br></pre></td></tr></table></figure><h2><span id="三路快排">三路快排</span></h2><p>二路快排对nums中数据有很多相等的元素不友好，三路排序是将nums分为3部分，小于pivot，等于pivot，大于pivot。<br>Java中的快排使用的就是三路</p><p>分成3个区间</p><ul><li>[left,lt]小于v</li><li>[lt+1,i]等于v</li><li>[rt,right]大于v</li></ul><p>在刚开始怎么给lt、gt、i初始化？<br>刚开始初始化，就是让以上3个区间全为空。<br>即lt=left-1，rt=right+1，i=left<br><img src="/2020/03/30/Leetcode之排序/排序算法/3-quick-sort1.png" alt=""></p><p>遍历每一个i，</p><ul><li>当nums[i]==v时，则nums[i]不需要移动，直接移动i，遍历下一个元素，i+=1</li><li>当nums[i]&lt;v时，需要归到小于v的左边行列中。即nums[i]和等于v的第一个元素交换，即nums[i]和nums[lt+1]交换，然后lt需要扩大一位，包住刚刚挪过来的那个小于v的数，lt+=1，i右移到下一个未遍历的元素i+=1</li><li>当nums[i]&gt;v时，需要归到大于v的右边行列中。即nums[i]和nums[gt-1]交换，然后gt需要左移一位，包住挪过来的这个数，然后被交换的这个值在i这个位置，因为这个数还没有被检测，所有i不需要右移，还是当前的位置。</li></ul><p><img src="/2020/03/30/Leetcode之排序/排序算法/3-quick-sort2.png" alt=""></p><p>当指针i和gt相等时，说明的元素都被检测完毕，这时退出while循环。<br>然后再把nums[left]的v值放在正确的位置，使得左边都是小于v的，即将nums[lt]和nums[left]交换，这样v所在的位置就是lt。</p><ul><li>[left,lt-1]都是小于v的</li><li>[lt,gt-1]都是等于v的</li><li>[gt,right]都是大于v的</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_rand</span><span class="params">(i,j)</span>:</span></span><br><span class="line">    <span class="comment">#产生[i,j]的随机整数</span></span><br><span class="line">    <span class="keyword">import</span> random</span><br><span class="line">    <span class="keyword">return</span> random.randint(i, j)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">quick_sort1</span><span class="params">(nums)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> qsort(nums,<span class="number">0</span>,len(nums)<span class="number">-1</span>)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">qsort1</span><span class="params">(nums,left,right)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> left &gt;= right:<span class="comment">#结束条件</span></span><br><span class="line">        <span class="keyword">return</span> nums</span><br><span class="line">    </span><br><span class="line">    pos = get_rand(left,right)</span><br><span class="line">    swap(nums,left,pos)</span><br><span class="line">    key = nums[left]</span><br><span class="line">    lp = left<span class="number">-1</span></span><br><span class="line">    rp = right+<span class="number">1</span></span><br><span class="line">    i = left<span class="comment">#指向未被遍历的数</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> i &lt; rp:</span><br><span class="line">        <span class="comment">#当前值小于key</span></span><br><span class="line">        <span class="keyword">if</span> nums[i]&lt;key:</span><br><span class="line">            <span class="comment">#和等于key的元素互换，并且将lp加1，将刚刚那个元素合并到小于key的行列</span></span><br><span class="line">            swap(nums,i,lp+<span class="number">1</span>)</span><br><span class="line">            lp+=<span class="number">1</span></span><br><span class="line">            i+=<span class="number">1</span></span><br><span class="line">        <span class="keyword">elif</span> nums[i]&gt;key:</span><br><span class="line">            <span class="comment">#将nums[i]和rp的前一个元素互换</span></span><br><span class="line">            swap(nums,i,rp<span class="number">-1</span>)</span><br><span class="line">            rp-=<span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>: </span><br><span class="line">            i+=<span class="number">1</span></span><br><span class="line">    <span class="comment">#现在lp指向小于key的最后一个元素</span></span><br><span class="line">    <span class="comment">#i==rp，指向第一个大于key的元素</span></span><br><span class="line">    swap(nums,left,lp)</span><br><span class="line">    <span class="comment">#现在key的位置就是lp</span></span><br><span class="line">    <span class="comment">#[left....lp-1] &lt; key</span></span><br><span class="line">    <span class="comment">#[lp....rp-1] == key</span></span><br><span class="line">    <span class="comment">#[rp....right] &gt; key</span></span><br><span class="line"></span><br><span class="line">    qsort1(nums,left,lp<span class="number">-1</span>)</span><br><span class="line">    qsort1(nums,rp,right)</span><br><span class="line">    <span class="keyword">return</span> nums</span><br></pre></td></tr></table></figure><h1><span id="6-归并排序">6. 归并排序</span></h1><p>归并排序采用递归分治。和选择排序一样，归并排序的性能不受输入数据的影响，时间复杂度始终是$O(nlogn)$，代价是需要额外的内存空间<br><strong>基本思想：</strong><br>归并排序就是将待排序序列分为前后两个子序列，然后分别对两个子序列继续调用归并排序，待两个子序列都排完序后，再将两个子序列合并，又称为2-路归并，可见归并排序是一个递归的过程。<br><strong>步骤：</strong></p><ol><li>将长度为n的输入序列划分为2个长度为n/2的子序列</li><li>对这2个子序列分别采用归并排序</li><li>将2个排序好的子序列合并成一个最终的排序序列</li><li>合并2个有序数组时，比较2个数组最前面的数，谁小先取谁，然后相应的指针向后移一位，然后再比较，直到一个数组为空，最后把另一个数组的剩余部分复制过来即可</li></ol><p><img src="/2020/03/30/Leetcode之排序/排序算法/merge.gif" alt=""></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">merge_sort</span><span class="params">(nums)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> len(nums) &lt;= <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> nums</span><br><span class="line">    mid = int(len(nums) / <span class="number">2</span>)</span><br><span class="line">    left = merge_sort(nums[:mid])</span><br><span class="line">    right = merge_sort(nums[mid:])</span><br><span class="line">    <span class="keyword">return</span> merge(left,right)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">merge</span><span class="params">(left,right)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    将2个有序数组合并成1个大的有序数据</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    lp,rp = <span class="number">0</span>,<span class="number">0</span></span><br><span class="line">    result = []</span><br><span class="line">    <span class="keyword">while</span> lp &lt; len(left) <span class="keyword">and</span> rp &lt; len(right):</span><br><span class="line">        <span class="keyword">if</span> left[lp] &lt; right[rp]:</span><br><span class="line">            result.append(left[lp])</span><br><span class="line">            lp += <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            result.append(right[rp])</span><br><span class="line">            rp += <span class="number">1</span></span><br><span class="line">    result += left[lp:]</span><br><span class="line">    result += right[rp:]</span><br><span class="line">    <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure><ul><li>稳定，因为我们在遇到相等的数据时必然是按顺序抄写到大数组中，没有改变顺序</li><li>时间复杂度：$O(nlogn)$</li><li>空间复杂度：$O(n)$</li><li>适用场景：在数据量比较大时表现出色，但是因为空间复杂度$O(n)$在数据量特别大时（如1千万）也不可以接受，因此使用归并排序时一定要注意。</li></ul><h1><span id="7-堆排序">7. 堆排序</span></h1><h2><span id="71-堆排序">7.1. 堆排序</span></h2><p>堆排序是借助二叉堆来实现，如果升序排列使用最大堆，反之使用最小堆。以下以最大堆为例。<br>堆排序在topK问题中使用频繁。<br>二叉堆具有以下性质：</p><ol><li>父节点的值总是大于或等于(小于或等于)子节点</li><li>每个节点的左右子树都是一个二叉堆</li></ol><p>堆是一个特殊的完全二叉树，除了最底层之外，每一层都是满的，这使得堆可以利用数组来表示（普通的二叉树通常用链表表示），如下所示，堆和数组的相互关系</p><p><img src="/2020/03/30/Leetcode之排序/排序算法/heap-sort.png" alt=""></p><p>给定某个节点，它在数组中的下标i，可以计算出它的父节点，左/右子节点的下标：<br>父节点下标：floor((i-1)/2)<br>左子节点：2i+1<br>右子节点：2(i+1)</p><p>在堆排序中，我们首先就是找最后一个非叶子节点，例如上面地树，最后一个非叶子节点是7，其实就是叶子节点1的父节点。已知叶子节点的下标是n-1，其父节点下标就是floor(n/2-1)</p><p><strong>基本思想：</strong><br>堆排序就是把最大堆的堆顶的最大数取出来，将剩下的堆继续调整为最大堆，再次将堆顶的最大数取出来，一直到只剩下一个节点结束。</p><p>对于堆排序我们只关心2个问题：</p><ol><li>给定一个无序数组，如何建立堆？</li><li>删除堆顶元素后，如何调整数组称为新队</li></ol><p>第一个问题，可以使用数组来表示堆，首先找到最后一个非叶子节点，作为需要调整的堆的根节点，将其调整为最大堆，然后根节点向前移，再调整前一个堆，直到nums[0]作为根节点，调整为最大堆。这样，一个完整的最大堆就建立起来了。堆顶就是最大的元素</p><p>第二个问题，假设我们已经有一个现成的最大堆，现在删除根元素，但并没有移动别的元素，则根元素空了，其他元素还保留着堆的性质，可以把最后一个元素(代号A)移动到根元素的位置，则堆的性质被破坏，A小于其某个左右子节点，于是，我们可以把A和它的子节点调换位置，如果A大于所有的子节点，则堆调整结束，否则，重复上述过程，A元素在树形结构中不断下沉，直到合适的位置，数组重新恢复堆的性质，上述过程一般称为“筛选”，自上而下。</p><p><strong>步骤：</strong></p><ol><li>建立最大堆</li><li>挨个输出：将最后一个节点和堆顶交换，重新调整堆为最大堆</li></ol><p><img src="/2020/03/30/Leetcode之排序/排序算法/heap.gif" alt=""></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">heap_sort</span><span class="params">(nums)</span>:</span></span><br><span class="line">    n = len(nums)</span><br><span class="line">    first = int(n/<span class="number">2</span><span class="number">-1</span>)</span><br><span class="line">    <span class="comment">#建立堆,从最后一个非叶子节点开始调整</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(first,<span class="number">-1</span>,<span class="number">-1</span>):</span><br><span class="line">        <span class="comment">#这里的high始终为n-1，high本身应该是以nums[i]为根节点的最后一个节点，</span></span><br><span class="line">        <span class="comment">#但是这个堆最后一个节点不好求，所以就直接用n-1作为high，对这个堆的调整没有任何影响，</span></span><br><span class="line">        <span class="comment">#high本身的作用是防止数组越界</span></span><br><span class="line">        heap_shift(nums,i,n<span class="number">-1</span>)</span><br><span class="line">    <span class="comment">#调整堆</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(n<span class="number">-1</span>,<span class="number">-1</span>,<span class="number">-1</span>):</span><br><span class="line">        <span class="comment">#i始终是堆的最后一个元素，将堆顶的最大值放在数组的后面</span></span><br><span class="line">        swap(nums,<span class="number">0</span>,i)</span><br><span class="line">        heap_shift(nums,<span class="number">0</span>,i<span class="number">-1</span>)</span><br><span class="line">    <span class="keyword">return</span> nums</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">heap_shift</span><span class="params">(nums,low,high)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    对某个对进行调整，使其变成最大堆。</span></span><br><span class="line"><span class="string">    其中被调整的数在nums中起始位置为low，</span></span><br><span class="line"><span class="string">    终止位置为high，即[low,high]</span></span><br><span class="line"><span class="string">    nums:待调整的nums</span></span><br><span class="line"><span class="string">    low:堆的第一个元素</span></span><br><span class="line"><span class="string">    high:堆的最后一个元素</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    i = low<span class="comment">#堆顶</span></span><br><span class="line">    j = <span class="number">2</span>*i+<span class="number">1</span><span class="comment">#左孩子</span></span><br><span class="line">    tmp = nums[low]<span class="comment">#当前堆顶</span></span><br><span class="line">    <span class="keyword">while</span> j &lt;= high:</span><br><span class="line">        <span class="comment">#找出左右孩子中较大的那个元素</span></span><br><span class="line">        <span class="keyword">if</span> j+<span class="number">1</span>&lt;=high <span class="keyword">and</span> nums[j+<span class="number">1</span>]&gt;nums[j]:</span><br><span class="line">            j += <span class="number">1</span><span class="comment">#j指向右孩子</span></span><br><span class="line">        <span class="keyword">if</span> nums[j] &gt; tmp:<span class="comment">#孩子&gt;父节点</span></span><br><span class="line">            nums[i] = nums[j]</span><br><span class="line">            i = j</span><br><span class="line">            j = <span class="number">2</span>*i+<span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:<span class="comment">#tmp比2个孩子都大,因为孩子已经是最大堆</span></span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    nums[i] = tmp</span><br></pre></td></tr></table></figure><ul><li>时间复杂度：$O(nlog(n))$</li></ul><h2><span id="72-应用topk问题">7.2. 应用：topK问题</span></h2><p>堆排序通常用来解决topK问题：有n个数，得到前k大的数</p><p>解决思路：</p><ul><li>排序后切片：$O(nlog(n))$</li><li>排序Low B三人组：$O(kn)$</li><li>堆排序：$O(nlog(k))$</li></ul><p>下面介绍使用堆排序</p><ul><li>取列表前k个元素建立一个最小堆，堆中只有k个元素，堆顶是最小的元素，下面的值都大于或等于堆顶，则堆顶就是目前这k个数中第k大的数</li><li>然后再看剩下的n-k个数，如果这个数比堆顶小，则堆顶保持不变，如果这个数比堆顶大，用这个数把堆顶换掉，然后再调整一下这个堆把它变成最小堆</li><li>然后再看后面的数，如果这个数比堆顶小，则堆顶保持不变，如果这个数比堆顶大，用这个数把堆顶换掉，然后再调整一下这个堆把它变成最小堆</li><li>重复以上步骤，直到列表遍历完，则这k个数组成的最小堆就是前k个最大的数</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">heap_shift</span><span class="params">(nums,low,high)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    调整为最小堆</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    i = low<span class="comment">#堆顶</span></span><br><span class="line">    j = <span class="number">2</span>*i+<span class="number">1</span><span class="comment">#左孩子</span></span><br><span class="line">    tmp = nums[low]</span><br><span class="line">    <span class="keyword">while</span> j &lt;= high:</span><br><span class="line">        <span class="keyword">if</span> j+<span class="number">1</span>&lt;=high <span class="keyword">and</span> nums[j+<span class="number">1</span>]&lt;nums[j]:</span><br><span class="line">            j += <span class="number">1</span><span class="comment">#j指向右孩子</span></span><br><span class="line">        <span class="keyword">if</span> nums[j] &lt; tmp:</span><br><span class="line">            nums[i] = nums[j]</span><br><span class="line">            i = j</span><br><span class="line">            j = <span class="number">2</span>*i+<span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    nums[i] = tmp</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">topk</span><span class="params">(nums,k)</span>:</span></span><br><span class="line">    n = len(nums)</span><br><span class="line">    heap = nums[:k]<span class="comment">#先使用nums中的前k个元素构建小顶堆</span></span><br><span class="line">    first = int(k/<span class="number">2</span><span class="number">-1</span>)</span><br><span class="line">    <span class="comment">#建立堆</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(first,<span class="number">-1</span>,<span class="number">-1</span>):</span><br><span class="line">        heap_shift(heap,i,k<span class="number">-1</span>)</span><br><span class="line">    <span class="comment">#遍历nums中剩下的元素，加入到最小堆中</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(k,n<span class="number">-1</span>):</span><br><span class="line">        <span class="keyword">if</span> nums[i] &gt; heap[<span class="number">0</span>]:<span class="comment">#当前值比堆顶大，替换堆顶，然后调整堆</span></span><br><span class="line">            heap[<span class="number">0</span>] = nums[i]</span><br><span class="line">            heap_shift(heap,<span class="number">0</span>,k<span class="number">-1</span>)</span><br><span class="line">    <span class="comment">#现在最小堆中已经是前k大的数，只不过是从小到大排序</span></span><br><span class="line">    <span class="comment">#但是返回的数是从大到小</span></span><br><span class="line">    <span class="keyword">return</span> heap[::<span class="number">-1</span>]</span><br></pre></td></tr></table></figure><h1><span id="8-nb三人组小结">8. NB三人组小结</span></h1><ul><li>三种排序时间复杂度都是$O(nlog(n))$</li><li>一般情况下，运行时间：<ul><li>快排 &lt; 归并 &lt; 堆排序</li></ul></li><li>三种排序的缺点：<ul><li>快排：极端情况下效率低</li><li>归并排序：需要额外的内存开销</li><li>堆排序：在快的排序算法中相对较慢</li></ul></li></ul><h1><span id="9-希尔排序插入排序的改良版">9. 希尔排序(插入排序的改良版)</span></h1><p>与插入排序的不同在于：它会优先比较距离较远的元素，又叫做“缩小增量排序”<br><strong>基本思想：</strong><br>将记录按照一定的增量分组，对每组使用插入排序进行排序，随着增量的变小，每组包含的数字越来越多，当增量变成1时，所有的数字恰好被分为1组，算法终止。<br>在此我们选择增量gap=length/2，缩小增量继续以gap = gap/2的方式，这种增量选择我们可以用一个序列来表示，{n/2,(n/2)/2…1}，称为增量序列。希尔排序的增量序列的选择与证明是个数学难题，我们选择的这个增量序列是比较常用的，也是希尔建议的增量，称为希尔增量，但其实这个增量序列不是最优的。此处我们做示例使用希尔增量。<br><strong>步骤：</strong></p><ol><li>选择一个增量序列${t_1,t_2,…1}$</li><li>先选第一个增量$t_1$，将数据划分为$t_1$组，对每组进行插入排序</li><li>再选择增量$t_2$，将数据划分为$t_2$组，对每组进行插入排序</li><li>直到增量为1</li></ol><p><strong>【注意】</strong> 增量序列最后一个必须为1</p><p><img src="/2020/03/30/Leetcode之排序/排序算法/shell.png" alt=""></p><p>当gap=2时，数组为[3,5,1,6,0,8,9,4,7,2],其中[3,1,0,9,7]为一组，[5,6,8,4,2]为一组，for循环i分为等于2,3,4,…9</p><ul><li>当i=2时，对第一个子数组排序，即当前待插入的值是1,和3比较，放在3前面，顺序变成[1,3,0,9,7]</li><li>当i=3时，对第二个子数组排序，当前待插入的值是6，大于5，顺序不变，依旧为[5,6,8,4,2]</li><li>当i=4时，对第一个子数组排序，当前待插入的值是0，前面已经排好序的是[1,3],分别和1,3比较，只要比0大，顺序就往后移，顺序变为[0,1,3,9,7]</li><li>当i=5时，对第二个子数组排序，待插入的值为8，前面已经排好序的是[5,6],和5,6比较，顺序不变，依旧为[5,6,8]</li><li>……</li></ul><p>由上可以看出，给定一个待排序的数字，和同组的数进行比较，然后交换，待排序的数字不是一步一步向前挪，而是跳跃式地往前挪。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">shell_sort</span><span class="params">(nums)</span>:</span></span><br><span class="line">    n = len(nums)</span><br><span class="line">    gap = round(n/<span class="number">2</span>)</span><br><span class="line">    <span class="keyword">while</span> gap &gt; <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(gap,n):</span><br><span class="line">            tmp = nums[i]</span><br><span class="line">            j = i</span><br><span class="line">            <span class="keyword">while</span>(j &gt;= gap <span class="keyword">and</span> nums[j-gap] &gt; tmp):</span><br><span class="line">                nums[j] = nums[j-gap]</span><br><span class="line">                j -= gap</span><br><span class="line">            nums[j] = tmp</span><br><span class="line">        gap = round(gap/<span class="number">2</span>)</span><br><span class="line">    <span class="keyword">return</span> nums</span><br></pre></td></tr></table></figure><ul><li>时间复杂度：很难分析，因为比较次数和移动次数和增量序列有关</li><li>空间复杂度：$O(1)$</li></ul><h1><span id="10-计数排序">10. 计数排序</span></h1><p>计数排序的核心在于将输入的数据值转化为键存储在额外开辟的数组空间中。 作为一种线性时间复杂度的排序，<strong>计数排序要求输入的数据必须是有确定范围的整数</strong>。</p><p>计数排序(Counting sort)是一种稳定的排序算法。计数排序使用一个额外的数组C，其中第i个元素是待排序数组A中值等于i的元素的个数。然后根据数组C来将A中的元素排到正确的位置。它只能对整数进行排序。</p><p><img src="/2020/03/30/Leetcode之排序/排序算法/count.gif" alt=""></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">count_sort</span><span class="params">(nums)</span>:</span></span><br><span class="line">    max_value = max(nums)</span><br><span class="line">    count = [<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> range(max_value+<span class="number">1</span>)]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> nums:</span><br><span class="line">        count[i]+=<span class="number">1</span></span><br><span class="line">    nums.clear()</span><br><span class="line">    <span class="keyword">for</span> idx,value <span class="keyword">in</span> enumerate(count):</span><br><span class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> range(value):</span><br><span class="line">            nums.append(idx)</span><br><span class="line">    <span class="keyword">return</span> nums</span><br></pre></td></tr></table></figure><p>当输入的元素是n个0到k之间的整数时，它的运行时间是 O(n + k)。计数排序不是比较排序，排序的速度快于任何比较排序算法。由于用来计数的数组C的长度取决于待排序数组中数据的范围（等于待排序数组的最大值与最小值的差加上1），这使得计数排序对于数据范围很大的数组，需要大量时间和内存。</p><h1><span id="11-桶排序">11. 桶排序</span></h1><p>桶排序是计数排序的升级版。它利用了函数的映射关系，高效与否的关键就在于这个映射函数的确定。<br>桶排序 (Bucket sort)的工作的原理：假设输入数据服从均匀分布，将数据分到有限数量的桶里，每个桶再分别排序.</p><p><img src="/2020/03/30/Leetcode之排序/排序算法/bucket.jpg" alt=""></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bucket_sort</span><span class="params">(nums,bucker_nums)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    nums:待排序数组</span></span><br><span class="line"><span class="string">    bucker_nums:一共有多少个桶</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="comment">#创建桶</span></span><br><span class="line">    min_value = min(nums)</span><br><span class="line">    max_value = max(nums)</span><br><span class="line">    buckets = [[] <span class="keyword">for</span> _ <span class="keyword">in</span> range(bucker_nums)]</span><br><span class="line">    <span class="comment">#每个桶放多少个数</span></span><br><span class="line">    bucker_size = int((max_value-min_value)/bucker_nums+<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> nums:</span><br><span class="line">        <span class="comment">#判断i放在哪个桶里</span></span><br><span class="line">        cur_id = int((i - <span class="number">1</span>) / bucker_size)</span><br><span class="line">        buckets[cur_id].append(i)</span><br><span class="line">        <span class="comment">#使用插入方法排序</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(len(buckets[cur_id])<span class="number">-1</span>,<span class="number">0</span>,<span class="number">-1</span>):</span><br><span class="line">            <span class="comment">#如果当前的值 &lt; 桶中的元素，和大的值交换</span></span><br><span class="line">            <span class="keyword">if</span> buckets[cur_id][j] &lt; buckets[cur_id][j<span class="number">-1</span>]:</span><br><span class="line">                swap(buckets[cur_id],j,j<span class="number">-1</span>)</span><br><span class="line">            <span class="comment">#当前值 &gt;= 桶中的元素，不用交换</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">    sorted_nums = []</span><br><span class="line">    <span class="comment">#每个桶已经排好序，遍历每个桶，放在sorted_nums中</span></span><br><span class="line">    <span class="keyword">for</span> bucket <span class="keyword">in</span> buckets:</span><br><span class="line">        sorted_nums.extend(bucket)</span><br><span class="line">    <span class="keyword">return</span> sorted_nums</span><br></pre></td></tr></table></figure><ul><li>桶排序的表现取决于数据的分布，也就是需要对不同数据排序时采取不同的分桶策略</li><li>空间复杂度：平均$O(nk)$，最坏$O(n^2k)$</li><li>时间复杂度：$O(n+k)$</li></ul><h1><span id="12-基数排序">12. 基数排序</span></h1><p>基数排序是按照低位先排序，然后收集，再按照高位排序，然后再收集，依次类推，直到最高位。</p><p><img src="/2020/03/30/Leetcode之排序/排序算法/radix.gif" alt=""></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">radix_sort</span><span class="params">(nums)</span>:</span></span><br><span class="line">    max_value = max(nums)</span><br><span class="line">    max_digit = len(str(max_value))<span class="comment">#最大数的位数</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(max_digit):</span><br><span class="line">        buckets = [[] <span class="keyword">for</span> _ <span class="keyword">in</span> range(<span class="number">10</span>)]</span><br><span class="line">        <span class="comment">#假设最大数为786，i = 0,1,2</span></span><br><span class="line">        <span class="keyword">for</span> val <span class="keyword">in</span> nums:</span><br><span class="line">            <span class="comment">#取出个位数，十位数，百位数</span></span><br><span class="line">            <span class="comment">#958,</span></span><br><span class="line">            <span class="comment">#i = 0,8=958//1 %10,</span></span><br><span class="line">            <span class="comment">#i = 1,5=958//10 %10</span></span><br><span class="line">            <span class="comment">#i = 2,9=958//100 %10</span></span><br><span class="line">            digit = (val // <span class="number">10</span>**i) % <span class="number">10</span></span><br><span class="line">            buckets[digit].append(val)</span><br><span class="line">        <span class="comment">#分桶完成，再放回到nums中</span></span><br><span class="line">        nums.clear()</span><br><span class="line">        <span class="keyword">for</span> bucket <span class="keyword">in</span> buckets:</span><br><span class="line">            nums.extend(bucket)</span><br><span class="line">    <span class="keyword">return</span> nums</span><br></pre></td></tr></table></figure><ul><li>时间复杂度：$O(nk)$,k是最大数的位数</li><li>空间复杂度：$O(k+n)$</li></ul><h1><span id="leetcode题">LeetCode题</span></h1><h2><span id="88-合并两个有序数组">88. 合并两个有序数组</span></h2><p>给你两个有序整数数组 nums1 和 nums2，请你将 nums2 合并到 nums1 中，使 num1 成为一个有序数组。</p><p>说明:<br>初始化 nums1 和 nums2 的元素数量分别为 m 和 n 。<br>你可以假设 nums1 有足够的空间（空间大小大于或等于 m + n）来保存 nums2 中的元素。</p><p>合并2个有序数组是归并排序的子过程。</p><p><strong>【解法1】</strong><br>开辟一个新的数据nums3，将nums1和nums2排序到nums3中</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">merge</span><span class="params">(self, nums1, m, nums2, n)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums1: List[int]</span></span><br><span class="line"><span class="string">        :type m: int</span></span><br><span class="line"><span class="string">        :type nums2: List[int]</span></span><br><span class="line"><span class="string">        :type n: int</span></span><br><span class="line"><span class="string">        :rtype: None Do not return anything, modify nums1 in-place instead.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        nums3 = []</span><br><span class="line">        p1=<span class="number">0</span></span><br><span class="line">        p2=<span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> p1 &lt; m <span class="keyword">and</span> p2 &lt; n:</span><br><span class="line">            <span class="keyword">if</span> nums1[p1] &lt; nums2[p2]:</span><br><span class="line">                nums3.append(nums1[p1])</span><br><span class="line">                p1+=<span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                nums3.append(nums2[p2])</span><br><span class="line">                p2+=<span class="number">1</span></span><br><span class="line"></span><br><span class="line">        nums3 += nums1[p1:m]</span><br><span class="line">        nums3 += nums2[p2:n]</span><br><span class="line">        nums1[:]=nums3[:]</span><br><span class="line">        <span class="keyword">return</span> nums1</span><br></pre></td></tr></table></figure><p><strong>【解法2】</strong><br>题目中说nums1中的空间大小为m+n，就是说我们可以不用新的数组nums3，使用nums1就可以了。从后往前遍历，哪个数大就存到nums1的后面，直到有个数组遍历完。如果遍历完的数组是nums2，这是nums1已经是有序了，直接返回即可。如果nums1遍历完了，就要把nums2未遍历的数都复制到nums1中</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">merge</span><span class="params">(self, nums1, m, nums2, n)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums1: List[int]</span></span><br><span class="line"><span class="string">        :type m: int</span></span><br><span class="line"><span class="string">        :type nums2: List[int]</span></span><br><span class="line"><span class="string">        :type n: int</span></span><br><span class="line"><span class="string">        :rtype: None Do not return anything, modify nums1 in-place instead.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> m==<span class="number">0</span>:</span><br><span class="line">            nums1[:]=nums2[:]</span><br><span class="line">            <span class="keyword">return</span> nums1</span><br><span class="line">        cur_idx=m+n<span class="number">-1</span></span><br><span class="line">        p1 = m<span class="number">-1</span></span><br><span class="line">        p2 = n<span class="number">-1</span></span><br><span class="line">        <span class="keyword">while</span> p1&gt;=<span class="number">0</span> <span class="keyword">and</span> p2&gt;=<span class="number">0</span>:</span><br><span class="line">            <span class="keyword">if</span> nums1[p1]&gt;nums2[p2]:</span><br><span class="line">                nums1[cur_idx]=nums1[p1]</span><br><span class="line">                cur_idx -=<span class="number">1</span></span><br><span class="line">                p1-=<span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                nums1[cur_idx]=nums2[p2]</span><br><span class="line">                cur_idx-=<span class="number">1</span></span><br><span class="line">                p2-=<span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> p2 &lt; <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> nums1</span><br><span class="line">        <span class="keyword">if</span> p1 &lt; <span class="number">0</span>:</span><br><span class="line">            nums1[:cur_idx+<span class="number">1</span>] = nums2[:p2+<span class="number">1</span>]</span><br><span class="line">            <span class="keyword">return</span> nums1</span><br></pre></td></tr></table></figure><h2><span id="215-数组中的第k个最大元素">215. 数组中的第K个最大元素</span></h2><p>在未排序的数组中找到第 k 个最大的元素。请注意，你需要找的是数组排序后的第 k 个最大的元素，而不是第 k 个不同的元素。</p><p>示例 1:</p><p>输入: [3,2,1,5,6,4] 和 k = 2<br>输出: 5<br>示例 2:</p><p>输入: [3,2,3,1,2,4,5,5,6] 和 k = 4<br>输出: 4</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/kth-largest-element-in-an-array" target="_blank" rel="noopener">https://leetcode-cn.com/problems/kth-largest-element-in-an-array</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p><p><strong>【解法1】</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findKthLargest</span><span class="params">(self, nums, k)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :type k: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="comment">#对nums进行排序，从大到小，第4个元素</span></span><br><span class="line">        nums.sort(reverse=<span class="keyword">True</span>)</span><br><span class="line">        <span class="keyword">return</span> nums[k<span class="number">-1</span>]</span><br></pre></td></tr></table></figure><ul><li>时间复杂度：$O(nlogn)$</li><li>空间复杂度：O(1)</li></ul><p>【解法2】<br>使用小顶堆，堆中只有k个元素，小顶堆的堆顶是k个元素中的最小值，下面的值都比它大，即堆顶就是第k大的数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findKthLargest</span><span class="params">(self, nums, k)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :type k: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        n = len(nums)</span><br><span class="line">        heap=nums[:k]<span class="comment">#前k个元素</span></span><br><span class="line">        first=int(k/<span class="number">2</span><span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(first,<span class="number">-1</span>,<span class="number">-1</span>):</span><br><span class="line">            self.heap_shift(heap,i,k<span class="number">-1</span>)</span><br><span class="line">        <span class="comment">#遍历k之后的所有元素</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(k,n):</span><br><span class="line">            <span class="keyword">if</span> nums[i]&gt;heap[<span class="number">0</span>]:</span><br><span class="line">                heap[<span class="number">0</span>]=nums[i]</span><br><span class="line">                self.heap_shift(heap,<span class="number">0</span>,k<span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">return</span> heap[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">heap_shift</span><span class="params">(self,nums,low,high)</span>:</span></span><br><span class="line">        <span class="comment">#只进行调整,把最小的数调整到上面</span></span><br><span class="line">        tmp = nums[low]</span><br><span class="line">        i= low</span><br><span class="line">        j = <span class="number">2</span>*i+<span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> j &lt;= high:</span><br><span class="line">            <span class="keyword">if</span> j+<span class="number">1</span>&lt;=high <span class="keyword">and</span> nums[j+<span class="number">1</span>]&lt;nums[j]:</span><br><span class="line">                j+=<span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> nums[j]&lt;tmp:</span><br><span class="line">                nums[i]=nums[j]</span><br><span class="line">                i=j</span><br><span class="line">                j=<span class="number">2</span>*i+<span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        nums[i]=tmp</span><br></pre></td></tr></table></figure><p><strong>【解法3】</strong><br>第k大的元素，假设对nums按照从小到大排序，第k大的元素的下标为n-k<br>[1,2,2,3,5,6,6]，n=7，第2大的元素下标为5，第3大的元素下标为4。<br>即给定nums，我们要找的就是对nums从小到大排序后，下标为n-k的元素<br>使用快速排序，快速排序是先给定一个pivot，然后将这个pivot放在nums中正确的位置，所谓正确的位置就是：左边的元素都小于pivot，右边的元素都大于等于pivot。经过一次排序，将pivot放在下标为i的位置，判断下标为i和n-k的关系，如果i等于n-k，则返回。如果i小于n-k,说明第k大的元素在pivot的右边，更新left=i+1，否则更新right=i-1</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findKthLargest</span><span class="params">(self, nums, k)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :type k: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        n = len(nums)</span><br><span class="line">        left=<span class="number">0</span></span><br><span class="line">        right=n<span class="number">-1</span></span><br><span class="line">        target=n-k</span><br><span class="line">        <span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">            idx = self.quick_sort(nums,left,right)</span><br><span class="line">            <span class="keyword">if</span> idx==target:</span><br><span class="line">                <span class="keyword">return</span> nums[target]</span><br><span class="line">            <span class="keyword">if</span> idx &lt; target:</span><br><span class="line">                left=idx+<span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                right=idx<span class="number">-1</span></span><br><span class="line">        <span class="keyword">return</span> nums[left]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">quick_sort</span><span class="params">(self,nums,left,right)</span>:</span></span><br><span class="line">        <span class="comment">#在nums中找一个pivot，使得左边都小于pivot，右边都大于等于pivot</span></span><br><span class="line">        <span class="comment">#返回pivot的位置下标</span></span><br><span class="line">        <span class="comment">#随机选择一个数作为pivot</span></span><br><span class="line">        <span class="keyword">import</span> random</span><br><span class="line">        random_index = random.randint(left, right)</span><br><span class="line">        nums[random_index], nums[left] = nums[left], nums[random_index]</span><br><span class="line">        pivot = nums[left]</span><br><span class="line">        lp = left</span><br><span class="line">        rp = right</span><br><span class="line">        <span class="keyword">while</span> lp&lt;rp:</span><br><span class="line">            <span class="keyword">while</span> lp &lt; rp <span class="keyword">and</span> nums[rp]&gt;=pivot:</span><br><span class="line">                rp-=<span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> lp &lt; rp <span class="keyword">and</span> nums[lp]&lt;=pivot:</span><br><span class="line">                lp+=<span class="number">1</span></span><br><span class="line">            nums[lp],nums[rp] = nums[rp],nums[lp]</span><br><span class="line">        <span class="comment">#跳出循环时，lp==rp，指向的元素小于pivot</span></span><br><span class="line">        nums[left],nums[lp]=nums[lp],nums[left]</span><br><span class="line">        <span class="keyword">return</span> lp</span><br></pre></td></tr></table></figure><h2><span id="347-前-k-个高频元素">347. 前 K 个高频元素</span></h2><p>给定一个非空的整数数组，返回其中出现频率前 k 高的元素。</p><p>示例 1:</p><p>输入: nums = [1,1,1,2,2,3], k = 2<br>输出: [1,2]</p><p><strong>【我的解法】</strong><br>使用字典保存每个元素和其出现的次数，</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">topKFrequent</span><span class="params">(self, nums, k)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :type k: int</span></span><br><span class="line"><span class="string">        :rtype: List[int]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        count_dict = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> nums:</span><br><span class="line">            <span class="keyword">if</span> i <span class="keyword">not</span> <span class="keyword">in</span> count_dict:</span><br><span class="line">                count_dict[i]=<span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                count_dict[i]+=<span class="number">1</span></span><br><span class="line">        <span class="comment">#对count_dict进行排序</span></span><br><span class="line">        count_dict=sorted(count_dict.items(),key=<span class="keyword">lambda</span> x:x[<span class="number">1</span>],reverse=<span class="keyword">True</span>)</span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">for</span> value,count <span class="keyword">in</span> count_dict[:k]:</span><br><span class="line">            res.append(value)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><p><strong>【解法2】</strong><br>使用大顶堆。首先使用字典count_dict记录每个数字及出现的次数，然后构造堆，堆中的值也可以是元组，(freq,value)分别是出现的次数和数字。然后使用nlargest从中取出前k的的值，取出的值也是(freq,value)的元组形式，最后返回所有的value值 </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="keyword">import</span> heapq</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">topKFrequent</span><span class="params">(self, nums, k)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :type k: int</span></span><br><span class="line"><span class="string">        :rtype: List[int]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        count_dict = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> nums:</span><br><span class="line">            <span class="keyword">if</span> i <span class="keyword">not</span> <span class="keyword">in</span> count_dict:</span><br><span class="line">                count_dict[i]=<span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                count_dict[i]+=<span class="number">1</span></span><br><span class="line">        h = []</span><br><span class="line">        <span class="keyword">for</span> value,freq <span class="keyword">in</span> count_dict.items():</span><br><span class="line">            <span class="comment">#heapq插入的值可以是元组，按照元组的第一个元素排序</span></span><br><span class="line">            heapq.heappush(h, (freq, value))</span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">for</span> freq,value <span class="keyword">in</span> heapq.nlargest(k, h):</span><br><span class="line">            res.append(value)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h2><span id="面试题39-数组中出现次数超过一半的数字">面试题39. 数组中出现次数超过一半的数字</span></h2><p>数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。</p><p>你可以假设数组是非空的，并且给定的数组总是存在多数元素。</p><p>示例 1:</p><p>输入: [1, 2, 3, 2, 2, 2, 5, 4, 2]<br>输出: 2</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/shu-zu-zhong-chu-xian-ci-shu-chao-guo-yi-ban-de-shu-zi-lcof" target="_blank" rel="noopener">https://leetcode-cn.com/problems/shu-zu-zhong-chu-xian-ci-shu-chao-guo-yi-ban-de-shu-zi-lcof</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p><p><strong>【解法1】</strong><br>使用count存储数字及出现的频率，因为题目中说肯定存储多数元素，所以直接返回出现次数最多的数字。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">majorityElement</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="comment">#用count记录每个数出现的次数</span></span><br><span class="line">        count=&#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> nums:</span><br><span class="line">            <span class="keyword">if</span> i <span class="keyword">not</span> <span class="keyword">in</span> count:</span><br><span class="line">                count[i]=<span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                count[i]+=<span class="number">1</span></span><br><span class="line">            </span><br><span class="line">        count=sorted(count.items(),key=<span class="keyword">lambda</span> x:x[<span class="number">1</span>],reverse=<span class="keyword">True</span>)</span><br><span class="line">        print(count)</span><br><span class="line">        <span class="keyword">return</span> count[<span class="number">0</span>][<span class="number">0</span>]</span><br></pre></td></tr></table></figure><p><strong>【解法2】</strong><br>将nums进行排序，多数元素肯定出现在中位数的位置</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">majorityElement</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        n=len(nums)</span><br><span class="line">        nums.sort()</span><br><span class="line">        <span class="keyword">return</span> nums[n/<span class="number">2</span>]</span><br></pre></td></tr></table></figure><p><strong>【解法3】</strong><br>使用摩尔投票，首先记nums[0]为众数，如果vote=0，则将当前值i设置为众数，然后再遍历下一个数，如果下一个数等于候选众数，vote则加1，否则减1.最终的vote肯定大于0，而mode也就是最终的众数。<br>超过一半的众数，和任何数抵消，最终的vote都&gt;0</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">majorityElement</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        vote=<span class="number">0</span></span><br><span class="line">        mode=nums[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> nums:</span><br><span class="line">            <span class="keyword">if</span> vote==<span class="number">0</span>:</span><br><span class="line">                mode=i</span><br><span class="line">            <span class="keyword">if</span> mode==i:</span><br><span class="line">                vote+=<span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                vote-=<span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> mode</span><br></pre></td></tr></table></figure><h2><span id="75-颜色分类">75. 颜色分类</span></h2><p>给定一个包含红色、白色和蓝色，一共 n 个元素的数组，原地对它们进行排序，使得相同颜色的元素相邻，并按照红色、白色、蓝色顺序排列。</p><p>此题中，我们使用整数 0、 1 和 2 分别表示红色、白色和蓝色。</p><p>注意:<br>不能使用代码库中的排序函数来解决这道题。</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/sort-colors" target="_blank" rel="noopener">https://leetcode-cn.com/problems/sort-colors</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p><blockquote><p>输入: [2,0,2,1,1,0]<br>输出: [0,0,1,1,2,2]</p></blockquote><p><strong>【我的解法】</strong><br>参考三路快排，这里比三路快排要简单，因为这里只有3个数，将pivot选为1，将小于1的放在左边，等于1的放在中间，大于1的放在右边。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sortColors</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: None Do not return anything, modify nums in-place instead.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        n = len(nums)</span><br><span class="line">        <span class="keyword">if</span> n &lt; <span class="number">2</span>:</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        lp = <span class="number">-1</span> </span><br><span class="line">        rp = n</span><br><span class="line">        i = <span class="number">0</span> <span class="comment">#指向未被遍历的数</span></span><br><span class="line">        <span class="keyword">while</span> i &lt; rp:</span><br><span class="line">            <span class="keyword">if</span> nums[i]&lt;<span class="number">1</span>:</span><br><span class="line">                self.swap(nums,i,lp+<span class="number">1</span>)</span><br><span class="line">                lp+=<span class="number">1</span></span><br><span class="line">                i+=<span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> nums[i]&gt;<span class="number">1</span>:</span><br><span class="line">                self.swap(nums,i,rp<span class="number">-1</span>)</span><br><span class="line">                rp-=<span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>: </span><br><span class="line">                i+=<span class="number">1</span></span><br><span class="line">        print(nums)  </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">swap</span><span class="params">(self,nums,i,j)</span>:</span></span><br><span class="line">        tmp=nums[i]</span><br><span class="line">        nums[i]=nums[j]</span><br><span class="line">        nums[j]=tmp</span><br></pre></td></tr></table></figure><h2><span id="350-两个数组的交集-ii">350. 两个数组的交集 II</span></h2><p>给定两个数组，编写一个函数来计算它们的交集。</p><p>示例 1:</p><p>输入: nums1 = [1,2,2,1], nums2 = [2,2]<br>输出: [2,2]</p><p>【我的解法】<br>首先将nums1中的值和出现的次数存储在count字典中，然后遍历nums2，从中找出交集。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">intersect</span><span class="params">(self, nums1, nums2)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums1: List[int]</span></span><br><span class="line"><span class="string">        :type nums2: List[int]</span></span><br><span class="line"><span class="string">        :rtype: List[int]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        count = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> nums1:</span><br><span class="line">            <span class="keyword">if</span> i <span class="keyword">not</span> <span class="keyword">in</span> count:</span><br><span class="line">                count[i]=<span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                count[i]+=<span class="number">1</span></span><br><span class="line">        res=[]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> nums2:</span><br><span class="line">            <span class="keyword">if</span> i <span class="keyword">in</span> count <span class="keyword">and</span> count[i]&gt;<span class="number">0</span>:</span><br><span class="line">                res.append(i)</span><br><span class="line">                count[i]-=<span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><p><strong>【解法2】</strong><br>使用双指针，如果2个元素相等,将相等元素加入到res中，然后将2个元素同时向前移一位,如果2个元素不等，将小的元素指针向前移一位。<br>还可以对这个算法改进一下，这里我们使用额外数据res保存最终的结果，其实可以不用额外空间，我们在nums1[p1]==nums2[p2]时，将相同的元素放在nums1[k]中，然后k+=1，因为nums1前面的元素已经遍历过了，就没用了，可以覆盖。返回nums1[:k]</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">intersect</span><span class="params">(self, nums1, nums2)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums1: List[int]</span></span><br><span class="line"><span class="string">        :type nums2: List[int]</span></span><br><span class="line"><span class="string">        :rtype: List[int]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="comment">#分别对nums1和nums2排序</span></span><br><span class="line">        nums1.sort()</span><br><span class="line">        nums2.sort()</span><br><span class="line">        p1=<span class="number">0</span></span><br><span class="line">        p2=<span class="number">0</span></span><br><span class="line">        res=[]</span><br><span class="line">        <span class="keyword">while</span> p1&lt;len(nums1) <span class="keyword">and</span> p2&lt;len(nums2):</span><br><span class="line">            print(p1,p2)</span><br><span class="line">            <span class="keyword">if</span> nums1[p1] == nums2[p2]:</span><br><span class="line">                res.append(nums1[p1])</span><br><span class="line">                p1+=<span class="number">1</span></span><br><span class="line">                p2+=<span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> nums1[p1]&lt;nums2[p2]:</span><br><span class="line">                p1+=<span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                p2+=<span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h2><span id="324-摆动排序-ii">324. 摆动排序 II</span></h2><p>给定一个无序的数组 nums，将它重新排列成 nums[0] &lt; nums[1] &gt; nums[2] &lt; nums[3]… 的顺序。</p><p>示例 1:</p><p>输入: nums = [1, 5, 1, 1, 6, 4]<br>输出: 一个可能的答案是 [1, 4, 1, 5, 1, 6]</p><p>说明:<br>你可以假设所有输入都会得到有效的结果。</p><p>进阶:<br>你能用 O(n) 时间复杂度和 / 或原地 O(1) 额外空间来实现吗？</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/wiggle-sort-ii" target="_blank" rel="noopener">https://leetcode-cn.com/problems/wiggle-sort-ii</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wiggleSort</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: None Do not return anything, modify nums in-place instead.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="comment">#先找到nums的中位数，即下标为</span></span><br><span class="line">        n = len(nums)</span><br><span class="line">        left,right=<span class="number">0</span>,n<span class="number">-1</span></span><br><span class="line">        mid_idx=(left+right)//<span class="number">2</span></span><br><span class="line">        nums.sort()</span><br><span class="line">        mid=nums[mid_idx]<span class="comment">#中位数</span></span><br><span class="line">        <span class="comment"># 交叉合并，划分为2部分[0...mid_idx],[]</span></span><br><span class="line">        small,big ,_nums = mid_idx,n<span class="number">-1</span>,nums[:]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">            <span class="keyword">if</span> i%<span class="number">2</span> == <span class="number">0</span>:</span><br><span class="line">                nums[i] = _nums[small]</span><br><span class="line">                small -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:<span class="comment">#big</span></span><br><span class="line">                nums[i] = _nums[big]</span><br><span class="line">                big -= <span class="number">1</span></span><br></pre></td></tr></table></figure><p><strong>【解法2】</strong></p><ul><li>先寻找nums中的中位数，即寻找第k大的数，k=n/2，</li><li>找到中位数后，然后对nums进行三路快排，小于mid放在左边，大于mid放在右边</li><li>然后把nums划分为small和big列表，倒序排列</li></ul><h1><span id="总结">总结</span></h1><ol><li>选数组中的第k大或第k小的元素，使用堆排序或快速排序<ul><li>堆排序：使用小顶堆(第k大)和大顶堆(第k小)</li><li>快速排序：因为每一轮快速排序，都会确定pivot的位置，比较pivot的位置是否等于k或n-k，然后调整left或right的位置。</li></ul></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;开始刷题了，首先整理并实现经典的排序算法并对其优化，使用Python实现。所有的排序默认从小到大排序&lt;/p&gt;
    
    </summary>
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
      <category term="排序" scheme="http://yoursite.com/tags/%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>图神经网络研讨会</title>
    <link href="http://yoursite.com/2020/03/29/%E5%9B%BE%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E7%A0%94%E8%AE%A8%E4%BC%9A/"/>
    <id>http://yoursite.com/2020/03/29/图神经网络研讨会/</id>
    <published>2020-03-29T05:40:52.000Z</published>
    <updated>2020-03-31T15:15:44.158Z</updated>
    
    <content type="html"><![CDATA[<p>在线图神经网络研讨会<br><a id="more"></a><br><img src="/2020/03/29/图神经网络研讨会/intro.png" alt=""></p><h1><span id="网络表示学习">网络表示学习</span></h1><ul><li>网络表示的关键问题：<br>如何定义图中节点的相似性</li></ul><h1><span id="图神经网络及认知推理">图神经网络及认知推理</span></h1><p><strong>网络上的学习任务：</strong></p><ul><li>节点分类：给定一个点，预测其类别</li><li>链接预测：给2个点，预测这2个点是否相连</li><li>community detection：找子图</li><li>网络相似度：2个网络或子网络的相似度</li></ul><h2><span id="回顾网络表示学习">回顾网络表示学习</span></h2><p>给定一个网络，学习节点的低维表示，如果2个节点距离很近，那这2个节点的表示也要相似。<br><strong>挑战：</strong></p><ol><li>CNN只适用于网格(二维)，但是网络是一个拓扑机构</li><li>RNN适用于文本/序列，这种都有先后关系，但是网络没有先后关系</li><li>网络是动态的，节点有属性，并且网络还有结构属性</li></ol><p><strong>网络表示学习发展：</strong></p><ol><li>使用word2vec来做网络表示学习，即DeepWalk</li><li>根据DeepWalk进行扩展：<ul><li>LINE：一阶和二阶相似性</li><li>PTE：异构网络</li><li>Node2vec：biased random walk</li></ul></li></ol><p><strong>网络表示学习的本质：</strong><br>都是在做矩阵分解，SVD分解，只是分解的形式不一样。<br>图表示学习结合的是context信息，用上下文信息来做网络表示学习。</p><p><img src="/2020/03/29/图神经网络研讨会/1.png" alt=""></p><p><strong>问题：</strong></p><h2><span id="gnn">GNN</span></h2><p><img src="/2020/03/29/图神经网络研讨会/2.png" alt=""></p><p><img src="/2020/03/29/图神经网络研讨会/3.png" alt=""></p><h2><span id="异质图">异质图</span></h2><p>同质网络：网络中只有一种类型的节点或边<br>异质网络：网络中有多类节点或边</p><p>首先分解出网络中的对象，以及对象之间的关系。<br>例如：作者-论文-会议，一个网络中有3类节点。<br>其中对象之间的关系（Meta path）有：</p><ul><li>作者1-论文-作者2（2个作者共同合作一篇论文）</li><li>作者1-论文-引用论文1，作者1写论文，引用了其他论文</li><li>……</li></ul><h3><span id="模型">模型</span></h3><ol><li>Metapath2Vec<br>基于meta path的随机游走，</li><li>HERec<br>解决异质图中节点的表示，将异质图变成同质图，在同质图中用DeepWalk或LINE学习节点表示</li><li>HIN2Vec<br>随机游走抽取出点边序列</li><li>MCRec</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在线图神经网络研讨会&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Deep Learning" scheme="http://yoursite.com/categories/Deep-Learning/"/>
    
    
      <category term="Graph" scheme="http://yoursite.com/tags/Graph/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode之二分法</title>
    <link href="http://yoursite.com/2020/03/27/Leetcode%E4%B9%8B%E4%BA%8C%E5%88%86%E6%B3%95/"/>
    <id>http://yoursite.com/2020/03/27/Leetcode之二分法/</id>
    <published>2020-03-27T14:34:31.000Z</published>
    <updated>2020-04-08T09:45:56.758Z</updated>
    
    <content type="html"><![CDATA[<p>列表查找：从列表中查找指定元素</p><ul><li>输出：列表</li><li>输出：元素下标，找不到返回None或-1</li></ul><a id="more"></a><p>python中内置列表查找函数：index(),用的是线性查找，因为二分查找要求列表是有序的。</p><!-- TOC --><ul><li><a href="#1-顺序查找">1. 顺序查找</a></li><li><a href="#2-二分查找">2. 二分查找</a><ul><li><a href="#21-二分查找拓展问题">2.1. 二分查找拓展问题</a></li></ul></li><li><a href="#3-leetcode例题">3. LeetCode例题</a><ul><li><a href="#31-查找target的索引">3.1. 查找target的索引</a><ul><li><a href="#311-二分查找">3.1.1. 二分查找</a></li><li><a href="#312-搜索旋转排序数组">3.1.2. 搜索旋转排序数组</a></li><li><a href="#313-搜索旋转排序数组-ii">3.1.3. 搜索旋转排序数组 II</a></li><li><a href="#314-寻找旋转排序数组中的最小值">3.1.4. 寻找旋转排序数组中的最小值</a></li><li><a href="#315-寻找旋转排序数组中的最小值-ii">3.1.5. 寻找旋转排序数组中的最小值 II</a></li><li><a href="#316-h指数-ii">3.1.6. H指数 II</a></li><li><a href="#317-最长上升子序列">3.1.7. 最长上升子序列</a></li><li><a href="#318-山脉数组中查找目标值">3.1.8. 山脉数组中查找目标值</a></li><li><a href="#319-寻找两个有序数组的中位数">3.1.9. 寻找两个有序数组的中位数</a></li></ul></li><li><a href="#32-在一个有上下界的区间中搜索一个整数">3.2. 在一个有上下界的区间中搜索一个整数</a><ul><li><a href="#321-x-的平方根">3.2.1. x 的平方根</a></li><li><a href="#322-寻找重复数">3.2.2. 寻找重复数</a></li></ul></li><li><a href="#33-判断条件是一个函数">3.3. 判断条件是一个函数</a><ul><li><a href="#331-第一个错误的版本">3.3.1. 第一个错误的版本</a></li><li><a href="#332-分割数组的最大值">3.3.2. 分割数组的最大值</a></li><li><a href="#333-爱吃香蕉的珂珂">3.3.3. 爱吃香蕉的珂珂</a></li><li><a href="#334-找到-k-个最接近的元素">3.3.4. 找到 K 个最接近的元素</a></li><li><a href="#335-转变数组后最接近目标值的数组和">3.3.5. 转变数组后最接近目标值的数组和</a></li></ul></li></ul></li><li><a href="#4-总结">4. 总结</a></li></ul><!-- /TOC --><h1><span id="1-顺序查找">1. 顺序查找</span></h1><p>也叫做线性查找，从一个元素开始，依次遍历，直到找到指定元素或到最后一个元素</p><ul><li>时间复杂度：$O(n)$</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">linear_search</span><span class="params">(nums,val)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> idx,v <span class="keyword">in</span> enumerate(nums):</span><br><span class="line">        <span class="keyword">if</span> v == val:</span><br><span class="line">            <span class="keyword">return</span> idx</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span></span><br></pre></td></tr></table></figure><h1><span id="2-二分查找">2. 二分查找</span></h1><p>从有序列表中，比较列表中间的数和val比较，然后向左或向右查找。<br>对于有序数组或者部分有序数组，基本都是使用二分法</p><ul><li>时间复杂度：$O(logn)$</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">binary_search</span><span class="params">(nums,val)</span>:</span></span><br><span class="line">    left = <span class="number">0</span></span><br><span class="line">    right = len(nums)<span class="number">-1</span></span><br><span class="line">    <span class="keyword">while</span> left &lt;= right:<span class="comment">#说明候选区有值</span></span><br><span class="line">        mid = (left+right)//<span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> nums[mid] == val:</span><br><span class="line">            <span class="keyword">return</span> mid</span><br><span class="line">        <span class="keyword">elif</span> nums[mid] &gt; val:</span><br><span class="line">            right = mid - <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            left = mid + <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span></span><br></pre></td></tr></table></figure><p>参考资料</p><p><a href="https://www.liwei.party/2019/06/19/leetcode-solution-new/search-insert-position/" target="_blank" rel="noopener">特别好用的二分查找法模板（Python 代码、Java 代码）</a></p><p><a href="https://leetcode-cn.com/problems/search-insert-position/solution/te-bie-hao-yong-de-er-fen-cha-fa-fa-mo-ban-python-/" target="_blank" rel="noopener">二分查找模板</a></p><p><a href="https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/solution/er-fen-cha-zhao-suan-fa-xi-jie-xiang-jie-by-labula/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/solution/er-fen-cha-zhao-suan-fa-xi-jie-xiang-jie-by-labula/</a><br>用排除法来写二分查找，将nums分为2个区间</p><ul><li>循环继续的条件是<code>while (left &lt; right):</code>，这样写的好处是：退出循环时，一定是<code>left=right</code>,不用纠结返回是left还是right</li><li><p>在写if和else语句是，在if()中写nums[mid]满足什么性质时，nums[mid]肯定不是目标元素，则真正的目标元素肯定在mid的左边或右边，分别在if和else中更新left或right。根据以下2种情况，考虑怎么更新left和right</p><ul><li>如果mid分到左区间，则更新left=mid+1，更新right=mid</li><li>如果mid分到右区间，则更新left=mid，更新right=mid-1</li></ul><p><img src="/2020/03/27/Leetcode之二分法/查找算法/binary.png" alt=""></p></li><li><p>更新mid（重难点）</p><ul><li><code>mid = (left+mid)/2</code>,最常用，但是在left和right较大时，会发生整形溢出</li><li><code>mid = left+(right-left)/2</code>,推荐写法</li><li><code>/</code>是整除，如果是小数，向下取整，当left和rigth相邻时，即rigth-left=1时，使用mid = left+(right-left)/2，得到的mid始终等于left，永远取不到right，可能会出现死循环。<br>例如nums=[1,2]，target=2，刚开始left=0，right=1，mid=0，if(nums[mid]&lt;target)，说明target在mid后面，更新left=mid，此时left还是等于0，然后就出现死循环，left一直都是0。</li><li><p>解决死循环的方案是：将mid划分到左边区间中，在更新时left=mid+1，right=mid，就不会出现left一直等于mid死循环。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(left &lt; right):</span><br><span class="line">    mid = left+(right-left)/<span class="number">2</span></span><br><span class="line">    <span class="keyword">if</span>(nums[mid] &lt; target):</span><br><span class="line">        left=mid+<span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        right=mid</span><br></pre></td></tr></table></figure><p>或者将mid划分到右区间，这时出现left=mid，将mid的取值从左中位数，改为右中位数，即<code>mid = left+(right-left+1)/2</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(left &lt; right):</span><br><span class="line">    mid = left+(right-left+<span class="number">1</span>)/<span class="number">2</span></span><br><span class="line">    <span class="keyword">if</span>(nums[mid] &lt; target):</span><br><span class="line">        left=mid</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        right=mid<span class="number">-1</span></span><br></pre></td></tr></table></figure></li></ul></li></ul><ul><li>退出while时，一定是left=right，需要判断下<code>if(nums[left])==target</code>。<ul><li>如果题目中说了target一定存在于nums中，则不必执行上述操作，因为在while中已经把不是target的元素排除了，退出while时的left==right，一定是target元素，直接返回left就行。</li><li>如果题目中没有说target一定存在于nums，即要找的target在nums中可能不存在，我们需要执行<code>if(nums[left]==target)</code>，如果满足返回left，不满足说明target在nums中不存在，返回-1</li></ul></li></ul><p><strong>【总结】</strong></p><ul><li>如果把mid分到左区间，<code>mid=left+(right-left)//2</code></li><li>如果把mid分到右区间，<code>mid=left+(right-left+1)//2</code></li><li>在nums中找第一个出现target的下标，需要把mid分到左边，不符合条件写成<code>if nums[mid] &lt; target</code></li><li>在nums中找最后一个出现target的下标，需要把mid分到右边，不符合条件写成<code>if nums[mid] &gt; target</code></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#找左侧边界</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">find_first</span><span class="params">(nums,target)</span>:</span></span><br><span class="line">    left = <span class="number">0</span></span><br><span class="line">    right = len(nums)<span class="number">-1</span></span><br><span class="line">    <span class="keyword">while</span> left &lt; right:</span><br><span class="line">        mid = left+(right-left)//<span class="number">2</span><span class="comment">#取左中位数</span></span><br><span class="line">        <span class="keyword">if</span> nums[mid] &lt; target:</span><br><span class="line">            left = mid+<span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            right = mid</span><br><span class="line">    <span class="keyword">if</span> nums[left] == target:</span><br><span class="line">        <span class="keyword">return</span> left</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#找右侧边界</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">find_last</span><span class="params">(nums,target)</span>:</span></span><br><span class="line">    left = <span class="number">0</span></span><br><span class="line">    right = len(nums)<span class="number">-1</span></span><br><span class="line">    <span class="keyword">while</span> left &lt; right:</span><br><span class="line">        mid = left+(right-left+<span class="number">1</span>)//<span class="number">2</span><span class="comment">#取右中位数</span></span><br><span class="line">        <span class="keyword">if</span> nums[mid] &gt; target:</span><br><span class="line">            right = mid - <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            left = mid</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">if</span> nums[left] == target:</span><br><span class="line">        <span class="keyword">return</span> left</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span></span><br></pre></td></tr></table></figure><h2><span id="21-二分查找拓展问题">2.1. 二分查找拓展问题</span></h2><ol><li>在有序数组中查找等于目标元素的第1个或最后1个下标</li><li>在有序数组中查找第1个大于(等于)目标元素的下标</li><li>在有序数组中查找第1个小于(等于)目标元素的下标</li><li>在有序数组中查找最后1个大于(等于)目标元素的下标</li><li>在有序数组中查找最后1个小于(等于)目标元素的下标</li></ol><p>Leetcode上的二分问题主要分为以下三类</p><h1><span id="3-leetcode例题">3. LeetCode例题</span></h1><h2><span id="31-查找target的索引">3.1. 查找target的索引</span></h2><p>一般而言，这个数组是有序的，也可能是半有序，但不大可能是无序的</p><h3><span id="311-二分查找">3.1.1. 二分查找</span></h3><p>给定一个 n 个元素有序的（升序）整型数组 nums 和一个目标值 target  ，写一个函数搜索 nums 中的 target，如果目标值存在返回下标，否则返回 -1。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">search</span><span class="params">(self, nums, target)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :type target: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        left = <span class="number">0</span></span><br><span class="line">        right = len(nums)<span class="number">-1</span></span><br><span class="line">        <span class="keyword">while</span> left &lt; right:</span><br><span class="line">            mid = left+(right-left)/<span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> nums[mid] &lt; target:</span><br><span class="line">                left = mid+<span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                right=mid</span><br><span class="line">        <span class="keyword">if</span> nums[left]==target:</span><br><span class="line">            <span class="keyword">return</span> left</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span></span><br></pre></td></tr></table></figure><h3><span id="312-搜索旋转排序数组">3.1.2. 搜索旋转排序数组</span></h3><p>假设按照升序排序的数组在预先未知的某个点上进行了旋转。</p><p>( 例如，数组 [0,1,2,4,5,6,7] 可能变为 [4,5,6,7,0,1,2] )。</p><p>搜索一个给定的目标值，如果数组中存在这个目标值，则返回它的索引，否则返回 -1 。</p><p>你可以假设数组中不存在重复的元素。</p><p>你的算法时间复杂度必须是 O(log n) 级别。</p><p>这道题有多种解法：</p><ol><li>中间元素和右边界比较，使用右中位数</li><li>中间元素和右边界比较，使用左中位数</li><li>中间元素和左边界比较，使用右中位数</li><li>中间元素和左边界比较，使用左中位数</li><li>分三个区间</li></ol><p>下面只给出前2种的解法：<br>讨论mid元素和右边界的关系，因为nums不存在重复元素，所以要么大于，要么小于</p><ul><li><p><code>nums[mid] &lt; nums[right]</code><br>例如[7,8,2,3,4,5,6],nums[mid]=3,nums[right]=6,此时[mid,right]一定是有序的，那么target要不在有序区间[mid,right]中，要么在不一定有序的[left,mid-1]中。</p><ul><li>假设target在[mid,right]中，即<code>nums[mid] &lt;= target and target &lt;= nums[right]</code>，因为该区间已经有序，比较简单，更新<code>left=mid</code></li><li>假设target落在[left,mid-1]中，就是上一个情况的反面，即<code>right=mid-1</code></li><li>因为这里出现了<code>left=mid</code>的情况，所有需要使用<code>mid=left+(right-left+1)//2</code>的方式来计算mid</li></ul></li><li><p><code>nums[mid] &gt; nums[right]</code><br>例如[5,6,7,8,9,2,3,4],nums[mid]=8,nums[right]=4,此时[left,mid]一定是有序的，那么target要不在有序区间[left,mid]中，要么在不一定有序的[mid+1,left]中。</p><ul><li>假设target在[left,mid]中，即<code>nums[left] &lt;= target and target &lt;= nums[mid]</code>，因为该区间已经有序，比较简单，更新<code>right=mid</code></li><li>假设target落在[mid+1,right]中，就是上一个情况的反面，即<code>left=mid+1</code></li><li>为了和上一种情况，在计算<code>mid=left+(right-left+1)//2</code>的方式保持一致，这里，我们认为target在[left,mid-1]中有序，这样更新right=mid-1,更新left=mid，并且放区间中只有2个元素时，mid始终等于right，此时在更新right=mid-1时也不会越界</li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">search</span><span class="params">(self, nums, target)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :type target: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="comment">#方式1：中间元素和右边界比较，使用右中位数</span></span><br><span class="line">        <span class="keyword">if</span> len(nums) == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">        left= <span class="number">0</span></span><br><span class="line">        right = len(nums)<span class="number">-1</span></span><br><span class="line">        <span class="keyword">while</span> left &lt; right:</span><br><span class="line">            mid = left+(right-left+<span class="number">1</span>)//<span class="number">2</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> nums[mid] &lt; nums[right]:</span><br><span class="line">                <span class="keyword">if</span> nums[mid] &lt;= target <span class="keyword">and</span> target &lt;= nums[right]:</span><br><span class="line">                    <span class="comment">#[mid,right]一定是有序的</span></span><br><span class="line">                    left = mid</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    right = mid - <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">if</span> nums[left] &lt;= target <span class="keyword">and</span> target &lt;= nums[mid<span class="number">-1</span>]:</span><br><span class="line">                    <span class="comment">#[left,mid-1]一定是有序的</span></span><br><span class="line">                    right = mid - <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    left = mid </span><br><span class="line">        <span class="keyword">if</span> nums[left] == target:</span><br><span class="line">            <span class="keyword">return</span> left</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">#方法2：中间元素和右边界比较，使用左中位数</span></span><br><span class="line">        <span class="keyword">if</span> len(nums) == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">        left= <span class="number">0</span></span><br><span class="line">        right = len(nums)<span class="number">-1</span></span><br><span class="line">        <span class="keyword">while</span> left &lt; right:</span><br><span class="line">            mid = left+(right-left)//<span class="number">2</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> nums[mid] &lt; nums[right]:</span><br><span class="line">                <span class="keyword">if</span> nums[mid+<span class="number">1</span>] &lt;= target <span class="keyword">and</span> target &lt;= nums[right]:</span><br><span class="line">                    left = mid + <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    right = mid</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">if</span> nums[left] &lt;= target <span class="keyword">and</span> target &lt;= nums[mid]:</span><br><span class="line">                    right = mid</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    left = mid + <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> nums[left] == target:</span><br><span class="line">            <span class="keyword">return</span> left</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">#方法5：三段区间</span></span><br><span class="line">        left = <span class="number">0</span></span><br><span class="line">        right = len(nums)<span class="number">-1</span></span><br><span class="line">        <span class="keyword">while</span> left &lt;= right:<span class="comment">#注意</span></span><br><span class="line">            mid = left + (right-left)//<span class="number">2</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> nums[mid] == target:</span><br><span class="line">                <span class="keyword">return</span> mid</span><br><span class="line">            <span class="keyword">if</span> nums[left] &lt;= nums[mid]:<span class="comment">#注意是&lt;=</span></span><br><span class="line">                <span class="comment">#因为上面已经判断nums[mid]==target，这里就不用=</span></span><br><span class="line">                <span class="keyword">if</span> nums[left] &lt;= target <span class="keyword">and</span> target &lt; nums[mid]:</span><br><span class="line">                    right = mid - <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    left = mid+<span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">if</span> nums[mid] &lt; target <span class="keyword">and</span> target &lt;= nums[right]:</span><br><span class="line">                    left = mid+<span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    right = mid<span class="number">-1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span></span><br></pre></td></tr></table></figure><h3><span id="313-搜索旋转排序数组-ii">3.1.3. 搜索旋转排序数组 II</span></h3><p>假设按照升序排序的数组在预先未知的某个点上进行了旋转。</p><p>( 例如，数组 [0,0,1,2,2,5,6] 可能变为 [2,5,6,0,0,1,2] )。</p><p>编写一个函数来判断给定的目标值是否存在于数组中。若存在返回 true，否则返回 false。</p><p>进阶:<br>这是 搜索旋转排序数组 的延伸题目，本题中的 nums  可能包含重复元素。<br>这会影响到程序的时间复杂度吗？会有怎样的影响，为什么？</p><p>这道题和上一题的区别是nums中存在重复元素。那nums[mid]和右边界比较来举例，上一题只考虑了2种情况，if nums[mid] &lt; nums[right]和nums[mid] &gt; nums[right]，但在这一题中，因为有重复元素，所以就需要考虑相等的情况。当nums[mid] == nums[right]，先判断是否等于target，如果等于返回True，否则当前的right被排除，right向前移一位。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">search</span><span class="params">(self, nums, target)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :type target: int</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="comment">#中间元素和右边界比较，使用右中位数</span></span><br><span class="line">        <span class="keyword">if</span> len(nums) == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">        left= <span class="number">0</span> </span><br><span class="line">        right = len(nums)<span class="number">-1</span></span><br><span class="line">        <span class="keyword">while</span> left &lt; right:</span><br><span class="line">            mid = left+(right-left+<span class="number">1</span>)//<span class="number">2</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> nums[mid] &lt; nums[right]:</span><br><span class="line">                <span class="keyword">if</span> nums[mid] &lt;= target <span class="keyword">and</span> target &lt;= nums[right]:</span><br><span class="line">                    <span class="comment">#[mid,right]一定是有序的</span></span><br><span class="line">                    left = mid</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    right = mid - <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> nums[mid] &gt; nums[right]:</span><br><span class="line">                <span class="keyword">if</span> nums[left] &lt;= target <span class="keyword">and</span> target &lt;= nums[mid<span class="number">-1</span>]:</span><br><span class="line">                    <span class="comment">#[left,mid-1]一定是有序的</span></span><br><span class="line">                    right = mid - <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    left = mid</span><br><span class="line">            <span class="keyword">else</span>:<span class="comment">#nums[mid] == nums[right]</span></span><br><span class="line">                <span class="keyword">if</span> nums[mid] == target:</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    right -= <span class="number">1</span> </span><br><span class="line">        <span class="keyword">if</span> nums[left] == target:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">False</span></span><br></pre></td></tr></table></figure><h3><span id="314-寻找旋转排序数组中的最小值">3.1.4. 寻找旋转排序数组中的最小值</span></h3><p>假设按照升序排序的数组在预先未知的某个点上进行了旋转。</p><p>( 例如，数组 [0,1,2,4,5,6,7] 可能变为 [4,5,6,7,0,1,2] )。</p><p>请找出其中最小的元素。</p><p>你可以假设数组中不存在重复元素。</p><p>虽然是要找最小数，但是数据部分有序，可以使用二分法。有2种情况，nums[mid]和左边界比较，nums[mid]和右边界比较</p><ul><li>nums[mid]和左边界比较<ul><li>例如[1,2,3,4,5]，中间数nums[mid]=3,比左边界大，最小值存在于左区间</li><li>[2,3,4,5,6,1],中间数nums[mid]=4比左边界大，说明左边界有序，最小值一定存在于右区间</li></ul></li></ul><p>根据上面2种情况，可以看出当nums[mid]大于左边界时，不知道最小值一定存在于哪个区间，所以不能用mid和左边界比较。</p><ul><li>nums[mid]和右边界比较<ul><li>当nums[mid] &lt; nums[target],</li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findMin</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="comment">#中间元素和右边元素比较</span></span><br><span class="line">        left = <span class="number">0</span></span><br><span class="line">        right = len(nums)<span class="number">-1</span></span><br><span class="line">        <span class="keyword">while</span> left &lt; right:</span><br><span class="line">            mid = left+(right-left)//<span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> nums[mid] &lt; nums[right]:<span class="comment">#说明右边有序，右边递增</span></span><br><span class="line">                <span class="comment">#说明最小值肯定在左区间</span></span><br><span class="line">                right = mid</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment">#mid大于右边，说明左边有序，左边递增，那左边的值比mid小，右边的值也比mid小，到底哪边的值更小呢？</span></span><br><span class="line">            <span class="comment">#答案是：右边的值更小，因为如果左边的值更小的话，那说明右边的值比左边的最小值大，比mid小，那这个值肯定在min和mid之间，</span></span><br><span class="line">            <span class="comment">#但现在这个值在右边，推翻前面的假设，即右边的值更小</span></span><br><span class="line">                left = mid+<span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> nums[left]</span><br><span class="line"></span><br><span class="line">        <span class="comment">#尝试使用nums[mid]和左边界比较，失败</span></span><br><span class="line">        <span class="comment"># left = 0</span></span><br><span class="line">        <span class="comment"># right = len(nums)-1</span></span><br><span class="line">        <span class="comment"># while left &lt; right:</span></span><br><span class="line">        <span class="comment">#     mid = left+(right-left)//2</span></span><br><span class="line">        <span class="comment">#     if nums[mid] &lt; nums[left]:#说明右边有序,右边递增，最小值一定在做区间</span></span><br><span class="line">        <span class="comment">#         right = mid</span></span><br><span class="line">        <span class="comment">#     else:#mid比左边大，说明左边有序，左边递增，但是最小值不一定在左边</span></span><br><span class="line">        <span class="comment">#     #[1,2,3,4,5,6,7]最小值在左区间，</span></span><br><span class="line">        <span class="comment">#     #[8,9,10,11,1,2]最小值在右区间</span></span><br><span class="line">        <span class="comment">#     #不确定该缩小到哪个区间，该方法不可行</span></span><br></pre></td></tr></table></figure><h3><span id="315-寻找旋转排序数组中的最小值-ii">3.1.5. 寻找旋转排序数组中的最小值 II</span></h3><p>假设按照升序排序的数组在预先未知的某个点上进行了旋转。</p><p>( 例如，数组 [0,1,2,4,5,6,7] 可能变为 [4,5,6,7,0,1,2] )。</p><p>请找出其中最小的元素。</p><p><strong>注意数组中可能存在重复的元素</strong>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findMin</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        left = <span class="number">0</span></span><br><span class="line">        right = len(nums)<span class="number">-1</span></span><br><span class="line">        <span class="keyword">while</span> left &lt; right:</span><br><span class="line">            mid = left+(right-left)//<span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> nums[mid] &lt; nums[right]:<span class="comment">#说明右边有序，最小值一定在左区间</span></span><br><span class="line">                right = mid</span><br><span class="line">            <span class="keyword">elif</span> nums[mid] &gt; nums[right]:<span class="comment">#说明左边有序，最小值一定在右区间</span></span><br><span class="line">                left = mid + <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:<span class="comment">#nums[mid] == nums[right]</span></span><br><span class="line">                right -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> nums[left]</span><br></pre></td></tr></table></figure><h3><span id="316-h指数-ii">3.1.6. H指数 II</span></h3><p>给定一位研究者论文被引用次数的数组（被引用次数是非负整数），数组已经按照升序排列。编写一个方法，计算出研究者的 h 指数。</p><p>h 指数的定义: “h 代表“高引用次数”（high citations），一名科研人员的 h 指数是指他（她）的 （N 篇论文中）有 h 篇论文分别被引用了至少 h 次。（其余的 N - h 篇论文每篇被引用次数不多于 h 次。）”</p><p>我们先举一个例子，<br>[1,2,3,7,9]，假设一个文章下标为i，则需要满足<code>citation[i] &gt;= n - i</code>,有h个文章的引用次数大于等于h，即当前的引用次数为citation[i]，引用次数大于等于它的文章有n-i个。h的值就是n-i<br>该问题可以简化为：给定一个长度为n的升序数组，找到满足<code>citation[i]&gt;=n-i</code>的citation[i]<br>用二分法来解决这个问题<br>我们要找i，先找到不符合citation[i] &gt;= n-i的情况，就是citation[i] &lt; n -i，即i太小了，需要变大到右区间找，更新left=mid+1，否则去左区间right=mid。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hIndex</span><span class="params">(self, citations)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type citations: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        n = len(citations)</span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">0</span> <span class="keyword">or</span> citations[n<span class="number">-1</span>] == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        left = <span class="number">0</span></span><br><span class="line">        right = n<span class="number">-1</span></span><br><span class="line">        <span class="comment">#要找citation[i] &gt;= n -i</span></span><br><span class="line">        <span class="keyword">while</span> left &lt; right:</span><br><span class="line">            mid = left+(right-left)//<span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> citations[mid] &lt; n - mid:<span class="comment">#说明mid小了，需要移到右区间</span></span><br><span class="line">                left = mid+<span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                right = mid</span><br><span class="line">        <span class="keyword">return</span> n-left</span><br></pre></td></tr></table></figure><h3><span id="317-最长上升子序列">3.1.7. 最长上升子序列</span></h3><p>动态规划+二分，以后再看</p><h3><span id="318-山脉数组中查找目标值">3.1.8. 山脉数组中查找目标值</span></h3><p>给你一个 山脉数组 mountainArr，请你返回能够使得 mountainArr.get(index) 等于 target 最小 的下标 index 值。</p><p>如果不存在这样的下标 index，就请返回 -1。</p><p>山脉数组：[1,2,4,7,4,2,1]先上升后下降的数组<br>使用3次二分</p><ul><li>使用二分，找出最大元素的下标</li><li>使用二分，找出左边升序数组中第一个等于target的下标</li><li>使用二分，找出右边降序数组中第一个等于target的下标</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findInMountainArray</span><span class="params">(self, target, mountain_arr)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type target: integer</span></span><br><span class="line"><span class="string">        :type mountain_arr: MountainArray</span></span><br><span class="line"><span class="string">        :rtype: integer</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        n = mountain_arr.length()<span class="number">-1</span></span><br><span class="line">        max_idx = self.findTop(mountain_arr,<span class="number">0</span>,n)</span><br><span class="line">        <span class="comment">#[0,max_idx+1]升序，[max_idx+1,n]降序</span></span><br><span class="line">        first_idx = self.sorted_first(mountain_arr,<span class="number">0</span>,max_idx,target)</span><br><span class="line">        <span class="keyword">if</span> first_idx != <span class="number">-1</span>:</span><br><span class="line">            <span class="keyword">return</span> first_idx</span><br><span class="line">        first_idx = self.reverse_first(mountain_arr,max_idx+<span class="number">1</span>,n,target)</span><br><span class="line">        <span class="keyword">return</span> first_idx</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findTop</span><span class="params">(self,mountain_arr,left,right)</span>:</span></span><br><span class="line">        <span class="comment">#找到mountain_arr中最大值的下标</span></span><br><span class="line">        <span class="keyword">while</span> left &lt; right:</span><br><span class="line">            mid = left+(right-left)//<span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> mountain_arr.get(mid) &lt; mountain_arr.get(mid+<span class="number">1</span>):<span class="comment">#说明最大值在右边</span></span><br><span class="line">                left = mid+<span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                right = mid</span><br><span class="line">        <span class="keyword">return</span> left</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sorted_first</span><span class="params">(self,mountain_arr,left,right,target)</span>:</span></span><br><span class="line">        <span class="comment">#nums升序，从nums中找到第一个等于target的下标，找不到返回-1</span></span><br><span class="line">     </span><br><span class="line">        <span class="keyword">while</span> left &lt; right:</span><br><span class="line">            mid=left+(right-left)//<span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> mountain_arr.get(mid) &lt; target:</span><br><span class="line">                left = mid+<span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                right = mid</span><br><span class="line">        <span class="keyword">if</span> mountain_arr.get(left)==target:</span><br><span class="line">            <span class="keyword">return</span> left</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverse_first</span><span class="params">(self,mountain_arr,left,right,target)</span>:</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> left &lt; right:</span><br><span class="line">            mid = left+(right-left+<span class="number">1</span>)//<span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> mountain_arr.get(mid) &lt; target:<span class="comment">#说明target在左边</span></span><br><span class="line">                right = mid<span class="number">-1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                left = mid</span><br><span class="line">        <span class="keyword">if</span> mountain_arr.get(left) == target:</span><br><span class="line">            <span class="keyword">return</span> left</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span></span><br></pre></td></tr></table></figure><h3><span id="319-寻找两个有序数组的中位数">3.1.9. 寻找两个有序数组的中位数</span></h3><p>给定两个大小为 m 和 n 的有序数组 nums1 和 nums2。</p><p>请你找出这两个有序数组的中位数，并且要求算法的时间复杂度为 O(log(m + n))。</p><p>你可以假设 nums1 和 nums2 不会同时为空</p><p><strong>【解法1】</strong><br>最简单的方法是：将2个数组拼接，重排序。这种方法很常规，但是不符合题目要求。<strong>这个方法的优点是：2个数组不需要有序</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findMedianSortedArrays</span><span class="params">(self, nums1, nums2)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums1: List[int]</span></span><br><span class="line"><span class="string">        :type nums2: List[int]</span></span><br><span class="line"><span class="string">        :rtype: float</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        m = len(nums1)</span><br><span class="line">        n = len(nums2)</span><br><span class="line">        nums1.extend(nums2)</span><br><span class="line">        nums1.sort()</span><br><span class="line">        <span class="keyword">if</span> (m+n)%<span class="number">2</span>==<span class="number">0</span>:</span><br><span class="line">            mid = (m+n)//<span class="number">2</span></span><br><span class="line">            <span class="keyword">return</span> (nums1[mid]+nums1[mid<span class="number">-1</span>])/<span class="number">2.0</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            mid = (m+n)//<span class="number">2</span></span><br><span class="line">            <span class="keyword">return</span> nums1[mid]</span><br></pre></td></tr></table></figure><ul><li>时间复杂度：$O((m+n)log(m+n))$</li><li>空间复杂度：$O(m+n)$</li></ul><p><strong>【解法2】</strong><br>不用把2个数组排序放在一起，直到遍历2个数组，找到中位数就可以了。</p><ul><li>当m+n为奇数时，[1,2,5,7],[3,6,8],一共7个数，中位数的下标为3，即7//2</li><li>当m+n为偶数时，[1,2,5,7],[3,6,8,9],一共8个数，中位数的下标为3,4，即8//2-1,8//2<br>即不管总数是奇数还是偶数，都要遍历到(m+n)//2这个下标。</li><li>使用2个变量left和right来标记当前遍历到的2个数，right表示当前遍历的数，left为前一个数。</li><li>使用2个指针p1和p2来标记nums1和nums2遍历到的位置。当nums1没有完，且当前nums1的值小于nums2的值，移动p1，或者nums1没有完，但是nums2遍历完了，移动p1， 其余情况都是移动p2。</li><li>在最后返回值的时候判断一下当前m+n奇偶情况。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findMedianSortedArrays</span><span class="params">(self, nums1, nums2)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums1: List[int]</span></span><br><span class="line"><span class="string">        :type nums2: List[int]</span></span><br><span class="line"><span class="string">        :rtype: float</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="comment">#不管m+n是奇数还是偶数，都遍历到下标为(m+n)/2的位置</span></span><br><span class="line">        m,n=len(nums1),len(nums2)</span><br><span class="line">        mid_idx = (m+n)//<span class="number">2</span></span><br><span class="line"></span><br><span class="line">        left_val,right_val = <span class="number">-1</span>,<span class="number">-1</span></span><br><span class="line">        p1,p2=<span class="number">0</span>,<span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>,mid_idx+<span class="number">1</span>):</span><br><span class="line">            left_val = right_val</span><br><span class="line">            <span class="keyword">if</span> p1 &lt; m <span class="keyword">and</span> (p2 &gt;= n <span class="keyword">or</span> nums1[p1] &lt; nums2[p2]):</span><br><span class="line">                right_val = nums1[p1]</span><br><span class="line">                p1 += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                right_val = nums2[p2]</span><br><span class="line">                p2+=<span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> (m+n)%<span class="number">2</span>==<span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> (left_val+right_val)/<span class="number">2.0</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> right_val</span><br></pre></td></tr></table></figure><ul><li>时间复杂度：$O(m+n)$<br>还是没有达到log的时间复杂度</li></ul><p><strong>【解法3】</strong></p><h2><span id="32-在一个有上下界的区间中搜索一个整数">3.2. 在一个有上下界的区间中搜索一个整数</span></h2><h3><span id="321-x-的平方根">3.2.1. x 的平方根</span></h3><p>实现 int sqrt(int x) 函数。</p><p>计算并返回 x 的平方根，其中 x 是非负整数。</p><p>由于返回类型是整数，结果只保留整数的部分，小数部分将被舍去。</p><p>【我的解法】<br>首先找到不符合条件的值，即mid*mid&gt;x，一定不符合条件。在更新left会出现left=mid，这时就需要把mid取右中位数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">mySqrt</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type x: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> x==<span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        left,right = <span class="number">1</span>,x//<span class="number">2</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># while left &lt; right:</span></span><br><span class="line">        <span class="comment">#     mid = left+(right-left)//2</span></span><br><span class="line">        <span class="comment">#     if mid*mid &lt; x:#mid的平方&lt;x,也是符合条件的，例如8的结果为2,2*2=4&lt;8</span></span><br><span class="line">        <span class="comment">#         left = mid+1</span></span><br><span class="line">        <span class="comment">#     else:</span></span><br><span class="line">        <span class="comment">#         right=mid</span></span><br><span class="line">        <span class="keyword">while</span> left &lt; right:</span><br><span class="line">            mid = left+(right-left+<span class="number">1</span>)//<span class="number">2</span><span class="comment">#取右中位数</span></span><br><span class="line">            <span class="keyword">if</span> mid*mid &gt; x:</span><br><span class="line">                right = mid <span class="number">-1</span><span class="comment">#有边界不包括中位数</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                left = mid<span class="comment">#左边界可以是中位数，</span></span><br><span class="line">        <span class="keyword">return</span> left</span><br></pre></td></tr></table></figure><h3><span id="322-寻找重复数">3.2.2. 寻找重复数</span></h3><p>给定一个包含 n + 1 个整数的数组 nums，其数字都在 1 到 n 之间（包括 1 和 n），可知至少存在一个重复的整数。假设只有一个重复的整数，找出这个重复的数。</p><p>说明：</p><ol><li>不能更改原数组（假设数组是只读的）。</li><li>只能使用额外的 O(1) 的空间。</li><li>时间复杂度小于 O(n2) 。</li><li>数组中只有一个重复的数字，但它可能不止重复出现一次。</li></ol><p>先不管上面这些限制条件，看有什么解法</p><p>【解法1】<br>先对nums排序，然后判断每个数和它后面的数是否相同，若相同则说明重复，直接返回</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findDuplicate</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        nums.sort()</span><br><span class="line">        n = len(nums)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n<span class="number">-1</span>):</span><br><span class="line">            <span class="keyword">if</span> nums[i] == nums[i+<span class="number">1</span>]:</span><br><span class="line">                <span class="keyword">return</span> nums[i]</span><br></pre></td></tr></table></figure><ul><li>时间复杂度：$O(nlogn)$</li><li>改变原数组，不符合题目要求</li></ul><p>【解法2】<br>使用字典保存每个数字出现的次数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findDuplicate</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        count = dict()</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> nums:</span><br><span class="line">            <span class="keyword">if</span> i <span class="keyword">not</span> <span class="keyword">in</span> count:</span><br><span class="line">                count[i] = <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                count[i]+=<span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> count[i] &gt; <span class="number">1</span>:</span><br><span class="line">                <span class="keyword">return</span> i</span><br></pre></td></tr></table></figure><ul><li>时间复杂度：$O(n)$,只遍历一次数组</li><li>空间复杂度：$O(n)$,不符合题目要求</li></ul><p>【解法3】<br>使用二分法，[1,3,3,2,4,5],例如有6个数，范围在1~5之间，其中小于等于3的有4个数，说明重复的数肯定在3的左边，要么是3,2,1中的1个数，更新right到左区间。<br>这里的mid表示当前重复的数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findDuplicate</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        n = len(nums)</span><br><span class="line">        left = <span class="number">0</span></span><br><span class="line">        right = n <span class="number">-1</span></span><br><span class="line">        <span class="keyword">while</span> left &lt; right:</span><br><span class="line">            mid = left + (right-left) // <span class="number">2</span></span><br><span class="line">            count=<span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> nums:</span><br><span class="line">                <span class="keyword">if</span> i&lt;=mid:</span><br><span class="line">                    count+=<span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> count &gt; mid:<span class="comment">#说明小于等于mid的元素有重复的，转到左区间</span></span><br><span class="line">                right = mid</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                left = mid + <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> left</span><br></pre></td></tr></table></figure><ul><li>时间复杂度：$O(nlogn)$，因为二分的复杂度为logn，在内部又遍历一次数组</li><li>空间复杂度：$O(1)$</li></ul><h2><span id="33-判断条件是一个函数">3.3. 判断条件是一个函数</span></h2><p>在二分法中if语句中，判断条件是一个函数</p><h3><span id="331-第一个错误的版本">3.3.1. 第一个错误的版本</span></h3><p>你是产品经理，目前正在带领一个团队开发新的产品。不幸的是，你的产品的最新版本没有通过质量检测。由于每个版本都是基于之前的版本开发的，所以错误的版本之后的所有版本都是错的。</p><p>假设你有 n 个版本 [1, 2, …, n]，你想找出导致之后所有版本出错的第一个错误的版本。</p><p>你可以通过调用 bool isBadVersion(version) 接口来判断版本号 version 是否在单元测试中出错。实现一个函数来查找第一个错误的版本。你应该尽量减少对调用 API 的次数。</p><p><strong>【我的解法】</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># The isBadVersion API is already defined for you.</span></span><br><span class="line"><span class="comment"># @param version, an integer</span></span><br><span class="line"><span class="comment"># @return a bool</span></span><br><span class="line"><span class="comment"># def isBadVersion(version):</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">firstBadVersion</span><span class="params">(self, n)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type n: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        left=<span class="number">1</span></span><br><span class="line">        right=n</span><br><span class="line">        <span class="keyword">while</span> left &lt; right:</span><br><span class="line">            mid=left+(right-left)//<span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> isBadVersion(mid):</span><br><span class="line">                left=mid+<span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                right=mid</span><br><span class="line">        <span class="keyword">return</span> left</span><br></pre></td></tr></table></figure><h3><span id="332-分割数组的最大值">3.3.2. 分割数组的最大值</span></h3><p>给定一个非负整数数组和一个整数 m，你需要将这个数组分成 m 个非空的连续子数组。设计一个算法使得这 m 个子数组各自和的最大值最小。</p><p>注意:<br>数组长度 n 满足以下条件:</p><p>1 ≤ n ≤ 1000<br>1 ≤ m ≤ min(50, n)</p><p><strong>【题解】</strong><br>子数组的最大值是有范围的，在[max(nums),sum(nums)]之间。令left=max(nums)，right=sum(nums)，mid=left+(right-left)//2,计算子数组和最大为mid时，所划分的子数组个数sub_arr_count</p><ul><li>如果sub_arr_count &gt; m，说明子数组划分多了，mid值应该变大，left=mid+1</li><li>否则，说明子数组少了，mid大了，减少mid的值，right=mid</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">splitArray</span><span class="params">(self, nums, m)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :type m: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="comment">#数组最大的范围在max(nums)和sum(nums)之间，首先找到nums的max和sum</span></span><br><span class="line">        <span class="comment">#将max(nums)作为最大值的left，sum(nums)作为最大值的right</span></span><br><span class="line">        left,right=nums[<span class="number">0</span>],<span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> nums:</span><br><span class="line">            right+=i</span><br><span class="line">            <span class="keyword">if</span> i&gt;left:</span><br><span class="line">                left=i</span><br><span class="line">        <span class="keyword">while</span> left &lt; right:</span><br><span class="line">            mid=left+(right-left)//<span class="number">2</span><span class="comment">#子数组的max</span></span><br><span class="line">            sub_sum = <span class="number">0</span><span class="comment">#子数组之和</span></span><br><span class="line">            sub_arr_count=<span class="number">1</span><span class="comment">#注意初始子数组个数为1</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> nums:</span><br><span class="line">                sub_sum += i</span><br><span class="line">                <span class="keyword">if</span> sub_sum &gt; mid:</span><br><span class="line">                    sub_sum = i</span><br><span class="line">                    sub_arr_count += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> sub_arr_count &gt; m:<span class="comment">#说明子数组个数多，增大mid</span></span><br><span class="line">                left = mid+<span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                right=mid</span><br><span class="line">        <span class="keyword">return</span> left</span><br></pre></td></tr></table></figure><h3><span id="333-爱吃香蕉的珂珂">3.3.3. 爱吃香蕉的珂珂</span></h3><p>珂珂喜欢吃香蕉。这里有 N 堆香蕉，第 i 堆中有 piles[i] 根香蕉。警卫已经离开了，将在 H 小时后回来。</p><p>珂珂可以决定她吃香蕉的速度 K （单位：根/小时）。每个小时，她将会选择一堆香蕉，从中吃掉 K 根。如果这堆香蕉少于 K 根，她将吃掉这堆的所有香蕉，然后这一小时内不会再吃更多的香蕉。  </p><p>珂珂喜欢慢慢吃，但仍然想在警卫回来前吃掉所有的香蕉。</p><p>返回她可以在 H 小时内吃掉所有香蕉的最小速度 K（K 为整数）。</p><p><strong>【我的解法】</strong><br>这一题和上一题<a href="https://leetcode-cn.com/problems/split-array-largest-sum/" target="_blank" rel="noopener">410. 分割数组的最大值</a>很像。首先明确left，right，mid代表什么意思。这里的mid表示吃的速度。根据当前mid来吃香蕉，看看需要多少小时，如果hours&gt;H,说明吃慢了，mid要变大，更新left，否则更新right</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minEatingSpeed</span><span class="params">(self, piles, H)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type piles: List[int]</span></span><br><span class="line"><span class="string">        :type H: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">import</span> math</span><br><span class="line">        <span class="comment">#最小速度的范围是1,max</span></span><br><span class="line">        left=<span class="number">1</span></span><br><span class="line">        right=piles[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> piles:</span><br><span class="line">            <span class="keyword">if</span> i&gt;right:</span><br><span class="line">                right=i</span><br><span class="line">        <span class="keyword">while</span> left&lt;right:</span><br><span class="line">            mid=left+(right-left)//<span class="number">2</span><span class="comment">#表示当前吃的速度</span></span><br><span class="line">            <span class="comment">#计算以当前的速度，需要吃几个小时</span></span><br><span class="line">            hours=<span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> piles:</span><br><span class="line">                hours+=math.ceil(i*<span class="number">1.0</span>/mid)</span><br><span class="line">            <span class="keyword">if</span> hours &gt; H:<span class="comment">#说明吃的太慢了，mid需要向右移</span></span><br><span class="line">                left=mid+<span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                right=mid</span><br><span class="line">        <span class="keyword">return</span> left</span><br></pre></td></tr></table></figure><h3><span id="334-找到-k-个最接近的元素">3.3.4. 找到 K 个最接近的元素</span></h3><p>给定一个排序好的数组，两个整数 k 和 x，从数组中找到最靠近 x（两数之差最小）的 k 个数。返回的结果必须要是按升序排好的。如果有两个数与 x 的差值一样，优先选择数值较小的那个数。</p><p><strong>【解法1】</strong><br>遍历整个数组，记录每个数和x的差值，然后取出前k小的差值，范湖其原始值。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findClosestElements</span><span class="params">(self, arr, k, x)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type arr: List[int]</span></span><br><span class="line"><span class="string">        :type k: int</span></span><br><span class="line"><span class="string">        :type x: int</span></span><br><span class="line"><span class="string">        :rtype: List[int]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        delta = &#123;&#125;<span class="comment">#存储每个数和x的差值</span></span><br><span class="line">        <span class="keyword">for</span> idx,val <span class="keyword">in</span> enumerate(arr):</span><br><span class="line">            delta[idx]=abs(val-x)</span><br><span class="line">        <span class="comment">#按照差值排序</span></span><br><span class="line">        delta1 = sorted(delta.items(),key=<span class="keyword">lambda</span> x:x[<span class="number">1</span>])</span><br><span class="line">        k_res = delta1[:k]<span class="comment">#取出差值在前k个的数据</span></span><br><span class="line">        k_res.sort(key= operator.itemgetter(<span class="number">0</span>))<span class="comment">#对这k个数按照下标排序</span></span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">for</span> idx,delta <span class="keyword">in</span> k_res:</span><br><span class="line">            res.append(arr[idx])</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><p><strong>【解法2】</strong><br>在arr中找到离x最近的k个数，因为arr已经是升序，所有删除的数一定在边界。使用2个指针，一个指向left，一个指向right。一共要保留k个数，即要删除n-k个数，while循环的条件是<code>while del_cnt &lt; n-k</code>,保证在退出循环时，<code>del_cnt=n-k</code>。如果左边数的差值&gt;右边数的差值，移动left，否则移动right。在else中其中有2种情况：</p><ul><li>右边数的差值&gt;左边的差值，移动right</li><li>右边数的差值=左边的差值，因为题目中说了，差值一样时，优先选择数值较小的那个数，即保留left，移动right</li></ul><p>退出循环时，left和right就是我们要保留的数，因为列表切片时，左闭右开，所以右边要写成right+1</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findClosestElements</span><span class="params">(self, arr, k, x)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type arr: List[int]</span></span><br><span class="line"><span class="string">        :type k: int</span></span><br><span class="line"><span class="string">        :type x: int</span></span><br><span class="line"><span class="string">        :rtype: List[int]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="comment">#使用双指针</span></span><br><span class="line">        n = len(arr)</span><br><span class="line">        left = <span class="number">0</span></span><br><span class="line">        right = n<span class="number">-1</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">#要保留k个数，即要删除n-k个数</span></span><br><span class="line">        del_cnt=<span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> del_cnt &lt; n-k:</span><br><span class="line">            <span class="keyword">if</span> abs(arr[left]-x) &gt; abs(arr[right]-x):</span><br><span class="line">               <span class="comment">#左边元素差值更大时，删除左边的元素</span></span><br><span class="line">                left+=<span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                right-=<span class="number">1</span></span><br><span class="line">            del_cnt+=<span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> arr[left:right+<span class="number">1</span>]</span><br></pre></td></tr></table></figure><p><strong>【题解3】</strong><br>利用二分法来找到长度为k的区间，这里我们只要确定左边界就可以了，因为知道区间长度为k，右边界为left+k-1。<br>首先确定左边界的范围[0,n-k]，比如[0,1,2,3,4,5,6]，一共7个数，n=7，假设k=3，那么左区间最大为4，如果更大的话，就不够3个数了。<br>所以现在要做的是在[0,n-k]这个区间中，找到一个合适的左边界。这就类似在一个有序数组中，查找一个数，可以使用二分法。<br>设定2个指针，一个left=0，指向左边界的最小值，right=n-k，指向左边界的最大值。<code>mid=left+(right-left)//2</code></p><p>解读以下代码：<br>在if语句中<code>abs(arr[mid]-x) &gt; abs(arr[mid+k]-x)</code>,如果左边界是mid，那整个区间是[mid,mid+k-1],下一个左区间范围是[mid+1,mid+k]，这2个区间除了arr[mid]和nums[mid+k]这2个数不一样，其余都一样，那就比较这2个数哪个数离x更远，假设nums[mid]离x更远，就要把left往右移，即left=mid+1，否则right=mid</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findClosestElements</span><span class="params">(self, arr, k, x)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type arr: List[int]</span></span><br><span class="line"><span class="string">        :type k: int</span></span><br><span class="line"><span class="string">        :type x: int</span></span><br><span class="line"><span class="string">        :rtype: List[int]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        n=len(arr)</span><br><span class="line">        left=<span class="number">0</span></span><br><span class="line">        right=n-k</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> left&lt;right:</span><br><span class="line">            mid=left+(right-left)//<span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> abs(arr[mid]-x) &gt; abs(arr[mid+k]-x):<span class="comment">#说明右边的元素离x更近，向右移</span></span><br><span class="line">                left=mid+<span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                right=mid</span><br><span class="line">        <span class="keyword">return</span> arr[left:left+k]</span><br></pre></td></tr></table></figure><h3><span id="335-转变数组后最接近目标值的数组和">3.3.5. 转变数组后最接近目标值的数组和</span></h3><p>给你一个整数数组 arr 和一个目标值 target ，请你返回一个整数 value ，使得将数组中所有大于 value 的值变成 value 后，数组的和最接近  target （最接近表示两者之差的绝对值最小）。</p><p>如果有多种使得和最接近 target 的方案，请你返回这些整数中的最小值。</p><p>请注意，答案不一定是 arr 中的数字。</p><p><strong>【我的解法】</strong><br>首先确定left，right，value表示什么。这里mid表示需要求的value。然后找到left和right的范围。value的范围最小为0，最大为arr中的最大值。然后开始写二分，给定mid，然后我们计算替换后的sum和target的差值。<br>在if语句中，需要有一个比较条件，但是我们不知道和谁比较，受下面2个题的启发<br><a href="https://leetcode-cn.com/problems/find-in-mountain-array/" target="_blank" rel="noopener">1095山脉数组中查找目标值</a>和<a href="https://leetcode-cn.com/problems/find-k-closest-elements/" target="_blank" rel="noopener">658. 找到 K 个最接近的元素</a>：不知道和谁比较时，一般和mid+1比较。如果mid的差值比mid+1的差值大，说明mid小了，应该变大，更新left=mid+1，否则更新right</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findBestValue</span><span class="params">(self, arr, target)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type arr: List[int]</span></span><br><span class="line"><span class="string">        :type target: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="comment">#mid表示要找的这个数value</span></span><br><span class="line">        <span class="comment">#它的范围是：0~arr中的最大值</span></span><br><span class="line">        left=<span class="number">0</span></span><br><span class="line">        right=arr[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> arr:</span><br><span class="line">            <span class="keyword">if</span> i&gt;right:</span><br><span class="line">                right=i</span><br><span class="line">        <span class="keyword">while</span> left&lt;right:</span><br><span class="line">            mid=left+(right-left)//<span class="number">2</span></span><br><span class="line">            <span class="comment">#计算当value=mid时，所有数据的和</span></span><br><span class="line">            mid_sum = self.get_sum(arr,mid)</span><br><span class="line">            mid_plus_sum = self.get_sum(arr,mid+<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">if</span> abs(mid_sum-target) &gt; abs(mid_plus_sum-target):</span><br><span class="line">                <span class="comment">#说明mid小了，向右移</span></span><br><span class="line">                left = mid+<span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                right=mid</span><br><span class="line">        <span class="keyword">return</span> left</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_sum</span><span class="params">(self,arr,value)</span>:</span></span><br><span class="line">        all_sum = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> arr:</span><br><span class="line">            <span class="keyword">if</span> i &gt; value:</span><br><span class="line">                all_sum+=value</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                all_sum+=i</span><br><span class="line">        <span class="keyword">return</span> all_sum</span><br></pre></td></tr></table></figure><h1><span id="4-总结">4. 总结</span></h1><ol><li>首先明确left，right，mid表示什么意思，确定了表示含义后，才可以确定left和right的范围</li><li>一般来说mid的含义要么是题目中要求的值，要么是下标。</li><li>在if语句中的条件时，mid的值或mid对应的函数值，需要和一个值进行比较，如果很容易发现和谁比较，就和谁比较，如果找不到就和mid+1的函数值比较</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;列表查找：从列表中查找指定元素&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;输出：列表&lt;/li&gt;
&lt;li&gt;输出：元素下标，找不到返回None或-1&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode之Array</title>
    <link href="http://yoursite.com/2020/03/13/Leetcode%E4%B9%8BArray/"/>
    <id>http://yoursite.com/2020/03/13/Leetcode之Array/</id>
    <published>2020-03-13T07:02:20.000Z</published>
    <updated>2020-04-08T11:46:28.632Z</updated>
    
    <content type="html"><![CDATA[<p>最近要开始准备刷Leetcode了，在这里记录下刷题的心得</p><a id="more"></a><!-- TOC --><ul><li><a href="#1-双指针">1. 双指针</a><ul><li><a href="#11-删除排序数组中的重复项">1.1. 删除排序数组中的重复项</a></li><li><a href="#12-移除元素">1.2. 移除元素</a></li><li><a href="#13-删除排序数组中的重复项-ii">1.3. 删除排序数组中的重复项 II</a></li><li><a href="#14-缺失的第一个正数">1.4. 缺失的第一个正数</a></li></ul></li><li><a href="#2-其他">2. 其他</a><ul><li><a href="#21-find-the-celebrity">2.1. Find the Celebrity</a></li><li><a href="#22-旋转数组">2.2. 旋转数组</a></li><li><a href="#23-猜数字游戏">2.3. 猜数字游戏</a></li><li><a href="#24-加油站">2.4. 加油站</a></li><li><a href="#25-多数元素">2.5. 多数元素</a></li><li><a href="#26-求众数-ii">2.6. 求众数 II</a></li><li><a href="#27-h指数">2.7. H指数</a></li><li><a href="#28-最短单词距离">2.8. 最短单词距离</a></li><li><a href="#29-最短单词距离-ii">2.9. 最短单词距离 II</a></li><li><a href="#210-最短单词距离之iii">2.10. 最短单词距离之III</a></li><li><a href="#211-存在重复元素">2.11. 存在重复元素</a></li><li><a href="#212-存在重复元素-ii">2.12. 存在重复元素 II</a></li><li><a href="#213-存在重复元素-iii">2.13. 存在重复元素 III</a></li><li><a href="#214-跳跃游戏">2.14. 跳跃游戏</a></li></ul></li></ul><!-- /TOC --><h1><span id="1-双指针">1. 双指针</span></h1><h2><span id="11-删除排序数组中的重复项">1.1. 删除排序数组中的重复项</span></h2><p>给定一个<strong>排序数组</strong>，你需要在 原地 删除重复出现的元素，使得每个元素只出现一次，返回移除后数组的新长度。</p><p>不要使用额外的数组空间，你必须在 原地 修改输入数组 并在使用 <strong>O(1) 额外空间</strong>的条件下完成。</p><p><strong>【我的解法】</strong><br>用一个变量<code>i_first</code>表示待验证是否重复的值，因为该数据已经排好序，所以已经验证不重复的元素后面不会再次出现。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">removeDuplicates</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        delete_num = <span class="number">0</span></span><br><span class="line">        len_nums = len(nums)</span><br><span class="line">        i_first = <span class="keyword">None</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len_nums):</span><br><span class="line">            i-=delete_num</span><br><span class="line">            <span class="keyword">if</span> i == <span class="number">0</span>: </span><br><span class="line">                i_first = nums[i]</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">if</span> nums[i] == i_first:</span><br><span class="line">                nums.pop(i)</span><br><span class="line">                delete_num += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                i_first = nums[i]</span><br><span class="line">        <span class="keyword">return</span> len(nums)</span><br></pre></td></tr></table></figure><p><strong>【改进1】</strong><br>如果数组长度为1，可以直接返回。其余情况使用快慢双指针，快指针用来遍历数据，注意快指针从下标1开始遍历，慢指针指向非重复的值，如果快指针和慢指针不相等，快指针后移，如果相等，将快指针的值拷贝到慢指针+1的位置</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">removeDuplicates</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> len(nums) == <span class="number">1</span>:<span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        slow = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> fast <span class="keyword">in</span> range(<span class="number">1</span>,len(nums)):</span><br><span class="line">            <span class="keyword">if</span> nums[fast] != nums[slow]:</span><br><span class="line">                slow+=<span class="number">1</span></span><br><span class="line">                nums[slow] = nums[fast]</span><br><span class="line">        <span class="keyword">return</span> slow+<span class="number">1</span></span><br></pre></td></tr></table></figure><h2><span id="12-移除元素">1.2. 移除元素</span></h2><p>给你一个数组 nums 和一个值 val，你需要 原地 移除所有数值等于 val 的元素，并返回移除后数组的新长度。</p><p>不要使用额外的数组空间，你必须仅使用 <strong>O(1) 额外空间</strong>并 原地 修改输入数组。</p><p><strong>元素的顺序可以改变</strong>。你不需要考虑数组中超出新长度后面的元素。</p><p><strong>【我的解法】</strong>:<br>使用remove函数从原始数组中删除元素，但是每调用一次remove函数，数组的中元素会向前移，时间复杂度大</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">removeElement</span><span class="params">(self, nums, val)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :type val: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        delete_count = <span class="number">0</span></span><br><span class="line">        nums_len = len(nums)</span><br><span class="line">        <span class="keyword">for</span> idx <span class="keyword">in</span> range(nums_len):</span><br><span class="line">            idx -= delete_count</span><br><span class="line">            <span class="keyword">if</span> nums[idx] == val:</span><br><span class="line">                nums.remove(nums[idx])</span><br><span class="line">                delete_count +=<span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> len(nums)</span><br></pre></td></tr></table></figure><p><strong>【改进1】</strong>：<br>使用快慢双指针，拷贝覆盖，快指针依次遍历nums数组，慢指针指向不等于val的元素，如果fast的元素不等于val，则拷贝到nums[slow]位置，否则fast++</p><ul><li>这种思路在移除元素较多时更适合使用，最极端的情况是全部元素都需要移除，遍历一遍结束即可</li><li>时间复杂度：O(n)，空间复杂度：O(1)</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">removeElement</span><span class="params">(self, nums, val)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :type val: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        slow = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> fast <span class="keyword">in</span> range(len(nums)):</span><br><span class="line">            <span class="keyword">if</span> nums[fast] != val:</span><br><span class="line">                nums[slow] = nums[fast]</span><br><span class="line">                slow +=<span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> slow</span><br></pre></td></tr></table></figure><h2><span id="13-删除排序数组中的重复项-ii">1.3. 删除排序数组中的重复项 II</span></h2><p>给定一个排序数组，你需要在原地删除重复出现的元素，使得每个元素最多出现两次，返回移除后数组的新长度。</p><p>不要使用额外的数组空间，你必须在原地修改输入数组并在使用 O(1) 额外空间的条件下完成。</p><p><strong>【我的解法】</strong></p><p>经过上面2道题，本题也使用快慢双指针。fast用来遍历数组，slow用来表示当前需要验证的值，如果fast=slow，则slow的count+1，如果不相等，则更新slow并将fast的值拷贝到slow中。但是这种方案总是在一些边界时出现问题，例如[1,1,1,2,2,3,3]其中后两个值相等，但是在处理最后一个3时，if条件判断fast和slow相等，count+1，然后就直接return，这样输出的结果将是[1,1,2,2,3],为了解决这个问题，加了对边界条件的处理，如下，但是这样[1,1,1]会出错，返回[1]，调了很久都没有想出来怎么满足所有的条件。。。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">removeDuplicates</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        slow,count = <span class="number">0</span>,<span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> fast <span class="keyword">in</span> range(<span class="number">1</span>,len(nums)):</span><br><span class="line">            <span class="keyword">if</span> nums[fast] == nums[slow]:</span><br><span class="line">                count+=<span class="number">1</span></span><br><span class="line">                <span class="comment">#处理边界</span></span><br><span class="line">                <span class="keyword">if</span> fast == len(nums) - <span class="number">1</span> <span class="keyword">and</span> count ==<span class="number">2</span>:</span><br><span class="line">                    slow += <span class="number">1</span></span><br><span class="line">                    nums[slow] = nums[fast]</span><br><span class="line">                    count = <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                slow += <span class="number">2</span> <span class="keyword">if</span> count&gt;<span class="number">2</span> <span class="keyword">else</span> count</span><br><span class="line">                nums[slow] = nums[fast]</span><br><span class="line">                count = <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> slow+<span class="number">1</span></span><br></pre></td></tr></table></figure><p><strong>【改进1】</strong><br>思路：</p><ul><li>快指针：遍历整个数组；</li><li>慢指针：记录可以覆写数据的位置；</li><li>题目中规定每个元素最多出现两次，因此，应检查快指针指向的元素和慢指针前一个元素是否相等。相等只更新快指针；不相等时，先将慢指针后移一位，再将快指针指向的元素覆写入慢指针指向的单元，最后更新快指针。</li></ul><p>边界：</p><ul><li>当数组的长度小于等于 2 时，不需要操作，直接返回原数组即可。</li></ul><p>初始化：</p><ul><li>快指针用于遍历数组，但算法不可能操作序号小于 2 的元素，因此快指针初始值为 2；</li><li>初始状态下，慢指针应紧随快指针之后，因此初始值为 1；</li></ul><p>结束条件：</p><ul><li>快指针达到数组结尾。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">removeDuplicates</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> len(nums) == <span class="number">2</span>:<span class="keyword">return</span> <span class="number">2</span></span><br><span class="line">        slow = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> fast <span class="keyword">in</span> range(<span class="number">2</span>,len(nums)):</span><br><span class="line">            <span class="keyword">if</span> nums[fast] != nums[slow<span class="number">-1</span>]:</span><br><span class="line">                slow+=<span class="number">1</span></span><br><span class="line">                nums[slow] = nums[fast]</span><br><span class="line">        <span class="keyword">return</span> slow+<span class="number">1</span></span><br></pre></td></tr></table></figure><p><strong>【改进2】</strong></p><ul><li>使用count来记录每一个元素出现的次数，初始值为1</li><li>当fast和slow相等时，说明fast出现了多次，count+1，否则说明fast是新出现的，count重置为1</li><li>如果count小于等于2，满足条件，slow+1,把fast的值拷贝到slow中，如果 count大于2，fast的值舍弃，不要拷贝到slow中</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">removeDuplicates</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> len(nums) == <span class="number">2</span>:<span class="keyword">return</span> <span class="number">2</span></span><br><span class="line">        slow,count = <span class="number">0</span>,<span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> fast <span class="keyword">in</span> range(<span class="number">1</span>,len(nums)):</span><br><span class="line">            <span class="keyword">if</span> nums[fast] == nums[slow]:</span><br><span class="line">                count+=<span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                count = <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> count &lt;= <span class="number">2</span>:</span><br><span class="line">                slow += <span class="number">1</span></span><br><span class="line">                nums[slow] = nums[fast]</span><br><span class="line">        <span class="keyword">return</span> slow+<span class="number">1</span></span><br></pre></td></tr></table></figure><h2><span id="14-缺失的第一个正数">1.4. 缺失的第一个正数</span></h2><p>给定一个未排序的整数数组，找出其中没有出现的最小的正整数。<br><strong>【我的解法】</strong><br>首先找到nums中的最大值和最小值，然后遍历min和max之间的所有数，判断是否在数组中。但是这样会出现内存溢出的问题</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">firstMissingPositive</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> len(nums) == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        <span class="comment">#先遍历数组找max和min</span></span><br><span class="line">        nums_min,nums_max = min(nums),max(nums)</span><br><span class="line">        <span class="keyword">if</span> nums_max &lt; <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        <span class="keyword">elif</span> nums_min &lt; <span class="number">0</span>:</span><br><span class="line">            nums_min = <span class="number">1</span></span><br><span class="line">        <span class="keyword">elif</span> nums_min &gt; <span class="number">0</span> <span class="keyword">and</span> nums_min != <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span> </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(nums_min,nums_max):</span><br><span class="line">            <span class="keyword">if</span> i <span class="keyword">not</span> <span class="keyword">in</span> nums:</span><br><span class="line">                <span class="keyword">return</span> i</span><br><span class="line">        <span class="keyword">return</span> nums_max+<span class="number">1</span></span><br></pre></td></tr></table></figure><p><strong>【改进1】</strong><br>使用快慢指针。</p><ul><li>先对nums排序</li><li>对特征情况处理：nums为空或最小值大于1，返回1</li><li>快指针遍历数组，慢指针表示最小的正整数，初始化为1</li><li>遍历数组，如果fast小于等于0，继续；如果fast和slow相等，说明slow在数组中，slow加1。遍历完之后返回slow，即最小的正整数。</li><li>不能在for循环的else中返回slow，如果list中有重复元素会报错，例如[0,1,1,2,2]</li><li>为了解决nums中有重复元素问题，使用set(sorted(nums))，但是这样也报错，因为set会让原先已经排好序的数组又变得乱序，改成sorted(set(nums))就可以了</li><li>但是排序的时间复杂度不符合题目要求</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">firstMissingPositive</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        nums = sorted(nums)</span><br><span class="line">        <span class="keyword">if</span> len(nums) ==<span class="number">0</span> <span class="keyword">or</span> nums[<span class="number">0</span>] &gt; <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        slow = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> fast <span class="keyword">in</span> nums:</span><br><span class="line">            <span class="keyword">if</span> fast &lt;= <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">if</span> fast == slow:</span><br><span class="line">                slow+=<span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> slow</span><br></pre></td></tr></table></figure><p><strong>【改进2】</strong><br>要返回丢失的最小正整数，该正整数一定在[1,n+1]之间。题目要求常数空间，所以将原始数组当做哈希表使用。</p><ul><li>最终返回的数在[1,n+1]之间，当[1,n]都在数组中，才会返回n+1</li><li>对[1,n]之间的数重新找位置。<br>数字1放在下标为0的位置<br>数字2放在下标为1的位置<br>…<br>数字n放在下标为n-1的位置<br>如果遇到的数不在[1,n]之间，不用换位置</li><li>在遍历一次数组，遇到第一个数字不等于下标+1的值，就是丢失的正整数，返回即可。如果遍历完整个数组，都没有return，说明[1,n]的所有数都在数组中，返回n+1</li><li>空间复杂度$O(1)$</li><li>时间复杂度$O(n)$</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">firstMissingPositive</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        n = len(nums)<span class="comment">#一共有n个数</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">            <span class="keyword">while</span> (nums[i] &gt;= <span class="number">1</span> <span class="keyword">and</span> nums[i] &lt;= n <span class="keyword">and</span> nums[i] != nums[nums[i] - <span class="number">1</span>]):</span><br><span class="line">                self.swap(nums,i,nums[i]<span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">            <span class="keyword">if</span> nums[i] != i + <span class="number">1</span>:</span><br><span class="line">                <span class="keyword">return</span> i+<span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> n+<span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">swap</span><span class="params">(self,nums,src,des)</span>:</span></span><br><span class="line">        temp = nums[des]</span><br><span class="line">        nums[des] = nums[src]</span><br><span class="line">        nums[src] = temp</span><br></pre></td></tr></table></figure><h1><span id="2-其他">2. 其他</span></h1><h2><span id="21-find-the-celebrity">2.1. Find the Celebrity</span></h2><p>在n个人中寻找名人，所谓名人就是每个人都认识他，他却不认识任何人，限定了只有1个或0个名人，给定了一个 API 函数，输入a和b，<code>bool know(a,b)</code>用来判断a是否认识b，让我们尽可能少的调用这个函数，来找出人群中的名人,能找到名人返回名人的下标，否则返回-1</p><p><strong>【解法1】</strong><br>遍历所有的人，判断i是否是名人，就要看i是否满足名人的条件，如果剩下的n-1个人中有i认识的人，或者有人不认识i，则i不是名人，使用break跳出内循环，继续遍历下一个i。如果剩下的n-1个人中i都不认识并且n-1个人都认识i，则返回i，否则返回-1。找出一种解法最可能少的调用<code>know</code>函数<br>时间复杂度$O(n^2)$</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">findCelebrity</span><span class="params">(n)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(n):</span><br><span class="line">            <span class="keyword">if</span>(i!=j <span class="keyword">and</span> (know(i,j) <span class="keyword">or</span> <span class="keyword">not</span> know(j,i))):</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">if</span>(j==n):</span><br><span class="line">            <span class="keyword">return</span> i</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span></span><br></pre></td></tr></table></figure><p><strong>【解法2】</strong><br>先找出名人的candidate，然后再验证这个candidate是否合理。</p><ul><li>第一步：找candidate,先初始化candidate为0，然后遍历所有人，如果candidate认识i，则candidate不符合，将candidate换成i。遍历完所有的人，最终选出一个candidate，这个candidate不认识它后面所有的人</li><li>第二步：验证candidate。先验证candicate前面的人，如果前面的人中不认识candicate，或candicate认识某人，则candicate不是名人，返回-1。再验证candidate后面的人，因为在选择candidate时已经知道candidate不认识后面的人，所以这里只需要验证后面的人是否认识candidate就可以了</li><li>时间复杂度$O(n)$</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">findCelebrity</span><span class="params">(n)</span>:</span></span><br><span class="line">    candidate = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">        <span class="keyword">if</span>(i != candicate <span class="keyword">and</span> know(candidate,i)):</span><br><span class="line">            candicate = i</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(candicate):</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">not</span> know(i,candidate) <span class="keyword">or</span> know(candidate,i)):</span><br><span class="line">            retur</span><br><span class="line">            n <span class="number">-1</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(candicate+<span class="number">1</span>,n):</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">not</span> know(i,candidate)):</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">    <span class="keyword">return</span> candidate</span><br></pre></td></tr></table></figure><h2><span id="22-旋转数组">2.2. 旋转数组</span></h2><p>给定一个数组，将数组中的元素向右移动 k 个位置，其中 k 是非负数。</p><p><strong>【我的解法】</strong><br>当时使用找规律的方法，旋转k步，原先下标为i的元素，旋转之后下标变成多少，然后赋值。但是有个问题赋值完后数组原先的值就丢失了，所以一直在纠结这个问题，下面的解法没有实现</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">rotate</span><span class="params">(self, nums, k)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :type k: int</span></span><br><span class="line"><span class="string">        :rtype: None Do not return anything, modify nums in-place instead.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        n = len(nums)</span><br><span class="line">        k = k % n</span><br><span class="line">        nums_0 = nums[<span class="number">0</span>] <span class="comment">#将来放在(0+k)%n的位置</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>,k):</span><br><span class="line">            <span class="keyword">if</span> i == <span class="number">0</span>:</span><br><span class="line">                nums[i] = nums[(n+i-k)%n]</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                tmp = nums[i]</span><br><span class="line">                nums[i] = nums[(n+i-k)%n]</span><br><span class="line">                nums[(n+i-k)%k] = tmp</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(k+<span class="number">1</span>,n):</span><br><span class="line">            nums[i] = 。。。</span><br><span class="line">        nums[k] = nums_0</span><br><span class="line">        <span class="keyword">return</span> nums</span><br></pre></td></tr></table></figure><p><strong>【改进1】</strong><br>利用python中数组的特性，pop()每次弹出最后一个元素，然后使用insert将其插入到开头</p><ul><li>空间复杂度：$O(1)$</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">rotate</span><span class="params">(self, nums, k)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :type k: int</span></span><br><span class="line"><span class="string">        :rtype: None Do not return anything, modify nums in-place instead.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        k %= len(nums)</span><br><span class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> range(k):</span><br><span class="line">            nums.insert(<span class="number">0</span>,nums.pop())</span><br><span class="line">        <span class="keyword">return</span> nums</span><br></pre></td></tr></table></figure><p><strong>【改进2】</strong><br>例如<code>1,2,3,4,5,6,7</code>，当k=3时，旋转后的数组为<code>5,6,7,1,2,3,4</code>，就是将原先数据中[-k:]的元素前移，将[:-k]的元素后移</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">rotate</span><span class="params">(self, nums, k)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :type k: int</span></span><br><span class="line"><span class="string">        :rtype: None Do not return anything, modify nums in-place instead.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        k %= len(nums)</span><br><span class="line">        nums[:] = nums[-k:]+nums[:-k]</span><br><span class="line">        <span class="keyword">return</span> nums</span><br></pre></td></tr></table></figure><p>【优秀题解3】<br>使用3次翻转，先翻转所有数据，再翻转前k个，再翻转后n-k个。</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">k = <span class="number">3</span></span><br><span class="line">原始数据：<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span></span><br><span class="line">翻转全部：<span class="number">7</span>,<span class="number">6</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span></span><br><span class="line">翻转前k个：<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span></span><br><span class="line">翻转后n-k个：<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">rotate</span><span class="params">(self, nums, k)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :type k: int</span></span><br><span class="line"><span class="string">        :rtype: None Do not return anything, modify nums in-place instead.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        k %= len(nums)</span><br><span class="line">        nums[:] = nums[-k:]+nums[:-k]</span><br><span class="line">        <span class="keyword">return</span> nums</span><br></pre></td></tr></table></figure><p>【总结】以上3种解法都是利用Python的特征，非常简单！人生苦短，我用Python！</p><h2><span id="23-猜数字游戏">2.3. 猜数字游戏</span></h2><p>你正在和你的朋友玩 猜数字（Bulls and Cows）游戏：你写下一个数字让你的朋友猜。每次他猜测后，你给他一个提示，告诉他有多少位数字和确切位置都猜对了（称为“Bulls”, 公牛），有多少位数字猜对了但是位置不对（称为“Cows”, 奶牛）。你的朋友将会根据提示继续猜，直到猜出秘密数字。</p><p>请写出一个根据秘密数字和朋友的猜测数返回提示的函数，用 A 表示公牛，用 B 表示奶牛。</p><p>请注意秘密数字和朋友的猜测数都可能含有重复数字。</p><blockquote><p>输入: secret = “1807”, guess = “7810”<br>输出: “1A3B”<br>解释: 1 公牛和 3 奶牛。公牛是 8，奶牛是 0, 1 和 7。</p></blockquote><p><strong>【我的解法】</strong><br>首先找出A的个数，然后找出B的个数。</p><ul><li>先找到A的个数，并记录这些数字的下标</li><li>除去A的数字，记录剩下的secret中每个数字及下标。</li><li>找B的个数。遍历guess中的数字，如果该数字在secret中，并且该数字验证的个数小于secret中该数字的个数，B的个数加一</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getHint</span><span class="params">(self, secret, guess)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type secret: str</span></span><br><span class="line"><span class="string">        :type guess: str</span></span><br><span class="line"><span class="string">        :rtype: str</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="comment">#先找到A</span></span><br><span class="line">        A = <span class="number">0</span></span><br><span class="line">        A_index = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(secr  et)):</span><br><span class="line">            <span class="keyword">if</span> secret[i] == guess[i]:</span><br><span class="line">                A +=<span class="number">1</span></span><br><span class="line">                A_index.append(i)</span><br><span class="line">        <span class="comment">#记录secret中剩下的数字及下标</span></span><br><span class="line">        other_index = [i <span class="keyword">for</span> i <span class="keyword">in</span> list(range(len(secret))) <span class="keyword">if</span> i <span class="keyword">not</span> <span class="keyword">in</span> A_index]</span><br><span class="line">        secret_dict = &#123;&#125;</span><br><span class="line">        secret_verify = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> other_index:</span><br><span class="line">            <span class="keyword">if</span> secret[i] <span class="keyword">not</span> <span class="keyword">in</span> secret_dict:</span><br><span class="line">                secret_dict[secret[i]] = [i]</span><br><span class="line">                secret_verify[secret[i]] = <span class="number">0</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                secret_dict[secret[i]].append(i)</span><br><span class="line">        <span class="comment">#找B的个数</span></span><br><span class="line">        B = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> other_index:</span><br><span class="line">            current = guess[i]</span><br><span class="line">            <span class="keyword">if</span> (current <span class="keyword">in</span> secret_dict) <span class="keyword">and</span> secret_verify[current] &lt; len(secret_dict[current]):</span><br><span class="line">                B += <span class="number">1</span></span><br><span class="line">                secret_verify[current] += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> str(A)+<span class="string">'A'</span>+str(B)+<span class="string">'B'</span></span><br></pre></td></tr></table></figure><h2><span id="24-加油站">2.4. 加油站</span></h2><p>在一条环路上有 N 个加油站，其中第 i 个加油站有汽油 gas[i] 升。</p><p>你有一辆油箱容量无限的的汽车，从第 i 个加油站开往第 i+1 个加油站需要消耗汽油 cost[i] 升。你从其中的一个加油站出发，开始时油箱为空。</p><p>如果你可以绕环路行驶一周，则返回出发时加油站的编号，否则返回 -1。</p><p>说明: </p><p>如果题目有解，该答案即为唯一答案。<br>输入数组均为非空数组，且长度相同。<br>输入数组中的元素均为非负数。</p><p><strong>【我的解法】</strong><br>暴力搜索</p><ul><li>先找出能够作为起始点的加油站，作为候选集。即gas[i] &gt;= cost[i]，从当前加油站出发能够走到下一个加油站</li><li><p>遍历所有的候选集。对于某一个候选加油站。终止的条件是：</p><ul><li>if cur_idx != start的前一个加油站，cur_gas-cost[cur_idx]+gas[next_idx] &lt; cost[next_idx]，即当前加油站出发走到下一个加油站加上油，不够走到下下一个加油站。则当前候选加油站失效，遍历下一个候选集</li><li>if cur_idx == start的前一个加油站，cur_gas &lt; cost[cur_idx],当前的油不够走到下一个加油站。则当前候选加油站失效，遍历下一个候选集</li></ul></li><li>空间复杂度$O(1)$</li><li>时间复杂度$O(N^2)$</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">canCompleteCircuit</span><span class="params">(self, gas, cost)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type gas: List[int]</span></span><br><span class="line"><span class="string">        :type cost: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        n = len(gas)</span><br><span class="line">        candidate = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">            <span class="keyword">if</span> gas[i] &gt;= cost[i]:</span><br><span class="line">                candidate.append(i)</span><br><span class="line">        <span class="keyword">for</span> start <span class="keyword">in</span> candidate:</span><br><span class="line">            cur_index = start</span><br><span class="line">            cur_gas = gas[cur_index]</span><br><span class="line">            next_index = (cur_index+<span class="number">1</span>)%n</span><br><span class="line">            tmp = n<span class="number">-1</span> <span class="keyword">if</span> start==<span class="number">0</span> <span class="keyword">else</span> start<span class="number">-1</span></span><br><span class="line">            <span class="keyword">while</span> cur_index != tmp:</span><br><span class="line">                <span class="keyword">if</span> cur_gas - cost[cur_index] + gas[next_index] &gt;= cost[next_index]:</span><br><span class="line">                    cur_gas = cur_gas - cost[cur_index] + gas[next_index]</span><br><span class="line">                    cur_index = next_index</span><br><span class="line">                    next_index = (cur_index+<span class="number">1</span>)%n</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">if</span> cur_index == tmp <span class="keyword">and</span> cur_gas &gt;= cost[cur_index]:</span><br><span class="line">                <span class="keyword">return</span> start</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span></span><br></pre></td></tr></table></figure><p>【改进1】</p><ul><li>时间复杂度$O(N)$</li><li>空间复杂度$O(1)$<br>这个题解还没有看懂，以后再看</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">canCompleteCircuit</span><span class="params">(self, gas, cost)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type gas: List[int]</span></span><br><span class="line"><span class="string">        :type cost: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        cur_gas = <span class="number">0</span><span class="comment">#当前剩余油量</span></span><br><span class="line">        delta_gas = <span class="number">0</span><span class="comment">#整个过程中油量和消耗的delta</span></span><br><span class="line">        start = <span class="number">0</span><span class="comment">#起始位置</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(gas)):</span><br><span class="line">            cur_gas += gas[i] - cost[i]</span><br><span class="line">            delta_gas += gas[i] - cost[i]</span><br><span class="line">            <span class="keyword">if</span> cur_gas &lt; <span class="number">0</span>:</span><br><span class="line">                <span class="comment">#当前i不满足时，start为什么跳到i+1，而不是start+1?</span></span><br><span class="line">                start = i+<span class="number">1</span></span><br><span class="line">                cur_gas = <span class="number">0</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span> <span class="keyword">if</span> delta_gas &lt; <span class="number">0</span> <span class="keyword">else</span> start</span><br></pre></td></tr></table></figure><h2><span id="25-多数元素">2.5. 多数元素</span></h2><p>给定一个大小为 n 的数组，找到其中的多数元素。多数元素是指在数组中出现次数大于 ⌊ n/2 ⌋ 的元素。</p><p>你可以假设数组是非空的，并且给定的数组总是存在多数元素。</p><p><strong>【我的解法】</strong><br>使用字典保存每个数字出现的个数，然后按照出现排序，找到出现次数最多的key</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">majorityElement</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        count = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> nums:</span><br><span class="line">            <span class="keyword">if</span> i <span class="keyword">not</span> <span class="keyword">in</span> count:</span><br><span class="line">                count[i] = <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                count[i]+=<span class="number">1</span></span><br><span class="line">        count = sorted(count.items(),key=<span class="keyword">lambda</span> x:x[<span class="number">1</span>],reverse=<span class="keyword">True</span>)</span><br><span class="line">        <span class="keyword">return</span> count[<span class="number">0</span>][<span class="number">0</span>]</span><br></pre></td></tr></table></figure><p><strong>【改进1】</strong><br>摩尔投票法的详细步骤：</p><ul><li>我们维护一个候选众数 major 和它出现的次数 count。初始时 major 可以为任意值，count 为 0；</li><li><p>遍历数组 nums 中的所有元素，对于每个元素 x，在判断 x 之前，如果 count 的值为 0，我们先将 x 的值赋予major，随后我们判断 x：</p><ul><li>如果 x 与 major 相等，那么计数器 count 的值增加 1；</li><li>如果 x 与 major 不等，那么计数器 count 的值减少 1。</li></ul></li><li><p>在遍历完成后，major 即为整个数组的众数。</p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">majorityElement</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="comment">#摩尔投票法</span></span><br><span class="line">        major = <span class="number">0</span></span><br><span class="line">        count = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> nums:</span><br><span class="line">            <span class="keyword">if</span> count == <span class="number">0</span>:</span><br><span class="line">                major = i</span><br><span class="line">            <span class="keyword">if</span> i == major:</span><br><span class="line">                count += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                count -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> major</span><br></pre></td></tr></table></figure><h2><span id="26-求众数-ii">2.6. 求众数 II</span></h2><p>给定一个大小为 n 的数组，找出其中所有出现超过 ⌊ n/3 ⌋ 次的元素。</p><p>说明: 要求算法的时间复杂度为 O(n)，空间复杂度为 O(1)。</p><p>同样使用摩尔投票法，参考<br><a href="https://leetcode-cn.com/problems/majority-element-ii/solution/liang-fu-dong-hua-yan-shi-mo-er-tou-piao-fa-zui-zh/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/majority-element-ii/solution/liang-fu-dong-hua-yan-shi-mo-er-tou-piao-fa-zui-zh/</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">majorityElement</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: List[int]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        cand1,count1 = <span class="number">0</span>,<span class="number">0</span></span><br><span class="line">        cand2,count2 = <span class="number">0</span>,<span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> nums:</span><br><span class="line">            <span class="keyword">if</span> i == cand1:</span><br><span class="line">                count1 +=<span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> i == cand2:</span><br><span class="line">                count2 += <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> count1 == <span class="number">0</span>:</span><br><span class="line">                cand1 = i</span><br><span class="line">                count1 +=<span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> count2 == <span class="number">0</span>:</span><br><span class="line">                cand2 = i</span><br><span class="line">                count2 += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                count1 -= <span class="number">1</span></span><br><span class="line">                count2 -= <span class="number">1</span></span><br><span class="line">        count1,count2 = <span class="number">0</span>,<span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> nums:</span><br><span class="line">            <span class="keyword">if</span> i == cand1:</span><br><span class="line">                count1 += <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> i == cand2:</span><br><span class="line">                count2 += <span class="number">1</span></span><br><span class="line">        result = []</span><br><span class="line">        <span class="keyword">if</span> count1 &gt; int(len(nums)/<span class="number">3</span>):</span><br><span class="line">            result.append(cand1)</span><br><span class="line">        <span class="keyword">if</span> count2 &gt; int(len(nums)/<span class="number">3</span>):</span><br><span class="line">            result.append(cand2)</span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure><h2><span id="27-h指数">2.7. H指数</span></h2><p>给定一位研究者论文被引用次数的数组（被引用次数是非负整数）。编写一个方法，计算出研究者的 h 指数。</p><p>h 指数的定义: “h 代表“高引用次数”（high citations），一名科研人员的 h 指数是指他（她）的 （N 篇论文中）有 h 篇论文分别被引用了至少 h 次。（其余的 N - h 篇论文每篇被引用次数不多于 h 次。）”</p><p><strong>【题解】</strong><br>先将数组从大到小排序，使用直方图表示，直方图上最大正方形的变长h就是最终的答案。<code>citations[i]&gt;i</code></p><ul><li>时间复杂度:$nlog(n)$，排序的下限</li></ul><p><a href="https://leetcode-cn.com/problems/h-index/solution/hzhi-shu-by-leetcode/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/h-index/solution/hzhi-shu-by-leetcode/</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hIndex</span><span class="params">(self, citations)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type citations: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> len(citations) == <span class="number">0</span> <span class="keyword">or</span> (len(citations)==<span class="number">1</span> <span class="keyword">and</span> citations[<span class="number">0</span>]==<span class="number">0</span>):</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> len(citations) == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        citations = sorted(citations,reverse=<span class="keyword">True</span>)</span><br><span class="line">        j = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(citations)):</span><br><span class="line">            <span class="keyword">if</span> citations[i] &gt; j:</span><br><span class="line">                j+=<span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> j</span><br></pre></td></tr></table></figure><h2><span id="28-最短单词距离">2.8. 最短单词距离</span></h2><p>Given a list of words and two words word1 and word2, return the shortest distance between these two words in the list.</p><p>Example:<br>Assume that words = [“practice”, “makes”, “perfect”, “coding”, “makes”].</p><p>Input: word1 = “coding”, word2 = “practice”<br>Output: 3<br>Input: word1 = “makes”, word2 = “coding”<br>Output: 1<br>Note:<br>You may assume that word1 does not equal to word2, and word1 and word2 are both in the list.<br>2个词不相同，并且都在list中</p><p><strong>【我的解法】</strong><br>首先遍历words数据，分别记录word1和word2的位置，然后遍历这些位置数组，找出最短的距离</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">shortestDistance</span><span class="params">(words,word1,word2)</span>:</span></span><br><span class="line">    idx1,idx2 = [],[]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(words)):</span><br><span class="line">        <span class="keyword">if</span> words[i] == word1:</span><br><span class="line">            idx1.append(i)</span><br><span class="line">        <span class="keyword">if</span> words[i] == word2:</span><br><span class="line">            idx2.append(i)</span><br><span class="line">    result = float(<span class="string">"inf"</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> idx1:</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> idx2:</span><br><span class="line">            result = min(result,abs(i-j))</span><br><span class="line">    <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure><p><strong>【改进1】</strong><br>不再使用数组来保存2个词的位置，只遍历一遍数组。用2个变量idx1和idx2来记录word1和word2的位置。如果idx1和idx2都不为-1时，更新result</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">shortestDistance</span><span class="params">(words,word1,word2)</span>:</span></span><br><span class="line">    idx1,idx2 = <span class="number">-1</span>,<span class="number">-1</span></span><br><span class="line">    result = float(<span class="string">"inf"</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(words)):</span><br><span class="line">        <span class="keyword">if</span> words[i] == word1:</span><br><span class="line">            idx1 = i</span><br><span class="line">        <span class="keyword">if</span> words[i] == word2:</span><br><span class="line">            idx2 = i</span><br><span class="line">        <span class="keyword">if</span> idx1 != <span class="number">-1</span> <span class="keyword">and</span> idx2 != <span class="number">-1</span>:</span><br><span class="line">            result = min(result,abs(idx1-idx2))</span><br><span class="line">    <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure><h2><span id="29-最短单词距离-ii">2.9. 最短单词距离 II</span></h2><p>This is a follow up of Shortest Word Distance. The only difference is now you are given the list of words and your method will be called repeatedly many times with different parameters. How would you optimize it?</p><p>Design a class which receives a list of words in the constructor, and implements a method that takes two words word1 and word2 and return the shortest distance between these two words in the list.</p><p>For example,<br>Assume that words = [“practice”, “makes”, “perfect”, “coding”, “makes”].</p><p>Given word1 = “coding”, word2 = “practice”, return 3.<br>Given word1 = “makes”, word2 = “coding”, return 1.</p><p>Note:<br>You may assume that word1 does not equal to word2, and word1 and word2 are both in the list.<br>这道题和上一道的区别：给定一个words列表，求最短距离函数会被调用很多次，算是对上一题的优化</p><p><strong>【解法1】</strong><br>因为最短距离函数会被调用很多次，所以我们可以提前讲words中每个单词的位置记录在dict中，在计算距离时，取出这2个单词的位置计算最短距离。</p><ul><li>时间复杂度：$O(M*N)$，其中M和N是2个单词的个数</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WordDistance</span><span class="params">(object)</span>:</span></span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, words)</span>:</span></span><br><span class="line">        <span class="keyword">from</span> collections <span class="keyword">import</span> defaultdict</span><br><span class="line">        self.words = words</span><br><span class="line">        self.dict= defaultdict(list)</span><br><span class="line">        <span class="keyword">for</span> i, word <span class="keyword">in</span> enumerate(words):</span><br><span class="line">            self.dict[word].append(i)</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">shortest</span><span class="params">(self, word1, word2)</span>:</span></span><br><span class="line">        res = float(<span class="string">'inf'</span>)</span><br><span class="line">        <span class="keyword">for</span> l1 <span class="keyword">in</span> self.dict[word1]:</span><br><span class="line">            <span class="keyword">for</span> l2 <span class="keyword">in</span> self.dict[word2]:</span><br><span class="line">                res = min(res, abs(l1 - l2))</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><p><strong>【解法2】</strong><br>将上述的时间复杂度$O(M*N)$变成$O(M+N)$<br>使用2个指针记录word1和word2的位置，每次让位置较小的指针加1</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WordDistance</span><span class="params">(object)</span>:</span></span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, words)</span>:</span></span><br><span class="line">        <span class="keyword">from</span> collections <span class="keyword">import</span> defaultdict</span><br><span class="line">        self.words = words</span><br><span class="line">        self.dict= defaultdict(list)</span><br><span class="line">        <span class="keyword">for</span> i, word <span class="keyword">in</span> enumerate(words):</span><br><span class="line">            self.dict[word].append(i)</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">shortest</span><span class="params">(self, word1, word2)</span>:</span></span><br><span class="line">        res = float(<span class="string">'inf'</span>)</span><br><span class="line">        p1,p2 = <span class="number">0</span>,<span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> p1 &lt; len(self.dict[word1]) <span class="keyword">and</span> p2 &lt; len(self.dict[word2]):</span><br><span class="line">            result = min(result,abs(self.dict[word1][p1] - self.dict[word2][p2]))</span><br><span class="line">            <span class="keyword">if</span> self.dict[word1][p1] &lt; self.dict[word2][p2]:</span><br><span class="line">                p1 += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                p2 += <span class="number">2</span></span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure><h2><span id="210-最短单词距离之iii">2.10. 最短单词距离之III</span></h2><p>Given a list of words and two words word1 and word2, return the shortest distance between these two words in the list.</p><p>word1 and word2 may be the same and they represent two individual words in the list.</p><p>Example:<br>Assume that words = [“practice”, “makes”, “perfect”, “coding”, “makes”].</p><p>Input: word1 = “makes”, word2 = “coding”<br>Output: 1<br>Input: word1 = “makes”, word2 = “makes”<br>Output: 3<br>Note:<br>You may assume word1 and word2 are both in the list.<br>对第一道题的区别：word1和word2可能相同</p><p><strong>【解法1】</strong><br>word1和word2可能相等，使用pre_idx1记录上一个idx1的位置。接下来分为2种情况，word1和word2相等时，根据pre_idx1和idx1来更新result，不相等时，根据idx1和idx2来更新result</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">shortestDistance</span><span class="params">(words,word1,word2)</span>:</span></span><br><span class="line">    idx1,idx2 = <span class="number">-1</span>,<span class="number">-1</span></span><br><span class="line">    result = float(<span class="string">"inf"</span>)</span><br><span class="line">    pre_idx1 = <span class="number">-1</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(words)):</span><br><span class="line">        <span class="keyword">if</span> words[i] == word1:</span><br><span class="line">            idx1 = i</span><br><span class="line">        <span class="keyword">if</span> words[i] == word2:</span><br><span class="line">            idx2 = i</span><br><span class="line">        <span class="keyword">if</span> idx1 != <span class="number">-1</span> <span class="keyword">and</span> idx2 != <span class="number">-1</span>:</span><br><span class="line">            <span class="keyword">if</span> word1 == word2:</span><br><span class="line">                <span class="keyword">if</span> pre_idx1 == <span class="number">-1</span> <span class="keyword">or</span> pre_idx1 == idx1:</span><br><span class="line">                    pre_idx1 = idx1</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="comment">#如果pre_idx1和idx1不相等，更新result</span></span><br><span class="line">                    result = min(result,abs(pre_idx1-idx1))</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                result = min(result,abs(idx1-idx2))</span><br><span class="line">    <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">shortestDistance</span><span class="params">(words,word1,word2)</span>:</span></span><br><span class="line">    idx1,idx2 = <span class="number">-1</span>,<span class="number">-1</span></span><br><span class="line">    result = float(<span class="string">"inf"</span>)</span><br><span class="line">    <span class="keyword">if</span> word1 != word2:</span><br><span class="line">        <span class="keyword">if</span> words[i] == word1:</span><br><span class="line">            idx1 = i</span><br><span class="line">        <span class="keyword">if</span> words[i] == word2:</span><br><span class="line">            idx2 = i</span><br><span class="line">        <span class="keyword">if</span> idx1 != <span class="number">-1</span> <span class="keyword">and</span> idx2 != <span class="number">-1</span>:</span><br><span class="line">            result = min(result,abs(idx1-idx2))</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        pre_idx1 = <span class="number">-1</span></span><br><span class="line">        <span class="keyword">for</span> i,word <span class="keyword">in</span> enumerate(words):</span><br><span class="line">            <span class="keyword">if</span> word == word1:</span><br><span class="line">                <span class="keyword">if</span> pre_idx1 != <span class="number">-1</span>:</span><br><span class="line">                    result = min(result,abs(i-pre_idx1))</span><br><span class="line">                pre_idx1 = i</span><br><span class="line">    <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure><h2><span id="211-存在重复元素">2.11. 存在重复元素</span></h2><p>给定一个整数数组，判断是否存在重复元素。</p><p>如果任何值在数组中出现至少两次，函数返回 true。如果数组中每个元素都不相同，则返回 false。</p><blockquote><p>示例 1:<br>输入: [1,2,3,1]<br>输出: true</p></blockquote><p>【我的解法】<br>使用字典</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">containsDuplicate</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        counts = dict()</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> nums:</span><br><span class="line">            <span class="keyword">if</span> i <span class="keyword">not</span> <span class="keyword">in</span> counts:</span><br><span class="line">                counts[i] = <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">False</span></span><br></pre></td></tr></table></figure><h2><span id="212-存在重复元素-ii">2.12. 存在重复元素 II</span></h2><p>给定一个整数数组和一个整数 k，判断数组中是否存在两个不同的索引 i 和 j，使得 nums [i] = nums [j]，并且 i 和 j 的差的 绝对值 至多为 k。</p><blockquote><p>示例 1:<br>输入: nums = [1,2,3,1], k = 3<br>输出: true</p></blockquote><p><strong>【我的解法】</strong><br>首先找到重复的元素，然后再遍历重复元素的下标，其差值是否&lt;=k，时间复杂度高</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">containsNearbyDuplicate</span><span class="params">(self, nums, k)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :type k: int</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="comment">#首先找出重复的元素</span></span><br><span class="line">        counts = collections.defaultdict(list)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums)):</span><br><span class="line">            counts[nums[i]].append(i)</span><br><span class="line">        <span class="keyword">for</span> value <span class="keyword">in</span> list(counts.values()):</span><br><span class="line">            <span class="keyword">if</span> len(value) &gt;= <span class="number">2</span>:</span><br><span class="line">                <span class="comment">#找出下标差最大的值</span></span><br><span class="line">                <span class="keyword">for</span> i <span class="keyword">in</span> range(len(value)):</span><br><span class="line">                    <span class="keyword">for</span> j <span class="keyword">in</span> range(len(value)):</span><br><span class="line">                        <span class="keyword">if</span> i!=j <span class="keyword">and</span> abs(value[i]-value[j]) &lt;= k:</span><br><span class="line">                            <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">False</span></span><br></pre></td></tr></table></figure><p><strong>【改进1】</strong><br>使用集合，集合的长度始终是k，如果集合中的k个元素存在相同元素，则说明这2个元素的距离&lt;=k,返回True。如果集合中没有当前元素，将其加入到set中，判断set中长度是否&gt;k,如果超过k，则将set中的第一个元素删掉。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">containsNearbyDuplicate</span><span class="params">(self, nums, k)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :type k: int</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="comment">#使用一个长度为k的set</span></span><br><span class="line">        k_set = set()</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums)):</span><br><span class="line">            <span class="keyword">if</span> nums[i] <span class="keyword">in</span> k_set:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line"></span><br><span class="line">            k_set.add(nums[i])</span><br><span class="line">            <span class="keyword">if</span> len(k_set) &gt; k:</span><br><span class="line">                k_set.remove(nums[i-k])</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">False</span></span><br></pre></td></tr></table></figure><h2><span id="213-存在重复元素-iii">2.13. 存在重复元素 III</span></h2><p>给定一个整数数组，判断数组中是否有两个不同的索引 i 和 j，使得 nums [i] 和 nums [j] 的差的绝对值最大为 t，并且 i 和 j 之间的差的绝对值最大为 ķ。</p><blockquote><p>示例 1:<br>输入: nums = [1,2,3,1], k = 3, t = 0<br>输出: true</p></blockquote><p><strong>【题解1】</strong><br>找出2个数，其下标之差&lt;=k,数之差&lt;=t<br>将数据放在桶中，每个桶放t+1个数，假设t=2<br>桶编号-1: [-3,-2,-1]<br>桶编号0：[0,1,2]<br>桶编号1：[3,4,5]<br>桶编号2：[6,7,8]<br>桶编号i：[i<em>(t+1),i</em>(t+1)+1,i*(t+1)+2]<br>首先编写一个分配桶的函数，根据数字i，计算被分配到哪个桶中。<br>dict中最多有k+1个元素，看做滑动窗口，保证元素下标之差&lt;=k。如果i&gt;k，说明当前滑动窗口中已经有k+1个元素了，装不下了，则将第一个元素nums[i-k-1]所在的桶清空，腾出一个位置。<br>dict[key]=value，其中key是桶id，value是nums中的值。</p><ul><li>如果2个元素的桶id一样，说明这2个值之差&lt;=t，返回True</li><li>如果该元素所在的桶没有其他值，那就看和它左右邻近的桶，看差值是否&lt;=t,如果是返回True</li><li>如果自己的桶和邻居桶都没有符合条件，则将该元素放在自己的桶内</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">containsNearbyAlmostDuplicate</span><span class="params">(self, nums, k, t)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :type k: int</span></span><br><span class="line"><span class="string">        :type t: int</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> t &lt; <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">        <span class="comment">#滑动窗口中有k+1个元素</span></span><br><span class="line">        <span class="comment">#每个桶中有t+1个元素</span></span><br><span class="line">        buckets = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums)):</span><br><span class="line">            <span class="keyword">if</span> i &gt; k:</span><br><span class="line">                buckets.pop(self.getBucket(nums[i-k<span class="number">-1</span>],t+<span class="number">1</span>))</span><br><span class="line"></span><br><span class="line">            cur_id = self.getBucket(nums[i],t+<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> cur_id <span class="keyword">in</span> buckets:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">            <span class="keyword">elif</span> cur_id+<span class="number">1</span> <span class="keyword">in</span> buckets <span class="keyword">and</span> abs(buckets[cur_id+<span class="number">1</span>] - nums[i]) &lt;= t:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">            <span class="keyword">elif</span> cur_id<span class="number">-1</span> <span class="keyword">in</span> buckets <span class="keyword">and</span> abs(buckets[cur_id<span class="number">-1</span>] - nums[i]) &lt;= t:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                buckets[cur_id] = nums[i]</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getBucket</span><span class="params">(self,x,w)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        一个桶中有w个数</span></span><br><span class="line"><span class="string">        返回数字x被分配的桶编号</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> x &gt; <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> int(x/w)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> (x+<span class="number">1</span>)/w<span class="number">-1</span></span><br></pre></td></tr></table></figure><h2><span id="214-跳跃游戏">2.14. 跳跃游戏</span></h2><p>给定一个非负整数数组，你最初位于数组的第一个位置。<br>数组中的每个元素代表你在该位置可以跳跃的最大长度。<br>判断你是否能够到达最后一个位置。</p><blockquote><p>示例 1:<br>输入: [2,3,1,1,4]<br>输出: true<br>解释: 我们可以先跳 1 步，从位置 0 到达 位置 1, 然后再从位置 1 跳 3 步到达最后一个位置</p><p>示例 2:<br>输入: [3,2,1,0,4]<br>输出: false<br>解释: 无论怎样，你总会到达索引为 3 的位置。但该位置的最大跳跃长度是 0 ， 所以你永远不可能到达最后一个位置。</p></blockquote><p>【题解1】<br>i表示当前节点，k表示当前节点的前面所有节点能达到的最远节点。<br>例如[3,2,1,0,4]</p><ul><li>k=0，i=0：当前节点i=0，前面能到达的最远节点下标为0</li><li>k=3，i=1：当前节点i=1，前面能到达的最远节点下标为3</li><li>k=3，i=2：当前节点i=2，前面能到达的最远节点下标为3</li><li>k=3，i=3：当前节点i=3，前面能到达的最远节点下标为3</li><li>k=3，i=4：当前节点i=4，前面能到达的最远节点下标为3</li><li>当前节点为4，但是前面的节点最远只能到达下标为3的位置，说明i=4达不到，即返回false</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">canJump</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        k = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums)):</span><br><span class="line">            <span class="keyword">if</span> i &gt; k:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">            k = max(k,i+nums[i])<span class="comment">#更新节点[0,i]能到达的最远节点</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">True</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近要开始准备刷Leetcode了，在这里记录下刷题的心得&lt;/p&gt;
    
    </summary>
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>argparse不支持bool类型</title>
    <link href="http://yoursite.com/2020/03/09/argparse%E4%B8%8D%E6%94%AF%E6%8C%81bool%E7%B1%BB%E5%9E%8B/"/>
    <id>http://yoursite.com/2020/03/09/argparse不支持bool类型/</id>
    <published>2020-03-09T08:28:29.000Z</published>
    <updated>2020-03-09T08:57:46.605Z</updated>
    
    <content type="html"><![CDATA[<p>在Python中通过下列方式向程序传递bool参数时，其中<code>neg</code>参数指定类型为bool，但是无论传入的值是什么，<code>neg</code>始终为<code>True</code></p><p>解决方法：<br><a href="https://blog.csdn.net/yaokai_assultmaster/article/details/77928629" target="_blank" rel="noopener">使用Python中的argparse从命令行接收boolean类型的参数</a><br><a id="more"></a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">parser = argparse.ArgumentParser()</span><br><span class="line">parser.add_argument(<span class="string">"--config"</span>, type=str, help=<span class="string">'configuration file'</span>)</span><br><span class="line">parser.add_argument(<span class="string">"--gpus"</span>, type=str,help=<span class="string">"test program"</span>)<span class="comment">#如果</span></span><br><span class="line">parser.add_argument(<span class="string">"--neg"</span>, type=bool, help=<span class="string">"test program"</span>)</span><br><span class="line">parser.add_argument(<span class="string">"--test"</span>, action=<span class="string">"store_true"</span>, help=<span class="string">"test program"</span>)</span><br></pre></td></tr></table></figure><p>【注意】类似于上文中<code>gpus</code>这种参数，指定也可以，不指定也可以</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在Python中通过下列方式向程序传递bool参数时，其中&lt;code&gt;neg&lt;/code&gt;参数指定类型为bool，但是无论传入的值是什么，&lt;code&gt;neg&lt;/code&gt;始终为&lt;code&gt;True&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;解决方法：&lt;br&gt;&lt;a href=&quot;https://blog.csdn.net/yaokai_assultmaster/article/details/77928629&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;使用Python中的argparse从命令行接收boolean类型的参数&lt;/a&gt;&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Python" scheme="http://yoursite.com/categories/Python/"/>
    
    
      <category term="Python" scheme="http://yoursite.com/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>深度学习优秀代码示例</title>
    <link href="http://yoursite.com/2020/03/03/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E4%BC%98%E7%A7%80%E4%BB%A3%E7%A0%81%E7%A4%BA%E4%BE%8B/"/>
    <id>http://yoursite.com/2020/03/03/深度学习优秀代码示例/</id>
    <published>2020-03-03T03:30:18.000Z</published>
    <updated>2020-03-07T05:14:24.731Z</updated>
    
    <content type="html"><![CDATA[<p>&ensp;&ensp;&ensp;&ensp;曾经一段时间很苦恼，对于深度学习算法不知道怎么上手，看了很多深度学习教程，依然不会写。后来就看论文公开的源代码，对照着论文模型，一点点看，多看几篇代码，逐渐有种开窍的感觉。其次是看Mxnet和Pytorch的源代码(我主要用这2个框架)，Mxnet和Pytorch的Github上给了很多示例代码，写的非常规范，从中可以学到用法，从而也可以规范自己的代码。<br>&ensp;&ensp;&ensp;&ensp;下面整理一下，在我学习过程中，对我帮助很大的教程和代码。</p><a id="more"></a><ol><li><a href="http://zh.gluon.ai/" target="_blank" rel="noopener">《动手学深度学习》Mxnet版</a><br>Mxnet的入门教程，沐神写的，来来回回看了2~3遍，每次看都有新的收货</li><li><a href="https://tangshusen.me/Dive-into-DL-PyTorch/#/" target="_blank" rel="noopener">《动手学深度学习》Pytorch版</a><br>将Mxnet改写为Pytorch版本，非常好的Pytorch入门教程</li><li><a href="https://github.com/Davidham3/ASTGCN" target="_blank" rel="noopener">ASTGCN</a><br>AAAI2019论文公开代码，用Mxnet写的</li><li><a href="https://yjucho1.github.io/spatio-temporal%20data/deep%20learning%20paper/ST-resnet/" target="_blank" rel="noopener">ST-ResNet</a><br>AAAI2017论文公开代码，用Keras，看这篇代码主要是学习模型架构，然后自己用mxnet复现了一下</li><li><a href="https://github.com/panzheyi/ST-MetaNet" target="_blank" rel="noopener">ST-MetaNet</a><br>KDD2019论文公开代码，用Mxnet写的，学到了很多高级用法，例如EarlyStopping，Encoder和Decoder，getattr，DGL</li><li><p><a href="https://github.com/pytorch/examples/tree/master/word_language_model" target="_blank" rel="noopener">Pytorch Transformer</a><br>学习怎么使用Transformer，Dropout和BN在训练和测试的不同，PositionEmbedding，getattr等用法。学习Transformer最好去看Pytorch关于Tranformer的源代码。</p></li><li><p><a href="https://github.com/pytorch/examples" target="_blank" rel="noopener">Pytorch示例代码</a><br>Pytorch Github中的示例代码</p></li><li><a href="https://github.com/apache/incubator-mxnet/tree/master/example" target="_blank" rel="noopener">Mxnet示例代码</a><br>Mxnet Github中的示例代码</li></ol><p>觉得自己最大的变化是喜欢去读源代码了，遇到问题去官网看教程，读源码，帮助很大。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;ensp;&amp;ensp;&amp;ensp;&amp;ensp;曾经一段时间很苦恼，对于深度学习算法不知道怎么上手，看了很多深度学习教程，依然不会写。后来就看论文公开的源代码，对照着论文模型，一点点看，多看几篇代码，逐渐有种开窍的感觉。其次是看Mxnet和Pytorch的源代码(我主要用这2个框架)，Mxnet和Pytorch的Github上给了很多示例代码，写的非常规范，从中可以学到用法，从而也可以规范自己的代码。&lt;br&gt;&amp;ensp;&amp;ensp;&amp;ensp;&amp;ensp;下面整理一下，在我学习过程中，对我帮助很大的教程和代码。&lt;/p&gt;
    
    </summary>
    
      <category term="Deep Learning" scheme="http://yoursite.com/categories/Deep-Learning/"/>
    
    
      <category term="Mxnet" scheme="http://yoursite.com/tags/Mxnet/"/>
    
      <category term="Pyotrch" scheme="http://yoursite.com/tags/Pyotrch/"/>
    
  </entry>
  
  <entry>
    <title>时空论文阅读笔记</title>
    <link href="http://yoursite.com/2020/02/27/%E6%97%B6%E7%A9%BA%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/2020/02/27/时空论文阅读笔记/</id>
    <published>2020-02-27T12:03:53.000Z</published>
    <updated>2020-05-01T14:39:49.897Z</updated>
    
    <content type="html"><![CDATA[<p>因为疫情推迟开学，在家把以前看的论文又看了一遍，每重新看一次都有新的收获，在此整理下。</p><a id="more"></a><!-- TOC --><ul><li><a href="#1-%e6%b5%81%e9%87%8f%e9%80%9f%e5%ba%a6%e9%a2%84%e6%b5%8b">1. 流量/速度预测</a><ul><li><a href="#11-deep-spatio-temporal-residual-networks-for-citywide-crowd-flows-predictionaaai2017">1.1. Deep Spatio-Temporal Residual Networks for Citywide Crowd Flows Prediction(AAAI2017)</a></li><li><a href="#12-deepstn-context-aware-spatial-temporal-neural-network-for-crowd-flow-prediction-in-metropolisaaai2019">1.2. DeepSTN+: Context-aware Spatial-Temporal Neural Network for Crowd Flow Prediction in Metropolis(AAAI2019)</a></li><li><a href="#13-urbanfm-inferring-fine-grained-urban-flowskdd2019">1.3. UrbanFM: Inferring Fine-Grained Urban Flows(KDD2019)</a></li><li><a href="#14-attention-based-spatial-temporal-graph-convolutional-networks-for-traffic-flow-forecastingaaai2019">1.4. Attention Based Spatial-Temporal Graph Convolutional Networks for Traffic Flow Forecasting(AAAI2019)</a></li><li><a href="#15-spatial-temporal-synchronous-graph-convolutional-networks-a-new-framework-for-spatial-temporal-network-data-forecastingaaai2020">1.5. Spatial-Temporal Synchronous Graph Convolutional Networks: A New Framework for Spatial-Temporal Network Data Forecasting(AAAI2020)</a></li><li><a href="#16-hyperst-net-hypernetworks-for-spatio-temporal-forecasting2019aaai">1.6. HyperST-Net: Hypernetworks for Spatio-Temporal Forecasting(2019AAAI)</a></li><li><a href="#17-urban-traffic-prediction-from-spatio-temporal-data-using-deep-meta-learning2019kdd">1.7. Urban Traffic Prediction from Spatio-Temporal Data Using Deep Meta Learning(2019KDD)</a></li><li><a href="#18-stepdeep-a-novel-spatial-temporal-mobility-event-prediction-framework-based-on-deep-neural-networkkdd2018">1.8. StepDeep: A Novel Spatial-temporal Mobility Event Prediction Framework based on Deep Neural Network(KDD2018)</a></li><li><a href="#19-stgrat-a-spatio-temporal-graph-attention-network-for-traffic-forecastingaaai2020">1.9. STGRAT: A Spatio-Temporal Graph Attention Network for Traffic Forecasting(AAAI2020)</a></li></ul></li><li><a href="#2-eta%e9%a2%84%e6%b5%8b">2. ETA预测</a><ul><li><a href="#21-when-will-you-arrive-estimating-travel-time-based-on-deep-neural-networksaaai20">2.1. When Will You Arrive? Estimating Travel Time Based on Deep Neural Networks(AAAI20)</a></li></ul></li><li><a href="#3-%e5%87%ba%e7%a7%9f%e8%bd%a6%e9%9c%80%e6%b1%82%e9%a2%84%e6%b5%8b">3. 出租车需求预测</a><ul><li><a href="#31-deep-multi-view-spatial-temporal-network-for-taxi-demand-predictionaaai2018">3.1. Deep Multi-View Spatial-Temporal Network for Taxi Demand Prediction(AAAI2018)</a></li><li><a href="#32-revisiting-spatial-temporal-similarity-a-deep-learning-framework-for-traffic-predictionaaai2019">3.2. Revisiting Spatial-Temporal Similarity: A Deep Learning Framework for Traffic Prediction(AAAI2019)</a></li><li><a href="#33-spatiotemporal-multi-graph-convolution-network-for-ride-hailing-demand-forecastingaaai2019">3.3. Spatiotemporal Multi-Graph Convolution Network for Ride-hailing Demand Forecasting(AAAI2019)</a></li><li><a href="#34-passenger-demand-forecasting-with-multi-task-convolutional-recurrent-neural-networkspakdd2019">3.4. Passenger Demand Forecasting with Multi-Task Convolutional Recurrent Neural Networks(PAKDD2019)</a></li><li><a href="#35-stg2seq-spatial-temporal-graph-to-sequence-model-for-multi-step-passenger-demand-forecasting2019ijcai">3.5. STG2Seq: Spatial-temporal Graph to Sequence Model for Multi-step Passenger Demand Forecasting(2019IJCAI)</a></li></ul></li><li><a href="#4-%e6%97%b6%e9%97%b4%e5%ba%8f%e5%88%97%e9%a2%84%e6%b5%8b">4. 时间序列预测</a><ul><li><a href="#41-restful-resolution-aware-forecasting-of-behavioral-time-series-data2018cikm">4.1. RESTFul: Resolution-Aware Forecasting of Behavioral Time Series Data(2018CIKM)</a></li><li><a href="#42-multi-horizon-time-series-forecasting-with-temporal-attention-learningkdd2019">4.2. Multi-Horizon Time Series Forecasting with Temporal Attention Learning(KDD2019)</a></li></ul></li><li><a href="#5-%e6%80%bb%e7%bb%93">5. 总结</a><ul><li><a href="#51-%e6%a0%b9%e6%8d%ae%e7%bd%91%e6%a0%bc%e6%9e%84%e5%bb%ba%e5%9b%be">5.1. 根据网格构建图</a></li><li><a href="#52-%e5%8a%a8%e6%80%81%e5%9b%be">5.2. 动态图</a></li><li><a href="#53-%e8%ae%a1%e7%ae%972%e4%b8%aa%e5%8c%ba%e5%9f%9f%e7%9a%84%e7%9b%b8%e4%bc%bc%e6%80%a7">5.3. 计算2个区域的相似性</a></li><li><a href="#54-poi">5.4. POI</a></li><li><a href="#55-%e6%97%b6%e9%97%b4">5.5. 时间</a></li><li><a href="#56-lstm%e5%85%b1t%e4%b8%aa%e9%9a%90%e8%97%8f%e7%8a%b6%e6%80%81%e6%95%b4%e5%90%88">5.6. LSTM共T个隐藏状态整合</a></li><li><a href="#57-%e5%a4%96%e9%83%a8%e5%9b%a0%e7%b4%a0%e5%b5%8c%e5%85%a5">5.7. 外部因素嵌入</a></li><li><a href="#58-mask">5.8. mask</a></li><li><a href="#59-max-min%e5%bd%92%e4%b8%80%e5%8c%96">5.9. Max-min归一化</a></li></ul></li></ul><!-- /TOC --><h1><span id="1-流量速度预测">1. 流量/速度预测</span></h1><h2><span id="11-deep-spatio-temporal-residual-networks-for-citywide-crowd-flows-predictionaaai2017">1.1. Deep Spatio-Temporal Residual Networks for Citywide Crowd Flows Prediction(AAAI2017)</span></h2><blockquote><p>张钧波(京东)<br>郑宇(京东)<br><a href="https://github.com/lucktroy/DeepST" target="_blank" rel="noopener">https://github.com/lucktroy/DeepST</a> Keras</p></blockquote><ul><li>给定所有区域历史T个时间段的inflow和outflow，预测下一个时间段所有区域的inflow和outflow</li></ul><p><img src="/2020/02/27/时空论文阅读笔记/ST-ResNet.png" alt=""></p><ul><li>每个时间段所有区域的输入是$I<em>J</em>2$,将输入分为recent，daily，weekly周期，预测第t个时间段的infow和outflow：<ul><li>recent：当天前r个时间段</li><li>daily：前d天该时间段</li><li>weekly：前w周该天该时间段</li></ul></li><li>外部特征包括：天气，节假日，dayOfWeek。用2层FCN对外部特征进行嵌入，第一层FCN作为嵌入层，第二层FCN转换维度和$X_{Res}$一致。</li><li>在融合阶段，先将3个时间周期的输出融合，再和外部因素拼接。</li><li>数据集：北京出租车和NYC自行车流量</li><li>将flow使用Max-Min归一化到[-1,1]，FCN最后一层使用tanh激活函数</li></ul><h2><span id="12-deepstn-context-aware-spatial-temporal-neural-network-for-crowd-flow-prediction-in-metropolisaaai2019">1.2. DeepSTN+: Context-aware Spatial-Temporal Neural Network for Crowd Flow Prediction in Metropolis(AAAI2019)</span></h2><blockquote><p>Ziqian Lin(清华大学)<br>Jie Feng(清华大学)<br>Ziyang Lu(清华大学)<br>Yong Li(清华大学)<br>Depeng Jin(清华大学)<br><a href="https://github.com/FIBLAB/DeepSTN" target="_blank" rel="noopener">https://github.com/FIBLAB/DeepSTN</a>  Keras</p></blockquote><ul><li>crowd flow预测是给定历史T个时间段，预测区域的inflow和outflow</li><li>现有研究的缺点：<ul><li>不能捕获长距离空间依赖</li><li>忽略区域功能对人流的影响(POI)</li></ul></li><li>提出DeeoSTN+，有3个组件<ul><li>ConvPlus：解决长距离区域的空间依赖</li><li>SemanticPlus：解决区域POI对人流的影响</li><li>early-fusuion模块</li></ul></li></ul><p><img src="/2020/02/27/时空论文阅读笔记/DeepSTN+.png" alt=""></p><ul><li><p>假设预测周四第5个时间段的flow，输入的数据有：</p><ul><li>recent：周四2,3,4个时间段</li><li>day：周一，周二，周三第5个时间段</li><li>week：上上上周四，上上周四，上周四第5个时间段</li><li>time：周四第5个时间段的时间向量</li><li>poi：(C,W,H)所有区域的poi信息</li></ul></li><li>【<strong>ConvPlus</strong>】传统的Conv中kernel的大小远小于网格大小，通常是$3 \times 3$,然后在人流量预测中通常有一些长距离的依赖，例如人们去很远的地方上班。在ConvPlus中，假设原始输入维度是(C,W,H),其中plus维用来捕获长距离依赖<ul><li>正常Conv2D：将原始输入(C,W,H)输入到正常Conv2D中,卷积核有C-plus个，输出维度(C-plus,W,H)，</li><li>ConvPlus：再将原始(C,W,H)输入到ConvPlus中，卷积核有plus<em>W\</em>H个，卷积大小为W*H,则输出维度(plus*W*H,1,1),reshape为(plus,W,H)</li><li>将上面2个卷积的输出拼接成(C,W,H)</li></ul></li><li><strong>计算POI在时间上的分布权重</strong><ul><li>POI维度$C \times W \times H$,表示每个网格有C类POI</li><li>时间维度$T \times W \times H$，T=24+7, 首先对时间进行嵌入，通过2D卷积，将31个数变成一个数$1 \times W \times H$，然后将时间repeat成$C \times W \times H$</li><li>时间和POI逐元素相乘，得到$C \times W \times H$</li><li>如果需要，还可以再通过K个2D卷积，变成$K \times W \times H$</li><li>将该张量和3个周期的输出在通道维上拼接。</li></ul></li><li>crowd flow使用Max-Min归一化到[-1,1]，最后一层使用Tanh，范围[-1,1]</li><li>POI使用Max-Min归一化到[0,1]</li></ul><h2><span id="13-urbanfm-inferring-fine-grained-urban-flowskdd2019">1.3. UrbanFM: Inferring Fine-Grained Urban Flows(KDD2019)</span></h2><blockquote><p>Yuxuan Liang(XiDian)<br>Kun Ouyang(新加坡国立)<br>张钧波(京东)<br>郑宇(京东)<br><a href="https://github.com/yoshall/UrbanFM" target="_blank" rel="noopener">https://github.com/yoshall/UrbanFM</a></p></blockquote><ul><li>基于粗粒度级的flow，实时推测整个城市细粒度级的flow，提出模型<strong>Urban</strong> <strong>F</strong>low <strong>M</strong>agnifier (<strong>UrbanFM</strong>)</li><li>有2个挑战：粗粒度和细粒度的flow在空间上的相关性、复杂的外部因素。</li></ul><p><img src="/2020/02/27/时空论文阅读笔记/UrbanFM1.png" alt=""></p><p><img src="/2020/02/27/时空论文阅读笔记/UrbanFM.png" alt=""></p><h2><span id="14-attention-based-spatial-temporal-graph-convolutional-networks-for-traffic-flow-forecastingaaai2019">1.4. Attention Based Spatial-Temporal Graph Convolutional Networks for Traffic Flow Forecasting(AAAI2019)</span></h2><blockquote><p>郭晟楠(北京交通大学)<br>冯宁(北京交通大学)<br>宋超(北京交通大学)<br>万怀宇(北京交通大学)<br><a href="https://github.com/Davidham3/ASTGCN" target="_blank" rel="noopener">https://github.com/Davidham3/ASTGCN</a> Mxnet</p></blockquote><p>根据所有节点历史T个时间段traffic flow，occupy，speed，预测所有节点未来T_p个时间段的traffic flow。</p><p><img src="/2020/02/27/时空论文阅读笔记/ASTGCN.png" alt=""></p><ul><li>三个独立的组件，分别对recent，daily，weekly周期进行建模</li><li>比如说预测6.14 8:00-8:55的flow，传入的样本是<br>时：6.14号6:00~7:55（前2个小时）的数据，<br>天：6.13和6.12（前2天）的8:00-8:55，<br>周：上周6.17，上上周5.31（前2周）的8:00-8:55</li></ul><h2><span id="15-spatial-temporal-synchronous-graph-convolutional-networks-a-new-framework-for-spatial-temporal-network-data-forecastingaaai2020">1.5. Spatial-Temporal Synchronous Graph Convolutional Networks: A New Framework for Spatial-Temporal Network Data Forecasting(AAAI2020)</span></h2><blockquote><p>宋超(北京交通大学)<br>郭晟楠(北京交通大学)<br>万怀宇(北京交通大学)<br><a href="https://github.com/Davidham3/STSGCN" target="_blank" rel="noopener">https://github.com/Davidham3/STSGCN</a> Mxnet</p></blockquote><ul><li>给定所有节点历史T个时间段的车流量，预测所有节点未来$T’$个时间段的车流量，</li><li>原先的研究通常使用分开的组件捕获时间和空间的相关性，并且忽略了时空数据的异构性。</li><li>提出<strong>S</strong>patial-<strong>T</strong>emporal <strong>S</strong>ynchronous <strong>G</strong>raph <strong>C</strong>onvolutional <strong>N</strong>etworks (<strong>STSGCN</strong>)</li><li><strong>对于图中的每个节点，它的影响范围有3种</strong>，这是该文章提出的一个新观点，以前的研究中通常只考虑前2种。</li></ul><p><img src="/2020/02/27/时空论文阅读笔记/STSGCN1.png" alt=""></p><ul><li>本文强调的内容有2点：<ul><li>局部的时空关系，称作localized spatial-temporal correlations</li><li>时空数据的异质性，居住区和商业区，早上和晚上</li></ul></li><li><strong>使用连续3个时间步的图数据来构建localized spatial-temporal graph，local指的是在时间上局部</strong><br>假设原先一个图中有N个节点，图信号矩阵为$N \times C$,邻接矩阵为$N \times N$，现在3个图来构建一个局部时空图，图信号矩阵为$3N \times C$,邻接矩阵为$3N \times 3N$,邻接矩阵中非0即1</li></ul><p><img src="/2020/02/27/时空论文阅读笔记/STSGCN2.png" alt=""></p><ul><li>但是把3个图构成1个图失去了图之间的时间关系，模型可能会认为这是一个有3N个节点在一个时间步的信息，为了区域这3个图的时间关系，受ConvS2S启发，为时空网络序列$N \times C \times T$添加位置嵌入，增加时间嵌入矩阵$C \times T$,空间嵌入矩阵$N \times C$,这2个矩阵是通过模型学习的，当模型训练好之后，这2个矩阵可以包含图的时间和空间信息。然后把这2个嵌入矩阵和原始的图信号矩阵相加，这样图中就包含了时间和位置信息。</li></ul><p><img src="/2020/02/27/时空论文阅读笔记/STSGCN.png" alt=""></p><ul><li>图中模型框架：多个STSGCM构成STSGCL，多个STSGCL构成STSGCN。STSGCN就是多层图卷积，从局部时空图中捕获邻居信息。STSGCL一层中有多个STSGCM，一个样本中每个时间段的局部时空图都用一个STSGCM来建模。</li><li><strong>第一个FCN成将输入转换到高维空间，提高模型的表示能力</strong></li><li>【<strong>STSGCM</strong>】中包含多层图卷积，使用GLU作为激活函数，其中sigmoid作为门控机制，控制哪个节点的信息可以流入到下一层。<strong>图卷积计算定义在顶点域，意味着不需要计算图的拉普拉斯矩阵</strong><br><img src="/2020/02/27/时空论文阅读笔记/STSGCN3.png" alt=""><br>STSGCM的架构如下：参考JK-net，一共有L个图卷积层，每一层的输出都输入到AGG层中，AGG层将接收到的L个输出进行max聚合，最终得到一个输出$3N \times C_{out}$,然后进行裁剪，将前中后3个时间步的数据只保留中间时间步，即$N \times C_out$<br><img src="/2020/02/27/时空论文阅读笔记/STSGCN4.png" alt=""></li><li>【<strong>STSGCL</strong>】多个STSGCM组成一个STSGCL层，其输入维度$T \times N \times C$,使用滑动窗口每次取3个时间段段的图构成$3N \times C$,一共构成$T-2$个局部时空图，然后需要$T-2$个STSGCM，最终输出$T-2个N \times C_{out}$，将其拼接为$(T-2) \times N \times C_{out}$，再输入到下一个STSGCL中。<strong>【注意】每个局部时空图是通过滑动窗口获得，每个时空局部图的邻接矩阵是不变的，而不是提前处理好局部图输入到模型中，这样会省空间</strong></li><li>上面使用的邻接矩阵$3N \times 3N$中的值非0即1，每个邻居聚合的权重相等，聚合能力会受到限制，这里对此做出改进，将邻接矩阵乘上一个Mask矩阵，对每个邻居赋予不同的权重，其中Mask矩阵是可学习参数，维度$3N \times 3N$<script type="math/tex; mode=display">A_{\text {adjusted}}^{\prime}=W_{\text {mask}} \otimes A^{\prime} \in \mathbb{R}^{3 N \times 3 N}</script></li><li>最后的FCN将STSGCL的输出转换成预测的格式。STSGCL的输出格式为$T \times N \times C$,reshape成$N \times TC$,然后使用$T’$个2层全连接，每个全连接输出维度为$(N,1)$,然后将$T’$个全连接的输出拼接成$N \times T’$</li><li><strong>损失函数使用Huber Loss，对异常值不敏感</strong><script type="math/tex; mode=display">L(Y, \hat{Y})=\left\{\begin{array}{ll}\frac{1}{2}(Y-\hat{Y})^{2} & |Y-\hat{Y}| \leq \delta \\\delta|Y-\hat{Y}|-\frac{1}{2} \delta^{2} & \text { otherwise }\end{array}\right.</script></li><li>使用mean-std归一化，训练集:验证集:测试集=6:2:2，模型包含4个STSGCL，每个STSGCM包含3个图卷积</li></ul><h2><span id="16-hyperst-net-hypernetworks-for-spatio-temporal-forecasting2019aaai">1.6. HyperST-Net: Hypernetworks for Spatio-Temporal Forecasting(2019AAAI)</span></h2><blockquote><p>潘哲逸(上海交通大学)<br>梁宇轩(西安电子科技大学)<br>张钧波(京东)<br>易修文(京东)<br>郑宇(京东)</p></blockquote><p>论文声称第一个考虑<strong>空间和时间内在因果关系</strong>的深度框架。</p><p><img src="/2020/02/27/时空论文阅读笔记/HyperST_Net.png" alt=""></p><ul><li>该论文提出的只是一个HyperNetwork框架，并不是一个具体的模型。</li><li><strong>HyperNetwork</strong>：和以往不同，以前都是一个网络的输出，输入到下一个网络中，<strong>超网络是一个网络的输出作为另一个网络的参数</strong>。</li><li>该模型有3个模块：空间模块，时间模块，推理模块。将空间模块的输出经过推理模块，得到的输出作为时间模块的权重参数，以此捕获时间和空间的内在因果关系。</li><li>这只是一个框架，可以变换成多种模型。在空间模块中如果使用全连接就是HyperST-Dense，使用卷积就是HyperST-Conv。</li></ul><h2><span id="17-urban-traffic-prediction-from-spatio-temporal-data-using-deep-meta-learning2019kdd">1.7. Urban Traffic Prediction from Spatio-Temporal Data Using Deep Meta Learning(2019KDD)</span></h2><blockquote><p>潘哲逸(上海交通大学)<br>梁宇轩(西安电子科技大学)<br>张钧波(京东)<br>郑宇(京东)<br><a href="https://github.com/panzheyi/ST-MetaNet" target="_blank" rel="noopener">https://github.com/panzheyi/ST-MetaNet</a> Mxnet</p></blockquote><ul><li>使用图中所有节点历史T个时间段的flow或speed，预测所有节点未来</li></ul><p><img src="/2020/02/27/时空论文阅读笔记/ST-MetaNet.png" alt=""></p><p><img src="/2020/02/27/时空论文阅读笔记/ST-MetaNet1.png" alt=""></p><p><img src="/2020/02/27/时空论文阅读笔记/ST-MetaNet2.png" alt=""></p><ul><li>本论文用的图，但是实验中有一个$I \times J$的网格数据，将网格数据构建成图</li><li>本论文来表示1张图有2个矩阵：图信号矩阵(N,D)和边特征矩阵(N,N,C)。对于网格数据来说，图信号矩阵表示每个网格POI个数，道路个数。边特征表示2个两个网格的道路个数。这都是静态数据，不随着时间变化。</li></ul><p>【总结】发现上面这2个论文都是一个网络生成另一个网络的参数，查阅资料发现这叫做<code>meta-learning</code>，先记录一下以后再自己看<br><img src="/2020/02/27/时空论文阅读笔记/Meta-learning.png" alt=""></p><h2><span id="18-stepdeep-a-novel-spatial-temporal-mobility-event-prediction-framework-based-on-deep-neural-networkkdd2018">1.8. StepDeep: A Novel Spatial-temporal Mobility Event Prediction Framework based on Deep Neural Network(KDD2018)</span></h2><blockquote><p>Bilong Shen(清华大学)<br>梁晓丹(卡耐基梅隆)</p></blockquote><ul><li><strong>S</strong>patial-<strong>T</strong>emporal mobility <strong>E</strong>vent <strong>P</strong>rediction framework based on <strong>Deep</strong> neural network (<strong>StepDeep</strong>)同时考虑时间和空间模式，给定所有区域历史T个时间段的出租车流量和外部因素，预测所有区域在下一个时间段出租车的inflow和outflow。</li><li>网格区域中的flow随时间变化，可以看做一个视频(T,C,W,H)，进而看做是视频预测任务</li><li>数据集NYC出租车轨迹数据，将NYC网格划分，计算每个区域的inflow和outflow，</li></ul><p><img src="/2020/02/27/时空论文阅读笔记/StepDeep.png" alt=""></p><p><img src="/2020/02/27/时空论文阅读笔记/StepDeep1.png" alt=""></p><ul><li>提出3种卷积：时间卷积，空间卷积，时空卷积。将输入(T,C,H,W)输入到以上7层卷积中，最终输出(C,H,W)表示下一个时间段所有区域的inflow和outflow，</li></ul><h2><span id="19-stgrat-a-spatio-temporal-graph-attention-network-for-traffic-forecastingaaai2020">1.9. STGRAT: A Spatio-Temporal Graph Attention Network for Traffic Forecasting(AAAI2020)</span></h2><blockquote><p>Cheonbok Park(韩国大学)<br>Chunggi Lee(韩国大学)<br>Hyojin Bahng(韩国大学)</p></blockquote><ul><li>根据所有节点历史T个时间段的交通速度，预测所有节点未来T个时间段的交通速度(T=12)，时间多预测多，Seq2Seq架构</li></ul><p><img src="/2020/02/27/时空论文阅读笔记/STGRAT.png" alt=""></p><ul><li>Encoder layer中有3个sublayer：空间Attention层，时间Attention层和point-wise FCN。<ul><li>空间Attention：关注每个时间步上空间邻近的节点</li><li>时间Attention：关注单个节点，输入时间序列的不同时间步</li></ul></li><li>整个Encoder = 1个嵌入层 + 4个Encoder layer，使用LINE对图节点进行嵌入</li></ul><p><img src="/2020/02/27/时空论文阅读笔记/STGRAT1.png" alt=""></p><ul><li>空间Attention层：参考Transformer，中心结点作为query，其邻居作为key和value，计算每个节点新的表示。</li><li>时间Attention==Transformer，输入维度(batch_size,T,N,D),计算时间步之间的attention分数，输出维度(batch_size,T,N,D)</li><li>Point-wise FFN和Transformer中一样，使用2层FCN，中间使用GELU激活函数，Transformer使用的是ReLU激活函数。</li><li>Decoder layer有4个sublayer：空间Attention层，mask时间Attention层，Encoder-Decoder Attention层，point-wise FFN层。整个Decoder层=1个嵌入层+4个Decoder层。</li><li><strong>本模型比Transformer多了一个空间Attention层，其余都一样，因为时间Attention层、FFN和Transformer的一样</strong></li></ul><h1><span id="2-eta预测">2. ETA预测</span></h1><h2><span id="21-when-will-you-arrive-estimating-travel-time-based-on-deep-neural-networksaaai20">2.1. When Will You Arrive? Estimating Travel Time Based on Deep Neural Networks(AAAI20)</span></h2><blockquote><p>王东(杜克大学)<br>张钧波(京东)<br>郑宇(京东)<br><a href="https://github.com/UrbComp/DeepTTE" target="_blank" rel="noopener">https://github.com/UrbComp/DeepTTE</a> Pytorch</p><ul><li>端到端<strong>Deep</strong> learning framework for <strong>T</strong>ravel <strong>T</strong>ime <strong>E</strong>stimation(<strong>DeepTTE</strong>)，给定路径P和外部因素(weather，day of week，开始时间)预测整个path的时间</li><li>原先的工作都是预测travel中单个路段的耗时，然后再把每个路段的时间加起来，缺点是没有考虑到道路交叉口，红绿灯等影响，错误累积</li></ul></blockquote><p><img src="/2020/02/27/时空论文阅读笔记/DeepTTE.png" alt=""></p><ul><li>DeepTTE提出geo-convolution，将地理信息加入到传统Conv中，捕获空间相关性</li><li>多任务学习，同时预测local path和entir path的时间，在loss中限制2者的权重</li><li><strong>在生成测试数据时，将历史轨迹点中的时间戳都去掉</strong>(因为要预测出行时间，所以测试数据不能带有事件信息)，从轨迹中抽样等距离的点组成路径P</li><li><p>DeepTTE一共有3个组件</p><ul><li>Attribute组件：外部因素：天气(one-hot)，司机ID(one-hot)，weekID和timeID(one-hot)，都是类别值，不能直接输入到网络中，需要先嵌入层低维向量，参考<a href="https://arxiv.org/abs/1512.05287" target="_blank" rel="noopener">(2016NIPS)A Theoretically Grounded Application of Dropout in Recurrent Neural Networks</a>,然后再和整个path的距离拼接作为该组件的输出</li><li>Geo-Conv层，历史轨迹是一个GPS序列，为了捕获空间依赖使用1D卷积，将历史轨迹序列先经过FCN变成一个矩阵$T \times V$,T个轨迹点，每个轨迹点有V个特征，然后使用C个k*V的1D卷积，卷积输出的时间维度变成$T-k+1$,将C个卷积核输出的结果拼接，然后再拼接上local path的距离,输出结果为$T-k+1 \times D$</li></ul><p><img src="/2020/02/27/时空论文阅读笔记/DeepTTE2.png" alt=""></p><ul><li>然后将$T-k+1 \times D$的序列拼接外部因素输入到LSTM中，每个时间步表示一个local path，将<strong>隐藏状态用来预测每个local path的时间作为辅助任务</strong></li><li>LTSM输出$T-k+1$个时间步，将其整合成1个向量，通过和外部因素做Attention，对每个local path赋予不同的权重，然后再和外部因素拼接，用来预测entir path的时间</li></ul></li><li><p><strong>训练阶段预测local path和entir path的时间，在测试阶段只预测entir path的时间</strong></p></li><li><p>在训练时，使用MAPE作为loss，包含辅助任务和主任务的loss<br><img src="/2020/02/27/时空论文阅读笔记/DeepTTE-loss.png" alt=""></p></li><li><p>这篇文章也是经典的CNN+LSTM的架构，只是这里的CNN是1D卷积。在融合外部因素上也是CNN的输出和外部因素拼接，送入到LSTM中。</p></li></ul><h1><span id="3-出租车需求预测">3. 出租车需求预测</span></h1><h2><span id="31-deep-multi-view-spatial-temporal-network-for-taxi-demand-predictionaaai2018">3.1. Deep Multi-View Spatial-Temporal Network for Taxi Demand Prediction(AAAI2018)</span></h2><blockquote><p>姚骅修(Pennsylvania State University)<br>吴飞(Pennsylvania State University)<br>柯金涛(香港科技大学)<br>Xianfeng Tang(Pennsylvania State University)<br>叶杰平(滴滴出行)<br><a href="https://github.com/huaxiuyao/DMVST-Net" target="_blank" rel="noopener">https://github.com/huaxiuyao/DMVST-Net</a> Keras</p></blockquote><ul><li><strong>出租车需求预测</strong>，根据S<em>S的小区域，历史T个时间段的出租车订单数据，预测下一个时间段中心区域的订单。<em>*空间和时间都是多预测一</em></em></li></ul><p><img src="/2020/02/27/时空论文阅读笔记/DMVST_Net.png" alt=""></p><ul><li>现有的研究都是使用CNN对空间建模，LSTM对时间建模，时间和空间分开建模，本文的模型是对时间和空间同时建模</li><li>本文提出DMVST-Net，有3个view：<strong>时间view</strong>（通过LSTM建模时间关系），<strong>空间view</strong>（使用local CNN建模邻近空间关系），<strong>语义view</strong>（建模功能相似的区域）</li><li>local CNN只考虑空间邻近的区域，但是不能考虑离得较远，但出租车需求模型相似的区域，所以又加了语义view</li><li><img src="/2020/02/27/时空论文阅读笔记/DMVST_Net-1.jpg" alt=""></li><li><strong>输入是S*S的邻居区域，如果是边界区域，其邻居用0填充</strong></li><li>在LSTM每个时间步的特征中拼接天气等外部因素</li><li>local CNN和LSTM对时间和空间建模，然后再构建图，表示区域之间需求相似性(功能相似性)。求出2个区域每周的需求量，形成一个时间序列，使用DTW计算2个序列的相似性，即<strong>2个区域的相似性，作为图中的边，创建一个全连接图(任意2个区域都相连)</strong>,使用LINE对图中节点进行嵌入。</li><li><img src="/2020/02/27/时空论文阅读笔记/DMVST_Net-2.png" alt=""><br>损失函数由MSE和MAPE组成，MSE更关注大值，为了避免模型偏向大值的方向训练，又添加了MAPE，但是使用MAPE时，真实值中不能有0</li><li>Max-Min激活，最终输出值在[0,1]之间，反归一化</li><li>最后一层FCN用sigmoid激活，其余的FCN用ReLU激活</li></ul><h2><span id="32-revisiting-spatial-temporal-similarity-a-deep-learning-framework-for-traffic-predictionaaai2019">3.2. Revisiting Spatial-Temporal Similarity: A Deep Learning Framework for Traffic Prediction(AAAI2019)</span></h2><blockquote><p>姚骅修(Pennsylvania State University)<br>Xianfeng Tang(Pennsylvania State University)<br><a href="https://github.com/tangxianfeng/STDN" target="_blank" rel="noopener">https://github.com/tangxianfeng/STDN</a> Keras</p></blockquote><ul><li>主要问题是：原先研究中的空间相关性都是静态的，本次建模<strong>动态的空间相关性</strong>。<strong>时间有天和周周期，且有时间偏移</strong>。</li><li>提出模型<strong>S</strong>patial-<strong>T</strong>emporal <strong>D</strong>ynamic <strong>N</strong>etwork(<strong>STDN</strong>)来traffic prediction</li><li>根据S<em>S小区域历史T个时间段的volume和flow，预测下一个时间段中心区域的volume，<em>*空间和时间都是多预测一</em></em></li></ul><p><img src="/2020/02/27/时空论文阅读笔记/STDN.png" alt=""></p><ul><li>将交通量分为2种<ul><li>traffic volume：无方向，一个区域进来和出去的流量。</li><li>traffic flow：有方向，从区域i到区域j的流量</li></ul></li><li>flow-gated local CNN每次输入S*S区域的volume和flow，其中flow起到门控作用，值在[0,1]之间，如果2个区域之间flow大，即门控的值大，2个区域的相关性强。每个时间段经过local CNN输出的值，再拼接上该时间段的天气等外部因素送入LSTM中</li><li><strong>时间偏移Attention</strong>：比如预测第t+1个时间段的volume，用到当天前t=7个时间段的数据(短期依赖)，前P=3天(长期依赖)，每天Q=3个时间段(解决时间偏移问题)。</li><li>先将短期的t个时间段数据输入LSTM中，得到隐藏状态h做Attention。前P天，每天Q个时间段输入到LSTM中，每天得到Q个隐藏状态，和h做attention，将Q个整合成1个，最终生成P个隐藏状态，再输入到LSTM，得到长期依赖的隐藏状态，然后再和短期的隐藏状态h拼接，输入到FCN中。</li><li><strong>短期的隐藏状态和长期的隐藏状态做Attention</strong></li><li><strong>短期的隐藏状态和长期的隐藏状态拼接</strong></li><li>数据集：出租车流量和自行车流量</li></ul><blockquote><ul><li>STDN和DMVST-Net是同一作者发的</li><li>两者都是：空间和时间<strong>多预测一</strong></li><li><strong>STDN</strong>：local CNN + LSTM</li><li><strong>DMVST-Net</strong>：flow-gated local CNN + Periodically Shifted Attention LSTM</li></ul></blockquote><h2><span id="33-spatiotemporal-multi-graph-convolution-network-for-ride-hailing-demand-forecastingaaai2019">3.3. Spatiotemporal Multi-Graph Convolution Network for Ride-hailing Demand Forecasting(AAAI2019)</span></h2><blockquote><p>Xu Geng(香港大学)<br>Yaguang Li(南加利福尼亚)<br>Lingyu Zhang(滴滴AI)<br>杨强(香港大学)<br>叶杰平(滴滴)</p></blockquote><p><img src="/2020/02/27/时空论文阅读笔记/ST_MGCN.png" alt=""></p><ul><li>问题：根据所有区域历史T个时间段的订单数，预测所有区域下一个时间段的订单数</li><li>将研究区域划分为网格，根据网格构建3个图，这3个图的图信号矩阵一样，只是邻接矩阵不一样。分别<ul><li><strong>邻居图</strong>（3*3网格，每个区域有8个邻居，2个区域是邻居，邻接矩阵为1，否则为0）；</li><li><strong>区域功能相似图</strong>（根据每个区域的POI，计算相似性，值在0&lt;=sim&lt;=1）；</li><li><strong>交通连通图</strong>（看2个区域是否在高速公路，公共交通等方式相连，相连为1，否则为0）</li></ul></li><li><strong>Channel-wise attention</strong>参考CV领域，图像输入$X \in \mathbb{R}^{W\times H \times C}$，计算每一个通道的权重$s$,然后再把输入和通道权重相乘$\tilde{\boldsymbol{X}}_{:,:,c}=\boldsymbol{X}_{:,:, c} \circ s_{c} \quad for \quad c=1,2, \cdots C$</li><li>一共有3类图，每类图的邻接矩阵不一样，图信号矩阵一样，表示该区域的订单数，图信号矩阵是动态的，每个时间段的图信号矩阵都不一样，一共有T个时间段。拿一个图距离，输入为(T,V,P),根据通道维的attention，<strong>这里将时间维作为通道维，对T个时间段做Attention</strong>，最终得到attention后的输入(T,V,P),然后输入到RNN中，因为RNN一次只能输入一个节点T个时间段的数据，但是这里有V个节点，这里V个节点共享一个RNN，最终得到隐藏状态，然后在把3个图的输出融合，得到最终的预测结果(所有区域下一个时间段的订单数)</li><li>T为5，根据ST_ResNet，其中3个邻近，1个天周期，1个周周期。</li></ul><h2><span id="34-passenger-demand-forecasting-with-multi-task-convolutional-recurrent-neural-networkspakdd2019">3.4. Passenger Demand Forecasting with Multi-Task Convolutional Recurrent Neural Networks(PAKDD2019)</span></h2><blockquote><p>Lei Bai1(University of New South Wales)<br>Lina Yao(University of New South Wales)<br>Salil S. Kanhere(University of New South Wales)</p></blockquote><ul><li>根据历史T个时间段<strong>相似区域</strong>出租车demand和人流量，预测下一个时间段中心区域的出租车demand。<strong>时间和空间都是多预测一</strong></li></ul><p><img src="/2020/02/27/时空论文阅读笔记/MT-CRNN.png" alt=""></p><ul><li>根据路网来划分区域</li><li>多任务预测：<ul><li><strong>主任务(回归)</strong>：预测中心区域的订单需求数</li><li><strong>辅助任务(分类)</strong>：预测中心区域的订单需求等级(高、中、低)</li></ul></li><li>主任务输入的是相似区域的订单数据和人流量数据，其中<strong>根据POI和taxi demand来计算2个区域的相似性</strong>，为中心区域选择m=3个最相似区域</li><li>使用外部信息(天气等)来预测订单需求等级(辅助任务)</li></ul><h2><span id="35-stg2seq-spatial-temporal-graph-to-sequence-model-for-multi-step-passenger-demand-forecasting2019ijcai">3.5. STG2Seq: Spatial-temporal Graph to Sequence Model for Multi-step Passenger Demand Forecasting(2019IJCAI)</span></h2><blockquote><p>Lei Bai1(University of New South Wales)<br>Lina Yao(University of New South Wales)<br>Salil S. Kanhere(University of New South Wales)</p></blockquote><ul><li>基于GCN，提出<strong>Seq2Seq的模型</strong>，来进行<strong>多步预测</strong>。本文说这是第一篇使用GCN来进行多步预测</li><li><p>大部分的研究只预测下一个时间段，本文预测多个时间段。以前的研究预测多个时间段使用seq2seq架构，里面是RNN或者其变体(ConvLSTM)，有个问题是：在decoder中，将前一个时间步的预测结果作为输入，会出现错误累积</p></li><li><p>将城市划分为N个小区域，基于网格或道路划分都可以</p></li><li><p>给定历史h个时间段的D(需求量，维度$N \times D_{in}$)和所有时间段的时间信息E，预测未来$\tau$个时间段的需求量<br><img src="/2020/02/27/时空论文阅读笔记/STG2Seq1.png" alt=""></p></li><li><p>图中每个节点表示一个小区域，图的邻接矩阵A中非0即1，根据区域demand的模式，计算2个区域的皮尔森相似度，如果相似度大于某个阈值，邻接矩阵为1，否则设置为0</p></li><li><p>模型主要有3个模块，假设预测时间段为$t+1,t+1,…,t+\tau$</p><ul><li>长期encoder：历史长期h个时间段，(h,N,D)</li><li>短期encoder：最近的q个时间段，(q,N,D)</li><li>Attention模块：在历史时间段中，找出对预测时间段的重要性</li></ul></li><li><p>长期encoder和短期encoder都是由GGCM组成，一个GGCM中有多个GCN。拿长期encoder举例，输入维度(h,N,D),每k个时间段(k,N,D)输入到GCN中，h个时间段一共有h-k+1个GCN，即经过一个GGCM，输入维度变成(h-k+1,N,D1)，每经过一个GGCM，时间维度都会变小，为了防止时间维度变小，会拼接上一个(k-1,N,D1)的全0padding，让其变成(h,N,D1)的维度，然后再输入到下一个GGCM中。<br>  <img src="/2020/02/27/时空论文阅读笔记/STG2Seq3.png" alt=""><br>  <img src="/2020/02/27/时空论文阅读笔记/STG2Seq4.png" alt=""></p></li><li>对于一个GCN中，输入维度是(k,N,D),reshape成(N,k*D),然后使用下面的公式。下面这个公式用到了残差连接，在经过GCN后，加上原来的$X^l$，同时和后面的sigmoid逐元素相乘，控制线性转换的哪部分可以通过门。<br><img src="/2020/02/27/时空论文阅读笔记/STG2Seq2.png" alt=""></li><li>在经过长期encoder和短期encoder后，将输出拼接，得到$(h+q,N,d_{out})$</li><li><strong>时间Attention</strong>：历史h+q个时间段对target时间段的影响不同，为了求出不同的影响程度，使用Attention机制。将$Y_{h+q}$reshape成$(h+q) \times (N \times d_{out})$<script type="math/tex; mode=display">\boldsymbol{\alpha}=\operatorname{softmax}\left(\tanh \left(Y_{h+q} W_{3}^{Y}+E_{T} W_{4}^{E}+b_{1}\right)\right)</script>其中$W_{3}^{Y} \in \mathbb{R}^{(h+q) \times\left(N \times d_{\text {out }}\right) \times 1}, W_{4}^{E} \in \mathbb{R}^{d_{e} \times(h+q)}$，$b_{1} \in \mathbb{R}^{(h+q)}$ 得到的Attention分数$\boldsymbol{\alpha} \in \mathbb{R}^{(h+q)}$<script type="math/tex; mode=display">Y_{\alpha}=\sum_{i=1}^{h+q} \alpha^{i} y_{i} \quad \in \mathbb{R}^{N \times d_{o u t}}</script></li><li><strong>通道Attention</strong>：经过上一步的时间Attention，得到的结果$Y_{\alpha}$维度为$N \times d_{out}$，然后再经过通道Attention，将$Y_{\alpha}$reshape成$N \times d_{out}$<script type="math/tex; mode=display">\boldsymbol{\beta}=\operatorname{softmax}\left(\tanh \left(Y_{\alpha} W_{5}^{Y}+E_{T} W_{6}^{E}+b_{2}\right)\right)</script>其中$W_{5}^{Y} \in \mathbb{R}^{d_{\text {out}} \times N \times 1}, W_{6}^{E} \in \mathbb{R}^{d_{e} \times d_{\text {out}}}, b_{2} \in \mathbb{R}^{d_{out}}$，$\boldsymbol{\beta} \in \mathbb{R}^{d_{\text {out }}}$<script type="math/tex; mode=display">Y_{\beta}=\sum_{i=1}^{d_{\text {out}}} \beta^{i} \mathscr{Y}_{i} \in \mathbb{R}^{N}</script></li><li>经过通道Attention，求得$Y_{\beta}$就是一个时间段的预测值</li></ul><p><strong>- 总结：</strong></p><ul><li>图的邻接矩阵非0即1，计算2个区域的相似度，大于阈值为1，否则为0</li><li>将历史时间段分为<strong>长期和短期</strong>，在历史时间段上设置一个<strong>长度为k的滑动窗口</strong>，每k个时间段都用不同的GCN来<strong>捕获空间关系</strong></li><li><strong>时间Attention</strong>：经过encoder后，将长期和短期的输出拼接，形成h+q个时间段，计算对target的时间段的时间Attention</li><li><strong>通道Attention</strong>：借鉴CV领域的思想《(CVPR2017)-Spatial and channel-wise attention in convolutional networks for image captioning》</li><li>使用GCN捕获空间相关性，然后分别使用时间Attention和通道Attention</li></ul><h1><span id="4-时间序列预测">4. 时间序列预测</span></h1><h2><span id="41-restful-resolution-aware-forecasting-of-behavioral-time-series-data2018cikm">4.1. RESTFul: Resolution-Aware Forecasting of Behavioral Time Series Data(2018CIKM)</span></h2><blockquote><p>吴宪(University of Notre Dame)<br>史宝旭(University of Notre Dame)<br>Yuxiao Dong(微软)<br>黄超(University of Notre Dame)</p></blockquote><p>本文使用<strong>多种时间粒度</strong>的<strong>时间序列数据</strong>来预测。<br>模型为<strong>RES</strong>olution-aware <strong>T</strong>ime <strong>S</strong>eries Forecasting (RESTFul)<br>第一个使用多种时间粒度来进行行为时间序列预测</p><p><img src="/2020/02/27/时空论文阅读笔记/RESTFul.png" alt=""></p><ul><li>有2个参数$\alpha和\beta$，取值{day,week}，限制α&gt;=β，<br>$\alpha$=1week,$\beta$=1day,表示1周测量1次，1次测1天。<br>$\alpha$=1week,$\beta$=1week,表示1周测量1次，1次测1周。<br>有一个完整的时间序列，要从中隔抽取不同时间粒度的时间序列。$X=\left[x_{1}, \ldots, x_{t}, \ldots, x_{T-1}, x_{T}\right]$，不同的$\alpha和\beta$就构成不同时间粒度的序列，序列长度为k，这里设置为5。</li><li>对于每一个时间序列都用GRU来捕获时间相关性，得到一个隐藏状态，那么n个时间序列就有n个隐藏状态</li><li>将所有的隐藏状态reshape成$\alpha <em> \beta </em> d$的张量，然后使用卷积融合不同粒度。</li><li>使用数据集：销售数据，311投诉数据</li></ul><h2><span id="42-multi-horizon-time-series-forecasting-with-temporal-attention-learningkdd2019">4.2. Multi-Horizon Time Series Forecasting with Temporal Attention Learning(KDD2019)</span></h2><blockquote><p>Chenyou Fan(京东金融)<br>Yuze Zhang(京东金融)<br>Yi Pan(京东金融)</p></blockquote><ul><li>使用前T个时间段的销售数据，预测未来<code>T&#39;</code>个时间段的销售数据</li><li>传统的encoder-decoder架构使用rnn,本文的一个改进是在decoder中使用BiLSTM</li></ul><p><img src="/2020/02/27/时空论文阅读笔记/BiLSTM-Enc-Dec.png" alt=""></p><p><img src="/2020/02/27/时空论文阅读笔记/BiLSTM-Enc-Dec1.png" alt=""></p><ul><li><strong>时间Attention</strong>:在decoder中第$t+1$个时间步生成的隐藏状态，对encoder中的隐藏状态进行attention，这里并不是对所有的历史时间段做attention，而是对历史$T_h$个时间段(可划分为M个period)做attention。例如上图中M=2，然后形成M个$c$向量，再经过FCN转换成$d$，然后再将M个$d$向量融合，这里使用attention融合，通过decoder的隐藏状态$h_{t+1}$对M个向量d做attention，将其融合成1个向量，然后再和$h_{t+1}$拼接，输入到FCN中预测第$t+1$个时间步的$y_{t+1}$，decoder中每个时间步都输出该时间步的预测值$y$。</li><li>本文的创新点就是：BILSTM和时间local Attention(只和局部时间段做Attention)</li></ul><h1><span id="5-总结">5. 总结</span></h1><h2><span id="51-根据网格构建图">5.1. 根据网格构建图</span></h2><p>图用2个矩阵表示：图信号矩阵和邻接矩阵。由网格构建图时，节点表示区域，图信号矩阵就是区域的特征。重点是怎么构建邻接矩阵。</p><ul><li>《Spatiotemporal Multi-Graph Convolution Network for Ride-hailing Demand Forecasting》(AAAI2019)这篇文章构建了3个图：邻居图，POI功能相似图，交通连通图</li><li>《RiskOracle: A Minute-level Citywide Traffic Accident Forecasting Framework》(AAAI2020)有27*27个网格，但只有354个网格有道路，所以构建图中有354个节点。根据区域之间的道路静态信息和交通动态信息(flow和speed)来计算区域之间的相似性，构建邻接矩阵。由于动态交通信息随时间变化，所有每个时间段的相似性都不同，即每个时间段的邻接矩阵都不一样。<ul><li>图信号矩阵：区域的flow，speed、和前一个时间段的差值</li><li>邻接矩阵：区域之间的相似性，在[0,1]之间</li></ul></li></ul><p><strong>邻接矩阵的构造</strong></p><ul><li><p>邻接矩阵，非0即1，如果2个区域相邻，为1，否则为0<br>《Spatial-Temporal Synchronous Graph Convolutional Networks: A New Framework for Spatial-Temporal Network Data Forecasting》（AAAI2020）</p></li><li><p>计算2个区域的相似性，如果2个区域的相似度大于某个阈值，设置为1，否则为0<br>《STG2Seq: Spatial-temporal Graph to Sequence Model for Multi-step Passenger Demand Forecasting》（2019IJCAI）</p></li><li>计算2个区域的相似性，使用相似性作为邻接矩阵的值<br>《RiskOracle: A Minute-level Citywide Traffic Accident Forecasting Framework》（AAAI2020）</li></ul><h2><span id="52-动态图">5.2. 动态图</span></h2><p>一般的图卷积的输入维度是<code>(batch_size,N,C)</code>，即只有一个时间段，但如果输入的是动态图即<code>(batch_size,T,N,C)</code>，该怎么办？</p><script type="math/tex; mode=display">h^{(l)}=\left(\hat{A} h^{(l-1)} W_{1}+b_{1}\right)</script><ul><li><code>(batch_size,T,N,C)--&gt;(batch_size,T*N,C)--&gt;(T*N,batch_size,C)</code>,例如《Spatial-Temporal Synchronous Graph Convolutional Networks: A New Framework for Spatial-Temporal Network Data Forecasting》（AAAI2020）,将时间T乘到节点N上，需要对邻接矩阵进行变换成<code>(TN,TN)</code>的形式，才可以和h相乘。不常用，除非对邻接矩阵A进行变换</li><li><code>(batch_size,T,N,C)--&gt;(batch_size,N,T*C)</code>，可以先经过一个FCN，将其转换为<code>(batch_size,N,D)</code>,然后再输出到GCN中，也可以不经过FCN，直接输入到GCN中。较常用，例如：<br>《RiskOracle: A Minute-level Citywide Traffic Accident Forecasting Framework》（AAAI2020）<br>《STG2Seq: Spatial-temporal Graph to Sequence Model for Multi-step Passenger Demand Forecasting》（2019IJCAI）</li></ul><h2><span id="53-计算2个区域的相似性">5.3. 计算2个区域的相似性</span></h2><ul><li><p>用<strong>出租车需求量</strong>计算2个区域的<strong>相似性</strong>，用2个区域<strong>训练集</strong>中出租车需求量组成时间序列</p><ul><li>使用DTW计算2个序列的相似性，2个时间序列越相似，说明2个区域越相似。例如：《Deep Multi-View Spatial-Temporal Network for Taxi Demand Prediction》(AAAI2018)</li><li>使用皮尔森度量函数Pearson Correlation Coefficient，<br>《Passenger Demand Forecasting with Multi-Task Convolutional Recurrent Neural Networks》(2019PAKDD)<br>《STG2Seq: Spatial-temporal Graph to Sequence Model for Multi-step Passenger Demand Forecasting》（2019IJCAI）</li></ul></li><li><p>计算2个区域之间的<strong>相关性</strong>，使用<strong>区域间带有方向的traffic flow</strong>，如果2个区域之间的traffic flow越大，说明这2个区域越相关。但是《R evisiting Spatial-Temporal Similarity: A Deep Learning Framework for Traffic Prediction》(AAAI2019)说这种相关性也是相似性。我觉得有问题，例如工作区和住宅区，2个区域的traffic flow很大，有很强的相关性，但是相似性并不强。</p></li><li>根据<strong>POI</strong>计算2个区域的相似性<ul><li>例如《Passenger Demand Forecasting with Multi-Task Convolutional Recurrent Neural Networks》(2019PAKDD)</li><li>《Spatiotemporal Multi-Graph Convolution Network for Ride-hailing Demand Forecasting》(2019AAAI)但是这篇文章没有提到使用什么函数来计算相似度</li></ul></li><li>《RiskOracle: A Minute-level Citywide Traffic Accident Forecasting Framework》(AAAI2020)根据区域的道路静态信息和交通动态信息(flow和speed)计算2个区域的相似性。使用JS散度</li></ul><h2><span id="54-poi">5.4. POI</span></h2><p>很多论文中都习惯将POI成为Semantic</p><ul><li>《Deep Multi-View Spatial-Temporal Network for Taxi Demand Prediction》(AAAI2018)</li><li>《DeepSTN+: Context-aware Spatial-Temporal Neural Network for Crowd Flow Prediction in Metropolis》(AAAI2019)</li></ul><h2><span id="55-时间">5.5. 时间</span></h2><p>像dayOfWeek，monthOfYear等时间信息，在论文中称作<strong>time meta feature</strong></p><h2><span id="56-lstm共t个隐藏状态整合">5.6. LSTM共T个隐藏状态整合</span></h2><p>LSTM一共有T个时间步，将输出T个隐藏状态，怎么将其整合成1个，有3种方法：</p><ul><li>只取最后一个时间步的隐藏状态，例如<br>《Deep Multi-View Spatial-Temporal Network for Taxi Demand Prediction》(AAAI2018)</li><li>将T个时间步的隐藏状态拼接或平均或加和</li><li>将T个时间步的隐藏状态和被预测时间步的某个向量(e.g.外部因素)做Attention，对每个时间步赋予不同的权重，整合成1个向量。例如<br>《Revisiting Spatial-Temporal Similarity: A Deep Learning Framework for Traffic Prediction》(AAAI2019)<br>《When Will You Arrive? Estimating Travel Time Based on Deep Neural Networks》(AAAI20)</li></ul><h2><span id="57-外部因素嵌入">5.7. 外部因素嵌入</span></h2><p>外部因素包括：天气，时间，holiday等信息，</p><ul><li>外部因素中<strong>类别值</strong>(dayOfWeek，weather等)用one-hot表示，<strong>连续值</strong>(温度，风速)等用float表示，将这些外部因素拼接在一起，送入FCN中做嵌入。<br>例如《 Deep Spatio-Temporal Residual Networks for Citywide Crowd Flows Prediction(AAAI2017)》</li><li>外部因素中<strong>类别值</strong>(dayOfWeek，weather等)直接用数字表示，例如周一用0表示，周日用6表示。<strong>连续值</strong>(温度，风速)等用float表示，然后将每个类别值用对应的Embedding嵌入，然后再把嵌入的结果拼接<br>例如《When Will You Arrive? Estimating Travel Time Based on Deep Neural Networks(AAAI20)》<br><code>Embedding</code>相关知识参考<a href="https://echohhhhhh.github.io/2020/02/24/Pytorch%E4%B9%8B%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB/#12-embedding" target="_blank" rel="noopener">Pytorhc之Embedding</a></li></ul><h2><span id="58-mask">5.8. mask</span></h2><p>有时候mask是舍弃一些不想关注的值，比如预测车流量时，真实车流量小于5的值则舍弃，即不关注那些车流量小的值预测结果，只关注大约5的值的预测结果。一般在评价指标中mask</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">mask_mae_np</span><span class="params">(y_true,y_pred,region_mask,null_val=None)</span>:</span></span><br><span class="line">    <span class="string">"""计算MAE</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    Arguments:</span></span><br><span class="line"><span class="string">        y_true &#123;np.ndarray&#125; -- 真实值,维度(samples,pre_len,W,H)</span></span><br><span class="line"><span class="string">        y_pred &#123;np.ndarray&#125; -- 预测值,维度(samples,pre_len,W,H)</span></span><br><span class="line"><span class="string">        region_mask &#123;np.ndarray&#125; -- mask矩阵,维度(W,H)</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    Returns:</span></span><br><span class="line"><span class="string">        np.float64 -- MAE值</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    y_true,y_pred = transfer_dtype(y_true,y_pred)</span><br><span class="line">    <span class="keyword">if</span> null_val <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span>:</span><br><span class="line">        label_mask = np.where(y_true &gt; <span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>).astype(<span class="string">'float32'</span>)</span><br><span class="line">        <span class="comment"># label_mask = np.not_equal(y_true, null_val).astype('float32')</span></span><br><span class="line">        mask = region_mask * label_mask</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        mask = region_mask</span><br><span class="line">    mask /= mask.mean()</span><br><span class="line">    <span class="keyword">return</span> np.mean(np.abs(y_true-y_pred)*mask)</span><br></pre></td></tr></table></figure><h2><span id="59-max-min归一化">5.9. Max-min归一化</span></h2><p>使用Max-Min将数据归一化到[0,1]，但是也有论文归一化成[-1,1]，如下所示：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MinMaxNormalization</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="string">'''MinMax Normalization --&gt; [-1, 1]</span></span><br><span class="line"><span class="string">       x = (x - min) / (max - min).</span></span><br><span class="line"><span class="string">       x = x * 2 - 1</span></span><br></pre></td></tr></table></figure><p>【注意】对特征和y归一化有2种方式：</p><ol><li><strong>只对特征进行归一化，y不进行归一化</strong>，模型预测的结果和真实y是同一量纲，模型的loss会偏大，计算评价指标时，不需要反归一化</li><li><strong>对特征和y都归一化</strong>，y归一化到[0,1]之间，在计算loss时，不需要反归一化，loss相对方法1会偏小，在计算评价指标时，需要对真实y和预测y进行反归一化，再计算MAE等指标</li><li><p>关于上面是否需要对y进行归一化。如果模型收敛(loss一直在下降)，可以不对y进行归一化。如果模型不收敛(数值过大)，则需要对y进行归一化。</p><p><img src="/2020/02/27/时空论文阅读笔记/神经网络踩坑/y-norm.png" alt=""><br>如果对y进行归一化，loss初始值很小，模型训练时很快就会收敛loss不再下降。不对y归一化，loss初始值很大，在训练过程中，训练很多轮loss才开始收敛，可能还会造成训练过程不稳定，loss上下震荡。</p></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;因为疫情推迟开学，在家把以前看的论文又看了一遍，每重新看一次都有新的收获，在此整理下。&lt;/p&gt;
    
    </summary>
    
      <category term="论文阅读笔记" scheme="http://yoursite.com/categories/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="时空领域" scheme="http://yoursite.com/tags/%E6%97%B6%E7%A9%BA%E9%A2%86%E5%9F%9F/"/>
    
  </entry>
  
  <entry>
    <title>VSCode连接服务器太慢</title>
    <link href="http://yoursite.com/2020/02/26/VSCode%E8%BF%9E%E6%8E%A5%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%A4%AA%E6%85%A2/"/>
    <id>http://yoursite.com/2020/02/26/VSCode连接服务器太慢/</id>
    <published>2020-02-26T09:59:55.000Z</published>
    <updated>2020-02-26T12:26:38.519Z</updated>
    
    <content type="html"><![CDATA[<p>使用VSCode远程连接服务器太慢，是因为需要远程下载vscode-server-linux-x64.tar.gz，下载太慢，下面是解决方案</p><a id="more"></a><p><img src="/2020/02/26/VSCode连接服务器太慢/vscode.png" alt=""></p><p><a href="https://blog.csdn.net/bcfd_yundou/article/details/96135456" target="_blank" rel="noopener">vscode搭建远程开发</a></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">先将vscode-server-linux-x64.tar.gz拷贝到/data/WangBeibei/.vscode-server/bin/xxx下面，并解压</span></span><br><span class="line">tar -xzvf vscode-server-linux-x64.tar.gz</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">删掉压缩包</span></span><br><span class="line">rm -r vscode-server-linux-x64.tar.gz</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">将vscode-server-linux-x64目录中所有内容移到/data/WangBeibei/.vscode-server/bin/xxx下面</span></span><br><span class="line">mv /data/WangBeibei/.vscode-server/bin/xxx/vscode-server-linux-x64/* /data/WangBeibei/.vscode-server/bin/xxx</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">删掉vscode-server-linux-x64</span></span><br><span class="line">rm -r vscode-server-linux-x64</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;使用VSCode远程连接服务器太慢，是因为需要远程下载vscode-server-linux-x64.tar.gz，下载太慢，下面是解决方案&lt;/p&gt;
    
    </summary>
    
      <category term="工具" scheme="http://yoursite.com/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="VSCode" scheme="http://yoursite.com/tags/VSCode/"/>
    
  </entry>
  
  <entry>
    <title>对loss进行mask</title>
    <link href="http://yoursite.com/2020/02/25/%E5%AF%B9loss%E8%BF%9B%E8%A1%8Cmask/"/>
    <id>http://yoursite.com/2020/02/25/对loss进行mask/</id>
    <published>2020-02-25T05:37:12.000Z</published>
    <updated>2020-03-06T16:32:42.950Z</updated>
    
    <content type="html"><![CDATA[<h1><span id="简介">简介</span></h1><p>在计算loss和评价指标时，对一些不关注的值进行mask。下面介绍mask的使用。</p><a id="more"></a><h1><span id="对loss进行mask">对loss进行mask</span></h1><p>在NLP中的Seq2Seq中经常会对loss进行mask，因为一个batch中句子的长度通常不一样，一个batch中不足长度的位置用0填充，最后生成句子计算loss时需要忽略掉原先那些padding的值，即只保留mask中值为1的位置，忽略值为0的位置。在计算loss时，将那些本不应该计算的mask掉，使其loss为0，这样就不会反向传播了。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">masked_predicts = torch.masked_select(predicts, mask)</span><br><span class="line">masked_targets = torch.masked_select(targets, mask)</span><br><span class="line">loss = my_criterion(masked_predicts, masked_targets)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">diff2 = (torch.flatten(input) - torch.flatten(target)) ** <span class="number">2.0</span> * torch.flatten(mask)</span><br><span class="line">loss = torch.sum(diff2) / torch.sum(mask)</span><br><span class="line">out.backward()</span><br></pre></td></tr></table></figure><p>有时候mask是舍弃一些不想关注的值，比如预测车流量时，真实车流量小于5的值则舍弃，即不关注那些车流量小的值预测结果，只关注大约5的值的预测结果。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">masked_mean_squared_error</span><span class="params">(y_true, y_pred)</span>:</span></span><br><span class="line">    idx = (y_true &gt; <span class="number">5</span>).nonzero()</span><br><span class="line">    <span class="keyword">return</span> K.mean(K.square(y_pred[idx] - y_true[idx]))</span><br></pre></td></tr></table></figure><h1><span id="pytorch的mask_select函数">Pytorch的mask_select函数</span></h1><p><code>torch.masked_select(input, mask, out=None) → Tensor</code><br>返回1-D的Tensor</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>x = torch.randn(<span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x</span><br><span class="line">tensor([[ <span class="number">0.3552</span>, <span class="number">-2.3825</span>, <span class="number">-0.8297</span>,  <span class="number">0.3477</span>],</span><br><span class="line">        [<span class="number">-1.2035</span>,  <span class="number">1.2252</span>,  <span class="number">0.5002</span>,  <span class="number">0.6248</span>],</span><br><span class="line">        [ <span class="number">0.1307</span>, <span class="number">-2.0608</span>,  <span class="number">0.1244</span>,  <span class="number">2.0139</span>]])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>mask = x.ge(<span class="number">0.5</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>mask</span><br><span class="line">tensor([[<span class="keyword">False</span>, <span class="keyword">False</span>, <span class="keyword">False</span>, <span class="keyword">False</span>],</span><br><span class="line">        [<span class="keyword">False</span>, <span class="keyword">True</span>, <span class="keyword">True</span>, <span class="keyword">True</span>],</span><br><span class="line">        [<span class="keyword">False</span>, <span class="keyword">False</span>, <span class="keyword">False</span>, <span class="keyword">True</span>]])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>torch.masked_select(x, mask)</span><br><span class="line">tensor([ <span class="number">1.2252</span>,  <span class="number">0.5002</span>,  <span class="number">0.6248</span>,  <span class="number">2.0139</span>])</span><br></pre></td></tr></table></figure><p>【参考资料】</p><p><a href="http://www.linzehui.me/2018/10/12/%E7%A2%8E%E7%89%87%E7%9F%A5%E8%AF%86/%E6%B5%85%E8%B0%88mask%E7%9F%A9%E9%98%B5/" target="_blank" rel="noopener">浅谈mask矩阵</a><br><a href="https://github.com/xlwang233/pytorch-DCRNN/blob/master/lib/metrics.py" target="_blank" rel="noopener">pytorch-DCRNN</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h1&gt;&lt;p&gt;在计算loss和评价指标时，对一些不关注的值进行mask。下面介绍mask的使用。&lt;/p&gt;
    
    </summary>
    
      <category term="Deep Learning" scheme="http://yoursite.com/categories/Deep-Learning/"/>
    
    
      <category term="Deep Learning" scheme="http://yoursite.com/tags/Deep-Learning/"/>
    
  </entry>
  
  <entry>
    <title>Pytorch之知识点汇总</title>
    <link href="http://yoursite.com/2020/02/24/Pytorch%E4%B9%8B%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB/"/>
    <id>http://yoursite.com/2020/02/24/Pytorch之知识点汇总/</id>
    <published>2020-02-24T09:08:12.000Z</published>
    <updated>2020-03-07T05:14:34.216Z</updated>
    
    <content type="html"><![CDATA[<h1><span id="1-简介">1. 简介</span></h1><p>汇总Pytorch的一些知识点</p><a id="more"></a><!-- TOC --><ul><li><a href="#1-%e7%ae%80%e4%bb%8b">1. 简介</a></li><li><a href="#2-%e6%9f%a5%e7%9c%8b%e7%bd%91%e7%bb%9c%e5%8f%82%e6%95%b0">2. 查看网络参数</a></li><li><a href="#3-%e5%88%86%e7%b1%bb%e9%97%ae%e9%a2%98">3. 分类问题</a></li><li><a href="#4-crossentropyloss%e5%92%8cnllloss-%e5%8c%ba%e5%88%ab">4. CrossEntropyLoss()和NLLLoss() 区别</a></li><li><a href="#5-%e6%a8%a1%e5%9e%8b%e8%ae%ad%e7%bb%83%e7%a4%ba%e4%be%8b">5. 模型训练示例</a></li><li><a href="#6-%e5%85%b3%e9%97%ad%e6%a2%af%e5%ba%a6">6. 关闭梯度</a></li><li><a href="#7-gpu">7. GPU</a></li><li><a href="#8-%e5%a4%9agpu%e8%bf%90%e8%a1%8c%e7%a8%8b%e5%ba%8f">8. 多GPU运行程序</a></li><li><a href="#9-tensor">9. Tensor</a></li><li><a href="#10-bn%e5%92%8cdropout%e5%9c%a8%e8%ae%ad%e7%bb%83%e5%92%8c%e6%b5%8b%e8%af%95%e7%9a%84%e4%b8%8d%e5%90%8c">10. BN和Dropout在训练和测试的不同</a></li><li><a href="#11-linear">11. Linear</a></li><li><a href="#12-embedding">12. Embedding</a></li></ul><!-- /TOC --><h1><span id="2-查看网络参数">2. 查看网络参数</span></h1><ul><li><p>方法1</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> param <span class="keyword">in</span> network.parameters():</span><br><span class="line">  print(param.shape)</span><br></pre></td></tr></table></figure></li><li><p>方法2<br>可以查看参数的名称</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> name, param <span class="keyword">in</span> network.named_parameters():</span><br><span class="line">  print(name, <span class="string">'\t\t'</span>, param.shape)</span><br></pre></td></tr></table></figure></li></ul><h1><span id="3-分类问题">3. 分类问题</span></h1><p>例如Fashion-MNIST分类任务中，一共有10类。假设batch_size=16,每个batch的feature维度为(16,1,28,28)，label的维度(16,)，经过模型最终输出的预测结果维度(16,10)，然后我们使用<code>argmax()</code>来得出最终的预测类别。然后可以和真实label比较，看预测结果的正确性,计算预测正确的个数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&gt; preds.argmax(dim=<span class="number">1</span>)</span><br><span class="line">tensor([<span class="number">5</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">4</span>])</span><br><span class="line"></span><br><span class="line">&gt; labels</span><br><span class="line">tensor([<span class="number">9</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">3</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">7</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">5</span>])</span><br><span class="line"></span><br><span class="line">&gt; preds.argmax(dim=<span class="number">1</span>).eq(labels)</span><br><span class="line">tensor([<span class="keyword">False</span>, <span class="keyword">False</span>, <span class="keyword">False</span>, <span class="keyword">False</span>, <span class="keyword">False</span>, <span class="keyword">False</span>, <span class="keyword">False</span>, <span class="keyword">False</span>, <span class="keyword">True</span>, <span class="keyword">False</span>], dtype=torch.bool)</span><br><span class="line"></span><br><span class="line">&gt; preds.argmax(dim=<span class="number">1</span>).eq(labels).sum()</span><br><span class="line">tensor(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">&gt; preds.argmax(dim=<span class="number">1</span>).eq(labels).sum().item()</span><br><span class="line"><span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#得到每个batch预测正确的样本</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_num_correct</span><span class="params">(preds, labels)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> preds.argmax(dim=<span class="number">1</span>).eq(labels).sum().item()</span><br></pre></td></tr></table></figure><h1><span id="4-crossentropyloss和nllloss-区别">4. CrossEntropyLoss()和NLLLoss() 区别</span></h1><p><a href="https://blog.csdn.net/zwqjoy/article/details/96282788" target="_blank" rel="noopener">Pytorch nn.CrossEntropyLoss()和nn.NLLLoss() 区别</a></p><p><a href="https://www.cnblogs.com/marsggbo/p/10401215.html" target="_blank" rel="noopener">Pytorch里的CrossEntropyLoss详解</a>  </p><p><a href="https://www.zhihu.com/question/66782101" target="_blank" rel="noopener">PyTorch 中，nn 与 nn.functional 有什么区别</a></p><h1><span id="5-模型训练示例">5. 模型训练示例</span></h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">network = Network()</span><br><span class="line"></span><br><span class="line">train_loader = torch.utils.data.DataLoader(train_set, batch_size=<span class="number">100</span>)</span><br><span class="line">optimizer = optim.Adam(network.parameters(), lr=<span class="number">0.01</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> epoch <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">    </span><br><span class="line">    total_loss = <span class="number">0</span></span><br><span class="line">    total_correct = <span class="number">0</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> batch <span class="keyword">in</span> train_loader: <span class="comment"># Get Batch</span></span><br><span class="line">        images, labels = batch </span><br><span class="line"></span><br><span class="line">        preds = network(images) <span class="comment"># Pass Batch</span></span><br><span class="line">        loss = F.cross_entropy(preds, labels) <span class="comment"># Calculate Loss</span></span><br><span class="line"></span><br><span class="line">        optimizer.zero_grad()</span><br><span class="line">        loss.backward() <span class="comment"># Calculate Gradients</span></span><br><span class="line">        optimizer.step() <span class="comment"># Update Weights</span></span><br><span class="line"></span><br><span class="line">        total_loss += loss.item()</span><br><span class="line">        total_correct += get_num_correct(preds, labels)</span><br><span class="line"></span><br><span class="line">    print(</span><br><span class="line">        <span class="string">"epoch"</span>, epoch, </span><br><span class="line">        <span class="string">"total_correct:"</span>, total_correct, </span><br><span class="line">        <span class="string">"loss:"</span>, total_loss</span><br><span class="line">    )</span><br></pre></td></tr></table></figure><h1><span id="6-关闭梯度">6. 关闭梯度</span></h1><p>关闭梯度有2种方法</p><ul><li><p>方法1：在模型训练的时候，需要计算梯度，但是在测试的时候不需要计算梯度，那我们就可以使用<code>@torch.no_grad()</code>。下面代码示例求所有的预测结果</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@torch.no_grad()</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_all_preds</span><span class="params">(model, loader)</span>:</span></span><br><span class="line">    all_preds = torch.tensor([])</span><br><span class="line">    <span class="keyword">for</span> batch <span class="keyword">in</span> loader:</span><br><span class="line">        images, labels = batch</span><br><span class="line">        preds = model(images)</span><br><span class="line">        all_preds = torch.cat(</span><br><span class="line">            (all_preds, preds),dim=<span class="number">0</span>)</span><br><span class="line">  <span class="keyword">return</span> all_preds</span><br></pre></td></tr></table></figure></li></ul><p>使用<code>@torch.no_grad()</code>就不用再记录梯度的轨迹(不用再保存动态图的计算轨迹)，省内存。</p><ul><li><p>方法2：<br>使用<code>with torch.no_grad()</code>在函数内部</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> torch.no_grad():</span><br><span class="line">  prediction_loader = torch.utils.data.DataLoader(train_set, batch_size=<span class="number">10000</span>)</span><br><span class="line">  train_preds = get_all_preds(network, prediction_loader)</span><br></pre></td></tr></table></figure></li></ul><h1><span id="7-gpu">7. GPU</span></h1><p>在这里原先一直有个误区，误认为<code>device = torch.device(&quot;cuda&quot;)</code>获取所有的GPU，<code>device = torch.device(&quot;cuda:0&quot;)</code>获取第一个GPU。下面是正解：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#程序只能看到1,2,3序号的GPU，然后重新给它们编号为：0,1,2</span></span><br><span class="line">&gt; os.environ[<span class="string">"CUDA_VISIBLE_DEVICES"</span>] = <span class="string">'1,2,3'</span></span><br><span class="line"></span><br><span class="line">&gt; device = torch.device(<span class="string">"cuda:0"</span>)<span class="comment">#获取下标为0的GPU</span></span><br><span class="line">device(type=<span class="string">'cuda'</span>, index=<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#如果不指定cuda编号，其实有一个默认编号，</span></span><br><span class="line"><span class="comment">#默认为torch.cuda.current_device()，该值默认为0</span></span><br><span class="line">&gt; device = torch.device(<span class="string">"cuda"</span>)</span><br><span class="line">device(type=<span class="string">'cuda'</span>)</span><br><span class="line"></span><br><span class="line">&gt; torch.cuda.current_device()</span><br><span class="line"><span class="number">0</span></span><br></pre></td></tr></table></figure><p>也就是说<code>device = torch.device(&quot;cuda&quot;)</code>还是1个GPU，等价于<code>device = torch.device(&quot;cuda:X&quot;)</code>,其中<code>X = torch.cuda.current_device()</code>  </p><p>【<strong>参考资料</strong>】</p><p><a href="https://pytorch.apachecn.org/docs/1.0/tensor_attributes.html" target="_blank" rel="noopener">torch.device</a></p><p><a href="https://pytorch.org/docs/stable/notes/cuda.html" target="_blank" rel="noopener">CUDA SEMANTICS</a></p><h1><span id="8-多gpu运行程序">8. 多GPU运行程序</span></h1><p><a href="https://echohhhhhh.github.io/2020/01/06/Pytorch%E4%B9%8BGPU%E7%A8%8B%E5%BA%8F/" target="_blank" rel="noopener">Pytorch之GPU程序</a></p><p><a href="https://echohhhhhh.github.io/2019/12/29/%E8%BF%90%E8%A1%8CGPU%E7%A8%8B%E5%BA%8F/" target="_blank" rel="noopener">运行GPU程序</a></p><h1><span id="9-tensor">9. Tensor</span></h1><p><a href="https://echohhhhhh.github.io/2020/02/17/Pytorch%E4%B9%8BTensor%E5%AD%A6%E4%B9%A0/" target="_blank" rel="noopener">Pytorch之Tensor学习</a></p><h1><span id="10-bn和dropout在训练和测试的不同">10. BN和Dropout在训练和测试的不同</span></h1><p><code>model.train()</code>:启用 BatchNormalization 和 Dropout<br><code>model.eval()</code>:不启用 BatchNormalization 和 Dropout<br>训练完train样本后，生成的模型model要用来测试样本。在model(test)之前，需要加上model.eval()，否则的话，有输入数据，即使不训练，它也会改变权值。这是model中含有batch normalization层所带来的的性质。</p><p>参考资料<br><a href="https://zhuanlan.zhihu.com/p/54986509" target="_blank" rel="noopener">Pytorch model.train 与 model.eval</a><br><a href="https://discuss.pytorch.org/t/model-eval-vs-with-torch-no-grad/19615/19" target="_blank" rel="noopener">‘model.eval()’ vs ‘with torch.no_grad()’</a><br><a href="https://github.com/pytorch/examples/blob/master/word_language_model/main.py" target="_blank" rel="noopener">https://github.com/pytorch/examples/word_language_model</a></p><h1><span id="11-linear">11. Linear</span></h1><p>原先误以为Pytorch中的Linear的输入只能接受二维数据，实际上Linear的输入数据可以是三维、四维等更多维。但是<strong>输入数据的最后一维一定要和<code>in_dim</code>一致，输出数据维度就是把<code>in_dim</code>换成了<code>out_dim</code>，前面所有的维度都不变</strong>。<br>例如定义一个全连接<code>nn.Linear(10,5)</code>，输入数据维度为(3,6,10),输出维度为(3,6,5)。即输入数据最后一个维度一定要和<code>in_dim</code>一致，也不用纠结到底3是batch_size,还是6是batch_size，因为最终输出的数据只有最后一个维度变化，前面维度都不变。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dense = nn.Linear(in_dim,out_dim)</span><br></pre></td></tr></table></figure><hr><p>2020.3.7更新</p><h1><span id="12-embedding">12. Embedding</span></h1><p><code>Embedding</code>层常用在词嵌入中，目的是将高维数据变成稠密的低维数据。例如：字典共9个字：[我,你,看,吃,吧,吗,饭,了,的]，例句：吃饭了吗，对这句话用向量表示有2种方式：</p><ul><li>one-hot表示<br>[0,0,0,1,0,0,0,0,0],<br>[0,0,0,0,0,0,1,0,0],<br>[0,0,0,0,0,0,0,1,0],<br>[0,0,0,0,0,1,0,0,0]<br>one-hot表示过于稀疏，如果字典中的层变大，维度会非常高</li><li><p>使用<code>Embedding</code>,字典中共有9个字，下标从0~8，例句被表示为[3,6,7,5],但是只用数字并不能表示字的含义和相似度，下面使用Embedding对其嵌入。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># example with padding_idx</span></span><br><span class="line">embedding = nn.Embedding(<span class="number">9</span>, <span class="number">3</span>)</span><br><span class="line">input = torch.LongTensor([[<span class="number">3</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">5</span>]])</span><br><span class="line">embedding(input)</span><br><span class="line">tensor([[[ <span class="number">0.0000</span>,  <span class="number">0.0000</span>,  <span class="number">0.0000</span>],</span><br><span class="line">       [ <span class="number">0.1535</span>, <span class="number">-2.0309</span>,  <span class="number">0.9315</span>],</span><br><span class="line">       [ <span class="number">0.0000</span>,  <span class="number">0.0000</span>,  <span class="number">0.0000</span>],</span><br><span class="line">       [<span class="number">-0.1655</span>,  <span class="number">0.9897</span>,  <span class="number">0.0635</span>]]])</span><br></pre></td></tr></table></figure><blockquote><p>CLASS torch.nn.Embedding(num_embeddings, embedding_dim, padding_idx=None, max_norm=None, norm_type=2.0, scale_grad_by_freq=False, sparse=False, _weight=None)</p></blockquote><p><strong>num_embeddings</strong>：原始数据维度，例如字典中有9个字，该值为9<br><strong>embedding_dim</strong>：嵌入维度，每个字用3维向量表示，该值为3<br><strong>输入维度</strong>：(<em>)任意维度<br><strong>输出维度</strong>：(\</em>,embedding_dim)，*表示输入维度<br>例如输入维度(16,100),输出为(16,100,3)，表示有16个句子，每个句子100个字，经过Embedding层后，有16个句子，每个句子100个字，每个字用3维特征表示。</p><p>在时空领域中，经常需要考虑外部因素，例如时间，天气，holiday等，需要对外部因素进行Embedding，例如<a href="https://github.com/UrbComp/DeepTTE" target="_blank" rel="noopener">https://github.com/UrbComp/DeepTTE</a></p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;1-简介&quot;&gt;&lt;a href=&quot;#1-简介&quot; class=&quot;headerlink&quot; title=&quot;1. 简介&quot;&gt;&lt;/a&gt;1. 简介&lt;/h1&gt;&lt;p&gt;汇总Pytorch的一些知识点&lt;/p&gt;
    
    </summary>
    
      <category term="Deep Learning" scheme="http://yoursite.com/categories/Deep-Learning/"/>
    
    
      <category term="Pytorch" scheme="http://yoursite.com/tags/Pytorch/"/>
    
  </entry>
  
  <entry>
    <title>RiskOracle-A Minute-level Citywide Traffic Accident Forecasting Framework</title>
    <link href="http://yoursite.com/2020/02/18/RiskOracle-A-Minute-level-Citywide-Traffic-Accident-Forecasting-Framework/"/>
    <id>http://yoursite.com/2020/02/18/RiskOracle-A-Minute-level-Citywide-Traffic-Accident-Forecasting-Framework/</id>
    <published>2020-02-18T03:34:20.000Z</published>
    <updated>2020-04-03T16:06:10.102Z</updated>
    
    <content type="html"><![CDATA[<p>AAAI2020原文链接：<a href="https://github.com/zzyy0929/AAAI2020-RiskOracle" target="_blank" rel="noopener">RiskOracle-A Minute-level Citywide Traffic Accident Forecasting Framework</a><br>中国科大发<br><a id="more"></a></p><!-- TOC --><ul><li><a href="#1-%e6%91%98%e8%a6%81">1. 摘要</a></li><li><a href="#2-%e4%bb%8b%e7%bb%8d">2. 介绍</a></li><li><a href="#%e8%b4%a1%e7%8c%ae">贡献</a></li><li><a href="#3-%e9%97%ae%e9%a2%98%e5%ae%9a%e4%b9%89">3. 问题定义</a></li><li><a href="#4-minute-level-real-time-traffic-accident-forecasting">4. Minute-level Real-time Traffic Accident Forecasting</a><ul><li><a href="#41-framework-overview">4.1. Framework Overview</a></li><li><a href="#42-data-preprocessing">4.2. Data Preprocessing</a></li><li><a href="#43-multi-task-dtgn-for-accident-risk-prediction">4.3. Multi-task DTGN for Accident Risk Prediction</a></li></ul></li><li><a href="#5-%e5%ae%9e%e9%aa%8c">5. 实验</a><ul><li><a href="#51-%e6%95%b0%e6%8d%ae%e5%87%86%e5%a4%87">5.1. 数据准备</a></li><li><a href="#52-%e5%ae%9e%e7%8e%b0%e7%bb%86%e8%8a%82">5.2. 实现细节</a></li><li><a href="#53-%e8%af%84%e4%bb%b7%e6%8c%87%e6%a0%87">5.3. 评价指标</a></li><li><a href="#54-baseline">5.4. Baseline</a></li><li><a href="#55-%e5%ae%9e%e9%aa%8c%e7%bb%93%e6%9e%9c">5.5. 实验结果</a></li><li><a href="#56-%e8%b6%85%e5%8f%82%e6%95%b0">5.6. 超参数</a></li><li><a href="#57-%e6%a1%88%e4%be%8b%e5%88%86%e6%9e%90">5.7. 案例分析</a></li></ul></li><li><a href="#6-%e6%80%bb%e7%bb%93">6. 总结</a></li><li><a href="#7-%e7%9f%a5%e8%af%86%e8%a1%a5%e5%85%85">7. 知识补充</a></li></ul><!-- /TOC --><p>论文总结：</p><ol><li>根据网格构建图，将NYC划分了27*27个网格，但是其中只有354个网格有道路，所以图中有354个节点。</li><li>根据网格之间道路相似性和历史一周交通的动态相似性来构建图中边的权重。构建的是全连通图，计算任意2个子区域的相似性</li><li>多任务学习。主任务：预测m个子区域的risk，辅助任务1：预测m个子区域的flow，辅助任务2：预测q个中等区域的事故次数count</li><li>在训练时，将risk=0替换为对应的负值，使用全部的数据。在测试时，只计算高频时间段和高频区域的评价指标</li></ol><h1><span id="1-摘要">1. 摘要</span></h1><p>&ensp;&ensp;&ensp;&ensp;实时交通事故预测对公共安全和城市管理意义重大（例如.实时路径规划和应急响应部署）。之前的事故预测是在小时级别上，利用神经网络和静态的区域关系。然而，随着道路网络的高度动态性和交通师傅的稀有性，提高预测的粒度仍然是一个挑战，这将会导致结果偏差和零膨胀问题。在这篇论文中，我们提出一个新颖的RiskOracle框架，提高预测的粒度到分钟级别。具体来说，我们首先将0风险值转换为适合网络训练的值，然后，我们提出差分时变图神经网络(DTGN)来捕获交通状态的即时变化和子区间之间的动态相关性，并且，我们采用多任务和区域选择方案来突出显示全市范围内最可能发生事故的子区域，弥合了偏差的风险值和稀疏的事故分布。在2个真实数据集上做了大量实验证明了我们的RiskOracle框架的有效性和可扩展性。</p><h1><span id="2-介绍">2. 介绍</span></h1><p>&ensp;&ensp;&ensp;&ensp;交通事故预测对城市安全非常重要。构建一个细粒度级的事故预测模型，为乘客提供及时的安全路径规划，为新兴应用(智能交通和自动驾驶)提供准确的应急响应的需求越来越大。<br>&ensp;&ensp;&ensp;&ensp;关于事故预测周期的长短，现有的工作主要分为2类：长期（天级别预测）和中期（小时级别预测）。我们在表1中总结了所有相关的工作。即使最近关于天级别的预测模型通过建模时空异质数据取得了很好的效果，但是对于紧急的情况并没有意义。<br>&ensp;&ensp;&ensp;&ensp;在小时级别上的中期事故预测可以进一步划分为：传统方法和深度学习。传统方法包括：基于聚类，基于频率树，基于非负矩阵分解。但是，这些方法忽略了时间关系，不能建模复杂非线性的时空关系。深度学习方法例如，仅仅将历史交通事故数据输入到模型中，利用LSTM学习时间相关性，缺少了多源实时交通数据，效果不好。还有一些工作利用深度学习框架SDAE/SDCAE和ConvLSTM，结合人类实时移动数据，来学习交通事故模式，但是它们都不能提取区域间和区域内随时间变化的关系。<br>&ensp;&ensp;&ensp;&ensp;即使深度学习模型的进展为小时级别的事故预测带了可喜的结果，但是我们认为其忽略了3个重要的问题，使得在分钟级别的预测效果较差。第一，在2019中提到的，当预测任务的时空分辨率提高时，会出现零膨胀问题，将预测所有的结果都为0。由于没有方法来解决这个问题，稀少的非零值在训练时使模型无法生效。第二，尽管CNN可以学习静态的子区域相关性，但是随时间变化的子区域相关性在城市短期事故预测有着重要的作用，例如，由于潮汐流，2个子区域在早上相关性强，在下午相关性弱。第三，在同一子区域相邻时间段内交通状况的异常变化通常会诱发交通事故或其他事件。没有考虑以上3个时空因素，小时级别的预测模型能力将受到严重阻碍。</p><p><img src="/2020/02/18/RiskOracle-A-Minute-level-Citywide-Traffic-Accident-Forecasting-Framework/Summarization.png" alt=""></p><p>表中的论文<br><a href="https://echohhhhhh.github.io/2019/07/21/traffic-accident/#11-learning-deep-representation-from-big-and-heterogeneous-data-for-traffic-accident-inference2016aaai" target="_blank" rel="noopener">Learning Deep Representation from Big and Heterogeneous Data for Traffic Accident Inference(2016AAAI)</a></p><p><a href="https://echohhhhhh.github.io/2019/07/21/traffic-accident/#14-a-deep-learning-approach-to-the-citywide-traffic-accident-risk-prediction2018ieee-itsc" target="_blank" rel="noopener">A Deep Learning Approach to the Citywide Traffic Accident Risk Prediction(2018IEEE-ITSC)</a></p><p><a href="http://tony.9shi.cf/index.php?q=aHR0cHM6Ly93d3cua2RkLm9yZy9rZGQyMDE4L2FjY2VwdGVkLXBhcGVycy92aWV3L2hldGVyby1jb252bHN0bS1hLWRlZXAtbGVhcm5pbmctYXBwcm9hY2gtdG8tdHJhZmZpYy1hY2NpZGVudC1wcmVkaWN0aW9uLW9uLQ" target="_blank" rel="noopener">Hetero-ConvLSTM: A Deep Learning Approach to Traffic Accident Prediction on Heterogeneous Spatio-Tem(2018KDD)</a></p><p>&ensp;&ensp;&ensp;&ensp;这篇论文，我们研究了分钟级别的全市交通事故预测，提出了三阶段RiskOracle框架，该框架基于多任务差分时变图卷积(Multi-task DTGN)。三个阶段分别是：数据预处理阶段，训练阶段，预测阶段。在数据预处理阶段，我们提出一个感知策略以最大程度地推断全球交通状况，然后设计基于数据增强的先验知识来解决短期预测中的零膨胀问题。在训练阶段，我们提出Multi-task DTGN，其中时变总体上建模了短期子区域的动态相关性，差分特征生成器在交通状态即时变化和交通事故之间建立了高级联系。正如我们所知，交通事故和交通量在城市中通常分布不均衡，因此多任务方案旨在解决事故预测中的空间异质性，然后在预测阶段，我们利用学到的多尺度事故分布，获取到一组离散的最可能发生事故的子区域。在2个真实数据集上的实验证明了我们的框架在10-min和30-min级别的预测任务上都超过了state-of-the-art。</p><h1><span id="贡献">贡献</span></h1><ul><li>提升实时事故预测的时间粒度，从小时—&gt;分钟</li><li>提出多任务STDN来解决短期事故预测的挑战。这是第一篇使用图卷积来解决事故预测问题</li><li>距离远但是有潜在关系的区域在图中可以被动态连接</li><li>通过差分特征生成器，交通状况的异常变化可以被捕获</li><li>多任务学习用来解决稀疏和空间异质性问题。多尺度的事故分布可以突出强调最可能发生交通事故的子区域</li><li>提出数据增强策略来解决零膨胀问题</li><li>提出协同感知策略来处理稀疏的感知数据</li></ul><h1><span id="3-问题定义">3. 问题定义</span></h1><p>&ensp;&ensp;&ensp;&ensp;在这一节，介绍基本定义，使用公式定义问题。<br>&ensp;&ensp;&ensp;&ensp;在我们的工作中，如果直接将整个研究区域作为方形区域，使用CNN进行时空特征提取，尤其在实时事故预测中，则会导致不必要的冗余，因为城市轮廓通常是不规则的。如图2(a)所示，我们首先将路网中研究区域划分为<code>q</code>个中等大小的矩形区域，每一个矩形区域包含一些小的方形子区域。一共有<code>m</code>个子区域(subregion)，我们通过城市图对<code>m</code>个子区域建模。</p><p><strong>定义1：Urban Graph</strong>：研究区域可以定义成无向图，用$G(\mathcal{V},\mathcal{E})$表示。顶点集$\mathcal{V}=\{v_1,v_2,…,v_m\}$，其中$v_i$表示第$i$个方形子区域，给定2个节点$v_i,v_j\in \mathcal{V}$,边$e_{ij} \in \mathcal{E}$表示2个subregion的连接，边非0即1。</p><script type="math/tex; mode=display">e_{i j}=\left\{\begin{array}{ll}{1} & {\text { if the traffic elements within two }} \\ {} & {\text { subregions have strong correlations }} \\ {0} & {\text { otherwise }}\end{array}\right.</script><blockquote><p>上面邻接矩阵的定义只是为了图定义的完整性，本文用到的邻接矩阵并不是非0即1的</p></blockquote><p>&ensp;&ensp;&ensp;&ensp;在该论文中，1个节点的<code>traffic element</code>包括2方面，静态的道路特征和动态的traffic特征。$\rho$来控制<code>affinity matrix</code>$\mathcal{A}_s$和$\mathcal{A}^{\Delta t}_o$的稀疏性，表示整个<code>urban graph</code>的连通性，在<code>affinity matrix</code>中的非0值表示subregion之间有很强的相关性。<br>&ensp;&ensp;&ensp;&ensp;在一个时间段$\Delta t$中<code>subregion</code> $v_i$的动态traffic特征包括3部分，(a)人流量，用<code>traffic volume</code>$TV_{v_i}(\Delta t)$表示;(b)交通状况，用平均交通速度$a_{v_i}(\Delta t)$表示;(c)交通事故风险等级$r_{v_i}(\Delta t)$。</p><p><strong>定义2：Static Road Network Features</strong>：一个城市<code>subregion</code>节点$v_i \in \mathcal{V}$,它的静态路网特征包括道路个数，道路类型，道路长度和宽度，除雪等级，红绿灯个数，<code>subregion</code> $v_i$中的所有道路使用一个固定长度的向量$s_i$表示。整个<code>urban graph</code>的静态道路特征使用$S=\{s_1,s_2,…,s_m\}$表示。静态特征，不随着时间变化，没有时间下标。</p><p><strong>定义3：Dynamic Traffic Features</strong>：对一个<code>subregion</code>节点$v_i \in \mathcal{V}$,在时间段$\Delta t$中，它的动态交通特征被表示为$f_{v_i}(\Delta t)=\left\{T V_{v_{i}}(\Delta t), a_{v_{i}}(\Delta t), r_{v_{i}}(\Delta t)\right\}$，即该时间段的车流量，车平均速度，事故风险，$r_{v_i}(\Delta t)$是交通事故的risk求和，将交通事故分为3类：轻度，中度，重度，risk值分别是1,2,3.所有子区域在时间段$\Delta t$的交通事故风险分布表示为$\mathcal{R}(\Delta t)=\left\{r_{v_{1}}(\Delta t), r_{v_{2}}(\Delta t), \cdots, r_{v_{m}}(\Delta t)\right\}$，动态交通特征表示为$\mathcal{F}(\Delta t)=\left\{f_{v_{1}}(\Delta t), f_{v_{2}}(\Delta t), \cdots, f_{v_{m}}(\Delta t)\right\}$。动态交通特征随着时间变化，所以有区域和时间2个变量，动态特征包括：人流量，交通平均速度，事故风险</p><p><strong>定义4:Traffic Accident Prediction</strong>：给定所有子区域的静态道路特征$S$和所有子区域历史$T$个时间段的动态交通特征$\mathcal{F}(\Delta t)(\Delta t=1,2,…,T)$,目标是预测下一个时间段全市的事故风险$\mathcal{R}(T+1)$和选出高风险的子区域$\mathcal{V}_{acc}(T+1)$</p><blockquote><p>总结：根据m个子区域构建无向图，节点表示子区域，边表示2个子区域特征之间的相关性。子区域的特征包括2类：静态道路特征和动态交通特征。静态道路特征包括：道路个数，道路类型，长宽，道路除雪等级，红绿灯个数。动态交通特征包括：在该时间段内的车流量，车平均速度，该子区域事故风险。</p></blockquote><h1><span id="4-minute-level-real-time-traffic-accident-forecasting">4. Minute-level Real-time Traffic Accident Forecasting</span></h1><p>&ensp;&ensp;&ensp;&ensp;在这一节，先整体看一下我们的<code>RiskOracle</code>框架，然后再详细介绍。</p><p><img src="/2020/02/18/RiskOracle-A-Minute-level-Citywide-Traffic-Accident-Forecasting-Framework/RiskOracle.png" alt=""></p><h2><span id="41-framework-overview">4.1. Framework Overview</span></h2><p>&ensp;&ensp;&ensp;&ensp;如图1所示，<code>RiskOracle</code>框架包括3个阶段：数据预处理阶段，训练阶段，预测阶段。</p><h2><span id="42-data-preprocessing">4.2. Data Preprocessing</span></h2><p><strong>解决事故预测中的空间异质</strong>。高风险的值通常出现在城市区域，由于市中心发生事故多且车流量大，导致风险值在空间上不均衡，会忽略农村地区相对高风险的区域。为了实现全市预测，选择最有可能发生事故的区域来解决空间异质性是非常必要的。如图2(a)所示,按照层次结构组织这个子区域，中等大小区域用来收集粗粒度的事故分布，小的子区域用来收集细粒度的事故分布，然后进一步突出显示每个中等区域中的子区域。多尺度分布也可以看做分层事故分布。<br><strong>解决零膨胀问题</strong>。深度神经网络在训练中，如果非零值非常少的话，受到零膨胀的影响，将会预测出无效的值。如图2(b)所示，在选定的10min中，整个NYC只有6个交通事故，说明在短期事故的内在稀有性。为了解决这个问题实现实时事故预测，我们设计基于先验知识的数据增强(PKDE)策略来区分训练数据集中标签的风险值。具体来说，对时间段$\Delta t$,我们将所有区域在该时间段内的风险值$\mathcal{R}(\Delta t)$中的0转换为具有区分度的负值。转换分为2步：a)风险中的0值通过等式2转换为事故风险指标；b)指标值通过等式3转换为静态事故强度。给定子区域$v_i$，我们计算它的事故风险指标$\varepsilon_{v_i}$  ，事故风险指标是个比例值，在[0,1]之间</p><script type="math/tex; mode=display">\varepsilon_{v_{i}}=\frac{1}{N_{\text {week}}} \sum_{j=1}^{N_{\text {week}}} \frac{r_{v_{i}}(j)}{\sum_{k=1}^{m} r_{v_{k}}(j)}</script><p>其中$N_{week}$是训练集中总共的周数，$r_{v_{i}}(j)$是区域$v_i$在第$j$周总的风险值。然后，根据该子区域的事故风险指标$\varepsilon_{v_i}$,我们通过以下公式计算子区域$v_i$的统计事故强度。  </p><script type="math/tex; mode=display">\pi_{v_{i}}=b_{1} \log _{2} \varepsilon_{v_{i}}+b_{2}</script><blockquote><p>总结：给定时间段$\Delta t$，将子区域中的riks 0值转换为负值，先计算事故风险指标，再计算事故强度。有m个子区域，每个子区域都有一个固定的事故强度，将该子区域risk=0值用该子区域的事故强度替换</p></blockquote><p>其中$b_1$和$b_2$是算子，用来保持绝对值$\pi_{v_{i}}$的范围和真实风险值的范围对称。我们通过对数在0和1之间的区分性质，可以使转换后的数据易于区分并适合于训练网络。转换的方式为：1)事故风险为0的子区域的事故强度为负，小于非零风险的子区域，反映了零风险子区域有较低的事故风险;2)具有较低事故风险指标的子区域有较低的事故概率，保留了实际事故风险的等级。<br>事故风险指数$\varepsilon_{v_{i}}$值在[0,1]之间，取对数值在$(-\infin,0]%$，如果一个子区域的风险值为0，则事故风险指数为0，则事故强度$\pi_{v_{i}}$为负。</p><blockquote><p>其中b1和b2的值是反复试出来的。为了保证事故强度的绝对值和真实风险范围对称。假设真实风险在1至25之间，那事故强度的值要在-25至-1之间，通过设置b1和b2强度值在-25~-1</p></blockquote><p><img src="/2020/02/18/RiskOracle-A-Minute-level-Citywide-Traffic-Accident-Forecasting-Framework/nyc-map.png" alt=""></p><p><strong>补充稀疏的传感数据</strong>。实时交通信息的通常收集不足来进行事故预测，动态交通信息通常和静态空间路网结构相互影响，因此，我们提出了一个协同感知策略，利用FM的交互操作，修改<code>xDeepFM</code>为时空深度因式分解(ST-DFM)。<br>我们首先通过静态关联矩阵$\mathcal{A}_s$来提取2个子区域间的路网相似性和连接性。其中关联矩阵affinity matrix中的元素$\alpha_s(i,j)$表示子区域$v_i和v_j$间的静态相关性。</p><script type="math/tex; mode=display">\alpha_{s}(i, j)=\left\{\begin{array}{cc}{1} & {\text { if subregion } v_{i} \text { and }} {v_{j}} {\text { are adjacent }} \\{e^{-J S\left(s_{i} \| s_{j}\right)}} & {\text { otherwise }}\end{array}\right.</script><p>其中，$JS$函数是Jensen-Shannon divergence（散度），$s_{i}和s_{j}$是子区域$i,j$的静态道路特征，包括道路个数，类型，长宽，除雪等级，红绿灯个数。</p><script type="math/tex; mode=display">J S\left(s_{i} \| s_{j}\right)=\frac{1}{2} \sum_{k}\left(\begin{array}{c}{s_{i}(k) \log \frac{2 s_{i}(k)}{s_{i}(k)+s_{j}(k)}+} \\{s_{j}(k) \log \frac{2 s_{j}(k)}{s_{i}(k)+s_{j}(k)}}\end{array}\right)</script><p>和xDeepFM一样，ST-DFM包含压缩交互网络模块和DNN模块。在ST-DFM中嵌入了3个时空字段，即静态空间特征，动态交通特征和时间戳。然后ST-DFM通过CIN模块学习矢量级别不同时空特征间的交互关系，通过DNN模块学习特征的高级表示，最后获取高级特征的组合。我们将对应子区间的交通量输入到ST-DFM中来推断速度值，反之亦然。然后通过训练2个实时交通数据的交集数据，来最大程度推断交通信息，以此获取全局交通状态。</p><blockquote><p>补充：JS散度是一个衡量距离的函数，JS散度的值域在[0,1]之间，相同为0，反之为1。静态affinity matrix $\mathcal{A}_s \in R^{m \times m}$，如果2个子区域相邻，值为1，不相邻则计算2个子区域的静态道路特征的相似度，值在$[\frac{1}{e},1]$之间，越相似，值越靠近1，越不相似，值越靠近$\frac{1}{e}$<br>通过静态道路特征构建一个全连接图，任意2个节点都有边相连，只是权重不同。如果2个子区域相邻，边权重为1，如果子区域不相邻，计算2个子区域间的JS散度</p></blockquote><h2><span id="43-multi-task-dtgn-for-accident-risk-prediction">4.3. Multi-task DTGN for Accident Risk Prediction</span></h2><p><strong>时空DTGN</strong>.事故和交通拥堵在路网中通常相互影响，特别是节假日和高峰。由于GCN对非欧式空间很好的建模，我们提出了DTGN，通过time-varying overall affinity和differential feature generator来修改GCN，解决分钟级别预测事故的挑战。</p><p><strong>Time-varying overall affinity matrix with dynamic traffic features involved</strong>. 不同城市分区之间的交通状况有很强的时变相关性。并且，交通事故和交通状况有很强的时空相关性。因此，对于分钟级别的事故预测，需要通过动态affinity matrix $\mathcal{A}^{\Delta t}_o$捕获子区域间在时间段$\Delta t$的时间交通相关性。在$\mathcal{A}^{\Delta t}_o$中的元素$\alpha^{\Delta t}_o(i,j)$表示子区域$i,j$的动态相似性。</p><script type="math/tex; mode=display">\alpha_{O}^{\Delta t}(i, j)=e^{-J S\left(s_{i}^{*} \| s_{j}^{*}\right)}+\gamma * e^{-J S\left(C_{i}^{\Delta t} \| C_{j}^{\Delta t}\right)}</script><p>其中$C_{i}^{\Delta t}$表示子区域$v_i$上周每一天相同时间段的交通量$TV_{v_i}(\Delta t)$和平均速度$a_{v_i}(\Delta t)$。注意我们使用Attention机制，根据子区域的静态空间特征对事故的影响，修改了子区域静态空间特征的权重。并且子区域的静态特征表示为$s^*_i$.权重$\gamma$用来调节动态交通affinity占overall affinity matrix的比例。通过overall affinity matrix，距离较远但有潜在事故相关的子区域可以被动态连接。为了在谱域运行GCN，我们需要计算动态affinity matrix $\mathcal{A}^{\Delta t}_o$的拉普拉斯矩阵$L^{\Delta t}$，其中$\mathcal{A}^{\Delta t}_o$可以被看做邻接矩阵。首先定义$\mathcal{B}^{\Delta t}$</p><script type="math/tex; mode=display">\mathcal{B}^{\Delta t}=\mathcal{A}_{o}^{\Delta t}+I_{m}</script><p>其中$I_{m}$是维度$m \times m$的单位矩阵。然后计算度矩阵$\Phi^{\Delta t}$</p><script type="math/tex; mode=display">\Phi^{\Delta t}=\left[\begin{array}{cccc}{\varphi_{11}} & {0} & {\cdots} & {0} \\{0} & {\varphi_{22}} & {\cdots} & {0} \\{\vdots} & {\vdots} & {\ddots} & {\vdots} \\{0} & {0} & {\cdots} & {\varphi_{m m}}\end{array}\right]</script><p>其中$\varphi_{i i}=\sum_{j=1}^{m} b_{i j}$，将矩阵$\mathcal{B}^{\Delta t}$每一行的元素相加组成度矩阵。然后获取时间段$\Delta t$的拉普拉斯矩阵。</p><script type="math/tex; mode=display">L^{\Delta t}=\left(\Phi^{\Delta t}\right)^{-\frac{1}{2}} \mathcal{B}^{\Delta t}\left(\Phi^{\Delta t}\right)^{-\frac{1}{2}}</script><blockquote><p>补充：原始GCN中，拉普拉斯矩阵为$\hat{D}^{-\frac{1}{2}}\hat{A}\hat{D}^{-\frac{1}{2}}$，其中$\hat{A}=A+I$</p><p>总结：文中提到的affinity matrix有2类：静态affinity matrix $\mathcal{A}_s$和动态overall affinity matrix $\mathcal{A}_o^{\Delta t}$，这2个矩阵的维度都是$R^{m \times m}$，其中静态affinity matrix不随着时间变化，根据子区域的静态道路特征计算得到。动态overall affinity matrix随着时间变化，由子区域的静态道路特征和上周每一天同时间段的动态交通特征(车流量和车平均速度)计算得来。这里将动态overall affinity matrix看做邻接矩阵，计算拉普拉斯矩阵，每个时间段都有一个拉普拉斯矩阵，用在GCN中。</p></blockquote><p><strong>Differential GCN for extracting spatiotemporal features</strong>和常规的交通状况相比，事故或事件预测和交通状况的异常变化更相关。因此，我们引入了差分特征生成器来计算相邻时间段的差分图片。将差分动态交通特征输入到GCN中，可以对交通状况的异常变化的传播和相互作用进行建模，并且可以学习即时的交通状态变化和事故之间的高层关系，可以更好地用来分钟级的事故预测。给定时间段$\Delta t$,差分向量$\vec{\Theta}^{\Delta t}$计算如下：</p><script type="math/tex; mode=display">\vec{\Theta}^{\Delta t}=\mathcal{D}(\Delta t)-\mathcal{D}(\Delta t-1)</script><p>其中$\mathcal{D}(\Delta t)=\left\{d_{v_{1}}(\Delta t), d_{v_{2}}(\Delta t), \cdots, d_{v_{m}}(\Delta t)\right\}$,$d_{v_{i}}(\Delta t)=\left\{T V_{v_{i}}(\Delta t), a_{v_{i}}(\Delta t)\right\}$，差分不涉及到事故风险的计算。在时间段$\Delta t$中所有的子区域通过结合它们的动态交通特征和对应的差分向量，生成了统一的特征元组$\mathcal{U}(\Delta t)=\left\{\mathcal{F}(\Delta t), \vec{\Theta}^{\Delta t}\right\}$,在郑宇AAAI2017 ST-ResNet文中提到的，城市交通有3个时间周期：小时，天，长期趋势。所以，预测时间段$\Delta t$，我们选取$\mathcal{k}$个统一特征元组，按照ST-ResNet，设置$\mathcal{k}=3$,作为DTGN的输入。具体来说，选取时间段$\Delta t$的前$\mathcal{k}$个时间段作为小时周期，选取连续前$\mathcal{k}$天中相同的时间段作为天周期，至于长期趋势，向前每10天取1天，一共取$\mathcal{k}$天,在这$\mathcal{k}$天种，取相同的时间段作为长期趋势。即hour周期有$\mathcal{k}$个时间段,天周期有$\mathcal{k}$个时间段，长期区域有$\mathcal{k}$个时间段。如图1所示，将这3个时间周期的二元组分别输入到3个DTGN中。其中DTGN的模型细节在图3(a)中。对于每一个时间周期，将它的特征二元组用$\mathbb{U}_{<em>} \Delta t$表示，将$\mathbb{U}_{</em>} \Delta t$输入到FCN中，将特征嵌入成低维特征，然后输入到GCN中。</p><script type="math/tex; mode=display">\mathcal{H}^{n+1}=\text{Leaky-ReLU}(L^*  \mathcal{H}^{n} \mathcal{W}^{n}),\text { where } \mathcal{H}^{0}=\mathbb{U}_{*}^{\Delta t}</script><p>其中$\mathcal{H}^{n}$表示第n层GCN输入的特征，$\mathcal{W}^{n}$表示第n层GCN的卷积核参数。因为每个时间周期会输出多个时间段的数据，在做GCN操作时，需要用到拉普拉斯矩阵，这里的$L^*$是输入所有时间段的拉普拉斯矩阵$L^{\Delta t}$的平均。每2个GCN后使用1次BN，防止梯度爆炸。考虑到转换后的risk中有负值，使用Leaky_ReLU激活。同时，对应时间段的外部数据(时间戳和天气)经过嵌入层变成定长的向量，再和GCN的输入融合。因为有3个时间周期，DTGN有3个输出，分别用$\mathcal{O}_{h c}^{\Delta t}, \mathcal{O}_{d p}^{\Delta t}$ and $\mathcal{O}_{d t}^{\Delta t}$表示。</p><p><img src="/2020/02/18/RiskOracle-A-Minute-level-Citywide-Traffic-Accident-Forecasting-Framework/DTGN.png" alt=""></p><blockquote><p>总结：每一个时间段有一个差分向量，是该时间段所有区域的车流量和车平均速度减去上一时间段的值，得到差分向量。然后将该时间段所有子区域的动态交通特征$\mathcal{F}(\Delta t)$和该时间段的差分向量$\vec{\Theta}^{\Delta t}$组成一个统一的特征元组$\mathcal{U}(\Delta t)$。那么每个时间段都有一个特征元组，存储所有子区域的特征。受郑宇2017AAAI ST-ResNet的启发，事故的发生有小时，天，长期的周期性，假设预测时间段是t，为其找出小时，天，长期的时间段。小时周期：[t-1,t-2,t-3]，天周期：[昨天t,前天t,大前天t]，长期周期[10天前t,20天前t,30天前t],然后分别输入到3个DTGN中。这个拿1个DTGN举例。输入的图信号矩阵维度是(batch_size,N,T<em>D)=(batch_size,N,3\</em>5)将时间维度乘到特征上，先经过FCN对特征进行嵌入，变成低维特征。然后输入到GCN中，GCN操作需要使用拉普拉斯矩阵。上节中提到拉普拉斯矩阵是动态的，每一个时间段都有一个L，这里每个周期都有3个时间段，使用的拉普拉斯矩阵是3个时间段拉普拉斯矩阵的平均值。<br>预测第t时间段的risk，输入的图信号矩阵：<br>小时周期：<br>t-1,t-2,t-3时刻：车流，车速，risk，$\Delta$车流，$\Delta$车速<br>天周期：<br>昨天t，前天t，大前天t时刻：车流，车速，risk，$\Delta$车流，$\Delta$车速<br>周周期：<br>10天前t，20天前t，30天前t时刻：车流，车速，risk，$\Delta$车流，$\Delta$车速<br>一共有3个组件，每个组件输入的维度是(batch_size,N,3*5)</p></blockquote><p><strong>多任务学习来事故风险预测</strong>设计多任务学习方案，不仅可以增强深度学习的表示能力，还可以学到分层事故分布，为最可能发生事故区域的选取提供指导。为了预测子区域的事故风险，我们首先<strong>将事故风险分布作为主任务</strong>。考虑到交通事故和人类活动强度有关，我们将<strong>区域交通量预测作为第一个辅助任务</strong>，用来提高深度学习的表示能，。为了给分层事故区域的选取提供指导，将<strong>预测中等区域发生的事故总数作为第二个辅助任务</strong>。<br>具体地，我们将DTGN的3个输出$\mathcal{O}_{h c}^{\Delta t}, \mathcal{O}_{d p}^{\Delta t}$ and $\mathcal{O}_{d t}^{\Delta t}$输入到卷积融合模块中，然后进行多任务学习，如图3(b)所示，3个多任务shared是3个DTGN的输出结果。将3个输出结果分别输入到3个融合模块中，3个融合模块的参数是$\mathcal{W}_{risk}^{\Delta t},\mathcal{W}_{vol}^{\Delta t},\mathcal{W}_{count}^{\Delta t}$，首先生成每个子区域的预测风险$\mathcal{O}_{\text {risk}}^{\Delta t}$,使用$Leaky_ReLU$激活是因为label中的risk值有负值，其余都使用$ReLU$激活。然后生成每个子区域的预测流量$\mathcal{O}_{v o l}^{\Delta t}$，然后预测每个中等区域的风险次数，先经过融合模块，再经过全连接，生成$\mathcal{O}_{\text {count}}^{\Delta t}$</p><script type="math/tex; mode=display">\mathcal{O}_{r i s k}^{\Delta t}=\text { Leaky } \operatorname{ReLU}\left(\mathcal{W}_{risk}^{\Delta t} *\left[\mathcal{O}_{h c}^{\Delta t}, \mathcal{O}_{d p}^{\Delta t}, \mathcal{O}_{d t}^{\Delta t}\right]\right)</script><script type="math/tex; mode=display">\mathcal{O}_{v o l}^{\Delta t}=\operatorname{ReLU}\left(\mathcal{W}_{v o l}^{\Delta t} *\left[\mathcal{O}_{h c}^{\Delta t}, \mathcal{O}_{d p}^{\Delta t}, \mathcal{O}_{d t}^{\Delta t}\right]\right)</script><script type="math/tex; mode=display">\mathcal{O}_{\text {count}}^{\Delta t}=\operatorname{ReLU}\left(\mathcal{W}_{f c}^{\Delta t} *\left(\mathcal{W}_{\text {count}}^{\Delta t} *\left[\mathcal{O}_{h c}^{\Delta t}, \mathcal{O}_{d p}^{\Delta t}, \mathcal{O}_{d t}^{\Delta t}\right]\right)\right)</script><p>$\mathcal{O}_{\text {count}}^{\Delta t}$是中等区域的事故次数，将其输入到另一个全连接中，reshape成和$\mathcal{O}_{\text {risk}}^{\Delta t}$相同维度，和原先的细粒度事故分布相加，迫使学习粗粒度和细粒度的事故分布之间的关系。最终$\mathcal{O}_{\text {risk}}^{\Delta t}$被更新为</p><script type="math/tex; mode=display">\mathcal{O}_{risk*}^{\Delta t}=\text { Leaky } \operatorname{ReLU}\left(\mathcal{W}_{f c *} * \mathcal{O}_{c o u n t}^{\Delta t}+\mathcal{O}_{r i s k}^{\Delta t}\right)</script><p>其中$\mathcal{O}_{risk*}^{\Delta t}$是最终主任务的输出。</p><p><img src="/2020/02/18/RiskOracle-A-Minute-level-Citywide-Traffic-Accident-Forecasting-Framework/multitask.png" alt=""></p><p>多任务的总loss如下：</p><script type="math/tex; mode=display">\operatorname{Loss}(\theta)=m s e_{r i s k}+\lambda_{1} * m s e_{v o l}+\lambda_{2} * m s e_{c o u n t}+\lambda_{3} * L_{2}</script><p>其中$m s e_{r i s k}, m s e_{v o l},m s e_{c o u n t}$是主任务和2个辅助任务的loss，这里使用L2正则化来避免过拟合。$\lambda_{1},\lambda_{2},\lambda_{3}$是损失函数的超参数。$\lambda_{1}=0.8,\lambda_{2}=1,\lambda_{3}=1e-4$。</p><blockquote><p>只根据risk，count，flow的MSELoss进行反向传播，训练模型。在预测时，根据这3个输出，求出评价指标</p></blockquote><p><strong>分层最可能发生事故区域选择</strong>.交通事故和交通量在城市和农村经常不均衡，导致空间异质性问题。因此，用统一的风险阈值来选择最可能发生事故的区域是不合理的，我们基于多任务中预测出的risk，提出一个分层的最可能发生事故区域选择的方法。<br>输入数据是中等区域的事故次数和子区域的risk值，对每个中等区域$i$，我们从中选出$k_i(i=1,2,…,q)$个风险最高的子区域，其中参数$k_i$等于第二个辅助任务学到的$\mathcal{O}_{\text {count}}^{\Delta t}$中对应的值。因此，我们获得了一组最可能发生事故的子区域。并且通过这种方式获得的$k_i$可以减少区域的过度预测，并且模型符合时间和天气的变化。</p><blockquote><p>对于$k_i$的选择这里解释下：在测试阶段，根据q个中等区域的事故数和m个子区域的risk值来选择$k_i$，假设q=5，预测出来5个中等区域发生的事故次数为[0,2,4,1,6],那就从5个中等区域中，分别选0,2,4,1,6个子区域，选risk最高的$k_i$个对应的子区域，就是模型预测的事故高发子区域</p><p>在模型训练阶段，只预测子区域的risk，子区域的flow，中等区域的count来计算loss，训练模型。在训练阶段，并不预测发生事故最高的区域。预测发生事故最高的区域，只在测试集上进行。在训练集和验证集上，将risk中的0替换掉训练模型，在测试集上，不需要将risk=0替换掉，因为在测试集上我们只需要找出topK就可以了。</p></blockquote><h1><span id="5-实验">5. 实验</span></h1><p>分钟级别的事故预测模型，设置时间段分别为10min和30min</p><h2><span id="51-数据准备">5.1. 数据准备</span></h2><p>在2个真实数据集上做实验：NYC Opendata和苏州工业园区(SIP)。对于NYC数据集，由于缺少实时的交通流量数据，这里利用每个子区域的出租车流量来代表人流量。对于SIP数据集，它包含交通流量和速度。我们将其从新浪收集的交通事故数据集集成。2个数据集的统计信息在表2中。</p><p><img src="/2020/02/18/RiskOracle-A-Minute-level-Citywide-Traffic-Accident-Forecasting-Framework/dataset.png" alt=""></p><h2><span id="52-实现细节">5.2. 实现细节</span></h2><p>训练集:验证集:测试集=6:1:3，划分子区域参照AAAI2019<a href="https://echohhhhhh.github.io/2019/03/05/Spatiotemporal-Multi-Graph-Convolution-Network-for-Ride-hailing-Demand-Forecasting/" target="_blank" rel="noopener">Spatiotemporal Multi-Graph Convolution Network for Ride-hailing Demand Forecasting</a>和实际情况。堆叠9层GCN，每层有384个filter。损失函数中$\lambda_{1}=0.8,\lambda_{2}=1,\lambda_{3}=1e-4$。优化器使用Adam。</p><p>在训练阶段，动态交通数据和affinity matrix被划分为小时，天，长期共3组，2种scale的事故分布输入到多任务DTGN中。在测试阶段，将数据组织成以上格式并输入到模型中，最有可能发生事故的子区域可以从主任务和辅助任务2中得到。高风险子区域被突出显示，并与实际的事故记录比较。</p><h2><span id="53-评价指标">5.3. 评价指标</span></h2><p>从2个角度验证RiskOracle模型，回归角度：MSE，分类角度：a)Acc@M，常用于时空排名任务中，表示m个子区域中，预测的前M个风险最高的子区域中正确的比例。NYC数据集中，在30min预测时，M=20，在10min预测时，M=6。在SIP数据集中，M=5。b)Acc@K,其中K是第二个辅助任务学到的$k_i$的总和。其中Acc1表示发生事故频率较高时间段的准确率，例如早上7~9点，下午12~4点。</p><blockquote><p>测试时，$Acc@M$：每个时间步从m个子区域中选出M个事故高发的区域，然后看选对了多少。M是全局选M个，每个中等子区域选多少个并不限制。$Acc@K$，只针对高频时间段计算该指标。假设在一个时间段中辅助任务2预测结果为[0,2,4,1,6],即K=13，从m个子区域中选出13个，但是每个中等子区域要选$k_i$个。</p></blockquote><h2><span id="54-baseline">5.4. Baseline</span></h2><ol><li>ARIMA，用于时间序列预测</li><li>Hetero-ConvLSTM(2018KDD),调整超参数为4,blocks with 16 filters, and a size of 12x12 moving window with step=6.</li><li>ST-ResNet(2017AAAI郑宇)用来预测车流量</li><li>SDAE(2016AAAI)使用人流量来预测risk</li><li>SDCAE最新的小时级别风险预测模型</li></ol><h2><span id="55-实验结果">5.5. 实验结果</span></h2><p><strong>性能比较</strong><br>实验结果如表3.RiskOracle获得了最高的准确率，且MSE优于大部分baseline。使用分层事故区域选择HARS，我们的模型解决了空间异质性和过度预测的问题。尤其在NYC数据集上，我们模型在Acc@20比最好的模型高22.49%。对于稀疏的传感数据和短期的时空预测，可扩展性高。并且，我们的模型在高峰期的预测更好，在现实应用中有用。所有的指标NYC的都比SIP的要好，可能因为SIP数据中事故标签不完整。<br>总体上，随着时间粒度变小，我们的模型性能稍微下降，而其他的模型急剧下降因为遇到零膨胀问题。这表明我们的模型在短期事故预测中的有效性和可扩展性。在实际应用中有很少的事故记录时，2个数据集上的提升验证了我们模型的健壮性和普适性。</p><p><img src="/2020/02/18/RiskOracle-A-Minute-level-Citywide-Traffic-Accident-Forecasting-Framework/result.png" alt=""></p><p><strong>Acc@K和消融实验</strong>.如图4所示。Acc@20和Acc@6的结果略高于Acc@K，这是合理的，因为统一阈值无法适应实时条件，并且往往会高估事故率。相反，我们的框架具有使用多尺度事故分布预测，近似估计每个矩形区域中事故数量，具有灵活性。与表3中的结果相比，我们的框架胜过其他baseline，并在Acc@K达到可接受的准确性水平。<br>为了验证哪个组件起作用，做了消融实验，从模型中去掉一些组件。</p><ul><li>RO-1：去掉基于先验知识的数据增强PKDE，无法解决零膨胀问题。priori knowledge-based data enhancement</li><li>RO-2：去掉ST-DFM，无法解决实时交通数据缺失问题</li><li>RO-3：去掉overall affinity，无法实现时变的GCN,即图的邻接矩阵是静态的</li><li>RO-4：去掉差分特征生成器，在输入到GCN中没有差分特征</li><li>RO-5：去掉带有HARS的多任务</li><li>Integrated model：完整模型<br>其中最重要的组件是overall affinity和PKED，说明零膨胀和时变GCN是重要的。</li></ul><p><img src="/2020/02/18/RiskOracle-A-Minute-level-Citywide-Traffic-Accident-Forecasting-Framework/ablation.png" alt=""></p><h2><span id="56-超参数">5.6. 超参数</span></h2><p>在NYC数据集的30min展示超参数实验。</p><ul><li>9层GCN，每层有384个filter</li><li>损失函数中$\lambda_{1}=0.8,\lambda_{2}=1,\lambda_{3}=1e-4$</li><li>计算overall affinity时动态元素占的比重$\gamma=0.5$</li><li>中等区域个数$q=18$</li></ul><h2><span id="57-案例分析">5.7. 案例分析</span></h2><p>可视化NYC2017.5.22这一天中选取的3个30min时间段。上面是预测值，下面是真实值。可以看到预测的高风险子区域和真实值相似。由于在周日上午很少人外出，因此早晨7:00预测发生的事故很少。但是，下午事故数量会增加，而到了晚上，事故更加严重，由于当晚大雨，路况易发生事故。结果证明，辅助任务和HARS通过捕获外部因素，来学习事故分布的动态模式，调整推理，比统一阈值解决方案具有更好的适应性。</p><p><img src="/2020/02/18/RiskOracle-A-Minute-level-Citywide-Traffic-Accident-Forecasting-Framework/case.png" alt=""></p><h1><span id="6-总结">6. 总结</span></h1><p>在这篇论文中，我们提出了基于多任务DTGN的RiskOracle框架，解决分钟级的事故预测问题。首先提出2个方法来解决零膨胀和稀疏感知的问题。在多任务DTGN中，结合差分特征生成器和时间overall affinity，模型可以建模稀疏的时空数据，捕获短期的子区域相关性。学习多尺度事故分布，突出显示最可能发生事故的子区域来解决空间异质性。在2个真实数据集上的实验验证模型的优越性。</p><h1><span id="7-知识补充">7. 知识补充</span></h1><p><strong>【Factorization Machine】</strong> FM (Factorization Machine) 主要是为了解决数据稀疏的情况下，特征怎样组合的问题。<br><a href="https://zhuanlan.zhihu.com/p/80726100" target="_blank" rel="noopener">【推荐系统】Factorization Machine</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;AAAI2020原文链接：&lt;a href=&quot;https://github.com/zzyy0929/AAAI2020-RiskOracle&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;RiskOracle-A Minute-level Citywide Traffic Accident Forecasting Framework&lt;/a&gt;&lt;br&gt;中国科大发&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="论文阅读笔记" scheme="http://yoursite.com/categories/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="时空领域" scheme="http://yoursite.com/tags/%E6%97%B6%E7%A9%BA%E9%A2%86%E5%9F%9F/"/>
    
  </entry>
  
  <entry>
    <title>时空论文列表</title>
    <link href="http://yoursite.com/2020/02/18/%E6%97%B6%E7%A9%BA%E8%AE%BA%E6%96%87%E5%88%97%E8%A1%A8/"/>
    <id>http://yoursite.com/2020/02/18/时空论文列表/</id>
    <published>2020-02-17T16:17:25.000Z</published>
    <updated>2020-02-18T08:32:08.173Z</updated>
    
    <content type="html"><![CDATA[<h1><span id="简介">简介</span></h1><p>以下列出AAAI2020和ICLR2020关于时空领域的论文<br><a id="more"></a></p><h1><span id="aaai2020">AAAI2020</span></h1><p><strong>[1]. RiskOracle: A Minute‐level Citywide Traffic Accident Forecasting Framework</strong><br><a href="https://github.com/zzyy0929/AAAI2020-RiskOracle" target="_blank" rel="noopener">https://github.com/zzyy0929/AAAI2020-RiskOracle</a></p><blockquote><p>Zhengyang Zhou (University of Science and Technology of China); Yang Wang (University of Science and<br>Technology of China)*; Xike Xie (University of Science and Technology of China); Lianliang Chen (University of<br>Science and Technology of China); Hengchang Liu (USTC)</p></blockquote><p><strong>[2]. GMAN: A Graph Multi-­Attention Network for Traffic Prediction</strong><br><a href="https://github.com/zhengchuanpan/GMAN" target="_blank" rel="noopener">https://github.com/zhengchuanpan/GMAN</a></p><blockquote><p>Chuanpan Zheng (Xiamen University); Xiaoliang Fan (Xiamen University)*; Cheng Wang (Xiamen University);<br>Jianzhong Qi (The University of Melbourne)</p></blockquote><p><strong>[3]. Multi-­Range Attentive Bicomponent Graph Convolutional Network for Traffic Forecasting</strong><br><a href="https://github.com/naganandy/graph-based-deep-learning-literature/blob/master/conference-publications/folders/publications_aaai20/mrabgcn_aaai20/README.md" target="_blank" rel="noopener">https://github.com/naganandy/graph-based-deep-learning-literature/blob/master/conference-publications/folders/publications_aaai20/mrabgcn_aaai20/README.md</a><br><a href="https://arxiv.org/abs/1911.12093?context=cs" target="_blank" rel="noopener">https://arxiv.org/abs/1911.12093?context=cs</a></p><blockquote><p>Weiqi Chen (Zhejiang University); Ling Chen (Zhejiang University)*; Yu Xie (Alibaba Cloud); Wei Cao (Alibaba);<br>Yusong Gao (Alibaba Cloud); Xiaojie Feng (Alibaba Cloud)</p></blockquote><p><strong>[4]. Spatio­‐Temporal Graph Structure Learning for Traffic Forecasting</strong></p><blockquote><p>Qi Zhang (institute of automation, Chinese academy of science)*; Jianlong Chang (National Laboratory of Pattern<br>Recognition, Institute of Automation, Chinese Academy of Sciences); Gaofeng Meng (Chinese Academy of<br>Sciences); SHIMING XIANG (Chinese Academy of Sciences, China); Chunhong Pan (Institute of Automation, Chinese<br>Academy of Sciences)</p></blockquote><p><strong>[5]. Pay Your Trip for Traffic Congestion: Dynamic Pricing in Traffic­‐Aware Road Networks</strong></p><blockquote><p>Lisi Chen (HKBU)*; Shuo Shang (KAUST); Bin Yao (“Shanghai Jiaotong University, China”); Jing Li (Inception Institute<br>of Artificial Intelligence)</p></blockquote><p><strong>[6]. Self­‐Attention ConvLSTM for Spatiotemporal Prediction</strong></p><blockquote><p>Zhihui Lin (Tsinghua University)*; Maomao Li (Tsinghua university); Zhuobin Zheng ( Tsinghua University);<br>Yangyang Cheng (Tsinghua University); Chun Yuan (Tsinghua University)</p></blockquote><p><strong>[7]. An Attentional Recurrent Neural Network for Personalized Next Location Recommendation</strong></p><blockquote><p>Qing Guo (Nanyang Technological University)*; Zhu Sun (Nanyang Technological University); Jie Zhang (Nanyang<br>Technological University); Yin-­‐Leng Theng (Nanyang Technological University)</p></blockquote><p><strong>[8]. Spatial­‐Temporal Synchronous Graph Convolutional Networks: A New Framework for Spatial-­‐Temporal Network Data Forecasting</strong><br><a href="https://github.com/Davidham3/STSGCN" target="_blank" rel="noopener">https://github.com/Davidham3/STSGCN</a></p><blockquote><p>Chao Song (Beijing Jiaotong University)*; Youfang Lin (Beijing Jiaotong University); Shengnan Guo (Beijing Jiaotong<br>University); Huaiyu Wan (Beijing Jiaotong University)</p></blockquote><p><strong>[9]. STGRAT: A Spatio-Temporal Graph Attention Network for Traffic Forecasting</strong><br><a href="https://arxiv.org/abs/1911.13181" target="_blank" rel="noopener">https://arxiv.org/abs/1911.13181</a></p><blockquote><p>Cheonbok Park1, Chunggi Lee2, Hyojin Bahng1, Taeyun won1,<br>Kihwan Kim2, Seungmin Jin2, Sungahn Ko2, Jaegul Choo1<br>1 Korea University , 2 UNIST</p></blockquote><p><strong>[10]. Semi-Supervised Hierarchical Recurrent Graph Neural Network for City-Wide Parking Availability Prediction</strong><br><a href="https://arxiv.org/abs/1911.10516" target="_blank" rel="noopener">https://arxiv.org/abs/1911.10516</a></p><blockquote><p>Weijia Zhang (University of Science and Technology of China); Hao LIU (Business Intelligence Lab, Baidu<br>Research)*; Yanchi Liu (Rutgers University); Jingbo Zhou (Baidu Inc.); Hui Xiong (Rutgers University)</p></blockquote><p><strong>[11]. RoadTagger: Robust Road Attribute Inference with Graph Neural Networks</strong><br><a href="https://arxiv.org/abs/1912.12408" target="_blank" rel="noopener">https://arxiv.org/abs/1912.12408</a></p><blockquote><p>Songtao He (MIT CSAIL)*; Favyen Bastani (MIT CSAIL); Satvat Jagwani (MIT CSAIL); Edward Park (MIT CSAIL);<br>Sofiane Abbar (Qatar Computing Research Institute); Mohammad Alizadeh (MIT CSAIL); Dr.Hari Balakrishnan<br>(Massachusetts institute of technology); Sanjay Chawla (QCRI); Samuel Madden (MIT); Mohammad Amin Sadeghi<br>(MIT)  </p></blockquote><h1><span id="iclr2020">ICLR2020</span></h1><p><a href="http://tony.9shi.cf/index.php?q=aHR0cHM6Ly93d3cuZW5kdG9lbmQuYWkvYmxvZy9pY2xyMjAyMC8" target="_blank" rel="noopener">ICLR2020 Accepted Papers</a></p><p><strong>[1]. Geom-gcn: Geometric Graph Convolutional Networks</strong><br>Spotlight paper<br><a href="https://github.com/graphdml-uiuc-jlu/geom-gcn" target="_blank" rel="noopener">https://github.com/graphdml-uiuc-jlu/geom-gcn</a></p><blockquote><p>Hongbin Pei, Bingzhe Wei, Kevin Chen-Chuan Chang, Yu Lei, Bo Yang<br>Jilin University</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h1&gt;&lt;p&gt;以下列出AAAI2020和ICLR2020关于时空领域的论文&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="论文阅读笔记" scheme="http://yoursite.com/categories/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="时空领域" scheme="http://yoursite.com/tags/%E6%97%B6%E7%A9%BA%E9%A2%86%E5%9F%9F/"/>
    
  </entry>
  
  <entry>
    <title>Pytorch之Tensor学习</title>
    <link href="http://yoursite.com/2020/02/17/Pytorch%E4%B9%8BTensor%E5%AD%A6%E4%B9%A0/"/>
    <id>http://yoursite.com/2020/02/17/Pytorch之Tensor学习/</id>
    <published>2020-02-17T14:56:16.000Z</published>
    <updated>2020-02-24T08:02:56.237Z</updated>
    
    <content type="html"><![CDATA[<h1><span id="1-简介">1. 简介</span></h1><p>最近发现一个学习Pytorch的教程，有视频版和文字版<a href="https://deeplizard.com/" target="_blank" rel="noopener">deeplizard</a>,这里面详细介绍了关于Tensor的知识，真的讲得超级好，解决了我很多关于Tensor运算的疑惑，在此记录下。</p><a id="more"></a>  <!-- TOC --><ul><li><a href="#1-%e7%ae%80%e4%bb%8b">1. 简介</a></li><li><a href="#2-%e5%88%9b%e5%bb%batensor">2. 创建Tensor</a></li><li><a href="#3-tensor%e7%9a%844%e7%b1%bb%e6%93%8d%e4%bd%9c">3. Tensor的4类操作</a><ul><li><a href="#31-reshape%e6%93%8d%e4%bd%9c">3.1. Reshape操作</a><ul><li><a href="#311-reshape">3.1.1. reshape</a></li><li><a href="#312-squeeze%e5%92%8cunsqueeze%e5%87%bd%e6%95%b0">3.1.2. squeeze和unsqueeze函数</a></li><li><a href="#313-cat%e5%87%bd%e6%95%b0">3.1.3. cat函数</a></li><li><a href="#314-stack%e5%87%bd%e6%95%b0">3.1.4. stack函数</a></li><li><a href="#315-cat%e5%92%8cstack%e7%9a%84%e5%8c%ba%e5%88%ab">3.1.5. cat和stack的区别</a></li></ul></li><li><a href="#32-element-wise%e6%93%8d%e4%bd%9c">3.2. Element-wise操作</a></li><li><a href="#33-reduction%e6%93%8d%e4%bd%9c">3.3. Reduction操作</a><ul><li><a href="#331-%e6%b2%bf%e7%9d%80%e6%9f%90%e4%b8%aaaxis%e8%81%9a%e5%90%88">3.3.1. 沿着某个axis聚合</a></li><li><a href="#332-argmax%e5%87%bd%e6%95%b0%e4%bb%8b%e7%bb%8d">3.3.2. Argmax函数介绍</a></li></ul></li><li><a href="#34-access%e6%93%8d%e4%bd%9c">3.4. Access操作</a></li></ul></li></ul><!-- /TOC --><h1><span id="2-创建tensor">2. 创建Tensor</span></h1><p>创建Tensor有四种方式</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#创建Tensor</span></span><br><span class="line">&gt; data = np.array([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>])</span><br><span class="line"></span><br><span class="line">&gt; o1 = torch.Tensor(data)</span><br><span class="line">&gt; o2 = torch.tensor(data)</span><br><span class="line">&gt; o3 = torch.as_tensor(data)</span><br><span class="line">&gt; o4 = torch.from_numpy(data)</span><br><span class="line"></span><br><span class="line">&gt; print(o1)</span><br><span class="line">&gt; print(o2)</span><br><span class="line">&gt; print(o3)</span><br><span class="line">&gt; print(o4)</span><br><span class="line">tensor([<span class="number">1.</span>, <span class="number">2.</span>, <span class="number">3.</span>])</span><br><span class="line">tensor([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], dtype=torch.int32)</span><br><span class="line">tensor([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], dtype=torch.int32)</span><br><span class="line">tensor([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], dtype=torch.int32)</span><br><span class="line"></span><br><span class="line">&gt; print(o1.dtype)</span><br><span class="line">&gt; print(o2.dtype)</span><br><span class="line">&gt; print(o3.dtype)</span><br><span class="line">&gt; print(o4.dtype)</span><br><span class="line">torch.float32</span><br><span class="line">torch.int32</span><br><span class="line">torch.int32</span><br><span class="line">torch.int32</span><br><span class="line"></span><br><span class="line"><span class="comment">#内存是否共享</span></span><br><span class="line">&gt; print(<span class="string">'old:'</span>, data)</span><br><span class="line">old: [<span class="number">1</span> <span class="number">2</span> <span class="number">3</span>]</span><br><span class="line"></span><br><span class="line">&gt; data[<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">&gt; print(<span class="string">'new:'</span>, data)</span><br><span class="line">new: [<span class="number">0</span> <span class="number">2</span> <span class="number">3</span>]</span><br><span class="line"></span><br><span class="line">&gt; print(o1)</span><br><span class="line">&gt; print(o2)</span><br><span class="line">&gt; print(o3)</span><br><span class="line">&gt; print(o4)</span><br><span class="line"></span><br><span class="line">tensor([<span class="number">1.</span>, <span class="number">2.</span>, <span class="number">3.</span>])</span><br><span class="line">tensor([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], dtype=torch.int32)</span><br><span class="line">tensor([<span class="number">0</span>, <span class="number">2</span>, <span class="number">3</span>], dtype=torch.int32)</span><br><span class="line">tensor([<span class="number">0</span>, <span class="number">2</span>, <span class="number">3</span>], dtype=torch.int32)</span><br></pre></td></tr></table></figure><ul><li><code>torch.Tensor()</code>和<code>torch.tensor()</code>区别<br><code>torch.Tensor()</code>是<code>Tensor</code>类的构造函数，<code>torch.tensor()</code>是factory function，该函数将传入的参数构造成一个<code>Tensor</code>对象并返回。<br>以上4个函数中，<code>torch.Tensor()</code>是构造函数，其余都是factory function。</li><li>这4个函数的主要区别是:<code>torch.Tensor()</code>返回的<code>Tensor</code>默认是<code>float32</code>类型，而其他3个函数返回的<code>Tensor</code>数据类型根据传入的数据而定。并且其他3个函数可以传入<code>dtype</code>来指定数据的类型，但是<code>torch.Tensor()</code>不能传入<code>dtype</code>参数。</li><li><p>通过<code>np.array</code>来创建<code>Tensor</code>，然后改变data的值，可以看到，前2个<code>Tensor</code>的值并没有改变，后2个<code>Tensor</code>的值改变。这是因为<code>torch.Tensor()</code>和<code>torch.tensor()</code>是copy输入数据的值，而<code>torch.as_tensor()</code>和<code>torch.from_numpy()</code>是share输入数据的memory</p><p>Shara Data | Copy Data<br>-|-|-|<br>torch.as_tensor() | torch.tensor()|<br>torch.from_numpy() |     torch.Tensor()|</p></li><li><p><code>torch.as_tensor()</code>和<code>torch.from_numpy()</code>都是factory function，且都是share data，那这2个函数有什么区别？<code>torch.from_numpy()</code>仅仅接受<code>np.array</code>的参数，然而<code>torch.as_tensor()</code>接受<a href="https://docs.scipy.org/doc/numpy/user/basics.creation.html#converting-python-array-like-objects-to-numpy-arrays" target="_blank" rel="noopener">array-like objects</a>类型的参数</p></li><li>综上所述，下面2个方法是创建Tensor的推荐方法：<ul><li><code>torch.tensor()</code></li><li><code>torch.as_tensor()</code></li></ul></li></ul><h1><span id="3-tensor的4类操作">3. Tensor的4类操作</span></h1><h2><span id="31-reshape操作">3.1. Reshape操作</span></h2><h3><span id="311-reshape">3.1.1. reshape</span></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt; t = torch.tensor([</span><br><span class="line">    [<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>],</span><br><span class="line">    [<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>],</span><br><span class="line">    [<span class="number">3</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">3</span>]</span><br><span class="line">], dtype=torch.float32)</span><br></pre></td></tr></table></figure><p>有2种方式获取Tensor的shape:<code>t.size()和t.shape</code></p><h3><span id="312-squeeze和unsqueeze函数">3.1.2. squeeze和unsqueeze函数</span></h3><ol><li><code>torch.squeeze(input, dim=None, out=None) → Tensor</code><br>将维度中的1去掉，如果不指定dim，则去掉所有维度上的1；如果指定dim，则只去掉该维度上的1。<strong>dim是可选项</strong></li></ol><ul><li>输入维度是(A×1×B×C×1×D),不指定dim，输出维度(A×B×CxD)</li><li>输入维度是(A×1×B×C×1×D),不指定dim=1，输出维度(A×B×C×1×D)</li></ul><ol><li><code>torch.unsqueeze(input, dim, out=None) → Tensor</code><br>在指定维度上增加1个维度。<strong>dim是必填项</strong><br><code>torch.unsqueeze(x, 0)</code><h3><span id="313-cat函数">3.1.3. cat函数</span></h3></li></ol><p><code>torch.cat(tensors, dim=0, out=None) → Tensor</code><br>如果要拼接多个Tensor，需要将多个Tensor包装成tuple，例如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">torch.cat((t1,t2,t3),dim=<span class="number">0</span>)</span><br></pre></td></tr></table></figure><p><strong>cat不改变数据维度个数</strong></p><h3><span id="314-stack函数">3.1.4. stack函数</span></h3><p><code>torch.stack(tensors, dim=0, out=None) → Tensor</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">torch.stack((t1,t2,t3),dim=<span class="number">0</span>)</span><br></pre></td></tr></table></figure><p><strong>stack改变数据维度个数,增加一个维度</strong></p><h3><span id="315-cat和stack的区别">3.1.5. cat和stack的区别</span></h3><p>cat和stack的区别可以用一句话描述：</p><ul><li>cat不会改变数据维度个数，原先是3维数据，n个tensor进行cat之后还是3维数据。</li><li>stack会增加维度个数，原先是3维，n个tensor进行stack会变成4维数据</li></ul><h2><span id="32-element-wise操作">3.2. Element-wise操作</span></h2><p><a href="https://deeplizard.com/learn/video/QscEWm0QTRY" target="_blank" rel="noopener">Broadcasting and Element-wise Operations with PyTorch</a><br><a href="https://deeplizard.com/learn/video/6_33ulFDuCg" target="_blank" rel="noopener">Broadcasting Explained</a></p><p>逐元素有以下4种叫法，意思都一样：</p><ul><li>Element-wise</li><li>Component-wise</li><li>Point-wise</li></ul><p>逐元素操作有以下几种:</p><ol><li><p><strong><code>t1+t2</code>维度相同</strong><br>其中t1和t2维度相同</p></li><li><p><strong><code>t1+2, t1-2, t1*2, t1/2</code></strong><br>实际上是对2进行了<code>broadcasting</code>，然后再和t1运算</p></li><li><p><strong><code>t1+t2</code>，rank相同，维度不同</strong><br>这种情况比较复杂。</p><ul><li><p>首先我们先看这2个Tensor在所有维度上是否兼容。判断2个Tensor在维度上是否兼容有2个条件，只要满足其中的一个条件就兼容，否则不兼容。</p><ul><li>相等</li><li><p>有一个值维1 </p><p>例如：t1维度(1,3)，t2维度(3,1)，<strong>从后往前对比</strong>，我们先看第二个维度的值，分别是3和1，不相等但是满足第二个条件，即第二个维度上兼容。再看第一个维度，分别是1和3，满足第二个条件，即第一个维度上兼容。所以2个Tensor在所有维度上兼容，可以进行下一步的操作。如果不兼容，则这2个Tensor无法进行逐元素运算。</p></li></ul></li><li><p>决定最终结果的输出维度。还是要看2个Tensor的维度。<strong>从后往前对比</strong>, t1维度(1,3)，t2维度(3,1)，先看第二维度是3和1，取最大值作为输出的第一个维度，即3，再看第一维度1和3，也是3作为输出的第二个维度。即输出的维度是(3,3)。</p></li><li>分别将t1维度(1,3)，t2维度(3,1)进行广播成(3,3)，然后再进行相加，得到最终的结果。</li></ul></li><li><p><strong><code>t1+t2</code>，rank不同</strong></p><ul><li>例子1：t1的维度(2,4),t2的维度是(4,)，这2个Tensor也可以进行，实际是先将低rank的t2最后一维和t1的最后一维相等，都等于4，但是t2只有一维，那就在缺失的维度上补1，变成(1,4),然后再广播成(2,4)维度，然后再和t1计算。</li><li>例子2：t1的维度(2,4),t2的维度是(2,)，这2个Tensor不可以进行。因为t1和t2的最后一维分别是4和2，不相等也不等于1，不兼容，无法进行下一步。</li><li>例子3：t1维度(1,2,3)，t2维度(3,3)，这个Tensor就不能做逐元素操作。先看所有维度是否兼容。最后一个维度3和3，相等即兼容，再看前一个维度2和3，既不相等也不等于1，不兼容。则不能进行逐元素操作</li></ul></li></ol><p><strong>以上2，3，4情况都涉及到了broadcasting的知识。</strong>  </p><ol><li><p>比较操作<br>比较也是逐元素操作的一种，</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; torch.tensor([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]) &lt; torch.tensor([<span class="number">3</span>, <span class="number">1</span>, <span class="number">2</span>])</span><br><span class="line">tensor([<span class="keyword">True</span>, <span class="keyword">False</span>, <span class="keyword">False</span>])</span><br></pre></td></tr></table></figure></li></ol><h2><span id="33-reduction操作">3.3. Reduction操作</span></h2><p>聚合操作：减少Tesnor中元素的个数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt; t = torch.tensor([</span><br><span class="line">    [<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>],</span><br><span class="line">    [<span class="number">2</span>,<span class="number">0</span>,<span class="number">2</span>],</span><br><span class="line">    [<span class="number">0</span>,<span class="number">3</span>,<span class="number">0</span>]</span><br><span class="line">], dtype=torch.float32)</span><br><span class="line">&gt; t.sum()</span><br><span class="line">tensor(<span class="number">8.</span>)</span><br></pre></td></tr></table></figure><p><code>sum()</code>返回的结果是scalar类型(0维的Tensor)，只包含1个元素</p><h3><span id="331-沿着某个axis聚合">3.3.1. 沿着某个axis聚合</span></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt; t = torch.tensor([</span><br><span class="line">    [<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>],</span><br><span class="line">    [<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>],</span><br><span class="line">    [<span class="number">3</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">3</span>]</span><br><span class="line">], dtype=torch.float32)</span><br><span class="line">&gt; t.sum(dim=<span class="number">0</span>)</span><br><span class="line">tensor([<span class="number">6.</span>, <span class="number">6.</span>, <span class="number">6.</span>, <span class="number">6.</span>])</span><br></pre></td></tr></table></figure><h3><span id="332-argmax函数介绍">3.3.2. Argmax函数介绍</span></h3><p>当一个Tensor变量a调用<code>argmax()</code>函数时，返回只包含1个元素的Tensor，该元素表示a中最大值的下标。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">t = torch.tensor([</span><br><span class="line">    [<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">2</span>],</span><br><span class="line">    [<span class="number">0</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">0</span>],</span><br><span class="line">    [<span class="number">4</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">5</span>]</span><br><span class="line">], dtype=torch.float32)</span><br><span class="line"></span><br><span class="line">&gt; t.max()</span><br><span class="line">tensor(<span class="number">5.</span>)</span><br><span class="line"></span><br><span class="line">&gt; t.argmax()</span><br><span class="line">tensor(<span class="number">11</span>)</span><br><span class="line"></span><br><span class="line">&gt; t.flatten()</span><br><span class="line">tensor([<span class="number">1.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">2.</span>, <span class="number">0.</span>, <span class="number">3.</span>, <span class="number">3.</span>, <span class="number">0.</span>, <span class="number">4.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">5.</span>])</span><br></pre></td></tr></table></figure><p>如果<code>argmax()</code>没有指定axis，则返回整个Tensor最大值的下标。如果指定axis，则返回指定轴上最大值下标。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&gt; t.max(dim=<span class="number">0</span>)</span><br><span class="line">(tensor([<span class="number">4.</span>, <span class="number">3.</span>, <span class="number">3.</span>, <span class="number">5.</span>]), tensor([<span class="number">2</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>]))</span><br><span class="line"></span><br><span class="line">&gt; t.argmax(dim=<span class="number">0</span>)</span><br><span class="line">tensor([<span class="number">2</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>])</span><br><span class="line"></span><br><span class="line">&gt; t.max(dim=<span class="number">1</span>)</span><br><span class="line">(tensor([<span class="number">2.</span>, <span class="number">3.</span>, <span class="number">5.</span>]), tensor([<span class="number">3</span>, <span class="number">1</span>, <span class="number">3</span>]))</span><br><span class="line"></span><br><span class="line">&gt; t.argmax(dim=<span class="number">1</span>)</span><br><span class="line">tensor([<span class="number">3</span>, <span class="number">1</span>, <span class="number">3</span>])</span><br></pre></td></tr></table></figure><p>当调用<code>max()</code>函数时，返回2个Tensor，第一个Tensor表示返回轴上最大的值，第2个Tensor返回最大值的下标，也就是<code>argmax()</code>的返回值。<br>通常<code>argmax()</code>通常用在分类任务的输出上，决定哪类有最高的预测值。</p><h2><span id="34-access操作">3.4. Access操作</span></h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&gt; t = torch.tensor([</span><br><span class="line">    [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],</span><br><span class="line">    [<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>],</span><br><span class="line">    [<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>]</span><br><span class="line">], dtype=torch.float32)</span><br><span class="line"></span><br><span class="line">&gt; t.mean()</span><br><span class="line">tensor(<span class="number">5.</span>)</span><br><span class="line"></span><br><span class="line">&gt; t.mean().item()</span><br><span class="line"><span class="number">5.0</span></span><br><span class="line"></span><br><span class="line">&gt; t.mean(dim=<span class="number">0</span>).tolist()</span><br><span class="line">[<span class="number">4.0</span>, <span class="number">5.0</span>, <span class="number">6.0</span>]</span><br><span class="line"></span><br><span class="line">&gt; t.mean(dim=<span class="number">0</span>).numpy()</span><br><span class="line">array([<span class="number">4.</span>, <span class="number">5.</span>, <span class="number">6.</span>], dtype=float32)</span><br></pre></td></tr></table></figure><p>如果返回的结果是scalar，只有1个元素，使用item()来获取其中的值。<br>如果返回的结果有多个值，可以将Tensor转换为pyhton中的list和array.</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;1-简介&quot;&gt;&lt;a href=&quot;#1-简介&quot; class=&quot;headerlink&quot; title=&quot;1. 简介&quot;&gt;&lt;/a&gt;1. 简介&lt;/h1&gt;&lt;p&gt;最近发现一个学习Pytorch的教程，有视频版和文字版&lt;a href=&quot;https://deeplizard.com/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;deeplizard&lt;/a&gt;,这里面详细介绍了关于Tensor的知识，真的讲得超级好，解决了我很多关于Tensor运算的疑惑，在此记录下。&lt;/p&gt;
    
    </summary>
    
      <category term="Deep Learning" scheme="http://yoursite.com/categories/Deep-Learning/"/>
    
    
      <category term="Pytorch" scheme="http://yoursite.com/tags/Pytorch/"/>
    
  </entry>
  
  <entry>
    <title>openpai</title>
    <link href="http://yoursite.com/2020/01/10/openpai/"/>
    <id>http://yoursite.com/2020/01/10/openpai/</id>
    <published>2020-01-10T02:34:27.000Z</published>
    <updated>2020-03-05T08:07:13.226Z</updated>
    
    <content type="html"><![CDATA[<p>&ensp;&ensp;&ensp;&ensp;最近实验室安装了openpai平台，可以在上面提交程序运行。下面记录怎么使用OpenPai提交NNI程序，进行调参。<br><a id="more"></a><br><!-- TOC --></p><ul><li><a href="#1-%e4%bd%bf%e7%94%a8%e6%ad%a5%e9%aa%a4">1. 使用步骤</a><ul><li><a href="#11-%e7%bc%96%e5%86%99%e7%a8%8b%e5%ba%8f">1.1. 编写程序</a></li><li><a href="#12-%e5%87%86%e5%a4%87%e9%95%9c%e5%83%8f">1.2. 准备镜像</a></li><li><a href="#13-%e7%bc%96%e5%86%99nni%e7%9a%84yml%e9%85%8d%e7%bd%ae%e6%96%87%e4%bb%b6">1.3. 编写NNI的yml配置文件</a></li><li><a href="#14-%e5%ae%89%e8%a3%85nni">1.4. 安装NNI</a></li><li><a href="#15-%e5%90%af%e5%8a%a8nni">1.5. 启动NNI</a></li><li><a href="#16-nni%e6%b5%8f%e8%a7%88%e5%99%a8%e6%9f%a5%e7%9c%8b">1.6. NNI浏览器查看</a></li><li><a href="#17-%e5%9c%a8%e6%b5%8f%e8%a7%88%e5%99%a8%e4%b8%ad%e6%9f%a5%e7%9c%8bopenpai">1.7. 在浏览器中查看OpenPai</a></li><li><a href="#18-%e5%85%b3%e9%97%adnni">1.8. 关闭NNI</a></li></ul></li><li><a href="#%e5%86%85%e5%ad%98%e6%8c%87%e6%a0%87%e8%a7%a3%e8%af%bb">内存指标解读</a></li></ul><!-- /TOC --><h1><span id="1-使用步骤">1. 使用步骤</span></h1><h2><span id="11-编写程序">1.1. 编写程序</span></h2><p>   先在VSCode中完成代码，先在VSCode的虚拟环境中运行，如果可以运行，再使用OpemPai运行。<br>   <strong>注：在OpenPai上运行程序，不需要指定使用哪块GPU，因为OpenPai会自动申请需要使用的GPU。即以下代码注释掉</strong></p>   <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># os.environ["CUDA_VISIBLE_DEVICES"] = "1,2,3"</span></span><br></pre></td></tr></table></figure><h2><span id="12-准备镜像">1.2. 准备镜像</span></h2><p>   准备一个包含hdfs的镜像，将需要用的镜像push到实验室服务器的仓库。<br>   下面是我本人的镜像：</p><ul><li>运行环境mxnet<br> <code>lin-ai-27:5000/wangbeibei/mxnet:cu100_hdfs</code></li><li>运行环境是pytorch<br> <code>172.31.246.45:5000/dlspree:hdfs_pyg</code></li></ul><h2><span id="13-编写nni的yml配置文件">1.3. 编写NNI的yml配置文件</span></h2><p>   使用<code>pip install nni==1.2</code>安装1.2版本的nni，如果不指定版本，默认安装最新版，目前最新是1.3，1.3版本的nni其yml配置文件和1.2有所区别<br>   <a href="https://nni.readthedocs.io/zh/latest/Tutorial/ExperimentConfig.html#openpai" target="_blank" rel="noopener">OpenPai模式</a><br>   1.3版本的nni的yml配置文件和1.2有所不同,<a href="https://nni.readthedocs.io/zh/latest/TrainingService/PaiMode.html" target="_blank" rel="noopener">最新版本的配置文件</a>，其中多了<code>nniManagerNFSMountPath,containerNFSMountPath,paiStoragePlugin</code>三个必填的键。<br>   下面使用的是1.2版本的nni配置文件</p>   <figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">authorName:</span> <span class="string">wangbeibei</span></span><br><span class="line"><span class="attr">experimentName:</span><span class="string">hetero_convlstm_grid_experiment</span></span><br><span class="line"><span class="comment">#并发尝试任务的最大数量，有1张gpu卡就是1，有2gpu卡就是2</span></span><br><span class="line"><span class="attr">trialConcurrency:</span> <span class="number">6</span></span><br><span class="line"><span class="attr">maxExecDuration:</span> <span class="number">100</span><span class="string">h</span></span><br><span class="line"><span class="comment">#Trial 任务的最大数量，成功和失败的都计算在内</span></span><br><span class="line"><span class="attr">maxTrialNum:</span> <span class="number">600</span></span><br><span class="line"><span class="comment">#choice: local, remote, pai</span></span><br><span class="line"><span class="attr">trainingServicePlatform:</span> <span class="string">pai</span></span><br><span class="line"><span class="comment"># 指定nni管理器ip 为29号服务器</span></span><br><span class="line"><span class="attr">nniManagerIp:</span> <span class="number">202.205</span><span class="number">.99</span><span class="number">.174</span></span><br><span class="line"><span class="attr">searchSpacePath:</span><span class="string">hetero_convlstm_search_space.json</span></span><br><span class="line"><span class="comment">#choice: true, false</span></span><br><span class="line"><span class="attr">useAnnotation:</span> <span class="literal">false</span></span><br><span class="line"><span class="comment"># 存储日志和数据的目录, 默认值是 /dataWangBeibei/nni/  experiments</span></span><br><span class="line"><span class="comment">#如果在虚拟环境中运行该代码，logDir是服务器下绝对路径，/data/ WangBeibei/graduation/Codenni_save_logs</span></span><br><span class="line"><span class="comment">#如果在docker下运行该代码，logDir是容器下的绝路径，/root/ Code/nni_save_logs/</span></span><br><span class="line"><span class="attr">logDir:</span> <span class="string">/data/WangBeibei/graduation/Codenni_save_logs</span></span><br><span class="line"><span class="attr">tuner:</span></span><br><span class="line">  <span class="comment">#choice: TPE, Random, Anneal, Evolution,BatchTuner,  MetisTuner, GPTuner</span></span><br><span class="line">  <span class="comment">#SMAC (SMAC should be installed throughnnictl)</span></span><br><span class="line"><span class="attr">  builtinTunerName:</span> <span class="string">TPE</span></span><br><span class="line"><span class="attr">  classArgs:</span></span><br><span class="line">    <span class="comment">#choice: maximize, minimize</span></span><br><span class="line"><span class="attr">    optimize_mode:</span> <span class="string">minimize</span></span><br><span class="line"><span class="attr">trial:</span></span><br><span class="line">  <span class="comment"># 指定了运行 Trial 进程的命令行</span></span><br><span class="line"><span class="attr">  command:</span> <span class="string">cd</span> <span class="string">baseline</span> <span class="string">&amp;&amp;</span> <span class="string">python3</span>  <span class="string">hetero_convlstm_baseline.py</span></span><br><span class="line">  <span class="comment">#指定了 Trial 代码文件的目录,../会进入到Cod目录下</span></span><br><span class="line"><span class="attr">  codeDir:</span> <span class="string">../</span></span><br><span class="line"><span class="attr">  gpuNum:</span> <span class="number">1</span></span><br><span class="line"><span class="attr">  cpuNum:</span> <span class="number">8</span></span><br><span class="line"><span class="attr">  memoryMB:</span> <span class="number">14000</span></span><br><span class="line">  <span class="comment"># docker 镜像地址</span></span><br><span class="line">  <span class="comment">#pytorch镜像：172.31.246.45:5000dlspree:hdfs_pyg</span></span><br><span class="line">  <span class="comment">#mxnet镜像：lin-ai-27:5000/wangbeibeimxnet:cu100_hdfs</span></span><br><span class="line"><span class="attr">  image:</span> <span class="number">172.31</span><span class="number">.246</span><span class="number">.45</span><span class="string">:5000/dlspree:hdfs_pyg</span></span><br><span class="line"><span class="comment"># 配置访问的 OpenPAI 集群</span></span><br><span class="line"><span class="attr">paiConfig:</span></span><br><span class="line">  <span class="comment">#OpenPai网页的用户名和密码，也是53号服务器用户名和密码</span></span><br><span class="line"><span class="attr">  userName:</span> <span class="string">user</span></span><br><span class="line">  <span class="comment"># 密码如果是全数字需要 ""</span></span><br><span class="line"><span class="attr">  passWord:</span> <span class="string">psw</span></span><br><span class="line">  <span class="comment">#OpenPai集群的主节点</span></span><br><span class="line"><span class="attr">  host:</span> <span class="number">172.31</span><span class="number">.246</span><span class="number">.52</span></span><br></pre></td></tr></table></figure><p>   <strong>这里资源的配置都是针对一个trail的，memoryMB也是针对一个trail的。</strong><br>   <strong>注意：</strong> pai 模式下，NNIManager 会启动 RESTful 服务，监听端口为 NNI 网页服务器的端口加1。 例如，如果网页端口为<code>8080</code>，那么 RESTful 服务器会监听在 <code>8081</code>端口，来接收运行在 Kubernetes 中的 Trial 作业的指标。 因此，需要在防火墙中启用端口 <code>8081</code> 的 TCP 协议，以允许传入流量。</p><p>通常在服务器中8080端口无法使用，我们需要在启动NNI管理器时手动通过 —port 指定端口。</p><h2><span id="14-安装nni">1.4. 安装NNI</span></h2><p>   由于NNI并不依赖于任何环境，因此当我们使用OpenPAI提交NNI任务时，为了方便（需要解决ip和端口映射问题），<strong>不需要在docker中启动NNI，直接在服务器环境下安装NNI，启动即可</strong>。<br>   使用<code>pip install nni==1.2</code>安装nni</p><h2><span id="15-启动nni">1.5. 启动NNI</span></h2><p>   使用<code>nnictl create --port 6688 --config xxx.yml</code>来启动一个Experiment,如果端口被占用，换别的端口</p><h2><span id="16-nni浏览器查看">1.6. NNI浏览器查看</span></h2><p>   在浏览器中输入<code>服务器ip:6688</code></p><h2><span id="17-在浏览器中查看openpai">1.7. 在浏览器中查看OpenPai</span></h2><p>   在浏览器中登录OpenPai，可以查看启动的trail，在代码中的print输出的内容在stdout中查看。<br>   <strong>注：有时候print语句输出的内容在stdout显示不出来，添加<code>flush=True</code>就可以了</strong></p>   <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(<span class="string">"************进入main函数"</span>,flush=<span class="keyword">True</span>)</span><br></pre></td></tr></table></figure><p>   <img src="/2020/01/10/openpai/logs.png" alt=""></p><h2><span id="18-关闭nni">1.8. 关闭NNI</span></h2><p>直接在服务器中使用<code>nnictl stop</code>即可关闭nni的Experiment</p><hr><p>2020.3.5更新</p><h1><span id="内存指标解读">内存指标解读</span></h1><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">trial:</span></span><br><span class="line">    <span class="comment"># 指定了运行 Trial 进程的命令行</span></span><br><span class="line"><span class="attr">    command:</span> <span class="string">cd</span> <span class="string">baseline</span> <span class="string">&amp;&amp;</span> <span class="string">python3</span>  <span class="string">hetero_convlstm_baseline.py</span></span><br><span class="line">    <span class="comment">#指定了 Trial 代码文件的目录,../会进入到Cod目录下</span></span><br><span class="line"><span class="attr">    codeDir:</span> <span class="string">../</span></span><br><span class="line"><span class="attr">    gpuNum:</span> <span class="number">2</span></span><br><span class="line"><span class="attr">    cpuNum:</span> <span class="number">3</span></span><br><span class="line"><span class="attr">    memoryMB:</span> <span class="number">20000</span></span><br></pre></td></tr></table></figure><p><strong>【gpuNum】</strong>：设置为2，表示该程序使用2张GPU，即该程序独占2张GPU卡，<strong>独占2张卡的显存和计算力</strong><br><strong>【cpuNum】</strong>：设置为3，占用3块CPU来计算<br><strong>【memoryMB】</strong>：设置为20000MB，表示该程序总共占2000MB的内存，在openpai上内存是共享的，显存是独享的。</p><p>当我设置如上资源来跑程序时，可以看到程序的资源占用情况如下所示：<br><img src="/2020/01/10/openpai/指标示意图.png" alt=""></p><p><strong>【指标解读】</strong></p><p>上面从左到右一共有6张图，我们只关注<code>CPU,memory usage,GPU Utilization,GPU Memory</code>这4张图。</p><ul><li><strong>CPU</strong>：CPU的占用率稳定在300%，说明程序分配的3张CPU卡都用来做计算，CPU一直是满载状况，这时候可以适当增加cpuNum的个数</li><li><strong>memory usage</strong>：内存占用率稳定在12G，我们分配给该程序的资源是20G，分配的有点多，可以适当减少些。内存分配的资源也不是越多越好，因为openpai在跑程序时，当有足够的GPU但是却没有足够的内存，程序依然不能运行，会一直处于waiting状态</li><li><strong>GPU Utilization和GPU Memory</strong>：GPU的占用率稳定在25%，给该程序分配了2张GPU卡，一张卡有11G显存，但是程序只占了25%，也就是大约3G，2张卡对该程序有点多，可以改为1张卡</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;ensp;&amp;ensp;&amp;ensp;&amp;ensp;最近实验室安装了openpai平台，可以在上面提交程序运行。下面记录怎么使用OpenPai提交NNI程序，进行调参。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="工具" scheme="http://yoursite.com/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="openpai" scheme="http://yoursite.com/tags/openpai/"/>
    
  </entry>
  
  <entry>
    <title>Pytorch之GPU程序</title>
    <link href="http://yoursite.com/2020/01/06/Pytorch%E4%B9%8BGPU%E7%A8%8B%E5%BA%8F/"/>
    <id>http://yoursite.com/2020/01/06/Pytorch之GPU程序/</id>
    <published>2020-01-06T06:35:30.000Z</published>
    <updated>2020-02-24T08:24:54.101Z</updated>
    
    <content type="html"><![CDATA[<p>介绍Pytorch的一些使用方法<br><a id="more"></a></p><h1><span id="gpu">GPU</span></h1><p><a href="https://zhuanlan.zhihu.com/p/71566775" target="_blank" rel="noopener">转载出处</a></p><p><a href="https://tangshusen.me/Dive-into-DL-PyTorch/#/chapter04_DL_computation/4.6_use-gpu" target="_blank" rel="noopener">GPU计算</a></p><h2><span id="查看-gpu-信息">查看 GPU 信息</span></h2><p>更多接口，参考 <a href="https://pytorch.org/docs/stable/cuda.html" target="_blank" rel="noopener">torch.cuda</a></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">torch</span><span class="selector-class">.cuda</span><span class="selector-class">.is_available</span>()       # 判断 <span class="selector-tag">GPU</span> 是否可用</span><br><span class="line"><span class="selector-tag">torch</span><span class="selector-class">.cuda</span><span class="selector-class">.device_count</span>()       # 判断有多少 <span class="selector-tag">GPU</span></span><br><span class="line"><span class="selector-tag">torch</span><span class="selector-class">.cuda</span><span class="selector-class">.get_device_name</span>(0)   # 返回 <span class="selector-tag">gpu</span> 名字，设备索引默认从 0 开始</span><br><span class="line"><span class="selector-tag">torch</span><span class="selector-class">.cuda</span><span class="selector-class">.current_device</span>()     # 返回当前设备索引</span><br></pre></td></tr></table></figure><h2><span id="torchdevice">torch.device</span></h2><p><code>torch.device</code> 表示 <code>torch.Tensor</code> 分配到的设备的对象。其包含一个设备类型（<code>cpu</code> 或 <code>cuda</code>），以及可选的设备序号。如果设备序号不存在，则为当前设备，即 <code>torch.cuda.current_device()</code> 的返回结果。</p><p>可以通过如下方式创建 <code>torch.device</code> 对象：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 通过字符串</span></span><br><span class="line"><span class="attr">device</span> = torch.device(<span class="string">'cpu'</span>)</span><br><span class="line"><span class="attr">device</span> = torch.device(<span class="string">'cuda:1'</span>)  # 指定类型及编号。注意，代码不会检查编号是否合法</span><br><span class="line"><span class="attr">device</span> = torch.device(<span class="string">'cuda'</span>)    # 默认为当前设备，如果是多GPU，默认使用全部GPU</span><br></pre></td></tr></table></figure><p>还可以通过设备类型加上编号，来创建 <code>device</code> 对象：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">device</span> = torch.device(<span class="string">'cuda'</span>, <span class="number">0</span>)</span><br><span class="line"><span class="attr">device</span> = torch.device(<span class="string">'cpu'</span>, <span class="number">0</span>)</span><br></pre></td></tr></table></figure><h2><span id="配置-cuda-访问限制">配置 CUDA 访问限制</span></h2><p>可以通过如下方式，设置当前 <code>Python</code> 脚本可见的 <code>GPU</code>。</p><h3><span id="在命令行设置">在命令行设置</span></h3><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">CUDA_VISIBLE_DEVICES</span>=<span class="number">1</span> python my_script.py</span><br></pre></td></tr></table></figure><p><strong>实例</strong></p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Environment Variable Syntax      Results</span><br><span class="line"></span><br><span class="line">CUDA_VISIBLE_DEVICES=<span class="number">1</span>           Only device <span class="number">1</span> will be seen</span><br><span class="line">CUDA_VISIBLE_DEVICES=<span class="number">0</span>,<span class="number">1</span>         Devices <span class="number">0</span> <span class="keyword">and</span> <span class="number">1</span> will be visible</span><br><span class="line">CUDA_VISIBLE_DEVICES=<span class="string">"0,1"</span>       Same as above, quotation marks are optional</span><br><span class="line">CUDA_VISIBLE_DEVICES=<span class="number">0</span>,<span class="number">2</span>,<span class="number">3</span>       Devices <span class="number">0</span>, <span class="number">2</span>, <span class="number">3</span> will be visible; device <span class="number">1</span> <span class="keyword">is</span> masked</span><br><span class="line">CUDA_VISIBLE_DEVICES=<span class="string">""</span>          No GPU will be visible</span><br></pre></td></tr></table></figure><h3><span id="在-python-代码中设置">在 Python 代码中设置</span></h3><figure class="highlight moonscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="built_in">os</span></span><br><span class="line"><span class="built_in">os</span>.environ[<span class="string">"CUDA_VISIBLE_DEVICES"</span>] = <span class="string">"0, 2"</span></span><br></pre></td></tr></table></figure><h3><span id="使用函数-set_device">使用函数 set_device</span></h3><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">import torch</span><br><span class="line">torch<span class="selector-class">.cuda</span><span class="selector-class">.set_device</span>(id)</span><br></pre></td></tr></table></figure><blockquote><p>官方建议使用 <code>CUDA_VISIBLE_DEVICES</code>，不建议使用 <code>set_device</code> 函数。</p></blockquote><h2><span id="用-gpu-训练">用 GPU 训练</span></h2><p>默认情况下，使用 <code>CPU</code> 训练模型。可以通过如下方式，通过 <code>GPU</code> 进行训练。<strong>使用 GPU 时，模型和输入必须位于同一张 GPU 上。</strong></p><p><code>.to(device)</code> 和 <code>.cuda()</code> 的区别如下：</p><p><a href="https://stackoom.com/question/3bltP/Pytorch-%E5%9C%A8CUDA%E8%AE%BE%E5%A4%87%E4%B8%8A%E6%9C%89%E4%B8%89%E7%A7%8D%E6%96%B9%E6%B3%95%E5%8F%AF%E4%BB%A5%E5%88%9B%E5%BB%BA%E5%BC%A0%E9%87%8F-%E5%AE%83%E4%BB%AC%E4%B9%8B%E9%97%B4%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%E5%90%97" target="_blank" rel="noopener">to和cuda的区别</a><br><img src="/2020/01/06/Pytorch之GPU程序/pytorch-学习/to和cuda区别.png" alt="to和cuda区别"></p><ol><li><code>.to()</code> 中的参数必不可少</li><li>对于 <code>module</code> 而言，<code>.to()</code> 是 <code>inplace</code> 的，而 <code>.cuda()</code> 不是；而对于 <code>tensor</code> 而言，两者一致。</li></ol><blockquote><p><strong>注</strong>：实测，两者时间消耗持平。推荐使用<code>.to()函数</code></p></blockquote><p><strong>方式 1 ：使用cuda</strong></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">device</span> = torch.device(<span class="string">"cuda:1"</span>)   <span class="comment"># 指定模型训练所在 GPU</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 将 CPU 转移至 GPU</span></span><br><span class="line"><span class="keyword">if</span> torch.cuda.is_available() <span class="literal">and</span> use_gpu:</span><br><span class="line">    <span class="attr">net</span> = net.cuda(device)    <span class="comment"># 默认在第一块 GPU 上训练</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 同时将数据转移至 GPU,注意cuda有返回值</span></span><br><span class="line"><span class="keyword">if</span> torch.cuda.is_available() <span class="literal">and</span> use_gpu:</span><br><span class="line">    <span class="attr">inputs</span> = inputs.cuda(device)</span><br><span class="line">    <span class="attr">labels</span> = labels.cuda(device)</span><br></pre></td></tr></table></figure><p><strong>方法 2 ：使用to</strong></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">device</span> = torch.device(<span class="string">"cuda:1"</span>)   <span class="comment"># 指定模型训练所在 GPU</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 将 CPU 转移至 GPU</span></span><br><span class="line"><span class="keyword">if</span> torch.cuda.is_available() <span class="literal">and</span> use_gpu:</span><br><span class="line">    <span class="attr">net</span> = net.to(device)    <span class="comment"># 默认在第一块 GPU 上训练</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 同时将数据转移至 GPU</span></span><br><span class="line"><span class="keyword">if</span> torch.cuda.is_available() <span class="literal">and</span> use_gpu:</span><br><span class="line">    <span class="attr">inputs</span> = inputs.to(device)</span><br><span class="line">    <span class="attr">labels</span> = labels.to(device)</span><br></pre></td></tr></table></figure><h2><span id="存在的问题">存在的问题</span></h2><h3><span id="batch-size-太大">batch size 太大</span></h3><p>当想要用大批量进行训练，但是 <code>GPU</code> 资源有限，此时可以通过<strong>梯度累加</strong>（<code>accumulating gradients</code>）的方式进行。</p><p>梯度累加的基本思想在于，在优化器更新参数前，也就是执行 <code>optimizer.step()</code> 前，进行多次反向传播，使得梯度累计值自动保存在 <code>parameter.grad</code> 中，最后使用累加的梯度进行参数更新。</p><p>这个在 <code>PyTorch</code> 中特别容易实现，因为 <code>PyTorch</code> 中，梯度值本身会保留，除非我们调用 <code>model.zero_grad()</code> 或 <code>optimizer.zero_grad()</code>。</p><p>修改后的代码如下所示：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">model.zero_grad() <span class="comment"># 重置保存梯度值的张量</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i, (inputs, labels) <span class="keyword">in</span> enumerate(training_set):</span><br><span class="line">    predictions = model(inputs)<span class="comment"># 前向计算</span></span><br><span class="line">    loss = loss_function(predictions, labels)<span class="comment"># 计算损失函数</span></span><br><span class="line">    loss.backward()<span class="comment"># 计算梯度</span></span><br><span class="line">    <span class="keyword">if</span> (i + <span class="number">1</span>) % accumulation_steps == <span class="number">0</span>:<span class="comment">#重复多次前面的过程</span></span><br><span class="line">        optimizer.step()<span class="comment">#更新梯度</span></span><br><span class="line">        model.zero_grad()<span class="comment">#重置梯度</span></span><br></pre></td></tr></table></figure><h3><span id="model-太大">model 太大</span></h3><p>当模型本身太大，以至于不能放置于一个 <code>GPU</code> 中时，可以通过<strong>梯度检查点</strong> (<code>gradient-checkpoingting</code>) 的方式进行处理。</p><p>梯度检查点的基本思想是<strong>以计算换内存</strong>。具体来说就是，在反向传播的过程中，把梯度切分成几部分，分别对网络上的部分参数进行更新。如下图所示：</p><p><img src="http://tankzhou.cn/images/%E6%A2%AF%E5%BA%A6%E6%A3%80%E6%9F%A5%E7%82%B9.gif" alt=""></p><p>梯度检查点图示</p><p>这种方法速度很慢，但在某些例子上很有用，比如训练长序列的 RNN 模型等。</p><p>具体可参考：<a href="https://medium.com/huggingface/from-zero-to-research-an-introduction-to-meta-learning-8e16e677f78a" target="_blank" rel="noopener">From zero to research — An introduction to Meta-learning</a></p><p>单机多卡训练，即<strong>并行训练</strong>。并行训练又分为<strong>数据并行</strong> (<code>Data Parallelism</code>) 和<strong>模型并行</strong>两种。</p><p>数据并行指的是，多张 <code>GPU</code> 使用相同的模型副本，但是使用不同的数据批进行训练。而模型并行指的是，多张<code>GPU</code> 分别训练模型的不同部分，使用同一批数据。</p><p>两者对比如下图所示：</p><p><img src="/2020/01/06/Pytorch之GPU程序/pytorch-学习/多GPU.jpg" alt=""></p><p>模型并行 VS 数据并行</p><h2><span id="数据并行">数据并行</span></h2><p><a href="https://pytorch.org/tutorials/beginner/blitz/data_parallel_tutorial.html" target="_blank" rel="noopener">Pytorch多GPU官方实例</a></p><h3><span id="pytorch-api">Pytorch API</span></h3><p>【<strong>Class 原型</strong>】</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">torch.nn.DataParallel(module, <span class="attribute">device_ids</span>=None, <span class="attribute">output_device</span>=None, <span class="attribute">dim</span>=0)</span><br></pre></td></tr></table></figure><p>【<strong>参数</strong>】</p><ul><li><strong>module</strong> ：要进行并行的 <code>module</code>。这里隐含了一点 ，即网络中的某一层也是可以进行数据并行的，但是一般不会这么使用。</li><li><strong>device_ids</strong> : <code>CUDA</code> 列表，可以为 <code>torch.device</code> 类型，也可以是编号组成的 <code>int</code> 列表。<strong>默认使用全部 GPU</strong></li><li><strong>output_device</strong> : 某一 <code>GPU</code> 编号或 <code>torch.device</code> 。指定输出的 <code>GPU</code>，默认为第一个，即 <code>device_ids[0]</code></li></ul><p>【<strong>返回值</strong>】</p><p>要进行并行的模型。</p><p>【<strong>基本使用方式</strong>】</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;</span>&gt; net = torch.nn.DataParallel(model, device_ids=[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>])</span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; output = net(input_var)  <span class="comment"># input_var can be on any device, including CP</span></span><br></pre></td></tr></table></figure><h3><span id="数据并行的原理">数据并行的原理</span></h3><p>数据并行的具体原理流程为：</p><p><img src="/2020/01/06/Pytorch之GPU程序/pytorch-学习/数据并行.png" alt=""></p><ol><li><p>将模型加载至主设备上，作为 <code>controller</code>，一般设置为 <code>cuda:0</code></p></li><li><p>在每次迭代时，执行如下操作：</p><ol><li><p>将 <code>controller</code> 模型复制（<code>broadcast</code>）到每一个指定的 <code>GPU</code> 上</p></li><li><p>将总输入的数据 <code>batch</code>，进行均分，分别作为各对应副本的输入 (<code>scatter</code>)</p></li><li><p>每个副本独立进行前向传播，并进行反向传播，但只是求取梯度，每个GPU上的loss都要进行<code>loss.backward()</code>,得到各自的梯度</p></li><li><p>将各副本的梯度汇总（<code>gather</code>）到 <code>controller</code> 设备，并进行求和 (<code>reduced add</code>)</p><blockquote><p>During the backwards pass, gradients from each replica are summed into the original module.</p></blockquote></li><li><p>更具总体度，更新 <code>controller</code> 设备上的参数</p></li></ol></li></ol><h3><span id="注意事项">注意事项</span></h3><p>【<strong>警告 1</strong>】</p><ul><li>设置的 <code>batch size</code> 为总的批量尺寸，其必须大于 <code>GPU</code> 数量。</li><li>在 <code>parallelized module</code> 运行之前，必须保证其在 <code>controller</code> 设备上，存在参数和 <code>buffers</code>。</li><li>并行的 <code>GPU</code> 列表中，必须包含主 <code>GPU</code></li><li>当 <code>forward()</code> 中，<code>module</code> 返回一个标量，那么并行的结果将返回一个 <code>vector</code>，其长度等于 <code>device</code> 的数量，对应于各个设备的结果。</li></ul><p>【<strong>警告 2</strong>】</p><p>在每次前向传播过程中，<code>module</code> 都先会被复制到每一个 <code>device</code> 上。因此，在前向传播中，任何对该运行的 <code>module</code> 的副本的更新，在此后都将会丢失。</p><p>比方说，如果 <code>module</code> 有一个 <code>counter</code> 属性，每次前向传播都会进行累加，则它将会保持为初始值。因为更新是发生在模型的副本（在其他 <code>device</code> 上的副本）上的，并且这些更新在前向传播结束之后将会被销毁。</p><p>然而，<code>DataParallel</code> 保证 <code>controller</code> 设备上的副本的参数和 <code>buffers</code> 与其他并行的 <code>modules</code> 之间共享存储。因此，如若对 <code>controller device</code> 的 参数和 <code>buffers</code> 的更改，将会被记录。例如，<code>BatchNorm2d</code> 和 <code>spectral_norm()</code> 依赖于这种行为来更新 <code>buffers</code>。</p><p>【<strong>警告 3</strong>】</p><p>定义于 <code>module</code> 及其子 <code>module</code> 上的前向传播和反向传播 <code>hooks</code>，将会被调用 <code>len(device_ids)</code> 次，每个设备对应一次。</p><p>具体来说，<code>hooks</code> 只能保证按照正确的顺序执行对应设备上的操作，即在对应设备上的 <code>forward()</code> 调用之前执行，但是不能保证，在所有 <code>forward)()</code> 执行之前，通过 <code>register_forward_pre_hook()</code> 执行完成所有的 <code>hooks</code>。</p><p>【<strong>警告 4</strong>】</p><p>任何位置和关键字 (<code>positional and keyword</code>) 输入都可以传递给 <code>DataParallel</code>，处理一些需要特殊处理的类型。</p><p><code>tensors</code> 将会在指定维度（默认为 <code>0</code>）上被 <code>scattered</code>。 <code>tuple</code>， <code>list</code> 和 <code>dict</code> 类型则会被浅拷贝。其他类型则会在不同的线程之间进行共享，且在模型前向传播过程中，如果进行写入，则可被打断。</p><p>【<strong>警告 5</strong>】</p><p>当对 <code>pack sequence -&gt; recurrent network -&gt; unpack sequence</code> 模式的 <code>module</code> 使用 <code>DataParallel</code> 或 <code>data_parallel</code> 时，有一些小的问题。</p><p>每个设备上的 <code>forward</code> 的对应输入，将仅仅是整个输入的一部分。因为默认的 <code>unpack</code> 操作 <code>torch.nn.utils.rnn.pad_packed_sequence()</code> 只会将该设备上的输入 <code>padding</code> 成该设备上的最长的输入长度，因此，将所有设备的结构进行汇总时，可能会发生长度的不匹配的情况。</p><p>因此，可以利用 <code>pad_packed_sequence()</code> 的 <code>total_length</code> 参数来保证 <code>forward()</code> 调用返回的序列长度一致。代码如下所示：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> torch.nn.utils.rnn <span class="keyword">import</span> pack_padded_sequence, pad_packed_sequence</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyModule</span><span class="params">(nn.Module)</span>:</span></span><br><span class="line">    <span class="comment"># ... __init__, other methods, etc.</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># padded_input is of shape [B x T x *] (batch_first mode) and contains</span></span><br><span class="line">    <span class="comment"># the sequences sorted by lengths</span></span><br><span class="line">    <span class="comment">#   B is the batch size</span></span><br><span class="line">    <span class="comment">#   T is max sequence length</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span><span class="params">(self, padded_input, input_lengths)</span>:</span></span><br><span class="line">        total_length = padded_input.size(<span class="number">1</span>)  <span class="comment"># get the max sequence length</span></span><br><span class="line">        packed_input = pack_padded_sequence(padded_input, input_lengths,</span><br><span class="line">                                            batch_first=<span class="keyword">True</span>)</span><br><span class="line">        packed_output, _ = self.my_lstm(packed_input)</span><br><span class="line">        output, _ = pad_packed_sequence(packed_output, batch_first=<span class="keyword">True</span>,</span><br><span class="line">                                        total_length=total_length)</span><br><span class="line">        <span class="keyword">return</span> output</span><br><span class="line"></span><br><span class="line">m = MyModule().cuda()        <span class="comment"># 设置 controller 模型</span></span><br><span class="line">dp_m = nn.DataParallel(m)    <span class="comment"># 进行副本拷贝</span></span><br></pre></td></tr></table></figure><h3><span id="示例程序">示例程序</span></h3><p>下面是使用 <code>DataParrel</code> 的核心代码，其余部分与一般的训练流程一致。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 设置当前脚本可见的 GPU 列表</span></span><br><span class="line"><span class="comment"># 这里设置 0 号和 1 号 GPU 对当前脚本可见。</span></span><br><span class="line"><span class="comment"># 此时，若 DataParallel 中指定使用其他 GPU 资源，额外的编号将会被忽略</span></span><br><span class="line">os.environ[<span class="string">"CUDA_VISIBLE_DEVICES"</span>] = <span class="string">"0, 1"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用数据并行</span></span><br><span class="line"><span class="comment"># 1. 将 model 转移到某 GPU 上 -- net.cuda()</span></span><br><span class="line"><span class="comment"># 2. 指定并行训练要用到的 GPU -- device_ids=[0, 1]</span></span><br><span class="line"><span class="keyword">if</span> torch.cuda.device_count() &gt; <span class="number">1</span>:</span><br><span class="line">    print(<span class="string">"Let's use"</span>, torch.cuda.device_count(), <span class="string">"GPUs!"</span>)</span><br><span class="line">    net = nn.DataParallel(net.cuda(), device_ids=[<span class="number">0</span>, <span class="number">1</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将数据转移到 controller 所在 GPU</span></span><br><span class="line"><span class="keyword">if</span> torch.cuda.is_available() <span class="keyword">and</span> use_gpu:</span><br><span class="line">    inputs = inputs.cuda(device)</span><br><span class="line">    labels = labels.cuda(device)</span><br></pre></td></tr></table></figure><h3><span id="模型的加载">模型的加载</span></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_Single2Parallel</span><span class="params">(self, origin_state)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    将串行的权值参数转换为并行的权值参数</span></span><br><span class="line"><span class="string">    :param origin_state : 原始串行权值参数</span></span><br><span class="line"><span class="string">    :return             : 并行的权值参数</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">  converted = OrderedDict()</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">for</span> k, v <span class="keyword">in</span> origin_state.items():</span><br><span class="line">      name = <span class="string">"module."</span> + k</span><br><span class="line">      converted[name] = v</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> converted</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_Parallel2Single</span><span class="params">(self, origin_state)</span>:</span></span><br><span class="line">  <span class="string">"""</span></span><br><span class="line"><span class="string">  将并行的权值参数转换为串行的权值参数</span></span><br><span class="line"><span class="string">  :param origin_state : 原始串行权值参数</span></span><br><span class="line"><span class="string">  :return             : 并行的权值参数</span></span><br><span class="line"><span class="string">  """</span></span><br><span class="line">    </span><br><span class="line">    converted = OrderedDict()</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> k, v <span class="keyword">in</span> origin_state.items():</span><br><span class="line">      name = k[<span class="number">7</span>:]</span><br><span class="line">      converted[name] = v</span><br><span class="line">      </span><br><span class="line">    <span class="keyword">return</span> converted</span><br></pre></td></tr></table></figure><h2><span id="模型并行">模型并行</span></h2><p>如果模型本身较大，一张 <code>GPU</code> 放置不下时，要通过模型并行来处理。模型并行指的是，将模型的不同部分，分别放置于不同的 <code>GPU</code> 上，并将中间结果在 <code>GPU</code> 之间进行传递。</p><p>尽管从执行时间上来看，将模型的不同部分部署在不同设备上确实有好处，但是它通常是出于避免内存限制才使用。具有特别多参数的模型会受益于这种并行策略，因为这类模型需要很高的内存占用，很难适应到单个系统。</p><h3><span id="基本使用">基本使用</span></h3><p>下面，我们以一个 <code>toy</code> 模型为例，讲解模型并行。模型并行的实现方式如下所示：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Net</span><span class="params">(nn.Module)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        super(Net, self).__init__()</span><br><span class="line"></span><br><span class="line">        self.features_1 = nn.Sequential(</span><br><span class="line">            nn.Conv2d(in_channels=<span class="number">3</span>, out_channels=<span class="number">16</span>, kernel_size=<span class="number">3</span>),</span><br><span class="line">            nn.BatchNorm2d(<span class="number">16</span>),</span><br><span class="line">            nn.ReLU(inplace=<span class="keyword">True</span>),  <span class="comment"># 30</span></span><br><span class="line">            ......</span><br><span class="line">            nn.Conv2d(in_channels=<span class="number">64</span>, out_channels=<span class="number">128</span>, kernel_size=<span class="number">3</span>),</span><br><span class="line">            nn.BatchNorm2d(<span class="number">128</span>),</span><br><span class="line">            nn.ReLU(inplace=<span class="keyword">True</span>),  <span class="comment"># 12</span></span><br><span class="line">        ).to(<span class="string">'cuda:0'</span>)</span><br><span class="line"></span><br><span class="line">        self.features_2 = nn.Sequential(</span><br><span class="line">            nn.Conv2d(in_channels=<span class="number">128</span>, out_channels=<span class="number">256</span>, kernel_size=<span class="number">3</span>, stride=<span class="number">2</span>),</span><br><span class="line">            nn.BatchNorm2d(<span class="number">256</span>),</span><br><span class="line">            nn.ReLU(inplace=<span class="keyword">True</span>),  <span class="comment"># 5</span></span><br><span class="line">            ......).to(<span class="string">'cuda:1'</span>)  <span class="comment"># 1</span></span><br><span class="line"></span><br><span class="line">        self.classifier = nn.Sequential(</span><br><span class="line">            nn.Dropout(),</span><br><span class="line">            ......</span><br><span class="line">            nn.Linear(<span class="number">1024</span>, class_num)).to(<span class="string">'cuda:1'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        out = self.features_1(x.to(<span class="string">'cuda:0'</span>))</span><br><span class="line">        out = self.features_2(out.to(<span class="string">'cuda:1'</span>))</span><br><span class="line">        out = out.view(<span class="number">-1</span>, <span class="number">384</span>)</span><br><span class="line">        out = self.classifier(out)</span><br><span class="line">        out = F.softmax(out, dim=<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> out</span><br></pre></td></tr></table></figure><p>上面的 <code>toy</code> 模型看起来和在单个 <code>GPU</code> 上运行的模型没什么区别，只不过用 <code>to(device)</code> 来将模型内的不同层分散到不同的 <code>GPU</code> 上进行运行，并且将中间结果转移到对应的 <code>GPU</code> 上即可。</p><p><code>backward()</code> 和 <code>torch.optim</code> 将会自动考虑梯度，与在一个 <code>GPU</code> 上没有区别。</p><blockquote><p><strong>注意</strong>：在调用 <code>loss</code> 函数时，<code>labels</code> 与 <code>output</code> 必须在同一个 <code>GPU</code> 上。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 此时，不在此需要使用 model = model.cuda()</span></span><br><span class="line">model = ToyModel()</span><br><span class="line"></span><br><span class="line">loss_fn = nn.MSELoss()</span><br><span class="line">optimizer = optim.SGD(model.parameters(), lr=<span class="number">0.001</span>)</span><br><span class="line"></span><br><span class="line">optimizer.zero_grad()</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> data <span class="keyword">in</span> trainloader:</span><br><span class="line">    images, labels = data</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 要处理的部分</span></span><br><span class="line">    images = images.to(<span class="string">'cuda:0'</span>)</span><br><span class="line">    labels = labels.to(<span class="string">'cuda:1'</span>)   <span class="comment"># 必须与输出所在 GPU 一致</span></span><br><span class="line">    </span><br><span class="line">    outputs = net(images)</span><br><span class="line">    loss = criterion(outputs, labels)</span><br><span class="line">    loss.backward()</span><br><span class="line">    optimizer.step()</span><br></pre></td></tr></table></figure><h3><span id="模型并行的性能分析">模型并行的性能分析</span></h3><p>以上的实现解决了单个模型太大，不能存放于一个 <code>GPU</code> 的情况。然而，需要注意的是，相较于在单个 <code>GPU</code> 上运行，其速度更慢。因为任何时候，只有一个 <code>GPU</code> 在工作，而另一个则闲置。而当中间结果在 <code>GPU</code> 之间进行转移时，速度会进一步下降。</p><p>下面同时实例分析。以 <code>resnet50</code> 为例，用随机生成的数据输入，比较两个版本的运行时间。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> torchvision.models.resnet <span class="keyword">import</span> ResNet, Bottleneck</span><br><span class="line"></span><br><span class="line">num_classes = <span class="number">1000</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ModelParallelResNet50</span><span class="params">(ResNet)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, *args, **kwargs)</span>:</span></span><br><span class="line">        super(ModelParallelResNet50, self).__init__(</span><br><span class="line">            Bottleneck, [<span class="number">3</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">3</span>], num_classes=num_classes, *args, **kwargs)</span><br><span class="line"></span><br><span class="line">        self.seq1 = nn.Sequential(</span><br><span class="line">            self.conv1,</span><br><span class="line">            self.bn1,</span><br><span class="line">            self.relu,</span><br><span class="line">            self.maxpool,</span><br><span class="line"></span><br><span class="line">            self.layer1,</span><br><span class="line">            self.layer2</span><br><span class="line">        ).to(<span class="string">'cuda:0'</span>)</span><br><span class="line"></span><br><span class="line">        self.seq2 = nn.Sequential(</span><br><span class="line">            self.layer3,</span><br><span class="line">            self.layer4,</span><br><span class="line">            self.avgpool,</span><br><span class="line">        ).to(<span class="string">'cuda:1'</span>)</span><br><span class="line"></span><br><span class="line">        self.fc.to(<span class="string">'cuda:1'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        x = self.seq2(self.seq1(x).to(<span class="string">'cuda:1'</span>))</span><br><span class="line">        <span class="keyword">return</span> self.fc(x.view(x.size(<span class="number">0</span>), <span class="number">-1</span>))</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torchvision.models <span class="keyword">as</span> models</span><br><span class="line"></span><br><span class="line">num_batches = <span class="number">3</span></span><br><span class="line">batch_size = <span class="number">120</span></span><br><span class="line">image_w = <span class="number">128</span></span><br><span class="line">image_h = <span class="number">128</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">train</span><span class="params">(model)</span>:</span></span><br><span class="line">    model.train(<span class="keyword">True</span>)</span><br><span class="line">    loss_fn = nn.MSELoss()</span><br><span class="line">    optimizer = optim.SGD(model.parameters(), lr=<span class="number">0.001</span>)</span><br><span class="line"></span><br><span class="line">    one_hot_indices = torch.LongTensor(batch_size) \</span><br><span class="line">                           .random_(<span class="number">0</span>, num_classes) \</span><br><span class="line">                           .view(batch_size, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> range(num_batches):</span><br><span class="line">        <span class="comment"># generate random inputs and labels</span></span><br><span class="line">        inputs = torch.randn(batch_size, <span class="number">3</span>, image_w, image_h)</span><br><span class="line">        labels = torch.zeros(batch_size, num_classes) \</span><br><span class="line">                      .scatter_(<span class="number">1</span>, one_hot_indices, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># run forward pass</span></span><br><span class="line">        optimizer.zero_grad()</span><br><span class="line">        outputs = model(inputs.to(<span class="string">'cuda:0'</span>))</span><br><span class="line"></span><br><span class="line">        <span class="comment"># run backward pass</span></span><br><span class="line">        labels = labels.to(outputs.device)</span><br><span class="line">        loss_fn(outputs, labels).backward()</span><br><span class="line">        optimizer.step()</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line">plt.switch_backend(<span class="string">'Agg'</span>)</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> timeit</span><br><span class="line"></span><br><span class="line">num_repeat = <span class="number">10</span></span><br><span class="line"></span><br><span class="line">stmt = <span class="string">"train(model)"</span></span><br><span class="line"></span><br><span class="line">setup = <span class="string">"model = ModelParallelResNet50()"</span></span><br><span class="line"><span class="comment"># globals arg is only available in Python 3. In Python 2, use the following</span></span><br><span class="line"><span class="comment"># import __builtin__</span></span><br><span class="line"><span class="comment"># __builtin__.__dict__.update(locals())</span></span><br><span class="line">mp_run_times = timeit.repeat(</span><br><span class="line">    stmt, setup, number=<span class="number">1</span>, repeat=num_repeat, globals=globals())</span><br><span class="line">mp_mean, mp_std = np.mean(mp_run_times), np.std(mp_run_times)</span><br><span class="line"></span><br><span class="line">setup = <span class="string">"import torchvision.models as models;"</span> + \</span><br><span class="line">        <span class="string">"model = models.resnet50(num_classes=num_classes).to('cuda:0')"</span></span><br><span class="line">rn_run_times = timeit.repeat(</span><br><span class="line">    stmt, setup, number=<span class="number">1</span>, repeat=num_repeat, globals=globals())</span><br><span class="line">rn_mean, rn_std = np.mean(rn_run_times), np.std(rn_run_times)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">plot</span><span class="params">(means, stds, labels, fig_name)</span>:</span></span><br><span class="line">    fig, ax = plt.subplots()</span><br><span class="line">    ax.bar(np.arange(len(means)), means, yerr=stds,</span><br><span class="line">           align=<span class="string">'center'</span>, alpha=<span class="number">0.5</span>, ecolor=<span class="string">'red'</span>, capsize=<span class="number">10</span>, width=<span class="number">0.6</span>)</span><br><span class="line">    ax.set_ylabel(<span class="string">'ResNet50 Execution Time (Second)'</span>)</span><br><span class="line">    ax.set_xticks(np.arange(len(means)))</span><br><span class="line">    ax.set_xticklabels(labels)</span><br><span class="line">    ax.yaxis.grid(<span class="keyword">True</span>)</span><br><span class="line">    plt.tight_layout()</span><br><span class="line">    plt.savefig(fig_name)</span><br><span class="line">    plt.close(fig)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">plot([mp_mean, rn_mean],</span><br><span class="line">     [mp_std, rn_std],</span><br><span class="line">     [<span class="string">'Model Parallel'</span>, <span class="string">'Single GPU'</span>],</span><br><span class="line">     <span class="string">'mp_vs_rn.png'</span>)</span><br></pre></td></tr></table></figure><p>结果如下所示。模型并行相较于单 <code>GPU</code> 训练的模型，训练时间开销多出 <code>4.02/3.75-1=7%</code> 左右。当然，这存在优化空间，因为多 <code>GPU</code> 中，每一时刻只有一个 <code>GPU</code> 进行训练，其他闲置。而在中间数据转移过程中，又消耗一定的时间。</p><p><img src="/2020/01/06/Pytorch之GPU程序/pytorch-学习/模型并行.jpg" alt=""></p><p>模型并行 VS 单 GPU</p><h3><span id="输入流水线">输入流水线</span></h3><p>解决上面的问题的最直接的方式就是使用流水线技术，即 <code>GPU-0</code> 输出到 <code>GPU-1</code> 之后，在 <code>GPU-1</code> 训练的同时，<code>GPU-0</code> 接收下一批数据，这样就可以多 <code>GPU</code> 同时执行了。</p><p>下面，我们将 <code>120</code> 个样本的 <code>batch</code> 再次细分，分为 <code>20</code> 张样本每份的小 <code>batch</code>。由于 <code>Pytorch</code> 同步启动 <code>CUDA</code> 操作，因此，该操作不需要使用额外的多线程来处理。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PipelineParallelResNet50</span><span class="params">(ModelParallelResNet50)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, split_size=<span class="number">20</span>, *args, **kwargs)</span>:</span></span><br><span class="line">        super(PipelineParallelResNet50, self).__init__(*args, **kwargs)</span><br><span class="line">        self.split_size = split_size</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        splits = iter(x.split(self.split_size, dim=<span class="number">0</span>))</span><br><span class="line">        s_next = next(splits)</span><br><span class="line">        s_prev = self.seq1(s_next).to(<span class="string">'cuda:1'</span>)</span><br><span class="line">        ret = []</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> s_next <span class="keyword">in</span> splits:</span><br><span class="line">            <span class="comment"># A. s_prev runs on cuda:1</span></span><br><span class="line">            s_prev = self.seq2(s_prev)</span><br><span class="line">            ret.append(self.fc(s_prev.view(s_prev.size(<span class="number">0</span>), <span class="number">-1</span>)))</span><br><span class="line"></span><br><span class="line">            <span class="comment"># B. s_next runs on cuda:0, which can run concurrently with A</span></span><br><span class="line">            s_prev = self.seq1(s_next).to(<span class="string">'cuda:1'</span>)</span><br><span class="line"></span><br><span class="line">        s_prev = self.seq2(s_prev)</span><br><span class="line">        ret.append(self.fc(s_prev.view(s_prev.size(<span class="number">0</span>), <span class="number">-1</span>)))</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> torch.cat(ret)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">setup = <span class="string">"model = PipelineParallelResNet50()"</span></span><br><span class="line">pp_run_times = timeit.repeat(</span><br><span class="line">    stmt, setup, number=<span class="number">1</span>, repeat=num_repeat, globals=globals())</span><br><span class="line">pp_mean, pp_std = np.mean(pp_run_times), np.std(pp_run_times)</span><br><span class="line"></span><br><span class="line">plot([mp_mean, rn_mean, pp_mean],</span><br><span class="line">     [mp_std, rn_std, pp_std],</span><br><span class="line">     [<span class="string">'Model Parallel'</span>, <span class="string">'Single GPU'</span>, <span class="string">'Pipelining Model Parallel'</span>],</span><br><span class="line">     <span class="string">'mp_vs_rn_vs_pp.png'</span>)</span><br></pre></td></tr></table></figure><p>需要注意的是，<code>device-to-device</code> 的 <code>tensor copy</code> 操作是同步的。如果创建多个数据流，则需要保证 <code>copy</code> 操作以合适的同步方式进行。</p><p>在完成 <code>tensor</code> 拷贝之前，对 <code>source tensor</code> 进行写入，或者对 <code>target tensor</code> 进行读写，都可能会导致不可预期的行为。上面的实现中，在源和目标设备中，均只使用了默认的 <code>stream</code>，因此无需额外的强化同步操作。</p><p><img src="/2020/01/06/Pytorch之GPU程序/pytorch-学习/模型并行2.jpg" alt=""><br>模型并行 VS 单 GPU VS 流水线模型并行</p><p>如上图所示，流水线输入确实加速了训练进程，大约 <code>3.75/2.51-1=49%</code>，但距离 <code>100%</code> 的加速相去甚远。由于我们在流水线并行实现中，引入了一个新的参数 <code>split_sizes</code>，但是并不知晓其对训练时间的影响。</p><p>直觉上来说，使用一个小的 <code>split_sizes</code> 将会导致许多微小的 <code>CUDA</code> 内核的启动，而使用较大的 <code>split_sizes</code>，则会导致较长的空闲时间。下面是一个搜索最佳 <code>split_sizes</code> 的实验。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">means = []</span><br><span class="line">stds = []</span><br><span class="line">split_sizes = [<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">10</span>, <span class="number">12</span>, <span class="number">20</span>, <span class="number">40</span>, <span class="number">60</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> split_size <span class="keyword">in</span> split_sizes:</span><br><span class="line">    setup = <span class="string">"model = PipelineParallelResNet50(split_size=%d)"</span> % split_size</span><br><span class="line">    pp_run_times = timeit.repeat(</span><br><span class="line">        stmt, setup, number=<span class="number">1</span>, repeat=num_repeat, globals=globals())</span><br><span class="line">    means.append(np.mean(pp_run_times))</span><br><span class="line">    stds.append(np.std(pp_run_times))</span><br><span class="line"></span><br><span class="line">fig, ax = plt.subplots()</span><br><span class="line">ax.plot(split_sizes, means)</span><br><span class="line">ax.errorbar(split_sizes, means, yerr=stds, ecolor=<span class="string">'red'</span>, fmt=<span class="string">'ro'</span>)</span><br><span class="line">ax.set_ylabel(<span class="string">'ResNet50 Execution Time (Second)'</span>)</span><br><span class="line">ax.set_xlabel(<span class="string">'Pipeline Split Size'</span>)</span><br><span class="line">ax.set_xticks(split_sizes)</span><br><span class="line">ax.yaxis.grid(<span class="keyword">True</span>)</span><br><span class="line">plt.tight_layout()</span><br><span class="line">plt.savefig(<span class="string">"split_size_tradeoff.png"</span>)</span><br><span class="line">plt.close(fig)</span><br></pre></td></tr></table></figure><p>实验结果如下所示：</p><p><img src="/2020/01/06/Pytorch之GPU程序/pytorch-学习/pipeline.jpg" alt=""></p><p>流水线输入分割份数</p><p>如上图所示，最佳的参数为 <code>12</code>，其将导致 <code>3.75/2.43-1=54%</code> 的加速。但这仍存在加速的可能。例如，所有在 <code>cuda:0</code> 上的操作放在默认的 <code>stream</code> 上。这意味着，在下一个 <code>split</code> 上的计算，不能与上一个 <code>split</code> 的 <code>copy</code> 操作进行重叠。然而，由于 <code>next_split</code> 和 <code>prev_plit</code> 是不同的 <code>tensor</code>，因此这不存在问题。</p><p>该实现需要在每个 <code>GPU</code> 上使用多个 <code>stream</code>，并且模型中不同的子网络需要使用不同的 <code>stream</code> 管理策略。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;介绍Pytorch的一些使用方法&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Deep Learning" scheme="http://yoursite.com/categories/Deep-Learning/"/>
    
    
      <category term="Pytorch" scheme="http://yoursite.com/tags/Pytorch/"/>
    
  </entry>
  
  <entry>
    <title>Mxnet和Pytorch区别</title>
    <link href="http://yoursite.com/2019/12/29/Mxnet%E5%92%8CPytorch%E5%8C%BA%E5%88%AB/"/>
    <id>http://yoursite.com/2019/12/29/Mxnet和Pytorch区别/</id>
    <published>2019-12-29T09:05:01.000Z</published>
    <updated>2020-03-22T15:31:10.733Z</updated>
    
    <content type="html"><![CDATA[<p>平时主要使用mxnet和pytorch，下面记录下在代码中怎么使用GPU<br><a id="more"></a></p><!-- TOC --><ul><li><a href="#1-mxnet">1. mxnet</a><ul><li><a href="#11-%e5%8d%95gpu">1.1. 单GPU</a></li><li><a href="#12-%e5%a4%9agpu">1.2. 多GPU</a></li></ul></li><li><a href="#2-pytorch">2. pytorch</a><ul><li><a href="#21-%e5%8d%95gpu">2.1. 单GPU</a></li><li><a href="#22-%e5%a4%9agpu">2.2. 多GPU</a></li></ul></li><li><a href="#3-mxnet%e5%92%8cpytorch%e5%8c%ba%e5%88%ab">3. mxnet和pytorch区别</a><ul><li><a href="#31-ndarray%e5%92%8ctensor">3.1. NDArray和Tensor</a><ul><li><a href="#311-%e5%92%8cnumpy%e8%bd%ac%e6%8d%a2">3.1.1. 和numpy转换</a></li><li><a href="#312-%e8%bd%ac%e6%8d%a2%e4%b8%ba%e6%a0%87%e9%87%8f">3.1.2. 转换为标量</a></li><li><a href="#313-%e6%94%b9%e5%8f%98%e6%95%b0%e6%8d%ae%e5%bd%a2%e7%8a%b6">3.1.3. 改变数据形状</a></li><li><a href="#314-%e6%95%b0%e6%8d%ae%e8%bd%ac%e5%88%b0gpu%e4%b8%8a">3.1.4. 数据转到GPU上</a></li></ul></li><li><a href="#32-loss%e8%ae%a1%e7%ae%97">3.2. loss计算</a></li><li><a href="#33-rnn%e8%be%93%e5%85%a5%e7%bb%b4%e5%ba%a6">3.3. RNN输入维度</a></li><li><a href="#34-transformer%e8%be%93%e5%85%a5%e7%bb%b4%e5%ba%a6">3.4. Transformer输入维度</a></li><li><a href="#35-%e5%a4%9agpu%e8%bf%90%e8%a1%8c">3.5. 多GPU运行</a></li><li><a href="#36-%e5%b0%86%e7%bd%91%e7%bb%9c%e5%8a%a0%e5%85%a5list%e4%b8%ad">3.6. 将网络加入list中</a></li><li><a href="#%e5%9b%ba%e5%ae%9a%e9%9a%8f%e6%9c%ba%e7%a7%8d%e5%ad%90">固定随机种子</a></li><li><a href="#%e8%ae%bf%e9%97%ae%e6%a8%a1%e5%9e%8b%e5%8f%82%e6%95%b0">访问模型参数</a></li></ul></li></ul><!-- /TOC --><h1><span id="1-mxnet">1. mxnet</span></h1><h2><span id="11-单gpu">1.1. 单GPU</span></h2><p><a href="http://zh.gluon.ai/chapter_deep-learning-computation/use-gpu.html" target="_blank" rel="noopener">GPU计算</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> mxnet <span class="keyword">as</span> mx</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"><span class="comment">#指定使用哪块GPU</span></span><br><span class="line">os.environ[<span class="string">"CUDA_VISIBLE_DEVICES"</span>] = <span class="string">"3"</span></span><br><span class="line"><span class="comment">#被指定的GPU编号默认为0</span></span><br><span class="line">ctx = mx.gpu(<span class="number">0</span>)</span><br><span class="line"><span class="comment">#模型、数据都需要拷贝到GPU中</span></span><br><span class="line">nd.array(data,ctx)</span><br><span class="line">data.as_in_context(ctx)</span><br></pre></td></tr></table></figure><h2><span id="12-多gpu">1.2. 多GPU</span></h2><p><a href="http://zh.gluon.ai/chapter_computational-performance/multiple-gpus-gluon.html" target="_blank" rel="noopener">多GPU计算</a><br><a href="http://mxnet.incubator.apache.org/api/faq/multi_device" target="_blank" rel="noopener">Run MXNet on Multiple CPU/GPUs with Data Parallelism</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> mxnet <span class="keyword">as</span> mx</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line">ctx_id = <span class="string">'1,2,3,4'</span></span><br><span class="line">os.environ[<span class="string">"CUDA_VISIBLE_DEVICES"</span>] = ctx_id</span><br><span class="line">num_gpus = len(ctx_id.split(<span class="string">','</span>))</span><br><span class="line">ctx = [mx.gpu(i) <span class="keyword">for</span> i <span class="keyword">in</span> range(num_gpus)]</span><br><span class="line"></span><br><span class="line"><span class="comment">#使用split_and_load()将数据分配到多个GPU上</span></span><br></pre></td></tr></table></figure><h1><span id="2-pytorch">2. pytorch</span></h1><h2><span id="21-单gpu">2.1. 单GPU</span></h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line">os.environ[<span class="string">"CUDA_VISIBLE_DEVICES"</span>] = <span class="string">"1"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> torch.cuda.is_available():</span><br><span class="line">    device = torch.device(<span class="string">"cuda:0"</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    device = torch.device(<span class="string">"cpu"</span>)</span><br><span class="line"><span class="comment">#使用to()将数据拷贝到GPU上</span></span><br><span class="line">train_feature.to(device)</span><br></pre></td></tr></table></figure><h2><span id="22-多gpu">2.2. 多GPU</span></h2><p><a href="https://github.com/dnddnjs/pytorch-multigpu/blob/master/data_parallel/train.py" target="_blank" rel="noopener">pytorch-multigpu</a></p><p><a href="https://pytorch.org/tutorials/beginner/blitz/data_parallel_tutorial.html" target="_blank" rel="noopener">OPTIONAL: DATA PARALLELISM</a></p><p><a href="https://pytorch.org/tutorials/beginner/former_torchies/parallelism_tutorial.html" target="_blank" rel="noopener">MULTI-GPU EXAMPLES</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">os.environ[<span class="string">"CUDA_VISIBLE_DEVICES"</span>] = <span class="string">"1,2,3"</span>  </span><br><span class="line"><span class="keyword">if</span> torch.cuda.is_available():</span><br><span class="line">    device = torch.device(<span class="string">"cuda:0"</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    device = torch.device(<span class="string">"cpu"</span>)</span><br><span class="line"><span class="comment">#pytorch在使用多GPU时，需要先将数据和模型拷贝到GPU-0上，</span></span><br><span class="line"><span class="comment">#使用多GPU的关键代码</span></span><br><span class="line"><span class="keyword">if</span> torch.cuda.device_count() &gt; <span class="number">1</span>:</span><br><span class="line">    print(<span class="string">"Let's use"</span>, torch.cuda.device_count(), <span class="string">"GPUs!"</span>,flush=<span class="keyword">True</span>)</span><br><span class="line">    <span class="comment">#数据并行</span></span><br><span class="line">    model = nn.DataParallel(model)</span><br><span class="line">model.to(device)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> data <span class="keyword">in</span> rand_loader:</span><br><span class="line">    input = data.to(device)</span><br><span class="line">    output = model(input)</span><br><span class="line">    print(<span class="string">"Outside: input size"</span>, input.size(),</span><br><span class="line">          <span class="string">"output_size"</span>, output.size())</span><br></pre></td></tr></table></figure><p><code>DataParallel</code>自动分割数据，并发送到多个GPU上，每个GPU上完成前向传播， <code>DataParallel</code>收集每个GPU上的结果。</p><hr><p>2020.2.11更新</p><h1><span id="3-mxnet和pytorch区别">3. mxnet和pytorch区别</span></h1><p>在写程序时，主要用到<code>mxnet和pytorch</code>框架，这里针对2者在代码上的不同做个总结，下面的不同都是我自己在写程序遇到的，仅仅是一部分，仅供参考。</p><h2><span id="31-ndarray和tensor">3.1. NDArray和Tensor</span></h2><h3><span id="311-和numpy转换">3.1.1. 和numpy转换</span></h3><ul><li><p>mxnet</p><ul><li><strong>Numpy—&gt;NDArray</strong><br><code>nd.array(a)</code></li><li><strong>NDArray—&gt;Numpy</strong><br><code>D.asnumpy()</code></li></ul></li><li><p>pytorch</p><ul><li><strong>Numpy—&gt;Tensor</strong><br><code>D = torch.from_numpy(a)</code></li><li><strong>Tensor—&gt;Numpy</strong><br><code>a = D.numpy()</code></li></ul></li></ul><h3><span id="312-转换为标量">3.1.2. 转换为标量</span></h3><ul><li>mxnet<br><code>asscalar()</code>将函数结果转换成Python的标量<br><code>X.sum().asscalar()</code></li><li>pytorch<br><code>item()</code>将函数结果转换成Python的标量<br><code>X.sum().item()</code></li></ul><h3><span id="313-改变数据形状">3.1.3. 改变数据形状</span></h3><ul><li><p>mxnet</p><ul><li><p><strong>reshape()</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">X = x.reshape((<span class="number">3</span>, <span class="number">4</span>))</span><br><span class="line">X = x.reshape((<span class="number">-1</span>, <span class="number">4</span>))</span><br></pre></td></tr></table></figure></li></ul></li><li><p>pytorch</p><ul><li><p><strong>view()</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">y = x.view(<span class="number">15</span>)</span><br><span class="line">z = x.view(<span class="number">-1</span>, <span class="number">5</span>)  <span class="comment"># -1所指的维度可以根据其他维度的值推出来</span></span><br></pre></td></tr></table></figure></li></ul></li></ul><h3><span id="314-数据转到gpu上">3.1.4. 数据转到GPU上</span></h3><ul><li><p>mxnet<br>使用<code>as_in_context()</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#在gpu上创建NDArray</span></span><br><span class="line">B = nd.random.uniform(shape=(<span class="number">2</span>, <span class="number">3</span>), ctx=mx.gpu(<span class="number">1</span>))</span><br><span class="line"></span><br><span class="line">z = x.as_in_context(mx.gpu())</span><br></pre></td></tr></table></figure></li><li><p>pytorch<br>使用<code>to()</code>函数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> torch.cuda.is_available():</span><br><span class="line">    device = torch.device(<span class="string">"cuda"</span>) <span class="comment"># GPU</span></span><br><span class="line">y = torch.ones_like(x, device=device)  <span class="comment"># 直接创建一个在GPU上的Tensor</span></span><br><span class="line">x = x.to(device)</span><br></pre></td></tr></table></figure></li></ul><h2><span id="32-loss计算">3.2. loss计算</span></h2><ul><li>maxnet</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">loss = L2Loss()</span><br><span class="line"><span class="keyword">for</span> epoch <span class="keyword">in</span> range(<span class="number">1</span>,num_epochs + <span class="number">1</span>):</span><br><span class="line">    <span class="keyword">for</span> X,y <span class="keyword">in</span> data_iter:</span><br><span class="line">        <span class="keyword">with</span> autograd.record()：</span><br><span class="line">            <span class="comment">#l维度(batch_size,)</span></span><br><span class="line">            l = loss(net(X),y)</span><br><span class="line">        <span class="comment">#等价于l.sum().backward()</span></span><br><span class="line">        l.backward()</span><br><span class="line">        <span class="comment">#step对参数的梯度进行更新，传入batch_size是因为计算得到的梯度是一个batch样本的梯度和，需要除以batch_size得到梯度的平均值</span></span><br><span class="line">        trainer.step(batch_size)</span><br></pre></td></tr></table></figure><blockquote><p>注1：在使用<code>y.backward()</code>自动求梯度时，如果<code>y</code>不是一个标量，mxnet将默认先对<code>y</code>中元素求和得到新的变量，在求该变量关于<code>x</code>的梯度 </p><p>注2：mxnet的<code>L2Loss()</code>返回值维度<code>(batch_size,)</code>，即batch中每个样本的loss。需要在<code>step()</code>中传入<code>batch_size</code>参数</p></blockquote><ul><li>pytorch</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">loss = MSELoss()</span><br><span class="line"><span class="keyword">for</span> epoch <span class="keyword">in</span> range(<span class="number">1</span>,num_epochs + <span class="number">1</span>):</span><br><span class="line">    <span class="keyword">for</span> X,y <span class="keyword">in</span> data_iter:</span><br><span class="line">        <span class="comment">#l维度(1,)</span></span><br><span class="line">        l = loss(net(X),y)</span><br><span class="line">        optimizer.zero_grad() <span class="comment"># 梯度清零，等价于net.zero_grad()</span></span><br><span class="line">        l.backward()</span><br><span class="line">        <span class="comment">#step对参数的梯度进行更新，不需要传入batch_size参数</span></span><br><span class="line">        trainer.step()</span><br></pre></td></tr></table></figure><blockquote><p>注1：在<code>y.backward()</code>时，如果<code>y</code>是标量，则<code>backward()</code>不需要传入任何参数，否则，需要传入与<code>y</code>同形的Tensor</p><p>注2：grad在反向传播过程中是累加的，这意味着每一个batch运行反向传播，梯度都会累加之前batch的梯度，所以一般在反向传播传播之前需要把梯度清零。</p><p>注3：pytorch的<code>MSELoss()</code>返回值维度<code>(1,)</code>，Tensor中只有1个数，也称作<code>scalar:零维的张量</code>。因为<code>MSELoss()</code>返回值是batch中所有样本loss的平均值。所以在<code>step()</code>中不需要传入<code>batch_size</code>参数</p></blockquote><h2><span id="33-rnn输入维度">3.3. RNN输入维度</span></h2><p>这里只讨论单向RNN</p><ul><li>mxnet<ul><li>输入数据维度默认<code>(T,batch_size,input_size)</code></li><li>初始化state维度<code>(num_layers,batch_size,hidden_size)</code>,可以不输入，则默认用全0初始化</li><li>output输出数据维度<code>(T,batch_size,hidden_size)</code>，表示最后一层所有时间步的隐藏状态</li><li>out_state：输出维度和state一样，都是<code>(num_layers,batch_size,hidden_size)</code>,表示所有层最后一个时间步的隐藏状态,如果state不输入，则out_state不会被返回</li><li>如果想让输入维度是(B,T,C),则指定参数<code>layout=NTC</code></li></ul></li><li>pytorch<ul><li>输入数据维度默认<code>(T,batch_size,input_size)</code></li><li>初始化state维度<code>(num_layers,batch_size,hidden_size)</code>,可以不输入，则默认用全0初始化</li><li>output输出数据维度<code>(T,batch_size,hidden_size)</code>，表示最后一层所有时间步的隐藏状态</li><li>out_state：输出维度和state一样，都是<code>(num_layers,batch_size,hidden_size)</code>,表示所有层最后一个时间步的隐藏状态,如果state不输入，则out_state不会被返回</li><li>如果想让输入维度是(B,T,C),则指定参数<code>batch_first=True</code></li></ul></li></ul><p><strong>注意：Mxnet和Pytorch的唯一区域是：mxnet的state不指定，out_state就不会输出，pytorch不管state是否指定，out_state都会输出</strong></p><h2><span id="34-transformer输入维度">3.4. Transformer输入维度</span></h2><ul><li><p>mxnet<br>Mxnet中有一个NLP相关的包<code>gluonnlp</code>,里面封装了<code>Transformer</code>，这里只讨论<code>TransformerEncoder</code></p><ul><li>输入维度为<code>(batch_size, length, C_in)</code></li><li>输出维度为<code>(batch_size, length, C_out)</code></li></ul></li><li><p>pytorch<br>Pytorch中也封装了Transformer，<code>TransformerEncoder</code></p><ul><li>输入维度为<code>(length, batch_size, Embedding)</code></li><li>输出维度为<code>(length, batch_size, Embedding)</code><br><code>nn.TransformerEncoderLayer</code></li><li>输入维度为<code>(length, batch_size, Embedding)</code></li><li>输出维度为<code>(length, batch_size, Embedding)</code></li></ul></li></ul><p>【注意】Mxnet版的Tranformer中Dropout的p默认为0，Pytorch版的Transformer中Dropout的p默认为0.1</p><h2><span id="35-多gpu运行">3.5. 多GPU运行</span></h2><ul><li><p>mxnet</p><blockquote><p>mxnet.gluon.utils.split_and_load(data, ctx_list, batch_axis=0, even_split=True)</p></blockquote><p><code>split_and_load()</code>将一个batch中的数据划分为多个小batch到多个GPU上。<br><strong>【注意】默认batch_axis=0，也就是默认划分axis=0的维度，如果batch不在第0维，例如RNN中，输入的维度默认为TNC，batch在第1维，那就需要在split_and_load中指定batch_axis=1</strong><br><code>split_and_load()</code>返回值是list，里面每个元素是<code>NDArray</code>,经过<code>split_and_load()</code>对一个batch数据进行分割，得到的<code>X,y</code>的shape变成<code>(batch_size/n,*)</code>,经过模型输出得到的predicted维度也是<code>(batch_size/n,*)</code><br>计算得到的loss也是list类型，里面存储一个batch在多个GPU上计算的loss，对每个loss分别反向传播求梯度，然后再使用<code>step()</code>更新参数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> epoch <span class="keyword">in</span> range(<span class="number">100</span>):</span><br><span class="line">    <span class="keyword">for</span> X,y <span class="keyword">in</span> train_iter:</span><br><span class="line">        gpu_Xs = gutils.split_and_load(X,ctx)</span><br><span class="line">        gpu_ys = gutils.split_and_load(y,ctx)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">with</span> autograd.record():</span><br><span class="line">            <span class="comment">#ls是list，里面有n个NDArray，n是GPU的个数</span></span><br><span class="line">            ls = [loss(net(gpu_X),gpu_y <span class="keyword">for</span> gpu_X,gpu_y <span class="keyword">in</span> zip(gpu_Xs,gpu_ys)</span><br><span class="line">        <span class="keyword">for</span> l <span class="keyword">in</span> ls:</span><br><span class="line">            l.backward()</span><br><span class="line"></span><br><span class="line">        train.step(batch_size)</span><br></pre></td></tr></table></figure><p><img src="/2019/12/29/Mxnet和Pytorch区别/gpus-mxnet.png" alt=""></p></li><li><p>pytorch<br><a href="https://echohhhhhh.github.io/2019/01/31/%E8%BF%90%E8%A1%8CGPU%E7%A8%8B%E5%BA%8F/" target="_blank" rel="noopener">Pytorch学习</a>  </p><blockquote><p>CLASS torch.nn.DataParallel(module, device_ids=None, output_device=None, dim=0)</p></blockquote><p><strong><code>DataParallel</code>自动将batch进行划分，划分维度默认dim=0，如果batch在其他维度，通过dim指定</strong><br>pytorch使用<code>DataParallel()</code>来进行数据并行，不需要手动将数据划分到多个GPU上，即<code>train_feature</code>的维度是<code>(batch_size,*)</code>，经过模型输出的<code>predicted</code>的维度也是<code>(batch_size,*)</code>，这一点和<code>mxnet</code>不同</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#使用多GPU的关键代码</span></span><br><span class="line"><span class="keyword">if</span> torch.cuda.device_count() &gt; <span class="number">1</span>:</span><br><span class="line">    transformer_model = nn.DataParallel(transformer_model)<span class="comment">#默认全部GPU</span></span><br><span class="line">transformer_model.to(device0)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> epoch <span class="keyword">in</span> range(<span class="number">1</span>,training_epoch+<span class="number">1</span>):</span><br><span class="line">    <span class="keyword">for</span> train_feature,train_label <span class="keyword">in</span> train_loader:</span><br><span class="line">        train_feature = train_feature.to(device0)</span><br><span class="line">        train_label = train_label.to(device0)</span><br><span class="line">        <span class="comment">#train_label:(tabch_size,*)</span></span><br><span class="line">        predicted = transformer_model(train_feature)</span><br><span class="line">        l = loss(predicted,train_label)<span class="comment">#l的shape：(1,)</span></span><br><span class="line">        trainer.zero_grad()</span><br><span class="line">        l.backward()</span><br><span class="line">        trainer.step()</span><br></pre></td></tr></table></figure></li></ul><p>  <img src="/2019/12/29/Mxnet和Pytorch区别/gpus-pytorch.png" alt=""></p><blockquote><p>从这2个图中可以看出Mxnet和Pytorch多GPU运行的区别。<br>  <strong>Mxnet</strong>将batch数据和label都分配到每个GPU上，然后在每个GPU上都计算loss，然后再把loss聚合。<br>  <strong>Pytorch</strong>只把batch数据分配到每个GPU上，在每个GPU上得到输出，gather到主设备上，然后再和label计算loss。<br>  Mxnet会比Pytorch会一些，因为Mxnet的loss是在不同的GPU上计算的，但Pytorch的写法更简单。<br>  为了解决Pytorch在一张卡上计算loss的问题，有人提出了解决方案，参考<a href="https://liumin.blog.csdn.net/article/details/89437058" target="_blank" rel="noopener">基于PyTorch使用大batch训练神经网络</a>和<a href="https://blog.csdn.net/weixin_40087578/article/details/87186613?depth_1-utm_source=distribute.pc_relevant.none-task&amp;utm_source=distribute.pc_relevant.none-task" target="_blank" rel="noopener">pytorch 多GPU训练总结（DataParallel的使用）</a></p></blockquote><h2><span id="36-将网络加入list中">3.6. 将网络加入list中</span></h2><ul><li><p>mxnet</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">self.submodules = []</span><br><span class="line">      <span class="keyword">with</span> self.name_scope():</span><br><span class="line">          <span class="keyword">for</span> backbones <span class="keyword">in</span> all_backbones:</span><br><span class="line">              self.submodules.append(</span><br><span class="line">                  ASTGCN_submodule(num_for_prediction, backbones))</span><br><span class="line">              self.register_child(self.submodules[<span class="number">-1</span>])</span><br></pre></td></tr></table></figure></li><li><p>pytorch<br>Pytorch中<code>nn.Module, nn.ModuleList, nn.Sequential</code>，统称为容器，因为我们可以添加模块module到它们中。但有时候容易混淆，我们主要讨论<code>nn.ModuleList, nn.Sequential</code>的使用。</p><p><strong>【nn.ModuleList】</strong><br><a href="https://zhuanlan.zhihu.com/p/64990232" target="_blank" rel="noopener">PyTorch 中的 ModuleList 和 Sequential: 区别和使用场景</a><br><a href="https://blog.csdn.net/qq_38863413/article/details/104118055" target="_blank" rel="noopener">Pytorch使用 nn.ModuleList() 和nn.Sequential()编写神经网络模型</a><br>ModuleList是一个类，可以将Module任意子类(Conv2d,Linear等)加入到list中，方法和Python自带的list一样，使用append或extend等操作。但不同于一般的list，<strong>加入到ModuleList里的module会自动注册到整个网络上，同时module的参数也会自动添加到整个网络中</strong>。</p></li></ul>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyModel</span><span class="params">(nn.Module)</span>:</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">      super(MyModel, self).__init__()</span><br><span class="line">      self.linears = nn.ModuleList([nn.linear <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>)])</span><br><span class="line"></span><br><span class="line">  <span class="comment"># ModuleList can act as an iterable, or be indexed using ints</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">forward</span><span class="params">(self, x)</span>:</span></span><br><span class="line">      <span class="keyword">for</span> i, l <span class="keyword">in</span> enumerate(self.linears):</span><br><span class="line">          x = self.linears[i // <span class="number">2</span>](x) + l(x)</span><br><span class="line">      <span class="keyword">return</span> x</span><br></pre></td></tr></table></figure><h2><span id="固定随机种子">固定随机种子</span></h2><ul><li><p>mxnet版本</p>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">   seed = <span class="number">2020</span></span><br><span class="line">   mx.random.seed(seed)</span><br><span class="line">np.random.seed(seed)</span><br><span class="line">random.seed(seed)</span><br></pre></td></tr></table></figure></li><li><p>pytorch版本</p>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">seed = <span class="number">2020</span></span><br><span class="line">torch.manual_seed(seed) <span class="comment"># cpu</span></span><br><span class="line">torch.cuda.manual_seed(seed) <span class="comment">#gpu</span></span><br><span class="line">torch.backends.cudnn.deterministic=<span class="keyword">True</span><span class="comment">#cudn,cpu/gpu结果一致</span></span><br><span class="line">np.random.seed(seed)<span class="comment">#numpy</span></span><br><span class="line">random.seed(seed)<span class="comment">#ramdom</span></span><br></pre></td></tr></table></figure></li></ul><h2><span id="访问模型参数">访问模型参数</span></h2><ul><li><p>mxnet</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> name,param <span class="keyword">in</span> gru.collect_params().items():</span><br><span class="line">    print(name,<span class="string">':'</span>,parameters.size())</span><br></pre></td></tr></table></figure></li><li><p>pytorch</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> name,parameters <span class="keyword">in</span> net.named_parameters():</span><br><span class="line">  print(name,<span class="string">':'</span>,parameters.size())</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> parameters <span class="keyword">in</span> net.parameters():</span><br><span class="line">  print(parameters)</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;平时主要使用mxnet和pytorch，下面记录下在代码中怎么使用GPU&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Deep Learning" scheme="http://yoursite.com/categories/Deep-Learning/"/>
    
    
      <category term="GPU" scheme="http://yoursite.com/tags/GPU/"/>
    
      <category term="Mxnet" scheme="http://yoursite.com/tags/Mxnet/"/>
    
      <category term="Pytorch" scheme="http://yoursite.com/tags/Pytorch/"/>
    
  </entry>
  
  <entry>
    <title>leetcode踩坑</title>
    <link href="http://yoursite.com/2019/12/26/leecode-tirck/"/>
    <id>http://yoursite.com/2019/12/26/leecode-tirck/</id>
    <published>2019-12-26T11:25:57.000Z</published>
    <updated>2020-03-28T02:14:38.190Z</updated>
    
    <content type="html"><![CDATA[<p>&ensp;&ensp;&ensp;&ensp;最近开始刷Leecode，使用Python语言，踩了很多坑，在此记录。</p><a id="more"></a><!-- TOC --><ul><li><a href="#1-%e4%b8%80%e4%b8%aa%e8%90%9d%e5%8d%9c%e4%b8%80%e4%b8%aa%e5%9d%91">1. 一个萝卜一个坑</a><ul><li><a href="#11-int%e5%87%bd%e6%95%b0">1.1. int函数</a></li><li><a href="#12-bin%e5%87%bd%e6%95%b0">1.2. bin函数</a></li><li><a href="#13-zip%e5%87%bd%e6%95%b0">1.3. zip函数</a></li><li><a href="#14-%e4%ba%8c%e5%88%86%e6%b3%95%e8%ae%b2%e8%a7%a3">1.4. 二分法讲解</a></li><li><a href="#%e6%ad%a3%e6%97%a0%e7%a9%b7%e5%92%8c%e8%b4%9f%e6%97%a0%e7%a9%b7">正无穷和负无穷</a></li></ul></li></ul><!-- /TOC --><h1><span id="1-一个萝卜一个坑">1. 一个萝卜一个坑</span></h1><h2><span id="11-int函数">1.1. int函数</span></h2><p>int()函数用于将一个字符串或数字转换为整型。<br><code>int(x,base=10)</code>:x—字符串或数字，base—进制数，默认十进制。 如果显示的指定base参数，x必须为str。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int(<span class="number">3</span>) = <span class="number">3</span></span><br><span class="line">int(<span class="number">3.6</span>) = <span class="number">3</span></span><br><span class="line">int(<span class="string">'12'</span>,<span class="number">16</span>) = <span class="number">18</span></span><br><span class="line">int(<span class="string">'11'</span>,<span class="number">2</span>) = <span class="number">3</span><span class="comment">#将字符串解析为2进制</span></span><br></pre></td></tr></table></figure><h2><span id="12-bin函数">1.2. bin函数</span></h2><p>bin()返回一个整数int的二进制表示，返回类型str<br><code>bin(x)</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#返回的结果前2个字符是固定的'0b'，后面才是真正的值。</span></span><br><span class="line">bin(<span class="number">10</span>) = <span class="string">'0b1010'</span></span><br><span class="line">bin(<span class="number">20</span>) = <span class="string">'0b10100'</span></span><br></pre></td></tr></table></figure><h2><span id="13-zip函数">1.3. zip函数</span></h2><p>zip()接受一系列(多个，个数不固定)可迭代对象(最常用list,tuple)作为参数，将多个对象中，对应位置的元素打包成一个个tuple，然后返回由这些tuple组成的list。若传入参数中长度不一样，则返回liist的长度和参数中最短的相同。  </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">x = [<span class="string">'wang'</span>,<span class="string">'bei'</span>]</span><br><span class="line">y = [<span class="string">'lei'</span>,<span class="string">'xiao'</span>,<span class="string">'kang'</span>]</span><br><span class="line">list(zip(x,y))</span><br><span class="line">输出：[(<span class="string">'wang'</span>,<span class="string">'lei'</span>),(<span class="string">'bei'</span>,<span class="string">'xiao'</span>)]</span><br><span class="line"></span><br><span class="line">x = <span class="string">'wang'</span></span><br><span class="line">y = <span class="string">'lei'</span></span><br><span class="line">list(zip(x,y))</span><br><span class="line">输出：[(<span class="string">'w'</span>,<span class="string">'l'</span>),(<span class="string">'a'</span>,<span class="string">'e'</span>),(<span class="string">'n'</span>,<span class="string">'i'</span>)]  </span><br><span class="line"></span><br><span class="line"><span class="comment">#假设zip传入的参数是x，y，zip依次将(x[0],y[0]),(x[1],y[1])..</span></span><br><span class="line"><span class="comment">#以可迭代对象返回，可强制转换为list或tuple</span></span><br></pre></td></tr></table></figure><p>zip(<em>)传入的参数是zip()的返回值类型，从<zip\>类型中每一个tuple中，取出第0个元素组成一个list，再取出第1个元素组成一个list，即zip(\</zip\></em>)返回值是一个大list，里面有2个tuple</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line">b = [<span class="string">'a'</span>,<span class="string">'b'</span>,<span class="string">'c'</span>]</span><br><span class="line">zipped = list(zip(a,b))</span><br><span class="line"><span class="comment">#zipped = [(1,'a'),(2,'b'),(3,'c')]</span></span><br><span class="line">c = list(zip(*zipped))</span><br><span class="line"><span class="comment">#c = [(1,2,3),('a','b','c')]</span></span><br></pre></td></tr></table></figure><h2><span id="14-二分法讲解">1.4. 二分法讲解</span></h2><p><a href="https://leetcode-cn.com/problems/search-insert-position/solution/te-bie-hao-yong-de-er-fen-cha-fa-fa-mo-ban-python-/" target="_blank" rel="noopener">参考资料</a></p><h2><span id="正无穷和负无穷">正无穷和负无穷</span></h2><p>在比较大小时，通常先将结果初始化为inf和-inf，使用下面的语句</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">res = float(<span class="string">"inf"</span>)</span><br><span class="line">res = float(<span class="string">"-inf"</span>)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;ensp;&amp;ensp;&amp;ensp;&amp;ensp;最近开始刷Leecode，使用Python语言，踩了很多坑，在此记录。&lt;/p&gt;
    
    </summary>
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Python" scheme="http://yoursite.com/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>nni</title>
    <link href="http://yoursite.com/2019/11/25/nni/"/>
    <id>http://yoursite.com/2019/11/25/nni/</id>
    <published>2019-11-25T06:23:50.000Z</published>
    <updated>2020-03-05T07:38:11.238Z</updated>
    
    <content type="html"><![CDATA[<p>NN是微软官方出的一个自动调参的第三方库。非常好用。但是用起来还是有一些需要注意的地方。这里记录一下。<br><a id="more"></a><br><!-- TOC --></p><ul><li><a href="#1-%e6%9c%af%e8%af%ad">1. 术语</a><ul><li><a href="#11-%e4%bd%bf%e7%94%a8%e6%ad%a5%e9%aa%a4">1.1. 使用步骤</a></li></ul></li><li><a href="#2-nni%e5%91%bd%e4%bb%a4">2. NNI命令</a></li></ul><!-- /TOC --><p><a href="https://nni.readthedocs.io/zh/latest/Tutorial/QuickStart.html" target="_blank" rel="noopener">NNi官方文档</a></p><h1><span id="1-术语">1. 术语</span></h1><p>主要有2个术语experiment和trial。<br>experiment：如果需要调整LSTM的超参数，则需要指定每个超参数的可选项，然后运行程序，让nni自动调参。运行的这个调参程序就是experiment。<br>trial：上面运行的程序中，有很多的参数组合，每一个超参数组合是trial。<br>每一个experiment有一个ID，experiment中的每一个trial也有一个ID。在网页中可以看到</p><p><img src="/2019/11/25/nni/experiment_id.png" alt=""></p><p><img src="/2019/11/25/nni/trial_id.png" alt=""></p><h2><span id="11-使用步骤">1.1. 使用步骤</span></h2><ol><li><p>创建搜索空间json文件<br>这里定义需要调整的超参数</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"> <span class="attr">"num_layer"</span>:&#123;<span class="attr">"_type"</span>:<span class="string">"choice"</span>,<span class="attr">"_value"</span>:[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]&#125;,</span><br><span class="line"> <span class="attr">"hidden_size"</span>:&#123;<span class="attr">"_type"</span>:<span class="string">"choice"</span>,<span class="attr">"_value"</span>:[<span class="number">64</span>,<span class="number">128</span>,<span class="number">256</span>,<span class="number">512</span>]&#125;,</span><br><span class="line"> <span class="attr">"batch_size"</span>: &#123;<span class="attr">"_type"</span>:<span class="string">"choice"</span>, <span class="attr">"_value"</span>: [<span class="number">8</span>, <span class="number">16</span>, <span class="number">32</span>,<span class="number">64</span>,<span class="number">128</span>,<span class="number">256</span>]&#125;,</span><br><span class="line"> <span class="attr">"learning_rate"</span>:&#123;<span class="attr">"_type"</span>:<span class="string">"uniform"</span>,<span class="attr">"_value"</span>:[<span class="number">0.0001</span>,<span class="number">0.001</span>]&#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></li><li><p>首先在程序中import nni </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> nni  </span><br><span class="line"><span class="keyword">import</span> os  </span><br><span class="line">os.environ[<span class="string">"CUDA_VISIBLE_DEVICES"</span>] = <span class="string">"2"</span><span class="comment">#单GPU</span></span><br><span class="line"><span class="keyword">for</span> epoch <span class="keyword">in</span> range(<span class="number">1</span>,train_epoch):</span><br><span class="line">    每一个batch，在测试集上训练，并反向传播  </span><br><span class="line">    每一个epoch，计算验证集/测试集的loss</span><br><span class="line">    每一个epoch，计算验证集/测试集的评价指标(mae,rmse)</span><br><span class="line">    <span class="comment">#将验证集的评价指标加入到nni中</span></span><br><span class="line">    <span class="keyword">if</span> epoch &lt; train_epoch:</span><br><span class="line">         nni.report_intermediate_result(valid_mae)</span><br><span class="line">     <span class="keyword">else</span>:</span><br><span class="line">         nni.report_final_result(valid_mae)</span><br></pre></td></tr></table></figure><p>在下面的yml文件中，需要指定gpuNum,即需要使用多少张GPU卡。但是nni会自动申请gpu，你也不知道会申请到哪个gpu。为了解决这个问题，需要指定程序只能看见哪些卡，那么就会只申请看见的卡。<br>通过以下代码指定：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">os.environ[<span class="string">"CUDA_VISIBLE_DEVICES"</span>] = <span class="string">"2"</span><span class="comment">#单GPU</span></span><br><span class="line">os.environ[<span class="string">"CUDA_VISIBLE_DEVICES"</span>] = <span class="string">"1,2"</span><span class="comment">#多GPU</span></span><br></pre></td></tr></table></figure><p><strong>注意：如果只指定能看见第2张卡，但是程序中，会给第2张卡编号的为0，即通过ctx=mx.gpu(0)来获取。如果指定能看见1和2卡，那么程序中会分别编号0和1。</strong></p></li><li><p>nni的配置文件config.yml</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">authorName:</span> <span class="string">wangbeibei</span></span><br><span class="line"><span class="attr">experimentName:</span> <span class="string">gru_grid_experiment</span></span><br><span class="line"><span class="comment">#并发尝试任务的最大数量，有1张gpu卡就是1，有2张gpu卡就是2</span></span><br><span class="line"><span class="attr">trialConcurrency:</span> <span class="number">1</span></span><br><span class="line"><span class="attr">maxExecDuration:</span> <span class="number">100</span><span class="string">h</span></span><br><span class="line"><span class="comment">#Trial 任务的最大数量，成功和失败的都计算在内</span></span><br><span class="line"><span class="attr">maxTrialNum:</span> <span class="number">10</span></span><br><span class="line"><span class="comment">#choice: local, remote, pai,在虚拟环境和docker运行时，都写local</span></span><br><span class="line"><span class="attr">trainingServicePlatform:</span> <span class="string">local</span></span><br><span class="line"><span class="comment">#在第一步创建的json文件的路径，这里需要写相对路径，因为当前的yml文件和json文件在同一文件夹下</span></span><br><span class="line"><span class="attr">searchSpacePath:</span> <span class="string">lstm_search_space.json</span></span><br><span class="line"><span class="comment">#choice: true, false</span></span><br><span class="line"><span class="attr">useAnnotation:</span> <span class="literal">false</span></span><br><span class="line"><span class="comment"># 存储日志和数据的目录, 默认值是 /data/WangBeibei/nni/experiments</span></span><br><span class="line"><span class="comment">#如果在虚拟环境中运行该代码，logDir是服务器下的绝对路径，/data/WangBeibei/graduation/Code/nni_save_logs</span></span><br><span class="line"><span class="comment">#如果在docker下运行该代码，logDir是容器下的绝对路径，/root/Code/nni_save_logs/</span></span><br><span class="line"><span class="attr">logDir:</span> <span class="string">/root/Code/nni_save_logs/</span></span><br><span class="line"><span class="attr">tuner:</span></span><br><span class="line">    <span class="comment">#choice: TPE, Random, Anneal, Evolution, BatchTuner, MetisTuner, GPTuner</span></span><br><span class="line">    <span class="comment">#SMAC (SMAC should be installed through nnictl)</span></span><br><span class="line"><span class="attr">    builtinTunerName:</span> <span class="string">TPE</span></span><br><span class="line"><span class="attr">    classArgs:</span></span><br><span class="line">        <span class="comment">#choice: maximize, minimize</span></span><br><span class="line">        <span class="comment">#mae、rmse、mse都是最小化</span></span><br><span class="line"><span class="attr">        optimize_mode:</span> <span class="string">minimize</span></span><br><span class="line"><span class="attr">trial:</span></span><br><span class="line"><span class="comment"># 指定了运行 Trial 进程的命令行</span></span><br><span class="line"><span class="attr">command:</span> <span class="string">cd</span> <span class="string">baseline</span> <span class="string">&amp;&amp;</span> <span class="string">python3</span> <span class="string">lstm_baseline.py</span></span><br><span class="line"><span class="comment">#指定了 Trial 代码文件的目录</span></span><br><span class="line"><span class="comment">#首先从yml目录下，进入到代码的根目录下</span></span><br><span class="line"><span class="attr">codeDir:</span> <span class="string">../</span></span><br><span class="line"><span class="comment">#指定需要使用</span></span><br><span class="line"><span class="attr">gpuNum:</span> <span class="number">1</span></span><br></pre></td></tr></table></figure></li><li><p>启动容器<br>nni网页的默认端口是8080，所以需要和本地映射一下，</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker run -it -p 7000:8080 -v $PWD:/root --runtime=nvidia --rm -u 1018 --name wbbnni lin-ai-27:5000/wangbeibei/mxnet:cu_100  </span><br><span class="line"></span><br><span class="line">docker run -it -p 7000:8080 -v $PWD:/root --runtime=nvidia --rm -u 1018 --name wbbnni lin-ai-27:5000/wangbeibei/pytorch_nni</span><br></pre></td></tr></table></figure></li><li><p>启动一个nni的experiment<br>进入到yml所在的目录，使用以下命令，启动一个experiment实例，然后就可以在网页上查看<br>使用<code>nnictl create --config config.yml</code><br>出现以下提示，说明启动成功。</p><p><img src="/2019/11/25/nni/create.png" alt=""></p></li><li><p>在网页上访问<br>在网页上打开<code>服务器ip:7000</code></p><p><img src="/2019/11/25/nni/success.png" alt=""></p></li><li><p>错误日志<br>如果提交的任务都失败了，可以去看日志文件。日志文件的位置在下图中。在容器中进入到下面的目录中。</p><p><img src="/2019/11/25/nni/error1.png" alt=""></p><p><img src="/2019/11/25/nni/error2.png" alt=""></p><p>在容器中进入到日志目录中，找到对应id的文件夹。</p><p><img src="/2019/11/25/nni/log.png" alt=""></p></li><li><p>成功日志<br>如果trial成功运行，那么关于这次trial的</p><p><img src="/2019/11/25/nni/success1.png" alt=""></p></li></ol><h1><span id="2-nni命令">2. NNI命令</span></h1><p><a href="https://github.com/microsoft/nni/blob/master/docs/zh_CN/Tutorial/Nnictl.md" target="_blank" rel="noopener">NNI命令参考文档</a></p><ol><li>nnictl create<br>（1）在默认端口8080上创建一个新的Experiment<br><code>nnictl create --config nni/examples/trials/mnist/config.yml</code><br>（2）在指定的端口上8088创建新的Experiment<br><code>nnictl create --config nni/examples/trials/mnist/config.yml --port 8088</code></li><li>nnictl stop<br>停止正在运行的单个或多个Experiment<br>（1）没有指定id，停止所有正在运行的Experiment<br><code>nnictl stop</code><br>（2）停止指定id的Experiment<br><code>nnictl stop [experiment_id]</code></li><li>nnictl update<br>更新 Experiment 的搜索空间，其中<code>experiment_id</code>是可选的参数，后面的<code>--filename</code>是必填的参数。<br>先使用vscode修改搜索空间的json文件，然后再使用下面的命令来更新搜索空间文件。<br><code>nnictl update searchspace [experiment_id] --filename examples/trials/mnist/search_space.json</code></li><li><p>nnictl view<br>如果使用stop结束调参程序，以后还想看一下网页上的调参结果，使用该命令。这个命令只是在前端展示调参的结果，调参程序不会再次启动。  </p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">nnictl <span class="keyword">view</span> [<span class="keyword">OPTIONS</span>]</span><br><span class="line">其中experiment_id是必填的，port是选填的</span><br><span class="line">nnictl <span class="keyword">view</span> [experiment_id] <span class="comment">--port 8088</span></span><br></pre></td></tr></table></figure></li><li><p>nnictl top<br>查看正在运行的Experiment</p></li><li>nnictl experiment show<br>显示Experiment的信息</li><li>nnictl experiment status<br>显示Experiment的状态</li><li>nnictl experiment list<br>显示正在运行的Experiment的信息</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;NN是微软官方出的一个自动调参的第三方库。非常好用。但是用起来还是有一些需要注意的地方。这里记录一下。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="工具" scheme="http://yoursite.com/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="Docker" scheme="http://yoursite.com/tags/Docker/"/>
    
      <category term="NNI" scheme="http://yoursite.com/tags/NNI/"/>
    
  </entry>
  
  <entry>
    <title>Deep Learning for Spatio-Temporal Data Mining: A Survey</title>
    <link href="http://yoursite.com/2019/11/08/Deep-Learning-for-Spatio-Temporal-Data-Mining-A-Survey/"/>
    <id>http://yoursite.com/2019/11/08/Deep-Learning-for-Spatio-Temporal-Data-Mining-A-Survey/</id>
    <published>2019-11-08T07:49:36.000Z</published>
    <updated>2020-01-23T13:06:45.571Z</updated>
    
    <content type="html"><![CDATA[<p>&ensp;&ensp;&ensp;&ensp;<a href="https://arxiv.org/pdf/1906.04928.pdf" target="_blank" rel="noopener">Deep Learning for Spatio-Temporal Data Mining: A Survey</a><br>这篇论文是时空领域的综述论文，介绍了近几年时空领域的发展。<br><a id="more"></a></p><p>一些比较好的GitHub<br><a href="https://github.com/xuehaouwa/Awesome-Trajectory-Prediction" target="_blank" rel="noopener">https://github.com/xuehaouwa/Awesome-Trajectory-Prediction</a></p><h1><span id="引言">引言</span></h1><p>时空领域的数据的应用很广泛，包括环境和气候预测（风预测，降雨预测等），公共安全预测（crime预测），智能交通预测（交通流量预测），人类活动（人类轨迹模式挖掘）。本文将时空数据的类型，和广泛应用的深度学习模型，以及现有的研究进展.</p><h1><span id="时空数据分类">时空数据分类</span></h1><ol><li>Even data<br>事件数据由离散的事件组成，有location和time信息，例如cirme事件和traffic accident事件，疾病爆发事件，社会事件。</li><li>Trajectory data<br>轨迹数据是一系列随着时间变化的经纬度序列组成。有人的轨迹和车的轨迹。  </li><li>Point reference data<br>一般都是气象数据，测量一个区域的温度，植被等。  </li><li>Raster data（栅格数据）<br>有固定的m个区域，每个区域有n个时间段，可以用一个$R^{m \times n}$来表示。例如traffic flow数据。</li><li>Vedio data<br>视频数据和时空数据类似，相邻的像素可以表示相似的RGB，在时间上，特征变化平缓。可以用三维张量表示。  </li></ol><p>以上的5类数据可以用下图的方式表示。</p><p><img src="/2019/11/08/Deep-Learning-for-Spatio-Temporal-Data-Mining-A-Survey/stdata.png" alt=""></p><p>(1)轨迹和时间序列都可以表示成序列的形式。<br>(2)有时轨迹也可以表示成2维矩阵，矩阵的行和列是网格的长和宽，矩阵的值表示轨迹走的网格。这个表示形式通常使用CNN模型。例如：<a href="https://arxiv.org/pdf/1705.09436.pdf" target="_blank" rel="noopener">（2017NIPS）Human Trajectory Prediction using Spatially aware Deep Attention Models</a><br>(3)空间地图可以表示为Graph和2维矩阵。至于使用图还是2D矩阵根据应用而定。例如在城市交通流预测，交通网络中的交通数据使用Graph表示，例如<a href="https://arxiv.org/pdf/1707.01926.pdf" target="_blank" rel="noopener">(2018ICLR)Diffusion Convolutional Recurrent Neural Network: Data-Driven Traffic Forecasting</a><br>(4)网格数据，通常使用2D或3D张量表示，如果是2D矩阵，行和列分别表示区域和时间。如果是3D张量，分别表示区域的行和列，时间。</p><p><img src="/2019/11/08/Deep-Learning-for-Spatio-Temporal-Data-Mining-A-Survey/model.png" alt=""><br>未完待续。。。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;ensp;&amp;ensp;&amp;ensp;&amp;ensp;&lt;a href=&quot;https://arxiv.org/pdf/1906.04928.pdf&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Deep Learning for Spatio-Temporal Data Mining: A Survey&lt;/a&gt;&lt;br&gt;这篇论文是时空领域的综述论文，介绍了近几年时空领域的发展。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="论文阅读笔记" scheme="http://yoursite.com/categories/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="时空领域" scheme="http://yoursite.com/tags/%E6%97%B6%E7%A9%BA%E9%A2%86%E5%9F%9F/"/>
    
  </entry>
  
</feed>
