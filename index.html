<!DOCTYPE html>




<html class="theme-next pisces" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.8.0">
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">



  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon.png?v=5.1.4">






  <meta name="keywords" content="默默努力">










<meta name="description" content="远方到底有多远">
<meta property="og:type" content="website">
<meta property="og:title" content="Echo&#39;s blog">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="Echo&#39;s blog">
<meta property="og:description" content="远方到底有多远">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Echo&#39;s blog">
<meta name="twitter:description" content="远方到底有多远">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":true,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":false,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/">





  <title>Echo's blog - 远方到底有多远</title>
  





  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?b759ac2a7fa45129e3ef060bf68259f0";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script><!-- hexo-inject:begin --><!-- hexo-inject:end -->




</head>

<body itemscope="" itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <!-- hexo-inject:begin --><!-- hexo-inject:end --><div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope="" itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Echo's blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <h1 class="site-subtitle" itemprop="description">远方到底有多远</h1>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br>
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br>
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off" placeholder="搜索..." spellcheck="false" type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/06/19/百面机器学习概述/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Echo">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/touxiang.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Echo's blog">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/06/19/百面机器学习概述/" itemprop="url">百面机器学习概述</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-06-19T23:12:34+08:00">
                2020-06-19
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/Machine-Learning/" itemprop="url" rel="index">
                    <span itemprop="name">Machine Learning</span>
                  </a>
                </span>

                
                
              
            </span>
          

          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  463
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  1
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <p>总结《百面机器学习》有关知识点。</p>
          <!--noindex-->
          <div class="post-button text-center">
            <a class="btn" href="/2020/06/19/百面机器学习概述/#more" rel="contents">
              阅读全文 &raquo;
            </a>
          </div>
          <!--/noindex-->
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/06/07/Leetcode之位运算/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Echo">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/touxiang.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Echo's blog">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/06/07/Leetcode之位运算/" itemprop="url">Leetcode之位运算</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-06-07T17:35:16+08:00">
                2020-06-07
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/算法/" itemprop="url" rel="index">
                    <span itemprop="name">算法</span>
                  </a>
                </span>

                
                
              
            </span>
          

          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  896
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  3
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <a id="more"></a>
<!-- TOC -->
<ul>
<li><a href="#1-位运算">1. 位运算</a></li>
<li><a href="#2-总结">2. 总结</a></li>
</ul>
<!-- /TOC -->
<h1><span id="1-位运算">1. 位运算</span></h1><p>位运算总共有5种运算：与，或，异或，左移，右移。<br>左移<code>m&lt;&lt;n</code>表示把m左移n位，在左移n位时，最左边的n位被丢弃，同时最右边补上n个0<br>右移<code>m&gt;&gt;n</code>表示把m右移n位，在右移n位时，最右边的n位被丢弃，在处理左边时比较复杂。如果数字是无符号数，最左边补上n个0。如果数字是一个有符号数，则用数字的符号填补左边的n位。也就是说，如果数字是整数，最左边用0填充，如果数字是负数，最左边用1填充。例如<br>00001010&gt;&gt;2=00000010<br>10001010&gt;&gt;3=11110001</p>
<p>请实现一个函数，输入一个整数，输出该数二进制表示中 1 的个数。例如，把 9 表示成二进制是 1001，有 2 位是 1。因此，如果输入 9，则该函数输出 2。</p>
<p>链接：<a href="https://leetcode-cn.com/problems/er-jin-zhi-zhong-1de-ge-shu-lcof" target="_blank" rel="noopener">https://leetcode-cn.com/problems/er-jin-zhi-zhong-1de-ge-shu-lcof</a></p>
<p><strong>【分析】</strong><br>将一个整数n减去1之后，再和n做与运算，可以将n中最右边的1变成0<br>比如原先n=1100，n-1=1011，n&amp;(n-1)=1000,与运算的结果1000与原先的n=1100相比，就把最后边的1变成0。然后再对1000执行相同的操作，就会变成0000。这样执行2次，说明原始的n中一共有2个1.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hammingWeight</span><span class="params">(self, n)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type n: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        <span class="comment">#n=n&amp;(n-1)可以让原先的n中的1变成0</span></span><br><span class="line">        <span class="keyword">while</span> n:</span><br><span class="line">            res+=<span class="number">1</span></span><br><span class="line">            n=n&amp;(n<span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<p>整数<code>n&amp;1</code>值为0或1，判断n的二进制数的最后一位是0还是1.如果n=8，n&amp;1=0，表示8的二进制1000最后一位是0。如果n=9，n&amp;1=1，表示9的二进制1001最后一位是1.<br>$x^n$中的n变换成二进制为$b_mb_{m-1}…b_2b_1$，二进制和十进制n的关系为$n=2^0b_1+2^1b_2+…+2^{m-1}b_m$,这样就可以把$x^n=x^{2^0b_1+2^1b_2+…+2^{m-1}b_m}=x^{2^0b_1}x^{2^1b_2}…x^{2^{m-1}b_m}$。其中$b_1,b_2….b_m$的值只能为0或1.如果$b_m=0$，那$x^{2^{m-1}b_m}=1$，否则$x^{2^{m-1}b_m}=x^{2^{m-1}}$<br>所以问题的关键就是计算十进制数n，转换成二进制后每一个位数是0还是1.<br>如果第一位是1，就乘上$x^1$,然后把n除以2，就是n=n&gt;&gt;1,然后再判断原始n的第二位。<br>如果第二位是1，就乘上$x^2$<br>如果第三位是1，就乘上$x^4$<br>如果第四位是1，就乘上$x^8$</p>
<p>n=11，变换成二进制是1011,分别是1,2,4,8，其中只有1,2,8的幂次有效。理论上应该是$x.x^2.x^8$</p>
<ul>
<li>进入while循环，n&amp;1=1，$res=x$，然后$x=x^2$，n右移一位成5</li>
<li>进入while循环，n&amp;1=1，$res=res*x=x^3,x=x^4$,n右移一位变成2</li>
<li>进入while循环，n&amp;1=0，$x=x^8$,n右移一位变成1</li>
<li>进入到while循环，n&amp;1=1，$res=x^11,x=x^16$,n右移一位变成0</li>
<li>退出while循环，返回res</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">myPow</span><span class="params">(self, x, n)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type x: float</span></span><br><span class="line"><span class="string">        :type n: int</span></span><br><span class="line"><span class="string">        :rtype: float</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> x==<span class="number">0</span>:<span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> n==<span class="number">0</span>:<span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        tmp_n = abs(n)</span><br><span class="line">        res=<span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> tmp_n:</span><br><span class="line">            <span class="keyword">if</span> tmp_n&amp;<span class="number">1</span>:</span><br><span class="line">                res*=x</span><br><span class="line">            x*=x</span><br><span class="line">            tmp_n=tmp_n&gt;&gt;<span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> n&gt;<span class="number">0</span>:<span class="keyword">return</span> res</span><br><span class="line">        <span class="keyword">else</span>:<span class="keyword">return</span> <span class="number">1</span>/res</span><br></pre></td></tr></table></figure>
<ul>
<li>时间复杂度：O(logn)</li>
<li>空间复杂度：O(1)</li>
</ul>
<h1><span id="2-总结">2. 总结</span></h1><ol>
<li>将二进制数字n的最右边的1变成0，n=n&amp;(n-1)<br>2.</li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/06/06/Leetcode之动态规划/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Echo">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/touxiang.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Echo's blog">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/06/06/Leetcode之动态规划/" itemprop="url">Leetcode之动态规划</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-06-06T14:55:38+08:00">
                2020-06-06
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/算法/" itemprop="url" rel="index">
                    <span itemprop="name">算法</span>
                  </a>
                </span>

                
                
              
            </span>
          

          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  9.4k
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  40
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <a id="more"></a>
<!-- TOC -->
<ul>
<li><a href="#1-动态规划">1. 动态规划</a></li>
<li><a href="#2-剪绳子">2. 剪绳子</a></li>
<li><a href="#3-最大子序列和">3. 最大子序列和</a></li>
<li><a href="#乘积最大子数组">乘积最大子数组</a></li>
<li><a href="#4-股票问题">4. 股票问题</a><ul>
<li><a href="#41-买卖股票的最佳时机">4.1. 买卖股票的最佳时机</a></li>
<li><a href="#42-买卖股票的最佳时机-ii">4.2. 买卖股票的最佳时机 II</a></li>
<li><a href="#43-买卖股票的最佳时机-iii">4.3. 买卖股票的最佳时机 III</a></li>
<li><a href="#44-买卖股票的最佳时机-iv">4.4. 买卖股票的最佳时机 IV</a></li>
<li><a href="#45-最佳买卖股票时机含冷冻期">4.5. 最佳买卖股票时机含冷冻期</a></li>
<li><a href="#46-买卖股票的最佳时机含手续费">4.6. 买卖股票的最佳时机含手续费</a></li>
<li><a href="#47-总结">4.7. 总结</a></li>
</ul>
</li>
<li><a href="#打家劫舍">打家劫舍</a><ul>
<li><a href="#打家劫舍-i">打家劫舍 I</a></li>
<li><a href="#打家劫舍-ii">打家劫舍 II</a></li>
<li><a href="#打家劫舍iii">打家劫舍III</a></li>
<li><a href="#总结">总结</a></li>
</ul>
</li>
<li><a href="#最长回文子串">最长回文子串</a></li>
<li><a href="#总结-1">总结</a></li>
</ul>
<!-- /TOC -->
<h1><span id="1-动态规划">1. 动态规划</span></h1><p>如果是求一个问题的最优解（通常是最大值或最小值），而且该问题可以分解成若干个子问题，并且子问题之间还有重叠的更小的子问题，可以考虑使用动态规划。</p>
<p>在解决动态规划问题时，需要分解成子问题，这里需要将子问题的最优解保存下来（一般是一维或二维数组），作为求取大问题最优解的基础。</p>
<p>做动态规划的三个关键：</p>
<ol>
<li>dp[i]表示什么意思（如果二维，dp[i][j]）</li>
<li>根据dp[i]和dp[i-1]的关系写出状态转移矩阵</li>
<li>确定初始条件，dp[0]</li>
</ol>
<h1><span id="2-剪绳子">2. 剪绳子</span></h1><p>给你一根长度为 n 的绳子，请把绳子剪成整数长度的 m 段（m、n都是整数，n&gt;1并且m&gt;1），每段绳子的长度记为 k[0],k[1]…k[m-1] 。请问 k[0]<em>k[1]</em>…*k[m-1] 可能的最大乘积是多少？例如，当绳子的长度是8时，我们把它剪成长度分别为2、3、3的三段，此时得到的最大乘积是18。</p>
<p>注意：m&gt;1，说明必须要切分，例如长度为2，必须要切分成1+1</p>
<p>链接：<a href="https://leetcode-cn.com/problems/jian-sheng-zi-lcof" target="_blank" rel="noopener">https://leetcode-cn.com/problems/jian-sheng-zi-lcof</a></p>
<p><strong>【方法一】</strong><br>使用动态规划解决。<br>状态转移公式：<code>dp[i] = max(dp[i],max(j*(i-j),j*dp[i-j]))</code>,<br>首先求不切割<code>dp[i]</code>和切割的最大值。<br>在切割中，有2种方式：（1）将i切割成j和i-j两部分，不再切割.（2）将i切割成<br>j和i-j两部分，然后再对i-j继续切割。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">cuttingRope</span><span class="params">(self, n)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type n: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="comment">#状态转移公式</span></span><br><span class="line">        <span class="comment">#dp[i] = max(dp[i],max(j*(i-j),j*dp[i-j]))</span></span><br><span class="line">        dp = [<span class="number">0</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(n+<span class="number">1</span>)]<span class="comment">#从0~n</span></span><br><span class="line">        dp[<span class="number">2</span>]=<span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">3</span>,n+<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(i):</span><br><span class="line">                dp[i] = max(dp[i],max(j*(i-j),j*dp[i-j]))</span><br><span class="line">        <span class="keyword">return</span> dp[n]</span><br></pre></td></tr></table></figure>
<p><strong>【方法二】</strong><br>找规律，也是贪心法则</p>
<ul>
<li>如果绳子长度&gt;=5,则尽可能多的切分成3</li>
<li>绳子长度为4，分成2+2</li>
<li>绳子长度为3，切分1+2</li>
<li>绳子长度为2，分成1+1</li>
</ul>
<p>总结如下,绳子长度为L：</p>
<ul>
<li>L&lt;3,切分成1+(L-1)</li>
<li>L&gt;=3<ul>
<li>L%3==0：全部划分为3</li>
<li>L%3==1：先划分成2+2，然后把剩下的划分为3</li>
<li>L%3==2：先划分成1个2，然后把剩下的划分成3 </li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">cuttingRope</span><span class="params">(self, n)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type n: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> n &lt;= <span class="number">3</span>:<span class="keyword">return</span> <span class="number">1</span>*(n<span class="number">-1</span>)</span><br><span class="line">        res = <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> n % <span class="number">3</span> == <span class="number">1</span>:</span><br><span class="line">            res = <span class="number">4</span></span><br><span class="line">            n -= <span class="number">4</span></span><br><span class="line">        <span class="keyword">elif</span> n % <span class="number">3</span> == <span class="number">2</span>:</span><br><span class="line">            res = <span class="number">2</span></span><br><span class="line">            n -= <span class="number">2</span></span><br><span class="line">        <span class="keyword">while</span> n:</span><br><span class="line">            res *= <span class="number">3</span></span><br><span class="line">            n -= <span class="number">3</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<h1><span id="3-最大子序列和">3. 最大子序列和</span></h1><p>给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。<br><a href="https://leetcode-cn.com/problems/maximum-subarray/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/maximum-subarray/</a></p>
<p><strong>【方法一】</strong><br>动态规划<br>dp[i]表示以nums[i]为结尾的最大子序列和<br>dp[0]=nums[0]<br><code>dp[i]=max(dp[i-1]+nums[i],nums[i])</code><br>dp[i]的最大值就是看当前元素nums[i]应该单独成一段，还是加入到上一段中dp[i-1]，所以需要从2个中找最大值。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxSubArray</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="comment">#dp[i]表示nums中以i为结尾的最大和</span></span><br><span class="line">        dp = [<span class="number">0</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums))]</span><br><span class="line">        dp[<span class="number">0</span>] = nums[<span class="number">0</span>]</span><br><span class="line">        <span class="comment">#dp[i] = max(dp[i-1]+nums[i],nums[i])</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,len(nums)):</span><br><span class="line">            dp[i] = max(dp[i<span class="number">-1</span>]+nums[i],nums[i])</span><br><span class="line">        <span class="keyword">return</span> max(dp)</span><br></pre></td></tr></table></figure>
<ul>
<li>时间复杂度：O(n)</li>
<li>空间复杂度：O(n)</li>
</ul>
<p><strong>【优化】</strong><br>上面方法的空间复杂度是O(n),因为dp需要存储n个数的最大值。但其实在计算dp[i]的时候，只需要用到dp[i-1]，其余都没用，所以我们可以将空间复杂度降到O(1),只保留dp[i-1]的值</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxSubArray</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        dp = nums[<span class="number">0</span>]</span><br><span class="line">        res = dp</span><br><span class="line">        <span class="comment">#dp[i] = max(dp[i-1]+nums[i],nums[i])</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,len(nums)):</span><br><span class="line">            dp = max(dp+nums[i],nums[i])</span><br><span class="line">            res = max(res,dp)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<p><strong>【方法二】</strong><br>使用贪心算法，从左向右遍历，一个个数字相加，使用sum记录当前遍历的和，max记录当前遍历和的最大值。如果sum&lt;0，则将sum更新为当前元素的值，重新找新的子序串，然后将sum和max比较，将max更新为较大的值</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxSubArray</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        sub_sum = nums[<span class="number">0</span>]</span><br><span class="line">        res = nums[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,len(nums)):</span><br><span class="line">            <span class="keyword">if</span> sub_sum &lt; <span class="number">0</span>:</span><br><span class="line">                sub_sum = nums[i]</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                sub_sum += nums[i]</span><br><span class="line">            res = max(res,sub_sum)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<h1><span id="4-乘积最大子数组">4. 乘积最大子数组</span></h1><p>给你一个整数数组 nums ，请你找出数组中乘积最大的连续子数组（该子数组中至少包含一个数字），并返回该子数组所对应的乘积。</p>
<p>示例 1:</p>
<p>输入: [2,3,-2,4]<br>输出: 6<br>解释: 子数组 [2,3] 有最大乘积 6。</p>
<p>链接：<a href="https://leetcode-cn.com/problems/maximum-product-subarray" target="_blank" rel="noopener">https://leetcode-cn.com/problems/maximum-product-subarray</a></p>
<p><strong>【分析一】</strong></p>
<p>乘积的最大值和和不同，两个负数相乘为正数。一个最大的正数乘以负数会变成最小值。因此最大值和最小值是相互转换的，我们可以将这种转换关系设计到状态转移方程中。</p>
<h1><span id="5-股票问题">5. 股票问题</span></h1><h2><span id="51-买卖股票的最佳时机">5.1. 买卖股票的最佳时机</span></h2><p>给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。</p>
<p>如果你最多只允许完成一笔交易（即买入和卖出一支股票一次），设计一个算法来计算你所能获取的最大利润。</p>
<p>注意：你不能在买入股票前卖出股票。</p>
<p>链接：<a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock" target="_blank" rel="noopener">https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock</a></p>
<p><strong>【方法一】</strong><br>一次遍历，记录前i天的最低价格和最大利润</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxProfit</span><span class="params">(self, prices)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type prices: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> prices:<span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="comment">#对于每个价格，记录在它之前的最低价格，求差值，然后和算出来的最大利润比较</span></span><br><span class="line">        <span class="comment">#如果当前差值大于以前的利润，修改max_profile</span></span><br><span class="line">        min_pricce = prices[<span class="number">0</span>]</span><br><span class="line">        max_profile = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> price <span class="keyword">in</span> prices:</span><br><span class="line">            min_pricce = min(min_pricce,price)</span><br><span class="line">            max_profile = max(max_profile,price-min_pricce)</span><br><span class="line">        <span class="keyword">return</span> max_profile</span><br></pre></td></tr></table></figure>
<ul>
<li>时间复杂度：O(n)</li>
<li>空间复杂度：O(1)</li>
</ul>
<p><strong>【方法二】</strong><br>动态规划<br>dp[i]表示前i天的最大利润，在遍历的过程中找到股票的最低价格，在第i天，看是否需要卖出。如果卖出利润为prices[i]-min_price，如果不卖，就和昨天的利润dp[i-1]一样。<br><code>dp[i]=max(dp[i-1],prices[i]-min_price)</code></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxProfit</span><span class="params">(self, prices)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type prices: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> prices:<span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        dp = [<span class="number">0</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(len(prices))]</span><br><span class="line">        dp[<span class="number">0</span>]=<span class="number">0</span></span><br><span class="line">        min_pricce = prices[<span class="number">0</span>]<span class="comment">#记录前i天的最低价格</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,len(prices)):</span><br><span class="line">            min_pricce = min(min_pricce,prices[i])</span><br><span class="line">            dp[i] = max(dp[i<span class="number">-1</span>],prices[i]-min_pricce)</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">-1</span>]</span><br></pre></td></tr></table></figure>
<ul>
<li>时间复杂度：O(n)</li>
<li>空间复杂度：O(n)</li>
</ul>
<h2><span id="52-买卖股票的最佳时机-ii">5.2. 买卖股票的最佳时机 II</span></h2><p>给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。</p>
<p>设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。</p>
<p>注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</p>
<blockquote>
<p>输入: [7,1,5,3,6,4]<br>输出: 7<br>解释: 在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格=5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。随后，在第 4 天（股票价格=3）的时候买入，在第 5 天（股票价格=6）的时候卖出, 这笔交易所能获得利润 = 6-3 = 3 </p>
</blockquote>
<p>链接：<a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii" target="_blank" rel="noopener">https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii</a></p>
<p><strong>【方法一】</strong></p>
<p>使用贪心算法只需要一次遍历。其主要想法是逢低便买入，逢高便卖出，即只要明天的价格大于今天的价格，就在今天买下，明天卖出。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxProfit</span><span class="params">(self, prices)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type prices: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="comment">#贪心算法，只遵循一个原则：低价买入，高价出售</span></span><br><span class="line">        <span class="comment">#只要明天的价格比今天高，就买今天的，然后明天卖出，获得差价利润</span></span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(prices)<span class="number">-1</span>):</span><br><span class="line">            diff = prices[i+<span class="number">1</span>] - prices[i]</span><br><span class="line">            <span class="keyword">if</span> diff&gt;<span class="number">0</span>:</span><br><span class="line">                res+=diff</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<p><strong>【方法二】</strong></p>
<p>一般能用贪心算法解决的，都可以使用动态规划算法。<br>定义dp，使用二维矩阵<br>dp[i][j]:第一维dp[i]表示前i天能获得的最大利润，第二维dp[i][j]表示在第i天手里有没有股票，dp[i][0]表示没有股票，手里持有现金时的最大利润，dp[i][1]表示持有股票的最大利润<br>第一天，dp[0][0]表示持有现金，则最大利润为0，dp[0][0]=0；dp[0][1]表示持有股票，则最大利润为dp[0][1]=-prices[0]。<br>对于dp[i][0]和dp[i][1]的状态转移需要分情况讨论</p>
<ul>
<li><p>dp[i][0]第i天持有现金状态</p>
<ul>
<li>第i-1天持有股票，第i天卖出股票：dp[i][0]=dp[i-1][1]+prices[i]</li>
<li>第i-1天没有股票，第i天也没有股票：dp[i][0]=dp[i-1][0]<br>最终dp[i][0]从以上2种情况选最大的作为最终利润 </li>
</ul>
</li>
<li><p>dp[i][1]第i天持有股票状态</p>
<ul>
<li>第i-1天没有股票，第i天买入股票：dp[i][1]=dp[i-1][0]-prices[i]</li>
<li>第i-1天有股票，第i天没有卖出：dp[i][1]=dp[i-1][1]<br>最终dp[i][1]从以上2种情况选最大的作为最终利润 </li>
</ul>
</li>
</ul>
<p>最终返回的结果是最后一天的最大利润，最后一天手里不能有任何股票，全都卖出，即dp[-1][0]</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxProfit</span><span class="params">(self, prices)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type prices: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="comment">#动态规划</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> prices:<span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        dp = [[<span class="number">0</span>,<span class="number">0</span>] <span class="keyword">for</span> i <span class="keyword">in</span> range(len(prices))]</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">0</span></span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">1</span>]=-prices[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,len(prices)):</span><br><span class="line">            dp[i][<span class="number">0</span>] = max(dp[i<span class="number">-1</span>][<span class="number">1</span>]+prices[i],dp[i<span class="number">-1</span>][<span class="number">0</span>])</span><br><span class="line">            dp[i][<span class="number">1</span>] = max(dp[i<span class="number">-1</span>][<span class="number">0</span>]-prices[i],dp[i<span class="number">-1</span>][<span class="number">1</span>])</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">-1</span>][<span class="number">0</span>]</span><br></pre></td></tr></table></figure>
<h2><span id="53-买卖股票的最佳时机-iii">5.3. 买卖股票的最佳时机 III</span></h2><p>给定一个数组，它的第 i 个元素是一支给定的股票在第 i 天的价格。</p>
<p>设计一个算法来计算你所能获取的最大利润。你最多可以完成 两笔 交易。</p>
<p>注意: 你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</p>
<p>链接：<a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iii" target="_blank" rel="noopener">https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iii</a></p>
<p><strong>【分析一】</strong></p>
<p>以前的dp都是一维或二维，本题因为说交易次数最多为2次，因此交易次数也需要当成一个新的维度考虑在dp中，所以dp变成三维。<code>dp[i][k][j]</code>，三个维度表示：天数i（i=0,1,…n-1），<strong>买入股票的次数</strong>（k=0,1,2），<strong>每买一次交易次数加1</strong>，是否持有股票（0表示没有股票，1表示持有股票）。买入股票的次数为k时，隐含了卖出股票的次数为k或k-1。<br>状态转移方程有2个</p>
<ul>
<li><code>dp[i][k][0]</code>第i天没有股票<ol>
<li>第i-1天也没有股票，第i天什么都没做：<code>dp[i][k][0]=dp[i-1][k][0]</code></li>
<li>第i-1天有股票，第i天卖了：<code>dp[i][k][0]=dp[i-1][k][1]+prices[i]</code></li>
</ol>
</li>
<li><code>dp[i][k][1]</code>第i天有股票<ol>
<li>第i-1天也有股票，第i天什么都没做：<code>dp[i][k][1]=dp[i-1][k][1]</code></li>
<li>第i-1天没有股票，第i天买了股票：<code>dp[i][k][1]=dp[i-1][k-1][0]-prices[i]</code><br>定义好状态转移矩阵，上面只对第三个维度进行遍历，下面初始化dp的i和k</li>
</ol>
</li>
<li>i=0，第1天<br><code>for _k in range(1,k)</code>:对每个k初始化i=0，因为下面的已经包含k=0了，这里从k=1开始遍历<ol>
<li><code>dp[0][k][0]</code>：第1天没有买股票，<code>dp[0][k][0]=0</code></li>
<li><code>dp[0][k][1]</code>：第1天买了股票，<code>dp[0][k][1]=-prices[0]</code></li>
</ol>
</li>
<li>k=0，买入股票次数为0<br>for _i in range(i)，对每个i初始化k=0，因为i=0已经在<ol>
<li><code>dp[i][0][0]</code>：在第i天从来没有买过股票，<code>dp[i][0][0]=0</code></li>
<li><code>dp[i][0][1]</code>：在第i天从来没有股票，所以也不可能持股，即利润为负无穷，<code>dp[i][0][1]=-float(&#39;inf&#39;)</code></li>
</ol>
</li>
</ul>
<p>以前2种遍历有重叠的部分：</p>
<ul>
<li><code>dp[0][0][0]=0</code></li>
<li><code>dp[0][0][1]=-float(&#39;inf&#39;)</code></li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxProfit</span><span class="params">(self, prices)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type prices: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        n = len(prices)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> prices:<span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        dp = [[[<span class="number">0</span>,<span class="number">0</span>] <span class="keyword">for</span> k <span class="keyword">in</span> range(<span class="number">3</span>)] <span class="keyword">for</span> i <span class="keyword">in</span> range(n)]</span><br><span class="line">        <span class="comment">#初始化，当i=0时</span></span><br><span class="line">        <span class="keyword">for</span> k <span class="keyword">in</span> range(<span class="number">1</span>,<span class="number">3</span>):</span><br><span class="line">            dp[<span class="number">0</span>][k][<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">            dp[<span class="number">0</span>][k][<span class="number">1</span>] = -prices[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">            dp[i][<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">            dp[i][<span class="number">0</span>][<span class="number">1</span>] = -float(<span class="string">'inf'</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 状态转移</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,n):</span><br><span class="line">            <span class="keyword">for</span> k <span class="keyword">in</span> range(<span class="number">1</span>,<span class="number">3</span>):</span><br><span class="line">                dp[i][k][<span class="number">0</span>]=max(dp[i<span class="number">-1</span>][k][<span class="number">0</span>],dp[i<span class="number">-1</span>][k][<span class="number">1</span>]+prices[i])</span><br><span class="line">                dp[i][k][<span class="number">1</span>]=max(dp[i<span class="number">-1</span>][k][<span class="number">1</span>],dp[i<span class="number">-1</span>][k<span class="number">-1</span>][<span class="number">0</span>]-prices[i])</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">-1</span>][<span class="number">-1</span>][<span class="number">0</span>]</span><br></pre></td></tr></table></figure>
<h2><span id="54-买卖股票的最佳时机-iv">5.4. 买卖股票的最佳时机 IV</span></h2><p>给定一个数组，它的第 i 个元素是一支给定的股票在第 i 天的价格。</p>
<p>设计一个算法来计算你所能获取的最大利润。你最多可以完成 k 笔交易。</p>
<p>注意: 你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</p>
<p>链接：<a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iv" target="_blank" rel="noopener">https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iv</a></p>
<p><strong>【分析一】</strong></p>
<p>和上一题一样，只是把原先的2换成k，其余代码不变，但是提交时，出现内存溢出的错误，因为当k较大时，比如k=1000000000，dp占用的空间太大。所以需要对此进行优化。<br>prices中有n天的价格，题目要求需要交易k次，因为有效的交易由买入和卖出组成，至少需要2天，所以有效的交易（有买有卖）次数限制k应该&lt;=n/2，如果k&gt;n/2，就没有约束作用了，相当于k=inf，这和leetcode122题一样。<br>所以代码分成2部分，</p>
<ul>
<li>if k&gt;n/2，按照leetcode122的解法（贪心）</li>
<li>else，按照leetcode123的解法（动态规划）</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxProfit</span><span class="params">(self, k, prices)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type k: int</span></span><br><span class="line"><span class="string">        :type prices: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        n = len(prices)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> prices:<span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> k&gt;n/<span class="number">2</span>:</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(n<span class="number">-1</span>):</span><br><span class="line">                diff = prices[i+<span class="number">1</span>]-prices[i]</span><br><span class="line">                <span class="keyword">if</span> diff&gt;<span class="number">0</span>:</span><br><span class="line">                    res+=diff</span><br><span class="line">            <span class="keyword">return</span> res</span><br><span class="line">        <span class="keyword">else</span>:    </span><br><span class="line">            dp = [[[<span class="number">0</span>,<span class="number">0</span>] <span class="keyword">for</span> _ <span class="keyword">in</span> range(k+<span class="number">1</span>)] <span class="keyword">for</span> i <span class="keyword">in</span> range(n)]</span><br><span class="line">            <span class="comment">#初始化，当i=0时</span></span><br><span class="line">            <span class="keyword">for</span> _k <span class="keyword">in</span> range(<span class="number">1</span>,k+<span class="number">1</span>):</span><br><span class="line">                dp[<span class="number">0</span>][_k][<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">                dp[<span class="number">0</span>][_k][<span class="number">1</span>] = -prices[<span class="number">0</span>]</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">                dp[i][<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">                dp[i][<span class="number">0</span>][<span class="number">1</span>] = -float(<span class="string">'inf'</span>)</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 状态转移</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,n):</span><br><span class="line">                <span class="keyword">for</span> _k <span class="keyword">in</span> range(<span class="number">1</span>,k+<span class="number">1</span>):</span><br><span class="line">                    dp[i][_k][<span class="number">0</span>]=max(dp[i<span class="number">-1</span>][_k][<span class="number">0</span>],dp[i<span class="number">-1</span>][_k][<span class="number">1</span>]+prices[i])</span><br><span class="line">                    dp[i][_k][<span class="number">1</span>]=max(dp[i<span class="number">-1</span>][_k][<span class="number">1</span>],dp[i<span class="number">-1</span>][_k<span class="number">-1</span>][<span class="number">0</span>]-prices[i])</span><br><span class="line">            <span class="keyword">return</span> dp[<span class="number">-1</span>][<span class="number">-1</span>][<span class="number">0</span>]</span><br></pre></td></tr></table></figure>
<h2><span id="55-最佳买卖股票时机含冷冻期">5.5. 最佳买卖股票时机含冷冻期</span></h2><p>给定一个整数数组，其中第 i 个元素代表了第 i 天的股票价格 。​</p>
<p>设计一个算法计算出最大利润。在满足以下约束条件下，你可以尽可能地完成更多的交易（多次买卖一支股票）:</p>
<ul>
<li>你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</li>
<li>卖出股票后，你无法在第二天买入股票 (即冷冻期为 1 天)。</li>
</ul>
<p>链接：<a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-cooldown" target="_blank" rel="noopener">https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-cooldown</a></p>
<blockquote>
<p>输入: [1,2,3,0,2]<br>输出: 3<br>解释: 对应的交易状态为: [买入, 卖出, 冷冻期, 买入, 卖出]</p>
</blockquote>
<p><strong>【分析一】</strong></p>
<p>该题和leetcode122类似，除了增加冷冻期。<br>同样定义dp，使用二维矩阵<br>dp[i][j]:第一维dp[i]表示前i天能获得的最大利润，第二维dp[i][j]表示在第i天手里有没有股票，dp[i][0]表示没有股票，手里持有现金时的最大利润，dp[i][1]表示持有股票的最大利润</p>
<p>对于dp[i][0]和dp[i][1]的状态转移需要分情况讨论</p>
<ul>
<li>dp[i][0]第i天持有现金状态<ul>
<li>第i-1天持有股票，第i天卖出股票：dp[i][0]=dp[i-1][1]+prices[i]</li>
<li>第i-1天没有股票，第i天也没有股票：dp[i][0]=dp[i-1][0]<br>最终dp[i][0]从以上2种情况选最大的作为最终利润 </li>
</ul>
</li>
</ul>
<p>下面这个转移公式与122题有变化。因为增加了冷冻期，在第i天买入股票，状态要从i-2天转移，因为第i-1天是冷冻期。</p>
<ul>
<li>dp[i][1]第i天持有股票状态<ul>
<li>第i-2天卖出股票，第i-1天是冷冻期，第i天买入股票：dp[i][1]=dp[i-2][0]-prices[i]</li>
<li>第i-1天有股票，第i天没有卖出：dp[i][1]=dp[i-1][1]<br>最终dp[i][1]从以上2种情况选最大的作为最终利润 </li>
</ul>
</li>
</ul>
<p>对dp进行初始化</p>
<ul>
<li>第一天，dp[0][0]表示持有现金，则最大利润为0，dp[0][0]=0</li>
<li>dp[0][1]表示第一天持有股票，则最大利润为dp[0][1]=-prices[0]</li>
<li>dp[1][0]表示第2天持有现金，有2种可能：（1）昨天也是持有现金dp[0][0],（2）昨天持有股票，今天卖了，dp[0][1]+prices[1]</li>
<li>dp[1][1]表示第2天持有股票，有2种情况：（1）昨天也持有股票dp[0][1]，（2）昨天持有现金，今天买了股票dp[0][0]-prices[1]</li>
</ul>
<p>最终返回的结果是最后一天的最大利润，最后一天手里不能有任何股票，全都卖出，即dp[-1][0]</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxProfit</span><span class="params">(self, prices)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type prices: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        n = len(prices)</span><br><span class="line">        <span class="keyword">if</span> n&lt;=<span class="number">1</span>:<span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        dp = [[<span class="number">0</span>,<span class="number">0</span>] <span class="keyword">for</span> i <span class="keyword">in</span> range(n)]</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">0</span></span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">1</span>]=-prices[<span class="number">0</span>]</span><br><span class="line">        dp[<span class="number">1</span>][<span class="number">0</span>]=max(dp[<span class="number">0</span>][<span class="number">0</span>],dp[<span class="number">0</span>][<span class="number">1</span>]+prices[<span class="number">1</span>])</span><br><span class="line">        dp[<span class="number">1</span>][<span class="number">1</span>]=max(dp[<span class="number">0</span>][<span class="number">1</span>],dp[<span class="number">0</span>][<span class="number">0</span>]-prices[<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>,n):</span><br><span class="line">            dp[i][<span class="number">0</span>]=max(dp[i<span class="number">-1</span>][<span class="number">0</span>],dp[i<span class="number">-1</span>][<span class="number">1</span>]+prices[i])</span><br><span class="line">            dp[i][<span class="number">1</span>]=max(dp[i<span class="number">-1</span>][<span class="number">1</span>],dp[i<span class="number">-2</span>][<span class="number">0</span>]-prices[i])</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">-1</span>][<span class="number">0</span>]</span><br></pre></td></tr></table></figure>
<h2><span id="56-买卖股票的最佳时机含手续费">5.6. 买卖股票的最佳时机含手续费</span></h2><p>给定一个整数数组 prices，其中第 i 个元素代表了第 i 天的股票价格 ；非负整数 fee 代表了交易股票的手续费用。</p>
<p>你可以无限次地完成交易，但是你每笔交易都需要付手续费。如果你已经购买了一个股票，在卖出它之前你就不能再继续购买股票了。</p>
<p>返回获得利润的最大值。</p>
<p>注意：这里的一笔交易指买入持有并卖出股票的整个过程，每笔交易你只需要为支付一次手续费。</p>
<p>链接：<a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with" target="_blank" rel="noopener">https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with</a></p>
<p><strong>【分析】</strong><br>这道题在leetcode122的基础上改进，每卖出一个股票就要支付手续费。</p>
<p>定义dp，使用二维矩阵<br>dp[i][j]:第一维dp[i]表示前i天能获得的最大利润，第二维dp[i][j]表示在第i天手里有没有股票，dp[i][0]表示没有股票，手里持有现金时的最大利润，dp[i][1]表示持有股票的最大利润<br>第一天，dp[0][0]表示持有现金，则最大利润为0，dp[0][0]=0；dp[0][1]表示持有股票，则最大利润为dp[0][1]=-prices[0]。<br>对于dp[i][0]和dp[i][1]的状态转移需要分情况讨论</p>
<ul>
<li><p>dp[i][0]第i天持有现金状态</p>
<ul>
<li>第i-1天持有股票，第i天卖出股票：dp[i][0]=dp[i-1][1]+prices[i]-fee</li>
<li>第i-1天没有股票，第i天也没有股票：dp[i][0]=dp[i-1][0]<br>最终dp[i][0]从以上2种情况选最大的作为最终利润 </li>
</ul>
</li>
<li><p>dp[i][1]第i天持有股票状态</p>
<ul>
<li>第i-1天没有股票，第i天买入股票：dp[i][1]=dp[i-1][0]-prices[i]</li>
<li>第i-1天有股票，第i天没有卖出：dp[i][1]=dp[i-1][1]<br>最终dp[i][1]从以上2种情况选最大的作为最终利润 </li>
</ul>
</li>
</ul>
<p>最终返回的结果是最后一天的最大利润，最后一天手里不能有任何股票，全都卖出，即dp[-1][0]</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxProfit</span><span class="params">(self, prices, fee)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type prices: List[int]</span></span><br><span class="line"><span class="string">        :type fee: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        n = len(prices)</span><br><span class="line">        <span class="keyword">if</span> n==<span class="number">0</span>:<span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        dp = [[<span class="number">0</span>,<span class="number">0</span>] <span class="keyword">for</span> i <span class="keyword">in</span> range(n)]</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">0</span></span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">1</span>]=-prices[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,n):</span><br><span class="line">            dp[i][<span class="number">0</span>]=max(dp[i<span class="number">-1</span>][<span class="number">0</span>],dp[i<span class="number">-1</span>][<span class="number">1</span>]+prices[i]-fee)</span><br><span class="line">            dp[i][<span class="number">1</span>]=max(dp[i<span class="number">-1</span>][<span class="number">1</span>],dp[i<span class="number">-1</span>][<span class="number">0</span>]-prices[i])</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">-1</span>][<span class="number">0</span>]</span><br></pre></td></tr></table></figure>
<h2><span id="57-总结">5.7. 总结</span></h2><p>对以上6个问题做一个分类</p>
<ul>
<li>Leetcode121：只交易一次（k=1，贪心或DP）</li>
<li>Leetcode122：不限交易次数（k=inf，贪心或二维DP）<ul>
<li>Leetcode309：不限交易次数（k=inf），但有冷冻期的条件</li>
<li>Leetcode714：不限交易次数（k=inf），但有手续费的条件</li>
</ul>
</li>
<li>Leetcode188：最多交易k次（三维DP）<ul>
<li>Leetcode123：最多交易2次（k=2，三维DP）</li>
</ul>
</li>
</ul>
<h1><span id="6-打家劫舍">6. 打家劫舍</span></h1><h2><span id="61-打家劫舍-i">6.1. 打家劫舍 I</span></h2><p>你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。</p>
<p>给定一个代表每个房屋存放金额的非负整数数组，计算你 不触动警报装置的情况下 ，一夜之内能够偷窃到的最高金额。</p>
<p>链接：<a href="https://leetcode-cn.com/problems/house-robber" target="_blank" rel="noopener">https://leetcode-cn.com/problems/house-robber</a></p>
<p>输入：[1,2,3,1]<br>输出：4<br>解释：偷窃 1 号房屋 (金额 = 1) ，然后偷窃 3 号房屋 (金额 = 3)。<br>     偷窃到的最高金额 = 1 + 3 = 4 。</p>
<p><strong>【分析一】</strong></p>
<p><code>dp[i]</code>表示在第i家的最大金额。<br>动态转移方程：<br><code>dp[i] = max(dp[i-2]+nums[i],dp[i-1])</code></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">rob</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> nums:<span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> len(nums)&lt;=<span class="number">2</span>:<span class="keyword">return</span> max(nums)</span><br><span class="line">        <span class="comment">#dp[i]表示偷到的i个房屋所获得的最大金额</span></span><br><span class="line">        dp = [<span class="number">0</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums))]</span><br><span class="line">        <span class="comment">#dp[i] = max(dp[i-2]+nums[i],dp[i-1])</span></span><br><span class="line">        dp[<span class="number">0</span>] = nums[<span class="number">0</span>]</span><br><span class="line">        dp[<span class="number">1</span>] = max(nums[<span class="number">0</span>],nums[<span class="number">1</span>])</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>,len(nums)):</span><br><span class="line">            dp[i] = max(dp[i<span class="number">-2</span>]+nums[i],dp[i<span class="number">-1</span>])</span><br><span class="line">        <span class="keyword">return</span> max(dp)</span><br></pre></td></tr></table></figure>
<p><strong>【优化】</strong></p>
<p>观察动态转移方程，dp[i]只和dp[i-2]和dp[i-1]有关，所以只用2个变量来保存这2个值就可以了，不用数组来保存。<br><code>dp[i] = max(dp[i-2]+nums[i],dp[i-1])</code></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> nums:<span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> len(nums)&lt;=<span class="number">2</span>:<span class="keyword">return</span> max(nums)</span><br><span class="line">        pre_pre = nums[<span class="number">0</span>]</span><br><span class="line">        pre = max(nums[<span class="number">0</span>],nums[<span class="number">1</span>])</span><br><span class="line">        max_res = <span class="number">0</span></span><br><span class="line">        cur = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>,len(nums)):</span><br><span class="line">            cur = max(pre_pre+nums[i],pre)</span><br><span class="line">            <span class="keyword">if</span> cur&gt;max_res:</span><br><span class="line">                max_res = cur</span><br><span class="line">            pre_pre = pre</span><br><span class="line">            pre = cur</span><br><span class="line">        <span class="keyword">return</span> max_res</span><br></pre></td></tr></table></figure>
<h2><span id="62-打家劫舍-ii">6.2. 打家劫舍 II</span></h2><p>你是一个专业的小偷，计划偷窃沿街的房屋，每间房内都藏有一定的现金。这个地方所有的房屋都围成一圈，这意味着第一个房屋和最后一个房屋是紧挨着的。同时，相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。</p>
<p>给定一个代表每个房屋存放金额的非负整数数组，计算你在不触动警报装置的情况下，能够偷窃到的最高金额。</p>
<p>示例 1:</p>
<p>输入: [2,3,2]<br>输出: 3<br>解释: 你不能先偷窃 1 号房屋（金额 = 2），然后偷窃 3 号房屋（金额 = 2）, 因为他们是相邻的。</p>
<p>链接：<a href="https://leetcode-cn.com/problems/house-robber-ii" target="_blank" rel="noopener">https://leetcode-cn.com/problems/house-robber-ii</a></p>
<p>【注】这道题和上一题的区别是：屋子围成环形，第一个房子和最后一个房子相邻</p>
<p>将环形问题变成单排问题来解决.第一间房子和最后一间房子相邻，有以下3种偷窃情况:</p>
<ol>
<li>偷第一间房子，不偷最后一间房子</li>
<li>不偷第一间房子，偷最后一间房子</li>
<li>2间房子都不偷<br>综合以上3种情况，可以总结为情况1和情况2，因为房子金额为非负数，多偷一间房子的钱肯定&gt;=不偷</li>
</ol>
<p>则环形房子偷的最大金额是情况1和情况2的最大值。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">rob</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">sub_rob</span><span class="params">(nums)</span>:</span></span><br><span class="line">            pre_pre = nums[<span class="number">0</span>]</span><br><span class="line">            pre = max(nums[<span class="number">0</span>],nums[<span class="number">1</span>])</span><br><span class="line">            res_max = max(pre_pre,pre)</span><br><span class="line">            cur = <span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>,len(nums)):</span><br><span class="line">                cur = max(pre_pre+nums[i],pre)</span><br><span class="line">                <span class="keyword">if</span> cur&gt;res_max:</span><br><span class="line">                    res_max = cur</span><br><span class="line">                pre_pre = pre</span><br><span class="line">                pre = cur</span><br><span class="line">            <span class="keyword">return</span> res_max</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> nums:<span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> len(nums)&lt;=<span class="number">2</span>:<span class="keyword">return</span> max(nums)</span><br><span class="line">        n = len(nums)</span><br><span class="line">        <span class="keyword">return</span> max(sub_rob(nums[<span class="number">0</span>:n<span class="number">-1</span>]),sub_rob(nums[<span class="number">1</span>:n]))</span><br></pre></td></tr></table></figure>
<h2><span id="63-打家劫舍iii">6.3. 打家劫舍III</span></h2><p>在上次打劫完一条街道之后和一圈房屋后，小偷又发现了一个新的可行窃的地区。这个地区只有一个入口，我们称之为“根”。 除了“根”之外，每栋房子有且只有一个“父“房子与之相连。一番侦察之后，聪明的小偷意识到“这个地方的所有房屋的排列类似于一棵二叉树”。 如果两个直接相连的房子在同一天晚上被打劫，房屋将自动报警。</p>
<p>计算在不触动警报的情况下，小偷一晚能够盗取的最高金额。</p>
<p>链接：<a href="https://leetcode-cn.com/problems/house-robber-iii" target="_blank" rel="noopener">https://leetcode-cn.com/problems/house-robber-iii</a></p>
<p><img src="/2020/06/06/Leetcode之动态规划/1.png" alt=""></p>
<p><strong>【分析一】</strong></p>
<p>这道题考察的是怎么在二叉树上进行动态规划。<br>每个节点有2个孩子。根节点称为爷爷，有2个儿子，有4个孙子。相邻节点不能同时偷的意思是爷爷偷了，那儿子就不能偷，但是孙子可以偷。那最大金额=爷爷的钱+4个孙子的钱 VS 2个儿子的钱，看哪个组合多</p>
<p>使用递归，但是这种方法超时。因为递归会重复计算。比如在计算2个儿子的最大金额时，当这2个儿子称为爷爷时又会重新计算一遍孙子的金额。</p>
<p>注意：递归需要从树的下面往上看，在叶子节点的金额是最少的，儿子的金额比孙子多，爷爷的金额比儿子多。可能会有这样的疑问：既然不能相邻的节点连续偷，那可以左孩子偷的钱+右孩子的2个孩子偷的钱。其实这种情况已经被2个儿子偷考虑进去了，因为左孩子+2个孙子 《 2个儿子</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">rob</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type root: TreeNode</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:<span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        root_money = root.val</span><br><span class="line">        method1 = root_money<span class="comment">#爷爷加上4个孙子的钱</span></span><br><span class="line">        method2 = <span class="number">0</span><span class="comment">#2个孩子的钱</span></span><br><span class="line">        <span class="keyword">if</span> root.left:</span><br><span class="line">            method1+=(self.rob(root.left.left)+self.rob(root.left.right))</span><br><span class="line">        <span class="keyword">if</span> root.right:</span><br><span class="line">            method1+=(self.rob(root.right.left)+self.rob(root.right.right))</span><br><span class="line">        method2 = self.rob(root.left)+self.rob(root.right)</span><br><span class="line">        <span class="keyword">return</span> max(method1,method2)</span><br></pre></td></tr></table></figure>
<p><strong>【分析二】</strong></p>
<p>为了解决上述重复计算的问题，使用空间换时间的方法，将已经计算的金额保存起来。二叉树不适合使用数组来当缓存，使用哈希表存储，节点作为key，当前节点的最大金额为value</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode(object):</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">rob</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type root: TreeNode</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">sub_rob</span><span class="params">(root,max_val)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> root:<span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">            <span class="keyword">if</span> root <span class="keyword">in</span> max_val:<span class="keyword">return</span> max_val[root]</span><br><span class="line">            </span><br><span class="line">            method1 = root.val<span class="comment">#爷爷加上4个孙子的钱</span></span><br><span class="line">            <span class="keyword">if</span> root.left:</span><br><span class="line">                method1+=(sub_rob(root.left.left,max_val)+sub_rob(root.left.right,max_val))</span><br><span class="line">            <span class="keyword">if</span> root.right:</span><br><span class="line">                method1+=(sub_rob(root.right.left,max_val)+sub_rob(root.right.right,max_val))</span><br><span class="line">            method2 = sub_rob(root.left,max_val)+sub_rob(root.right,max_val)</span><br><span class="line">            max_val[root] = max(method1,method2)</span><br><span class="line">            <span class="keyword">return</span> max_val[root]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:<span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        max_val = dict()</span><br><span class="line">        <span class="keyword">return</span> sub_rob(root,max_val)</span><br></pre></td></tr></table></figure>
<p>【分析三】</p>
<p>参照买股票问题，每个节点都有2种状态：偷和不偷。dp使用二维数据组，</p>
<ul>
<li>dp[i][0]：节点i不偷时的最大金额。节点i不偷，那i.left和i.right可以偷也可以不偷。则<code>dp[i][0] = max(dp[i.left][1],dp[i.left][0]) + max(dp[i.right][1],dp[i.right][0])</code></li>
<li>dp[i][1]：节点i偷时的最大金额。节点i偷，那i.left和i.right只能选择不偷，则<code>dp[i][1] = dp[i.left][0]+dp[i.right][0]+i.val</code></li>
<li>空间优化：由于在计算dp[i]时，只需要dp[i.left]和dp[i.right]的信息，所以不需要使用dp[][]二维数组。只需要3个一维数组，left[0]和left[1]表示左节点偷和不偷的最大金额，right[0]和right[1]表示右节点偷和不偷的最大金额。root[0]和root[1]表示根节点</li>
<li>初始化</li>
<li>返回结果：输出根节点中2个状态的最大值</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">rob</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type root: TreeNode</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">sub_rob</span><span class="params">(root)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> root:<span class="keyword">return</span> [<span class="number">0</span>,<span class="number">0</span>]</span><br><span class="line">            left = sub_rob(root.left)</span><br><span class="line">            right = sub_rob(root.right)</span><br><span class="line"></span><br><span class="line">            root_val = [<span class="number">0</span>,<span class="number">0</span>]<span class="comment">#根节点2种状态的最大金额</span></span><br><span class="line">            root_val[<span class="number">0</span>] = max(left[<span class="number">0</span>],left[<span class="number">1</span>])+max(right[<span class="number">0</span>],right[<span class="number">1</span>])</span><br><span class="line">            root_val[<span class="number">1</span>] = left[<span class="number">0</span>]+right[<span class="number">0</span>]+root.val</span><br><span class="line">            <span class="keyword">return</span> root_val</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:<span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        root_val = sub_rob(root)</span><br><span class="line">        <span class="keyword">return</span> max(root_val)</span><br></pre></td></tr></table></figure>
<h2><span id="64-总结">6.4. 总结</span></h2><p>第一题是单排动态规划问题<br>第二题是环形动态规划问题，可以转换为多个单排问题解决，然后求多个单排问题的最大值<br>第三题是树形动态规划问题，使用递归解决</p>
<h1><span id="7-最长回文子串">7. 最长回文子串</span></h1><p>给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为 1000。</p>
<p>示例 1：</p>
<p>输入: “babad”<br>输出: “bab”<br>注意: “aba” 也是一个有效答案。</p>
<p>链接：<a href="https://leetcode-cn.com/problems/longest-palindromic-substring" target="_blank" rel="noopener">https://leetcode-cn.com/problems/longest-palindromic-substring</a></p>
<p><strong>【分析一】</strong></p>
<p>暴力求解</p>
<p>先以第一个字符为头，找长度为2,3，。。。的字符串中是否是回文字符串，使用res_str记录下来。然后以第二个字符为头，找长度为2,3，。。。的字符串中是否是回文字符串。。。</p>
<p>但是这种方法超时</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">longestPalindrome</span><span class="params">(self, s)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type s: str</span></span><br><span class="line"><span class="string">        :rtype: str</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="comment">#暴力求解</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> s:<span class="keyword">return</span> <span class="string">''</span></span><br><span class="line">        <span class="keyword">if</span> len(s)==<span class="number">1</span>:<span class="keyword">return</span> s</span><br><span class="line">        n = len(s)</span><br><span class="line">        res_len = <span class="number">0</span><span class="comment">#当前回文子串的最长长度</span></span><br><span class="line">        res_str = <span class="string">''</span><span class="comment">#当前最长的回文串</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">#以第一个字符为头，长度为2,3，。。。的字符串中是否是回文字符串，使用res_str记录下来</span></span><br><span class="line">        <span class="comment">#然后以第二个字符为头，找长度为2,3，。。。的字符串中是否是回文字符串。。。</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>,n<span class="number">-1</span>):<span class="comment">#当前开始遍历的字符下标</span></span><br><span class="line">            <span class="keyword">for</span> cur_len <span class="keyword">in</span> range(<span class="number">2</span>,n-i+<span class="number">1</span>):<span class="comment">#字符串的长度</span></span><br><span class="line">                cur_str = s[i:i+cur_len]</span><br><span class="line">                <span class="keyword">if</span> cur_str == cur_str[::<span class="number">-1</span>]:</span><br><span class="line">                    <span class="keyword">if</span> cur_len&gt;res_len:</span><br><span class="line">                        res_len = cur_len</span><br><span class="line">                        res_str = cur_str</span><br><span class="line">        <span class="keyword">return</span> s[<span class="number">0</span>] <span class="keyword">if</span> res_str==<span class="string">''</span> <span class="keyword">else</span> res_str</span><br></pre></td></tr></table></figure>
<p><strong>【分析二】</strong></p>
<p>动态规划的关键就是找出什么是状态和状态转移方程，<br>我们先看问题：找出最长的回文子串</p>
<ul>
<li>一个回文串去掉2个头后，剩下的依然是回文串</li>
<li>如果一个字符串的头尾2个字符不相等，一定不是回文串</li>
<li>如果一个字符串的头尾2个字符相等，才有必要继续判断下去：<ul>
<li>如果里面的子串是回文，则整个字符串就是回文</li>
<li>如果里面的子串不是回文，则整个字符串不是回文</li>
</ul>
</li>
</ul>
<ol>
<li>定义状态<br><code>dp[i][j]</code>表示子串s[i..j]是否是回文串。因此dp[][]是bool类型的值。这里的s[i…j]是左闭右闭区间，包括s[i]和s[j]</li>
<li><p>状态转移方程<br><code>dp[i][j] = (s[i]==s[j]) and dp[i+1][j-1]</code></p>
<ul>
<li>这里的<code>i&lt;=j</code>，因此只用填二维表的对角线和对角线以上的部分就可以了。</li>
<li><code>dp[i+1][j-1]</code>，s[i+1..j-1]中至少有1个元素，即<code>j-1-(i+1)&gt;=1</code>,可得出<code>j-i&gt;=3</code></li>
<li>因此当<code>j-i&gt;=3</code>时才可以使用动态转移方程。当<code>j-i&lt;3</code>时，就可以当做特殊情况单独处理。<code>j-i可以是0,1,2</code>，即子串长度分为<code>1,2,3</code>，当子串长度为1时肯定是回文，当子串长度为2和3时，如果<code>s[i]==s[j]</code>，那肯定也是回文。因此在<code>s[i]==s[j] and j-i&lt;3</code>时，可以直接下结论<code>dp[i][j]=True</code>,否则才进行状态转移。</li>
</ul>
</li>
<li>初始化<br>初始化时，单个字符串一定是回文，因此对角线先初始化为True，即<code>dp[i][i]=True</code></li>
<li>返回值<br>只要一得到<code>dp[i][j]=True</code>，即记录子串的长度和起始位置。</li>
<li>考虑优化空间<br>在填表的过程中，dp[i][j]只和dp[i+1][j-1]有关，即和左下放的表格有关，因此是可以优化的，但是优化后可读性就会变差，这里就不优化了。</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">longestPalindrome</span><span class="params">(self, s)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type s: str</span></span><br><span class="line"><span class="string">        :rtype: str</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="comment">#暴力求解</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> s:<span class="keyword">return</span> <span class="string">''</span></span><br><span class="line">        <span class="keyword">if</span> len(s)==<span class="number">1</span>:<span class="keyword">return</span> s</span><br><span class="line">        n = len(s)</span><br><span class="line">        dp = [[<span class="keyword">False</span> <span class="keyword">for</span> _ <span class="keyword">in</span> range(n)] <span class="keyword">for</span> _ <span class="keyword">in</span> range(n)]</span><br><span class="line">        </span><br><span class="line">        <span class="comment">#回文串的长度，不能为0，比如"ac"不是回文字</span></span><br><span class="line">        <span class="comment">#符串，但是只有1个字符'a'或'c'是回文字符串，</span></span><br><span class="line">        <span class="comment">#因此回文字符串的长度最小也是1</span></span><br><span class="line">        res_len = <span class="number">1</span></span><br><span class="line">        start = <span class="number">0</span><span class="comment">#回文串开始的下标</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">#初始化对角线为True</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">            dp[i][i] = <span class="keyword">True</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>,n):</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>,j):</span><br><span class="line">                <span class="keyword">if</span> s[i] == s[j]:</span><br><span class="line">                    <span class="keyword">if</span> j - i &lt;<span class="number">3</span>:</span><br><span class="line">                        dp[i][j] = <span class="keyword">True</span></span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        <span class="comment">#2层for循环，必须是j在外循环，i在内循环</span></span><br><span class="line">                        <span class="comment">#因此dp[i][j]和dp[i+1][j-1]有关，如果i在外循环</span></span><br><span class="line">                        <span class="comment">#在遍历dp[i][:]的时候，并不知道dp[i+1][:]的值</span></span><br><span class="line">                        <span class="comment">#而如果j在外循环时，dp[:][j]可以知道dp[:][j-1]的值</span></span><br><span class="line">                        dp[i][j] = dp[i+<span class="number">1</span>][j<span class="number">-1</span>]</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    dp[i][j] = <span class="keyword">False</span></span><br><span class="line">                </span><br><span class="line">                <span class="keyword">if</span> dp[i][j]:</span><br><span class="line">                    <span class="keyword">if</span> j-i+<span class="number">1</span>&gt;res_len:</span><br><span class="line">                        res_len = j-i+<span class="number">1</span></span><br><span class="line">                        start = i</span><br><span class="line">        <span class="keyword">return</span> s[start:start+res_len]</span><br></pre></td></tr></table></figure>
<ul>
<li>时间复杂度：O(n^2)</li>
<li>空间复杂度：O(n^2)</li>
</ul>
<p><strong>【分析三】</strong></p>
<p>中心扩散法：枚举可能出现的回文子串的中心位置，从中心位置尝试尽可能扩散出去，得到一个回文串。</p>
<p>中心扩散法的思路是：遍历每个字符，以这个字符为中心，利用回文串左右对称的特征，向两边扩散，看最多能扩散多远。<br>枚举中心位置的时间复杂度是O(N)，从中心扩散得到回文子串的时间复杂度为O(N)，因此时间复杂度为O(N^2)</p>
<p>注意：回文串的长度为奇数和偶数时，中心不一样</p>
<ul>
<li>当回文串长度为奇数时，中心是中间的具体字符，例如<code>bab</code>,中心为<code>a</code></li>
<li>当回文串长度为偶数时，中心是中间2个字符的空隙，例如<code>baab</code>的中心是2个<code>a</code>中间的空隙</li>
</ul>
<p><img src="/2020/06/06/Leetcode之动态规划/2.png" alt=""></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">longestPalindrome</span><span class="params">(self, s)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type s: str</span></span><br><span class="line"><span class="string">        :rtype: str</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="comment">#暴力求解</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> s:<span class="keyword">return</span> <span class="string">''</span></span><br><span class="line">        <span class="keyword">if</span> len(s)==<span class="number">1</span>:<span class="keyword">return</span> s</span><br><span class="line">        n = len(s)</span><br><span class="line"></span><br><span class="line">        res_len = <span class="number">1</span><span class="comment">#回文串的长度，不能为0，比如"ac"不是回文字符串，但是只有1个字符'a'或'c'是回文字符串，因此回文字符串的长度最小也是1</span></span><br><span class="line">        res_max = s[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n):<span class="comment">#遍历中心节点</span></span><br><span class="line">            str_odd,len_odd = self.center_spread(s,i,i)</span><br><span class="line">            str_even,len_even = self.center_spread(s,i,i+<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">            <span class="comment">#找到当前的最长回文子串,首先求出奇偶长度的最大值</span></span><br><span class="line">            <span class="comment">#然后看这个最大值和当前的res_len比较</span></span><br><span class="line">            tmp_len = len_odd <span class="keyword">if</span> len_odd&gt;len_even <span class="keyword">else</span> len_even</span><br><span class="line">            tmp_res = str_odd <span class="keyword">if</span> tmp_len%<span class="number">2</span>==<span class="number">1</span> <span class="keyword">else</span> str_even</span><br><span class="line">            <span class="keyword">if</span> tmp_len&gt;res_len:</span><br><span class="line">                res_len = tmp_len</span><br><span class="line">                res_max = tmp_res</span><br><span class="line">        <span class="keyword">return</span> res_max</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">center_spread</span><span class="params">(self,s,left,right)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        left,right为中心位置</span></span><br><span class="line"><span class="string">        如果left==right，说明之后找到的回文串长度为奇数</span></span><br><span class="line"><span class="string">        如果left+1=right，说明之后找到的回文串长度为偶数</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        i,j = left,right</span><br><span class="line">        n = len(s)</span><br><span class="line">        <span class="comment">#babad举例，第2个b为中心位</span></span><br><span class="line">        <span class="keyword">while</span> i&gt;=<span class="number">0</span> <span class="keyword">and</span> j&lt;n <span class="keyword">and</span> s[i] == s[j]:</span><br><span class="line">            i-=<span class="number">1</span></span><br><span class="line">            j+=<span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> s[i+<span class="number">1</span>:j],j-i+<span class="number">1</span></span><br></pre></td></tr></table></figure>
<h1><span id="8-总结">8. 总结</span></h1><p>动态规划的思路是自底向上，先从最基本最简单的问题出发，逐步计算中间过程，最后得到需要求的解。<br>动态规划要求“后无效性”，即dp[i]依赖dp的某个值，这个值必须在dp[i]之前已经被正确求出来。<br>在做动态规划问题时，需要考虑以下问题</p>
<ul>
<li>状态<br>首先定义状态，看看题目问的问题可不可以作为状态。哪个状态方便转移就定义哪个状态</li>
<li>状态转移方程<br>其实就是多个问题找最优解。将当前问题分解成多个子问题，找出子问题的解，然后再从子问题中找出最优解</li>
<li>初始化<br>对dp进行初始化</li>
<li>返回结果<br>通过求解dp，思考怎么返回最终的结果，有些问题并不是返回dp[-1]</li>
<li>优化空间<br>写完代码之后，看一下是否可以优化空间，即表格，数组复用。观察状态转移矩阵，看看是否有些dp在用了之后就不再用到，可以使用变量来代替数据<br>多练习0-1背包问题</li>
</ul>
<p>动态规划在求子序列，子数组，例如最大子序列和，最大子序列乘积等问题时，状态dp[i]为以i为结尾的最大值。这是一个经验</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/06/06/Leetcode之回溯/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Echo">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/touxiang.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Echo's blog">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/06/06/Leetcode之回溯/" itemprop="url">Leetcode之回溯</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-06-06T10:41:31+08:00">
                2020-06-06
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/算法/" itemprop="url" rel="index">
                    <span itemprop="name">算法</span>
                  </a>
                </span>

                
                
              
            </span>
          

          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  6.5k
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  28
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <a id="more"></a>
<!-- TOC -->
<ul>
<li><a href="#1-回溯">1. 回溯</a></li>
<li><a href="#2-矩阵中单词路径搜索">2. 矩阵中单词路径搜索</a></li>
<li><a href="#3-机器人的运动范围">3. 机器人的运动范围</a></li>
<li><a href="#4-全排列">4. 全排列</a></li>
<li><a href="#5-全排列-ii">5. 全排列 II</a></li>
<li><a href="#6-组合">6. 组合</a></li>
<li><a href="#7-组合总和">7. 组合总和</a></li>
<li><a href="#8-组合总和-ii">8. 组合总和 II</a></li>
<li><a href="#9-组合总和-iii">9. 组合总和 III</a></li>
<li><a href="#10-括号生成">10. 括号生成</a></li>
<li><a href="#11-n皇后">11. N皇后</a></li>
<li><a href="#12-总结">12. 总结</a></li>
</ul>
<!-- /TOC -->
<h1><span id="1-回溯">1. 回溯</span></h1><p>回溯可以看做是暴力法的升级。回溯法非常适合由多个步骤组成的问题，每个步骤都有多个选项。当我们在某一步选择了其中一个选项时，就进入到下一步，然后又面临新的选项，就这样重读选择，直至达到最终的状态。</p>
<p>回溯问题可以理解成在一个树上进行深度优先遍历。例如给定[1,2,3]，求一共有多少种组合。第一个数字可以是1,2,3，有3种选择。然后第二个数字有2种选择，第三个数字有1个选择。<br>回溯就是在这个树上进行深度遍历时，从较深的节点层返回较浅的节点层，需要将状态回复到过去，这个恢复的过程就是“回溯”<br>回溯算法一般用递归实现。回溯算法的时间复杂度很高，因此在遍历时，如果能提前直到这一分支不可能达到满意的结果，就可以提前结束，这一操作称为“剪枝”<br>回溯+剪枝可以加快搜索速度，在这之前，一般需要做一些预处理工作来达到剪枝的目的，例如排序。但这会节省很多剪枝的时间。在回溯+剪枝时，因为时间复杂度很高，所以能用空间换时间就尽量用空间，来减少时间的消耗。</p>
<p><img src="/2020/06/06/Leetcode之回溯/1.png" alt=""></p>
<p>做回溯问题时，最好先画图，考虑以下问题</p>
<ul>
<li>分支如何产生</li>
<li>题目需要的解在哪里，是在叶子节点，还是非叶子节点，还是在从根节点到叶子节点的路径上</li>
<li>哪些搜索会产生不必要的解，如果知道这个分支会产生不必要的解，应该做剪枝，剪枝的条件是什么，代码怎么写。</li>
</ul>
<p><img src="/2020/06/06/Leetcode之回溯/3.png" alt=""></p>
<p>在二维矩阵寻找路径的问题，基本都可以用回溯解决</p>
<p>【参考资料】</p>
<p><a href="https://leetcode-cn.com/problems/permutations/solution/hui-su-suan-fa-python-dai-ma-java-dai-ma-by-liweiw/" target="_blank" rel="noopener">从全排列问题开始理解「回溯」算法</a></p>
<p><a href="https://leetcode-cn.com/problems/permutations/solution/hui-su-suan-fa-xiang-jie-by-labuladong-2/" target="_blank" rel="noopener">扒一扒回溯算法的裤子</a></p>
<p><strong>【回溯算法模板】</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">result = []</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">backtrack</span><span class="params">(路径, 选择列表)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> 满足结束条件:</span><br><span class="line">        result.add(路径)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> 选择 <span class="keyword">in</span> 选择列表:</span><br><span class="line">        做选择</span><br><span class="line">        backtrack(路径, 选择列表)</span><br><span class="line">        撤销选择  <span class="comment">#在递归后撤销选择</span></span><br></pre></td></tr></table></figure>
<h1><span id="2-矩阵中单词路径搜索">2. 矩阵中单词路径搜索</span></h1><p>请设计一个函数，用来判断在一个矩阵中是否存在一条包含某字符串所有字符的路径。路径可以从矩阵中的任意一格开始，每一步可以在矩阵中向左、右、上、下移动一格。如果一条路径经过了矩阵的某一格，那么该路径不能再次进入该格子。例如，在下面的3×4的矩阵中包含一条字符串“bfce”的路径（路径中的字母用加粗标出）。</p>
<p>[[“a”,”<strong>b</strong>“,”c”,”e”],</p>
<p>[“s”,”<strong>f</strong>“,”<strong>c</strong>“,”s”],</p>
<p>[“a”,”d”,”<strong>e</strong>“,”e”]]</p>
<p>但矩阵中不包含字符串“abfb”的路径，因为字符串的第一个字符b占据了矩阵中的第一行第二个格子之后，路径不能再次进入这个格子。</p>
<p>链接：<a href="https://leetcode-cn.com/problems/ju-zhen-zhong-de-lu-jing-lcof" target="_blank" rel="noopener">https://leetcode-cn.com/problems/ju-zhen-zhong-de-lu-jing-lcof</a></p>
<p><strong>【分析】</strong></p>
<p>使用深度有限搜索DFS+回溯方法来解决</p>
<p>深度优先搜索：先找到一个可能的方向，朝这个方向搜到底，如果不满足，再回溯到上一个节点，沿这个方向搜索<br>回溯：在搜索中，遇到这条路不可能和目标字符串匹配的情况，则返回</p>
<p>这道题使用递归</p>
<ul>
<li>递归的参数：当前元素在board的位置<code>board[i][j]</code>,当前需要匹配的字符<code>word[k]</code></li>
<li>递归终止条件<ul>
<li>返回false：i和j越界，当前元素board[i][j]和board[k]不相等，当前元素board[i][j]已经被访问过</li>
<li>返回true：字符串word已经全部匹配，即k=len(word)-1<br>递推工作：</li>
</ul>
</li>
</ul>
<ol>
<li>标记当前元素已经被访问过</li>
<li>搜索board[i][j]的上下左右4个方向，是否和board[k+1]匹配</li>
<li>如果匹配，返回True，如果都不匹配，回溯，说明当前元素board[i][j]行不通，将其标记为未采纳该节点</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">exist</span><span class="params">(self, board, word)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type board: List[List[str]]</span></span><br><span class="line"><span class="string">        :type word: str</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        rows,cols = len(board),len(board[<span class="number">0</span>])</span><br><span class="line">        <span class="comment">#标记当前是否被访问</span></span><br><span class="line">        visit = [[<span class="number">0</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(cols)] <span class="keyword">for</span> i <span class="keyword">in</span> range(rows)]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(rows):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(cols):</span><br><span class="line">                <span class="keyword">if</span> board[i][j] == word[<span class="number">0</span>]:</span><br><span class="line">                    <span class="keyword">if</span> self.dfs(i,j,<span class="number">0</span>,board,word,visit):<span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(self,i,j,k,board,word,visit)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        board[i][j]</span></span><br><span class="line"><span class="string">        word[k]</span></span><br><span class="line"><span class="string">        判断board[i][j]和word[k]是否匹配，如果匹配，则判断board[i][j]的下一个元素和word[k+1]是否匹配</span></span><br><span class="line"><span class="string">        如果不匹配，直接返回false</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="comment">#递归结束的条件</span></span><br><span class="line">        <span class="comment">#1.board[i][j]已经访问过，返回false</span></span><br><span class="line">        <span class="comment">#2.board[i][j]与word[k]不相等，返回false</span></span><br><span class="line">        <span class="comment">#3.board[i][j]超出索引，返回false</span></span><br><span class="line">        <span class="comment">#4.word已全部匹配，即k=len(word)-1</span></span><br><span class="line">        deltas = [[<span class="number">0</span>,<span class="number">1</span>],[<span class="number">0</span>,<span class="number">-1</span>],[<span class="number">1</span>,<span class="number">0</span>],[<span class="number">-1</span>,<span class="number">0</span>]]</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> <span class="number">0</span> &lt;= i &lt; len(board) <span class="keyword">or</span> <span class="keyword">not</span> <span class="number">0</span> &lt;= j &lt; len(board[<span class="number">0</span>]) <span class="keyword">or</span> board[i][j]!= word[k] <span class="keyword">or</span> visit[i][j] == <span class="number">1</span>:<span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">        <span class="keyword">if</span> k == len(word)<span class="number">-1</span>:<span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">        visit[i][j] = <span class="number">1</span><span class="comment">#board[i][j]和word[k]匹配</span></span><br><span class="line">        <span class="keyword">for</span> delta <span class="keyword">in</span> deltas:<span class="comment">#搜索board的上下左右是否和word[k+1]匹配</span></span><br><span class="line">            next_i = i+delta[<span class="number">0</span>]</span><br><span class="line">            next_j = j+delta[<span class="number">1</span>]</span><br><span class="line">            <span class="keyword">if</span> self.dfs(next_i,next_j,k+<span class="number">1</span>,board,word,visit):<span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">        visit[i][j] = <span class="number">0</span><span class="comment">#上下左右都不匹配，回溯        </span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">False</span></span><br></pre></td></tr></table></figure>
<h1><span id="3-机器人的运动范围">3. 机器人的运动范围</span></h1><p>地上有一个m行n列的方格，从坐标 [0,0] 到坐标 [m-1,n-1] 。一个机器人从坐标 [0, 0] 的格子开始移动，它每次可以向左、右、上、下移动一格（不能移动到方格外），也不能进入行坐标和列坐标的数位之和大于k的格子。例如，当k为18时，机器人能够进入方格 [35, 37] ，因为3+5+3+7=18。但它不能进入方格 [35, 38]，因为3+5+3+8=19。请问该机器人能够到达多少个格子？</p>
<p>链接：<a href="https://leetcode-cn.com/problems/ji-qi-ren-de-yun-dong-fan-wei-lcof" target="_blank" rel="noopener">https://leetcode-cn.com/problems/ji-qi-ren-de-yun-dong-fan-wei-lcof</a></p>
<ul>
<li>深度优先搜索+回溯</li>
<li>用队列实现广度优先搜索</li>
</ul>
<p><strong>【方法一】</strong><br>深度优先搜搜+回溯<br>使用visit记录m行n列矩阵的遍历情况。</p>
<ul>
<li>递归的参数：当前元素在board的位置<code>[i][j]</code></li>
<li>递归终止条件<ul>
<li>返回0（当前元素没有被访问）：i和j越界，i和j位数和大于k，当前元素[i][j]已经被访问过，</li>
</ul>
</li>
</ul>
<p>递推工作：</p>
<ol>
<li>当前元素符合条件，标记当前元素已经被访问过</li>
<li>搜索[i][j]的上下左右4个方向，记录每个方向走过的格子个数，</li>
<li>返回结果+1，表示除了4个方向访问的格子，还要加上当前访问的格子[i][j]</li>
</ol>
<p>优化：</p>
<ul>
<li>其实只需要访问下和右2个方向就可以了，不需要访问4个方向</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">movingCount</span><span class="params">(self, m, n, k)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type m: int</span></span><br><span class="line"><span class="string">        :type n: int</span></span><br><span class="line"><span class="string">        :type k: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="comment">#时间复杂度：O(mn)</span></span><br><span class="line">        <span class="comment">#空间复杂度：O(mn),visit数组</span></span><br><span class="line">        <span class="comment">#优化：搜索反向其实只用向下和向右就可以了</span></span><br><span class="line">        visit = [[<span class="number">0</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(n)] <span class="keyword">for</span> j <span class="keyword">in</span> range(m)]</span><br><span class="line">        all_sum = self.dfs(<span class="number">0</span>,<span class="number">0</span>,m,n,k,visit)</span><br><span class="line">        <span class="keyword">return</span> all_sum</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(self,i,j,m,n,k,visit)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        i和j表示机器人当前的格子</span></span><br><span class="line"><span class="string">        m和n，k是题目给定的参数</span></span><br><span class="line"><span class="string">        visit记录遍历情况</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        deltas = [[<span class="number">0</span>,<span class="number">1</span>],[<span class="number">0</span>,<span class="number">-1</span>],[<span class="number">1</span>,<span class="number">0</span>],[<span class="number">-1</span>,<span class="number">0</span>]]</span><br><span class="line">        <span class="comment">#递归结束的条件</span></span><br><span class="line">        <span class="comment">#1.i和j超过范围</span></span><br><span class="line">        <span class="comment">#2.i和j的位数之和超过k</span></span><br><span class="line">        <span class="comment">#3.i和j已经被访问过</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> <span class="number">0</span>&lt;=i&lt;m <span class="keyword">or</span> <span class="keyword">not</span> <span class="number">0</span>&lt;=j&lt;n <span class="keyword">or</span> self.digit_sum(i)+self.digit_sum(j)&gt;k <span class="keyword">or</span> visit[i][j]==<span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        visit[i][j] = <span class="number">1</span></span><br><span class="line">        all_sum = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> delta <span class="keyword">in</span> deltas:</span><br><span class="line">            next_i = i + delta[<span class="number">0</span>]</span><br><span class="line">            next_j = j + delta[<span class="number">1</span>]</span><br><span class="line">            all_sum += self.dfs(next_i,next_j,m,n,k,visit)</span><br><span class="line">        <span class="keyword">return</span> all_sum + <span class="number">1</span><span class="comment">#加1是为了加上当前访问的格子i,j</span></span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">digit_sum</span><span class="params">(self,i)</span>:</span></span><br><span class="line">        all_sum = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> i &gt; <span class="number">0</span>:</span><br><span class="line">            all_sum += i%<span class="number">10</span></span><br><span class="line">            i /= <span class="number">10</span></span><br><span class="line">        <span class="keyword">return</span> all_sum</span><br></pre></td></tr></table></figure>
<p><strong>【方法二】</strong></p>
<p>广度优先遍历BFS</p>
<p>queue中保存当前待检测的格子，里面保存的值有4个元素(i,j,sum_i,sum_j)，分别表示：当前格子的下标i和j，下标的位数</p>
<p>因为机器人要求从(0,0)出发，所以首先将(0,0,0,0)加入到queue中，遍历第一个格子，判断当前格式是否符合要求，如果不符合要求，则遍历下一个格子。如果符合要求，将当前格子(i,j)加入到visit中，然后将该格子的下和右格子加入队列中，等待遍历。最终返回visit的长度即为访问的格子数量</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">movingCount</span><span class="params">(self, m, n, k)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type m: int</span></span><br><span class="line"><span class="string">        :type n: int</span></span><br><span class="line"><span class="string">        :type k: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        queue = [(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>)]<span class="comment">#当前元素的位置i,j和位数和</span></span><br><span class="line">        visit = set()</span><br><span class="line">        <span class="keyword">while</span> queue:</span><br><span class="line">            i,j,sum_i,sum_j = queue.pop(<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> <span class="number">0</span>&lt;=i&lt;m <span class="keyword">or</span> <span class="keyword">not</span> <span class="number">0</span>&lt;=j&lt;n <span class="keyword">or</span> sum_i+sum_j&gt;k <span class="keyword">or</span> (i,j) <span class="keyword">in</span> visit:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            visit.add((i,j))</span><br><span class="line">            queue.append((i+<span class="number">1</span>,j,self.digit_sum(i+<span class="number">1</span>),sum_j))</span><br><span class="line">            queue.append((i,j+<span class="number">1</span>,sum_i,self.digit_sum(j+<span class="number">1</span>)))</span><br><span class="line">        <span class="keyword">return</span> len(visit)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">digit_sum</span><span class="params">(self,i)</span>:</span></span><br><span class="line">        all_sum = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> i &gt; <span class="number">0</span>:</span><br><span class="line">            all_sum += i%<span class="number">10</span></span><br><span class="line">            i /= <span class="number">10</span></span><br><span class="line">        <span class="keyword">return</span> all_sum</span><br></pre></td></tr></table></figure>
<h1><span id="4-全排列">4. 全排列</span></h1><p>给定一个 <strong>没有重复 数字</strong>的序列，返回其所有可能的全排列。</p>
<blockquote>
<p>输入: [1,2,3]<br>输出:<br>[<br>  [1,2,3],<br>  [1,3,2],<br>  [2,1,3],<br>  [2,3,1],<br>  [3,1,2],<br>  [3,2,1]<br>]</p>
</blockquote>
<p>链接：<a href="https://leetcode-cn.com/problems/permutations" target="_blank" rel="noopener">https://leetcode-cn.com/problems/permutations</a></p>
<p><strong>【分析】</strong></p>
<p><img src="/2020/06/06/Leetcode之回溯/1.png" alt=""></p>
<ol>
<li>这棵树中，除了根节点和叶子节点，其余节点做的事情都一样，都是在还未选择的数字中选一个数，可以用递归实现</li>
<li>递归结束条件：当递归到树的最后一层时，需要一个变量<code>depth</code>来记录当前遍历到树的第几层</li>
</ol>
<p>本题要点</p>
<ul>
<li><code>depth</code>：记录当前递归遍历到树的层数</li>
<li><code>path=[]</code>，记录当前路径中的节点，例如path=[1,2,3]，当下一层选择节点4时，将4添加到path中，path=[1,2,3,4]，然后在回溯的过程中，撤销4的选择，也需要修改path=[1,2,3]，然后再选择3的其他子孩子，例如path=[1,2,3,5]</li>
<li><code>visit=[]</code>：记录<code>path</code>中哪些数据没有被遍历过。path=[1,2]，则visit[1]=ture,visit[2]=true，剩余没被遍历的节点为false，这样在path考虑下一个数字时，可以直接从visit为false的数字中选择。</li>
<li>在path选择下一个节点时，visit中有多个未被访问的节点，使用循环遍历visit中所有未被访问的节点。</li>
<li><code>res</code>：记录所有的组合结果，例如[[1,2,3],[1,3,2],…]</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">permutation</span><span class="params">(self, s)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type s: str</span></span><br><span class="line"><span class="string">        :rtype: List[str]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(depth)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> depth == len(s):</span><br><span class="line">                res.append(<span class="string">''</span>.join(path[:]))</span><br><span class="line">                <span class="keyword">return</span> </span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(len(s)):</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> visit[i]:</span><br><span class="line">                    visit[i]=<span class="keyword">True</span></span><br><span class="line">                    path.append(s[i])</span><br><span class="line">                    dfs(depth+<span class="number">1</span>)</span><br><span class="line">                    visit[i]=<span class="keyword">False</span></span><br><span class="line">                    path.pop()</span><br><span class="line">        res,path = [],[]</span><br><span class="line">        visit = [<span class="keyword">False</span> <span class="keyword">for</span> _ <span class="keyword">in</span> range(len(s))]</span><br><span class="line">        dfs(depth=<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<h1><span id="5-全排列-ii">5. 全排列 II</span></h1><p>给定一个可包含<strong>重复数字</strong>的序列，返回所有不重复的全排列。</p>
<p>示例:</p>
<p>输入: [1,1,2]<br>输出:<br>[<br>  [1,1,2],<br>  [1,2,1],<br>  [2,1,1]<br>]</p>
<p>链接：<a href="https://leetcode-cn.com/problems/permutations-ii" target="_blank" rel="noopener">https://leetcode-cn.com/problems/permutations-ii</a></p>
<p><strong>【分析一】</strong></p>
<ul>
<li><code>depth</code>：记录当前递归遍历到树的层数</li>
<li><code>path=[]</code>，记录当前路径中的节点，例如path=[a,b,c]</li>
<li><code>visit=[]</code>：记录<code>path</code>中哪些数据没有被遍历过。path=[a,b]，则visit[1]=ture,visit[2]=true，剩余没被遍历的节点为false，这样在path考虑下一个节点时，可以直接从visit为false的节点中选择。</li>
<li>在path选择下一个节点时，visit中有多个未被访问的节点，使用循环遍历visit中所有未被访问的节点。</li>
<li><code>res</code>：记录所有的组合结果，例如[abc],[acb],…]</li>
</ul>
<p>depth = 0时，处于第一层[]，depth=3时，说明已经将所有的字母都加入到path中，然后将当前path加入到res中</p>
<p><strong>一般都是在递归的后面进行回溯</strong>,例如在<code>dfs</code>中，递归函数后，使用<code>visit[i]=False,path.pop()</code>进行回溯</p>
<figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">              []</span><br><span class="line">    a          <span class="keyword">b </span>           c</span><br><span class="line"> ab  ac     <span class="keyword">ba </span>  <span class="keyword">bc </span>    ca    cb</span><br><span class="line"><span class="symbol">abc</span>  acb   <span class="keyword">bac </span>  <span class="keyword">bca </span>   cab   cba</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">permutation</span><span class="params">(self, s)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type s: str</span></span><br><span class="line"><span class="string">        :rtype: List[str]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(depth)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> depth == len(s):</span><br><span class="line">                res.append(<span class="string">''</span>.join(path[:]))</span><br><span class="line">                <span class="keyword">return</span> </span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(len(s)):</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> visit[i]:</span><br><span class="line">                    visit[i]=<span class="keyword">True</span></span><br><span class="line">                    path.append(s[i])</span><br><span class="line">                    dfs(depth+<span class="number">1</span>)</span><br><span class="line">                    visit[i]=<span class="keyword">False</span></span><br><span class="line">                    path.pop()</span><br><span class="line">        res,path = [],[]</span><br><span class="line">        visit = [<span class="keyword">False</span> <span class="keyword">for</span> _ <span class="keyword">in</span> range(len(s))]</span><br><span class="line">        dfs(depth=<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> list(set(res))</span><br></pre></td></tr></table></figure>
<p><strong>【分析二】</strong></p>
<p>上面那个方法没有对重复元素进行判断，只在最后返回值时将list转换为set进行去重，如果数组中全是重复元素，且个数较多，例如[aaaaaaaaaaaaaaaaaaaaaaaaaa……]，那么就会非常耗时。下面对此进行改进。<br>首先需要对s进行排序，然后在<code>dfs</code>中对s进行遍历时，如果当前元素没有被访问，判断当前元素和前一个元素是否相等，且前一个元素已经遍历完成，且被撤销了。<br>这里<code>not visit[i-1]</code>的理解如下：当前数组为[1,1,2]，为了区分这2个1，写成[1,1’,2]。首先第一次选择1，会形成2个组合[1,1’,2]和[1,2,1’]，将这2个组合加入到res中，然后回溯，依次将visit[1’]=false,visit[2]=false,visit[1]=false。然后在进行下一次循环时，第一个数据选中1<code>，此时的s[i]=1&#39;和s[i-1]=1相等，且前面的1已经完成组合和回溯，visit[i-1]==false，这就说明此时的1&#39;可以不用遍历了。
如果不加</code>not visit[i-1]`，那么就会在第一个分支中的[1,1’]中，遍历到1’，和上一个元素1相同，就会continue。但当前的visit[1]=true，数字1还没有完成回溯，还需要继续进行。</p>
<p><img src="/2020/06/06/Leetcode之回溯/2.png" alt=""></p>
<p>要点</p>
<ul>
<li><strong>先对nums进行排序，<code>nums=sorted(nums)</code></strong></li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">permuteUnique</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: List[List[int]]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(depth)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> depth == len(nums):</span><br><span class="line">                res.append(path[:])</span><br><span class="line">                <span class="keyword">return</span> </span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums)):</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> visit[i]:<span class="comment">#当前字符为访问，理论上来说可以把该字符加入到path中</span></span><br><span class="line">                    <span class="comment">#但是如果当前字符和前一个字符一样，说明当前字符是重复字符</span></span><br><span class="line">                    <span class="comment">#并且visit[i-1]为false表示前面那个相同的字符之前被访问到根节点，然后被撤销</span></span><br><span class="line">                    <span class="keyword">if</span> i&gt;<span class="number">0</span> <span class="keyword">and</span> nums[i]==nums[i<span class="number">-1</span>] <span class="keyword">and</span> <span class="keyword">not</span> visit[i<span class="number">-1</span>]:</span><br><span class="line">                        <span class="keyword">continue</span></span><br><span class="line">                    visit[i]=<span class="keyword">True</span></span><br><span class="line">                    path.append(nums[i])</span><br><span class="line">                    dfs(depth+<span class="number">1</span>)</span><br><span class="line">                    visit[i] = <span class="keyword">False</span></span><br><span class="line">                    path.pop()</span><br><span class="line">        res,path = [],[]</span><br><span class="line">        visit = [<span class="keyword">False</span> <span class="keyword">for</span> _ <span class="keyword">in</span> range(len(nums))]</span><br><span class="line">        nums = sorted(nums)</span><br><span class="line">        dfs(depth=<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<h1><span id="6-组合">6. 组合</span></h1><p>给定两个整数 n 和 k，返回 1 … n 中所有可能的 k 个数的组合。</p>
<p>示例:</p>
<p>输入: n = 4, k = 2<br>输出:<br>[<br>  [2,4],<br>  [3,4],<br>  [2,3],<br>  [1,2],<br>  [1,3],<br>  [1,4],<br>]</p>
<p>链接：<a href="https://leetcode-cn.com/problems/combinations" target="_blank" rel="noopener">https://leetcode-cn.com/problems/combinations</a></p>
<p><strong>【分析一】</strong></p>
<p>分析可以发现，第一个选择的数假设为1，第二个选择数要严格大于第一个数，当path的长度为k时，结束递归。</p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">                    []</span><br><span class="line">    <span class="number">1</span>                 <span class="number">2</span>              <span class="number">3</span>              <span class="number">4</span>    </span><br><span class="line"><span class="number">12</span>   <span class="number">13</span>  <span class="number">14</span>        <span class="number">23</span>    <span class="number">24</span>          <span class="number">34</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">combine</span><span class="params">(self, n, k)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type n: int</span></span><br><span class="line"><span class="string">        :type k: int</span></span><br><span class="line"><span class="string">        :rtype: List[List[int]]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(res,path)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> len(path) == k:</span><br><span class="line">                res.append(path[:])</span><br><span class="line">                <span class="keyword">return</span> </span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,n+<span class="number">1</span>):<span class="comment">#依次选择</span></span><br><span class="line">                <span class="keyword">if</span> len(path)&gt;<span class="number">0</span> <span class="keyword">and</span> i &lt;= path[<span class="number">-1</span>]:<span class="comment">#只选择比path中大的数,如果&lt;=path[-1]，则继续遍历下一个数</span></span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                path.append(i)</span><br><span class="line">                dfs(res,path)</span><br><span class="line">                path.pop()</span><br><span class="line">        </span><br><span class="line">        res,path = [],[]</span><br><span class="line">        dfs(res,path)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<p><strong>【优化一】</strong><br>对上一种方法进行优化，上一种方法中for循环遍历时，从1开始遍历，然后再使用if语句判断是否比path中的数大。这里改为在for循环中，只遍历比path大的数，即使用start来标识for从哪里开始，这样for出来的数肯定比path中大，不用再使用if语句判断。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">combine</span><span class="params">(self, n, k)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type n: int</span></span><br><span class="line"><span class="string">        :type k: int</span></span><br><span class="line"><span class="string">        :rtype: List[List[int]]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(start,res,path)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> len(path) == k:</span><br><span class="line">                res.append(path[:])</span><br><span class="line">                <span class="keyword">return</span> </span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(start,n+<span class="number">1</span>):</span><br><span class="line">                path.append(i)</span><br><span class="line">                dfs(i+<span class="number">1</span>,res,path)</span><br><span class="line">                path.pop()</span><br><span class="line">        </span><br><span class="line">        res,path = [],[]</span><br><span class="line">        dfs(<span class="number">1</span>,res,path)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<p><strong>【优化二】</strong></p>
<p>在for循环中，不但可以对开始位置进行剪枝，还可以对结束位置进行剪枝。原先i的取值为[start,n]，但其实在递归中，并不是每次递归i都会取到n，i有一个上限。<br>下面来找规律，如果n=15，k=4<br>当选定了一个元素，即len(path)=1，接下来还可以再选3个元素，i最大为13，选[13,14,15]<br>当选定了两个元素，即len(path)=2，接下来还可以选2个元素，i最大为14，选[14,15]<br>当选定了三个元素，即len(path)=3，接下来还可以选1个元素，i最大为15，选[15]<br>在每个循环中可以选择的元素个数为<code>k-len(path)</code>，i的最大值分别为13,14,15，即<code>max(i)=n-(k-len(path))+1</code></p>
<p><img src="/2020/06/06/Leetcode之回溯/4.png" alt=""></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">combine</span><span class="params">(self, n, k)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type n: int</span></span><br><span class="line"><span class="string">        :type k: int</span></span><br><span class="line"><span class="string">        :rtype: List[List[int]]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(start,res,path)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> len(path) == k:</span><br><span class="line">                res.append(path[:])</span><br><span class="line">                <span class="keyword">return</span> </span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(start,n-(k-len(path))+<span class="number">2</span>):</span><br><span class="line">                <span class="comment"># if len(path)&gt;0 and i &lt;= path[-1]:</span></span><br><span class="line">                <span class="comment">#     continue</span></span><br><span class="line">                <span class="comment">#i&gt;path[-1]</span></span><br><span class="line">                path.append(i)</span><br><span class="line">                dfs(i+<span class="number">1</span>,res,path)</span><br><span class="line">                path.pop()</span><br><span class="line">        </span><br><span class="line">        res,path = [],[]</span><br><span class="line">        dfs(<span class="number">1</span>,res,path)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<h1><span id="7-组合总和">7. 组合总和</span></h1><p>给定一个<strong>无重复元素</strong>的数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。</p>
<p>candidates 中的数字可以无限制重复被选取。</p>
<p>说明：<br>所有数字（包括 target）都是正整数。<br>解集不能包含重复的组合。 </p>
<p>链接：<a href="https://leetcode-cn.com/problems/combination-sum" target="_blank" rel="noopener">https://leetcode-cn.com/problems/combination-sum</a></p>
<p><strong>重点</strong></p>
<ul>
<li>candidates中没有重复元素</li>
<li>path中元素可以重复被选取</li>
</ul>
<p>输入: candidates = [2,3,6,7], target = 7,<br>所求解集为:<br>[<br>  [7],<br>  [2,2,3]<br>]</p>
<p><strong>【分析一】</strong></p>
<p>如果path中的和等于target，则将path加入到res中。</p>
<ul>
<li>如果path中数字可以重复选取，则递归中开始下标为i</li>
<li>如果path中数组不可以重复选取，则递归中开始下标为i+1</li>
</ul>
<p>先对candidates从小到大排序，在遍历到当前元素时，如果candidates[i]+sum(path)&gt;target，那后面的元素肯定也不可能了，使用break退出for循环进行剪枝。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">combinationSum</span><span class="params">(self, candidates, target)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type candidates: List[int]</span></span><br><span class="line"><span class="string">        :type target: int</span></span><br><span class="line"><span class="string">        :rtype: List[List[int]]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(start,res,path)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> sum(path)==target:</span><br><span class="line">                res.append(path[:])</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(start,len(candidates)):</span><br><span class="line">                <span class="keyword">if</span> candidates[i]+sum(path)&gt;target:<span class="comment">#剪枝</span></span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">                path.append(candidates[i])</span><br><span class="line">                dfs(i,res,path)</span><br><span class="line">                path.pop()</span><br><span class="line">        candidates = sorted(candidates)</span><br><span class="line">        res,path = [],[]</span><br><span class="line">        dfs(<span class="number">0</span>,res,path)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<h1><span id="8-组合总和-ii">8. 组合总和 II</span></h1><p>给定一个数组 candidates 和一个目标数 target ，candidates中<strong>有重复元素</strong>，找出 candidates 中所有可以使数字和为 target 的组合。</p>
<p>candidates 中的每个数字在每个组合中只能使用一次。</p>
<p>说明：</p>
<p>所有数字（包括目标数）都是正整数。<br>解集不能包含重复的组合。 </p>
<p>链接：<a href="https://leetcode-cn.com/problems/combination-sum-ii" target="_blank" rel="noopener">https://leetcode-cn.com/problems/combination-sum-ii</a></p>
<p>输入: candidates = [10,1,2,7,6,1,5], target = 8,<br>所求解集为:<br>[<br>  [1, 7],<br>  [1, 2, 5],<br>  [2, 6],<br>  [1, 1, 6]<br>]</p>
<p><strong>重点</strong></p>
<ul>
<li>candidates中有重复元素</li>
<li>每个数字在path中只能使用一次</li>
</ul>
<p>在回溯题中，如果数组中有重复元素，在回溯的过程，需要去重，步骤如下</p>
<ul>
<li>先对数组排序，<code>nums = sorted(nums)</code></li>
<li>在for循环内部，使用<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(start,len(nums)):</span><br><span class="line">    <span class="keyword">if</span> i &gt; statr <span class="keyword">and</span> nums[i]==nums[i<span class="number">-1</span>]:</span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">path.append(nums[i])</span><br><span class="line">dfs(...)</span><br><span class="line">path.pop()</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>对candidates排完序后为[1,1,2,5,6,7,10]<br><code>i</code>是当前考察元素的下标，<code>start</code>是本层最开始的那个元素下标。<strong>这里的去重是同层去重</strong>，例如下图中，第一层的1和1<em>重复，需要将`1</em><code>去掉。在第一个分支中第一层是1，第二层是</code>1<em><code>，这2个1在不同的层，不需要去重。如果只写成</code>nums[i]==nums[i-1]<code>,在树中处于不同层的相同元素也生成不了。为了保留不同层的相同元素，使用</code>i&gt;start<code>将这种情况排除，因为在不同层第一次出现的数字</code>i=start<code>，而在同一层出现的相同的数字</code>i&gt;start<code>，这样就可以把第一层出现的</code>1</em>`给剪枝掉。</p>
<p><img src="/2020/06/06/Leetcode之回溯/5.png" alt=""></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">combinationSum2</span><span class="params">(self, candidates, target)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type candidates: List[int]</span></span><br><span class="line"><span class="string">        :type target: int</span></span><br><span class="line"><span class="string">        :rtype: List[List[int]]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(start,res,path)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> sum(path)==target:</span><br><span class="line">                res.append(path[:])</span><br><span class="line">                <span class="keyword">return</span> </span><br><span class="line">            </span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(start,len(candidates)):</span><br><span class="line">                <span class="keyword">if</span> candidates[i]+sum(path)&gt;target:</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">                <span class="keyword">if</span> i &gt; start <span class="keyword">and</span> candidates[i]==candidates[i<span class="number">-1</span>]:</span><br><span class="line">                    <span class="keyword">continue</span> </span><br><span class="line">                path.append(candidates[i])</span><br><span class="line">                dfs(i+<span class="number">1</span>,res,path)</span><br><span class="line">                path.pop()</span><br><span class="line">        res,path = [],[]</span><br><span class="line">        candidates = sorted(candidates)</span><br><span class="line">        dfs(<span class="number">0</span>,res,path)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<h1><span id="9-组合总和-iii">9. 组合总和 III</span></h1><p>找出所有相加之和为 n 的 k 个数的组合。组合中只允许含有 1 - 9 的正整数，并且每种组合中不存在重复的数字。</p>
<p>说明：</p>
<p>所有数字都是正整数。<br>解集不能包含重复的组合。 </p>
<blockquote>
<p>示例 1:<br>输入: k = 3, n = 7<br>输出: <code>[[1,2,4]]</code></p>
</blockquote>
<p>链接：<a href="https://leetcode-cn.com/problems/combination-sum-iii" target="_blank" rel="noopener">https://leetcode-cn.com/problems/combination-sum-iii</a></p>
<p><strong>【分析一】</strong></p>
<ul>
<li>数组中不包含重复的数字，所以不需要去重</li>
<li>每个数字只能用一次，所以在递归时start=i+1</li>
</ul>
<p>在for循环遍历所有的数字时，i的最大值为9，但并不是每次i都可以取到9，下面举例找i的最大值</p>
<p>1~9个数，找k个数，和为n，假设k=5，n=15</p>
<p>当len(path)=0，还可以选5个数，i的最大值为5，选[5,6,7,8,9]<br>当len(path)=1，还可以选4个数，i的最大值为6，选[6,7,8,9]<br>当len(path)=2，还可以选3个数，i的最大值为7，选[7,8,9]</p>
<p>即i的最大值为<code>10-(k-len(path))</code>,在for循环中，<code>range(start,10-(k-len(path))+1)</code></p>
<p>在进入<code>dfs</code>之前，先判断n是否符合实际情况，从1~9中选出k个数，最大为[9,8,…9-k+1],即和最大为(19-k)*k/2，如果n大于这个最大值，则不可能找出这k个数，所以这个提前判断一下n的值是否符合实际情况。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">combinationSum3</span><span class="params">(self, k, n)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type k: int</span></span><br><span class="line"><span class="string">        :type n: int</span></span><br><span class="line"><span class="string">        :rtype: List[List[int]]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(start,path,res)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> sum(path)==n <span class="keyword">and</span> len(path)==k:</span><br><span class="line">                res.append(path[:])</span><br><span class="line">                <span class="keyword">return</span> </span><br><span class="line">            </span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(start,<span class="number">10</span>-(k-len(path))+<span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> i+sum(path)&gt;n <span class="keyword">or</span> len(path)&gt;k:</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">                path.append(i)</span><br><span class="line">                dfs(i+<span class="number">1</span>,path,res)</span><br><span class="line">                path.pop()</span><br><span class="line">        <span class="keyword">if</span> k&lt;=<span class="number">0</span> <span class="keyword">or</span> n&lt;=<span class="number">0</span> <span class="keyword">or</span> k&gt;= n:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        <span class="keyword">if</span> n&gt;(<span class="number">19</span>-k)*k/<span class="number">2</span>:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        res,path = [],[]</span><br><span class="line">        dfs(<span class="number">1</span>,path,res)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<h1><span id="10-括号生成">10. 括号生成</span></h1><p>数字 n 代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且 有效的 括号组合。</p>
<p>示例：</p>
<p>输入：n = 3<br>输出：[<br>       “((()))”,<br>       “(()())”,<br>       “(())()”,<br>       “()(())”,<br>       “()()()”<br>     ]</p>
<p>链接：<a href="https://leetcode-cn.com/problems/generate-parentheses" target="_blank" rel="noopener">https://leetcode-cn.com/problems/generate-parentheses</a></p>
<p><strong>【分析一】</strong></p>
<p>在递归中，使用left和right表示左右括号使用的个数。使用path存储当前括号的组合。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">generateParenthesis</span><span class="params">(self, n)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type n: int</span></span><br><span class="line"><span class="string">        :rtype: List[str]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(path,res,left,right)</span>:</span></span><br><span class="line">            <span class="string">"""</span></span><br><span class="line"><span class="string">            left:左括号已经使用的个数</span></span><br><span class="line"><span class="string">            right:右括号已经使用的个数</span></span><br><span class="line"><span class="string">            """</span></span><br><span class="line">            <span class="keyword">if</span> left==n <span class="keyword">and</span> right==n:</span><br><span class="line">                res.append(<span class="string">""</span>.join(path[:]))</span><br><span class="line">                <span class="keyword">return</span> </span><br><span class="line">            <span class="keyword">if</span> left&lt;right:</span><br><span class="line">                <span class="keyword">return</span> </span><br><span class="line">            <span class="keyword">if</span> left &lt; n:</span><br><span class="line">                path.append(<span class="string">'('</span>)</span><br><span class="line">                dfs(path,res,left+<span class="number">1</span>,right)</span><br><span class="line">                path.pop()</span><br><span class="line">            <span class="keyword">if</span> right &lt; n:</span><br><span class="line">                path.append(<span class="string">')'</span>)</span><br><span class="line">                dfs(path,res,left,right+<span class="number">1</span>)</span><br><span class="line">                path.pop()</span><br><span class="line">        res,path = [],[]</span><br><span class="line">        dfs(path,res,<span class="number">0</span>,<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<p>这个方法和上面的区别是使用path是字符串类型。并且递归时，在传入的参数中对path进行改变，在外部path并没有变化，所以不需要回溯。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">generateParenthesis</span><span class="params">(self, n)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type n: int</span></span><br><span class="line"><span class="string">        :rtype: List[str]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(path,res,left,right)</span>:</span></span><br><span class="line">            <span class="string">"""</span></span><br><span class="line"><span class="string">            left:左括号已经使用的个数</span></span><br><span class="line"><span class="string">            right:右括号已经使用的个数</span></span><br><span class="line"><span class="string">            """</span></span><br><span class="line">            <span class="keyword">if</span> left==n <span class="keyword">and</span> right==n:</span><br><span class="line">                res.append(path)</span><br><span class="line">                <span class="keyword">return</span> </span><br><span class="line">            <span class="keyword">if</span> left&lt;right:</span><br><span class="line">                <span class="keyword">return</span> </span><br><span class="line">            <span class="keyword">if</span> left &lt; n:</span><br><span class="line">                dfs(path+<span class="string">'('</span>,res,left+<span class="number">1</span>,right)</span><br><span class="line">            <span class="keyword">if</span> right &lt; n:</span><br><span class="line">                dfs(path+<span class="string">')'</span>,res,left,right+<span class="number">1</span>)</span><br><span class="line">        res,path = [],<span class="string">''</span></span><br><span class="line">        dfs(path,res,<span class="number">0</span>,<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<h1><span id="11-n皇后">11. N皇后</span></h1><p>n 皇后问题研究的是如何将 n 个皇后放置在 n×n 的棋盘上，并且使皇后彼此之间不能相互攻击。即任意2个皇后不能除以同一行，同一列，或者同一对角线上。给定一个整数 n，返回所有不同的 n 皇后问题的解决方案。</p>
<p>每一种解法包含一个明确的 n 皇后问题的棋子放置方案，该方案中 ‘Q’ 和 ‘.’ 分别代表了皇后和空位。</p>
<p>链接：<a href="https://leetcode-cn.com/problems/n-queens" target="_blank" rel="noopener">https://leetcode-cn.com/problems/n-queens</a></p>
<p><strong>【分析一】</strong></p>
<p>首先board表示某一种摆放方案。先摆放row_start=0的第一行，将皇后摆放在某一列，然后再摆放下一行，因为一行只摆放了一个皇后，所以行没有冲突，在递归中，我们只需要判断列，左上对角线，右上对角线是否有冲突。如果不冲突，在该位置上摆放皇后，即<code>board[row][col]=&#39;Q&#39;</code>,否则回溯<code>board[row][col]=&#39;.&#39;</code></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">solveNQueens</span><span class="params">(self, n)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type n: int</span></span><br><span class="line"><span class="string">        :rtype: List[List[str]]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(row_start,res,board)</span>:</span></span><br><span class="line">            <span class="string">"""</span></span><br><span class="line"><span class="string">            row_start:当前在row_start行的哪一列摆放皇后，取值0~n-1</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">            """</span></span><br><span class="line">            <span class="keyword">if</span> row_start==n:</span><br><span class="line">                res.append([<span class="string">''</span>.join(board[i]) <span class="keyword">for</span> i <span class="keyword">in</span> range(n)])</span><br><span class="line">                <span class="keyword">return</span> </span><br><span class="line">            </span><br><span class="line">            cols = len(board[<span class="number">0</span>])</span><br><span class="line">            <span class="keyword">for</span> col <span class="keyword">in</span> range(cols):</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> is_valid(board,row_start,col):</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                board[row_start][col]=<span class="string">'Q'</span></span><br><span class="line">                dfs(row_start+<span class="number">1</span>,res,board)</span><br><span class="line">                board[row_start][col]=<span class="string">'.'</span></span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">is_valid</span><span class="params">(borad,row_start,col)</span>:</span></span><br><span class="line">            <span class="string">"""</span></span><br><span class="line"><span class="string">            判断将皇后放在board[row_start][col]是否合理</span></span><br><span class="line"><span class="string">            即判断在col列上是否已经有皇后</span></span><br><span class="line"><span class="string">            判断row_start以上的左上方和右上方的对角线上是否有皇后</span></span><br><span class="line"><span class="string">            """</span></span><br><span class="line">            n = len(board)</span><br><span class="line"></span><br><span class="line">            <span class="comment">#判断所有行在col列是否有皇后</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">                <span class="keyword">if</span> board[i][col] == <span class="string">'Q'</span>:</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment">#判断左上方是否有皇后</span></span><br><span class="line">            i,j = row_start<span class="number">-1</span>,col+<span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> i&gt;=<span class="number">0</span> <span class="keyword">and</span> j&lt;=n<span class="number">-1</span>:</span><br><span class="line">                <span class="keyword">if</span> board[i][j]==<span class="string">'Q'</span>:</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">                i-=<span class="number">1</span></span><br><span class="line">                j+=<span class="number">1</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment">#p判断右上方是否有皇后</span></span><br><span class="line">            i,j = row_start<span class="number">-1</span>,col<span class="number">-1</span></span><br><span class="line">            <span class="keyword">while</span> i&gt;=<span class="number">0</span> <span class="keyword">and</span> j&gt;=<span class="number">0</span>:</span><br><span class="line">                <span class="keyword">if</span> board[i][j]==<span class="string">'Q'</span>:</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">                i-=<span class="number">1</span></span><br><span class="line">                j-=<span class="number">1</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">        res = []</span><br><span class="line">        board = [[<span class="string">'.'</span> <span class="keyword">for</span> _ <span class="keyword">in</span> range(n) ] <span class="keyword">for</span> _ <span class="keyword">in</span> range(n)]</span><br><span class="line">        dfs(<span class="number">0</span>,res,board)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<h1><span id="12-总结">12. 总结</span></h1><p>在回溯题中，需要判断给定数组中是否有重复元素，如果有重复元素，在回溯的过程，需要去重，步骤如下</p>
<ul>
<li>先对数组排序，<code>nums = sorted(nums)</code></li>
<li>在for循环内部，使用<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(start,len(nums)):</span><br><span class="line">    <span class="keyword">if</span> i &gt; statr <span class="keyword">and</span> nums[i]==nums[i<span class="number">-1</span>]:</span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">path.append(nums[i])</span><br><span class="line">dfs(...)</span><br><span class="line">path.pop()</span><br></pre></td></tr></table></figure>
</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/06/02/How-to-Build-a-Graph-Based-Deep-Learning-Architecture-in-Traffic-Domain-A-Survey/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Echo">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/touxiang.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Echo's blog">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/06/02/How-to-Build-a-Graph-Based-Deep-Learning-Architecture-in-Traffic-Domain-A-Survey/" itemprop="url">How to Build a Graph-Based Deep Learning Architecture in Traffic Domain: A Survey</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-06-02T09:41:59+08:00">
                2020-06-02
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/论文阅读笔记/" itemprop="url" rel="index">
                    <span itemprop="name">论文阅读笔记</span>
                  </a>
                </span>

                
                
              
            </span>
          

          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  1.5k
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  5
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <p>这篇综述性论文介绍图神经网络在交通领域的应用。</p>
          <!--noindex-->
          <div class="post-button text-center">
            <a class="btn" href="/2020/06/02/How-to-Build-a-Graph-Based-Deep-Learning-Architecture-in-Traffic-Domain-A-Survey/#more" rel="contents">
              阅读全文 &raquo;
            </a>
          </div>
          <!--/noindex-->
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/05/29/Leetcode之树/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Echo">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/touxiang.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Echo's blog">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/05/29/Leetcode之树/" itemprop="url">Leetcode之树</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-05-29T21:11:48+08:00">
                2020-05-29
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/算法/" itemprop="url" rel="index">
                    <span itemprop="name">算法</span>
                  </a>
                </span>

                
                
              
            </span>
          

          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  3.7k
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  15
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <a id="more"></a>
<!-- TOC -->
<ul>
<li><a href="#1-树概念介绍">1. 树概念介绍</a></li>
<li><a href="#2-树的前向遍历">2. 树的前向遍历</a></li>
<li><a href="#3-二叉树的中序遍历">3. 二叉树的中序遍历</a></li>
<li><a href="#4-后序遍历">4. 后序遍历</a></li>
<li><a href="#5-树的层次遍历">5. 树的层次遍历</a></li>
<li><a href="#6-根据前序和中序创建二叉树">6. 根据前序和中序创建二叉树</a></li>
<li><a href="#7-计算树的最大深度">7. 计算树的最大深度</a></li>
<li><a href="#8-对称二叉树">8. 对称二叉树</a></li>
<li><a href="#9-平衡二叉树">9. 平衡二叉树</a></li>
<li><a href="#10-二叉树的镜像">10. 二叉树的镜像</a></li>
<li><a href="#11-二叉搜索树的后序遍历序列">11. 二叉搜索树的后序遍历序列</a></li>
<li><a href="#12-总结">12. 总结</a></li>
</ul>
<!-- /TOC -->
<h1><span id="1-树概念介绍">1. 树概念介绍</span></h1><ul>
<li>二叉树一般有2种通用的遍历策略<ul>
<li>深度优先搜索DFS<ol>
<li>前序遍历：根左右</li>
<li>中序遍历：左根右</li>
<li>后序遍历：左右根</li>
</ol>
</li>
<li>广度优先搜索BFS<br>先遍历第一层，再遍历第二层</li>
</ul>
</li>
</ul>
<p>值得注意的是，在删除树中的节点时，删除过程将按照后序遍历的顺序进行，也就是先删除左节点和右节点，然后再删除节点本身。</p>
<ul>
<li><p>平衡二叉树，需要满足1个条件：</p>
<ul>
<li>左右子树深度之差&lt;=1</li>
</ul>
</li>
<li><p>二叉搜索树，需要满足以下2个条件：</p>
<ul>
<li>左子树的值&lt;父节点，右子树的值&gt;父节点</li>
<li>所有左子树和右子树是二叉搜索树</li>
</ul>
</li>
</ul>
<p>二叉树常见问题<br><a href="https://zhuanlan.zhihu.com/p/91243381" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/91243381</a></p>
<h1><span id="2-树的前向遍历">2. 树的前向遍历</span></h1><p>给定一个二叉树，返回它的前序遍历序列。</p>
<p><strong>【方法1】</strong></p>
<p>前序遍历：根左右<br>迭代遍历树，使用栈的思想来实现。<br>定义一个stack数据，作为临时的存储栈。首先cur指向根节点，循环遍历所有的节点，当cur不为空时，因为先遍历根节点，所以将cur的值保存在res中，然后将cur保存至stack中，然后遍历cur的左节点，直到cur的左节点为空（cur没有左节点，或cur是叶子节点）。当cur为空时，进入到else中，从stack中弹出cur的父节点，然后遍历其右子树。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">preorderTraversal</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type root: TreeNode</span></span><br><span class="line"><span class="string">        :rtype: List[int]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:<span class="keyword">return</span> []</span><br><span class="line">        <span class="comment">#stack作为临时栈，先弹出根节点，再压入右节点和左节点</span></span><br><span class="line">        stack,res = [],[]</span><br><span class="line">        cur = root</span><br><span class="line">        <span class="keyword">while</span> cur <span class="keyword">or</span> stack:</span><br><span class="line">            <span class="keyword">if</span> cur:<span class="comment">#只要根节点不为空，一直向下遍历，知道cur为空</span></span><br><span class="line">                res.append(cur.val)<span class="comment">#将当前根节点的存储到res中</span></span><br><span class="line">                stack.append(cur)</span><br><span class="line">                cur = cur.left</span><br><span class="line">            <span class="keyword">else</span>:<span class="comment">#cur为空，说明该子树没有左子树或者是叶子节点</span></span><br><span class="line">                top = stack.pop()</span><br><span class="line">                cur = top.right</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<p><strong>【方法二】</strong></p>
<p>迭代方法</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">preorderTraversal</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type root: TreeNode</span></span><br><span class="line"><span class="string">        :rtype: List[int]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:<span class="keyword">return</span> []</span><br><span class="line">        res = []</span><br><span class="line">        self.dfs(root,res)</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(self,root,res)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> root:</span><br><span class="line">            res.append(root.val)</span><br><span class="line">            self.dfs(root.left,res)</span><br><span class="line">            self.dfs(root.right,res)</span><br></pre></td></tr></table></figure>
<h1><span id="3-二叉树的中序遍历">3. 二叉树的中序遍历</span></h1><p>给定一个二叉树，返回它的中序 遍历。</p>
<p><strong>【方法一】</strong><br>中序遍历：左根右，<br>每到一个节点A，因为需要先遍历左子树，所以需要把根节点先存储在stack中，然后一直遍历左子树，直到cur为None时，说明当前节点没有左子树，再从stack中弹出None的根节点，然后再遍历根节点的右子树。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inorderTraversal</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type root: TreeNode</span></span><br><span class="line"><span class="string">        :rtype: List[int]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root: <span class="keyword">return</span> []</span><br><span class="line">        stack,res = [],[]</span><br><span class="line">        cur = root</span><br><span class="line">        <span class="keyword">while</span> cur <span class="keyword">or</span> stack:</span><br><span class="line">            <span class="keyword">if</span> cur:</span><br><span class="line">                stack.append(cur)</span><br><span class="line">                cur = cur.left</span><br><span class="line">            <span class="keyword">else</span>:<span class="comment">#当某个节点的左子树为None时，弹出该节点（根节点），然后再遍历其右子树</span></span><br><span class="line">                cur = stack.pop()</span><br><span class="line">                res.append(cur.val)</span><br><span class="line">                cur = cur.right</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<p><strong>【方法二】</strong><br>递归<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inorderTraversal</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type root: TreeNode</span></span><br><span class="line"><span class="string">        :rtype: List[int]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root: <span class="keyword">return</span> []</span><br><span class="line">        res = []</span><br><span class="line">        self.dfs(root,res)</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(self,root,res)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> root:</span><br><span class="line">            <span class="keyword">if</span> root.left:</span><br><span class="line">                self.dfs(root.left,res)</span><br><span class="line">            res.append(root.val)</span><br><span class="line">            <span class="keyword">if</span> root.right:</span><br><span class="line">                self.dfs(root.right,res)</span><br></pre></td></tr></table></figure></p>
<h1><span id="4-后序遍历">4. 后序遍历</span></h1><p><strong>【方法一】</strong><br>后续遍历：左右根，使用res保存根右左的节点顺序，返回时倒序输出<br>每到一个节点A，先遍历根节点，因为左子树最后遍历，所以先把左子树压入栈中，然后遍历右子树</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">postorderTraversal</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type root: TreeNode</span></span><br><span class="line"><span class="string">        :rtype: List[int]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:<span class="keyword">return</span> []</span><br><span class="line">        stack,res = [],[]</span><br><span class="line">        cur = root</span><br><span class="line">        <span class="keyword">while</span> cur <span class="keyword">or</span> stack:</span><br><span class="line">            <span class="keyword">if</span> cur:</span><br><span class="line">                res.append(cur.val)</span><br><span class="line">                stack.append(cur.left)</span><br><span class="line">                cur = cur.right</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                cur = stack.pop()</span><br><span class="line">        <span class="keyword">return</span> res[::<span class="number">-1</span>]</span><br></pre></td></tr></table></figure>
<p><strong>【方法二】</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">postorderTraversal</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type root: TreeNode</span></span><br><span class="line"><span class="string">        :rtype: List[int]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:<span class="keyword">return</span> []</span><br><span class="line">        res = []</span><br><span class="line">        self.dfs(root,res)</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(self,root,res)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> root:</span><br><span class="line">            <span class="keyword">if</span> root.left:</span><br><span class="line">                self.dfs(root.left,res)</span><br><span class="line">            <span class="keyword">if</span> root.right:</span><br><span class="line">                self.dfs(root.right,res)</span><br><span class="line">            res.append(root.val)</span><br></pre></td></tr></table></figure>
<h1><span id="5-树的层次遍历">5. 树的层次遍历</span></h1><p>给你一个二叉树，请你返回其按 层序遍历 得到的节点值。 （即逐层地，从左到右访问所有节点）。</p>
<p><a href="https://leetcode-cn.com/problems/binary-tree-level-order-traversal/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/binary-tree-level-order-traversal/</a></p>
<p><strong>【方法一】</strong></p>
<p>参考<a href="https://leetcode-cn.com/problems/binary-tree-level-order-traversal/solution/die-dai-di-gui-duo-tu-yan-shi-102er-cha-shu-de-cen/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/binary-tree-level-order-traversal/solution/die-dai-di-gui-duo-tu-yan-shi-102er-cha-shu-de-cen/</a></p>
<p>首先队列中存储根节点，每一次队列中只存储某一层的元素。当队列中存储根节点时，进入while循环，弹出根节点，再将左右子节点压入到队列中。然后再遍历队列的左子节点，弹出左子节点，并将左子节点的孩子压入到队列中，然后遍历队列的右子节点，并将右子节点的孩子压入到队列中。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">levelOrder</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type root: TreeNode</span></span><br><span class="line"><span class="string">        :rtype: List[List[int]]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:<span class="keyword">return</span> []</span><br><span class="line">        queue,res = [root],[]</span><br><span class="line">        <span class="keyword">while</span> queue:</span><br><span class="line">            cur_len = len(queue)<span class="comment">#当前层节点个数</span></span><br><span class="line">            cur_nodes = []<span class="comment">#用来存储当前层的节点</span></span><br><span class="line">            <span class="keyword">for</span> _ <span class="keyword">in</span> range(cur_len):</span><br><span class="line">                <span class="comment">#对于当前层的每个节点，将其左右子节点压入队列中</span></span><br><span class="line">                cur = queue.pop(<span class="number">0</span>)<span class="comment">#注意弹出第一个元素，pop()默认弹出最后一个元素</span></span><br><span class="line">                cur_nodes.append(cur.val)</span><br><span class="line">                <span class="keyword">if</span> cur.left:</span><br><span class="line">                    queue.append(cur.left)</span><br><span class="line">                <span class="keyword">if</span> cur.right:</span><br><span class="line">                    queue.append(cur.right)</span><br><span class="line">            res.append(cur_nodes)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<h1><span id="6-根据前序和中序创建二叉树">6. 根据前序和中序创建二叉树</span></h1><p>输入某二叉树的前序遍历和中序遍历的结果，请重建该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。</p>
<p><a href="https://leetcode-cn.com/problems/zhong-jian-er-cha-shu-lcof/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/zhong-jian-er-cha-shu-lcof/</a></p>
<p><strong>【分析】</strong><br>使用递归的方式。首先找到整个树的根节点（前序的第一个节点），然后找到该节点在中序的下标（使用字典记录中序每个数字的下标），左边的即为左子树，右边的即为右子树。</p>
<p>例如：从前序中可以看到根节点为3，其在中序的下标为1，则左边的9为左子树节点，右边的15,20,7为右子树节点。然后递归遍历左子树，返回左子树的根节点作为3的左子树，递归遍历右子树，返回右子树的根节点作为3的右子树。</p>
<p>前序：3,9,20,15,7<br>中序：9,3,15,20,7</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode(object):</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">buildTree</span><span class="params">(self, preorder, inorder)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type preorder: List[int]</span></span><br><span class="line"><span class="string">        :type inorder: List[int]</span></span><br><span class="line"><span class="string">        :rtype: TreeNode</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="comment">#原理：首先在先序遍历中，第一个节点作为根节点，然后在中序遍历中，找出根节点在中序中的位置，区分哪些是左子树，哪些是右子树，然后分别对左子树和右子树递归</span></span><br><span class="line"></span><br><span class="line">        self.dic = dict()<span class="comment">#用来标记每个节点在中序遍历的位置，key：节点，value：下标</span></span><br><span class="line">        self.pre= preorder<span class="comment">#保存先序遍历</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">#遍历中序，为self.dic赋值</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(inorder)):</span><br><span class="line">            self.dic[inorder[i]] = i</span><br><span class="line">        <span class="keyword">return</span> self.recur(<span class="number">0</span>,<span class="number">0</span>,len(inorder)<span class="number">-1</span>)</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">recur</span><span class="params">(self,pre_root,in_left,in_right)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        pre_root：根节点在前序中的下标</span></span><br><span class="line"><span class="string">        in_left：该子树在中序的最左下标</span></span><br><span class="line"><span class="string">        in_right：该子树在中序的最右下标</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> in_left &gt; in_right:<span class="keyword">return</span> <span class="comment">#递归中止条件</span></span><br><span class="line">        root= TreeNode(self.pre[pre_root])<span class="comment">#创建当前子树的根节点</span></span><br><span class="line">        i = self.dic[root.val]<span class="comment">#搜索根节点在中序的索引</span></span><br><span class="line">        root.left= self.recur(pre_root+<span class="number">1</span>,in_left,i<span class="number">-1</span>)<span class="comment">#递归遍历左子树</span></span><br><span class="line">        root.right = self.recur(pre_root+i-in_left+<span class="number">1</span>,i+<span class="number">1</span>,in_right)</span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure>
<p>需要解释下，遍历左右子树的下标。<br>根节点在前序的下标为pre_root，在中序的下标为i，整个树在中序的左边界为in_left，右边界为in_right。</p>
<p><img src="/2020/05/29/Leetcode之树/7-1.png" alt=""></p>
<ul>
<li>时间复杂度：O(N)</li>
<li>空间复杂度：O(N)</li>
</ul>
<h1><span id="7-计算树的最大深度">7. 计算树的最大深度</span></h1><p>主要最后要加1<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">depth</span><span class="params">(self,root)</span>:</span></span><br><span class="line">        <span class="comment">#计算树root的最大深度</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:<span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">return</span> max(self.depth(root.left),self.depth(root.right))+<span class="number">1</span></span><br></pre></td></tr></table></figure></p>
<h1><span id="8-对称二叉树">8. 对称二叉树</span></h1><p>给定一个二叉树，检查它是否是镜像对称的。<br><a href="https://leetcode-cn.com/problems/symmetric-tree/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/symmetric-tree/</a></p>
<p>镜像对称<br>终止条件：</p>
<ul>
<li>如果left和right同时为空，返回True</li>
<li>如果left和right中有一个为空，或者2个都不为空，但是值不相等，返回False</li>
</ul>
<p>在递归中：</p>
<ul>
<li>将左节点的左孩子和右节点的右孩子比较</li>
<li>将左节点的右孩子和右节点的左孩子比较</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isSymmetric</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type root: TreeNode</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:<span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">        <span class="keyword">return</span> self.mirror(root.left,root.right)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">mirror</span><span class="params">(self,left,right)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> left == <span class="keyword">None</span> <span class="keyword">and</span> right == <span class="keyword">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">        <span class="keyword">if</span> left == <span class="keyword">None</span> <span class="keyword">or</span> right == <span class="keyword">None</span> <span class="keyword">or</span> left.val != right.val:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">        <span class="keyword">return</span> self.mirror(left.left,right.right) <span class="keyword">and</span> self.mirror(left.right,right.left)</span><br></pre></td></tr></table></figure>
<h1><span id="9-平衡二叉树">9. 平衡二叉树</span></h1><p>给定一个二叉树，判断它是否是高度平衡的二叉树。</p>
<p>本题中，一棵高度平衡二叉树定义为：<br>一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过1。</p>
<p><strong>【分析一】</strong><br><code>isBalanced(root)</code>判断树root是否是平衡二叉树</p>
<ul>
<li>特例处理：如果root为None，返回True</li>
<li><p>判断是否为平衡二叉树</p>
<ul>
<li><code>abs(self.depth(root.left)-self.depth(root.right))&lt;=1</code>root的左右高度差&lt;=1</li>
<li><code>self.isBalanced(root.left)</code>root的左子树是平衡树</li>
<li><code>self.isBalanced(root.right)</code>root的右子树是平衡树</li>
</ul>
</li>
</ul>
<p><code>depth(root)</code>计算树root的最大深度</p>
<ul>
<li>终止条件：当root为空时，说明root已经越过叶子节点，返回高度0</li>
<li>返回左子树和右子树的最大高度+1</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isBalanced</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type root: TreeNode</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:<span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">        <span class="comment">#如果root的左子树和右子树深度之差&lt;=1，且左右子树都是平衡树</span></span><br><span class="line">        <span class="keyword">if</span> abs(self.depth(root.left)-self.depth(root.right))&lt;=<span class="number">1</span> <span class="keyword">and</span> self.isBalanced(root.left) <span class="keyword">and</span> self.isBalanced(root.right):</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">depth</span><span class="params">(self,root)</span>:</span></span><br><span class="line">        <span class="comment">#计算树root的最大深度</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:<span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">return</span> max(self.depth(root.left),self.depth(root.right))+<span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>【方法二】</p>
<p>自底向上<br><code>recur(root)</code>返回树root的最大深度</p>
<ul>
<li><p>返回值：如果root的左右子树深度差&lt;=1，返回root的深度，max(左,右)+1，否则说明root树不是平衡树，返回-1</p>
</li>
<li><p>递归终止条件：root为None时，说明已经越过叶子节点，返回深度为0</p>
</li>
<li>当root的左右子树返回值为-1时，表示左或右子树不是平衡树，root直接返回-1</li>
</ul>
<p><code>isBalanced(root)</code>判断root是否是平衡树</p>
<ul>
<li>判断recur(root)返回值是否为-1，为-1则不是平衡树，否则是平衡树</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isBalanced</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type root: TreeNode</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:<span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">        <span class="keyword">return</span> self.recur(root) != <span class="number">-1</span></span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">recur</span><span class="params">(self,root)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        返回以root为根的树最大深度</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:<span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        left_h= self.recur(root.left)</span><br><span class="line">        <span class="keyword">if</span> left_h==<span class="number">-1</span>:<span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">        right_h = self.recur(root.right)</span><br><span class="line">        <span class="keyword">if</span> right_h == <span class="number">-1</span>:<span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">        <span class="keyword">return</span> max(left_h,right_h)+<span class="number">1</span> <span class="keyword">if</span> abs(left_h-right_h)&lt;=<span class="number">1</span> <span class="keyword">else</span> <span class="number">-1</span></span><br></pre></td></tr></table></figure>
<h1><span id="10-二叉树的镜像">10. 二叉树的镜像</span></h1><p>请完成一个函数，输入一个二叉树，该函数输出它的镜像。</p>
<p><a href="https://leetcode-cn.com/problems/er-cha-shu-de-jing-xiang-lcof/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/er-cha-shu-de-jing-xiang-lcof/</a></p>
<p><strong>【分析一】</strong><br>使用递归</p>
<ol>
<li>递归终止条件：当节点root为空时，返回None</li>
<li>递归工作<ul>
<li>先使用tmp保存节点root的左子树</li>
<li>给root.left赋予新的值</li>
<li>给root.right赋予新的值</li>
</ul>
</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">mirrorTree</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type root: TreeNode</span></span><br><span class="line"><span class="string">        :rtype: TreeNode</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:<span class="keyword">return</span> <span class="keyword">None</span></span><br><span class="line">        <span class="comment">#不用生成新的树，直接在原始树进行修改</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:<span class="keyword">return</span> <span class="keyword">None</span></span><br><span class="line">        tmp = root.left</span><br><span class="line">        root.left = self.mirrorTree(root.right)</span><br><span class="line">        root.right = self.mirrorTree(tmp)</span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure>
<p><strong>【分析二】</strong><br>使用栈stack遍历树的所有节点，并交换每个节点的左右子树</p>
<p><img src="/2020/05/29/Leetcode之树/2.png" alt=""></p>
<ol>
<li>特例处理：当root为空时，直接使用return</li>
<li>初始化栈，将root加入到栈中</li>
<li>遍历栈，刚开始弹出节点4，并将节点2和节点7压入栈中，然后交换节点4的左右节点。然后再进入到while循环中，弹出节点7，再将节点6和节点9压入栈中，交换节点7的左右节点。然后再将节点9弹出栈，因为节点9的左右节点为空，所以没有节点压入shatck中，然后交换节点9的左右节点（交换None）。然后弹出节点6出栈…….</li>
</ol>
<p>使用栈，可以看做是DFS，先将右子树内部的节点交换，然后再将左子树内部的节点交换<br>如果使用队列，可以看做是BFS，先交换第一层的左右节点，再交换第二层的左右节点。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">mirrorTree</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type root: TreeNode</span></span><br><span class="line"><span class="string">        :rtype: TreeNode</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:<span class="keyword">return</span> <span class="keyword">None</span></span><br><span class="line">        <span class="comment">#不用生成新的树，直接在原始树进行修改</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:<span class="keyword">return</span> <span class="keyword">None</span></span><br><span class="line">        stack = [root]</span><br><span class="line">        <span class="keyword">while</span> stack:</span><br><span class="line">            cur = stack.pop()</span><br><span class="line">            <span class="keyword">if</span> cur.left:stack.append(cur.left)</span><br><span class="line">            <span class="keyword">if</span> cur.right:stack.append(cur.right)</span><br><span class="line">            cur.left,cur.right = cur.right,cur.left</span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure>
<h1><span id="11-二叉搜索树的后序遍历序列">11. 二叉搜索树的后序遍历序列</span></h1><p>输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历结果。如果是则返回 true，否则返回 false。假设输入的数组的任意两个数字都互不相同。</p>
<p><a href="https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-hou-xu-bian-li-xu-lie-lcof/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-hou-xu-bian-li-xu-lie-lcof/</a></p>
<p><strong>【分析一】</strong><br>二叉搜索树：左子树&lt;根节点，右子树&gt;根节点<br>后序遍历：左右根<br>给定序列的最后一个元素肯定是整个树的根，比它小的是左子树，比它大的是右子树</p>
<p><img src="/2020/05/29/Leetcode之树/3.png" alt=""></p>
<p>使用递归的方法，递归函数传入的参数是后续序列。</p>
<ul>
<li>递归终止条件：后续序列为空，返回True</li>
<li>递归返回值：如果当前postorder可以构成二叉搜索树，返回True，否则返回False</li>
<li>递归工作：<ul>
<li>找根节点=postorder的最后一个元素</li>
<li>找左子树的范围</li>
<li>在右子树中，如果有小于root的值，返回false。如果没有的话，说明root的左右子树都正常</li>
<li>下面递归判断左子树的后序序列和右子树的后序序列是否正常</li>
<li>返回2者的and值</li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">verifyPostorder</span><span class="params">(self, postorder)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type postorder: List[int]</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> postorder:<span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">isTree</span><span class="params">(postorder)</span>:</span></span><br><span class="line">            <span class="string">"""</span></span><br><span class="line"><span class="string">            输入一个后续序列，判断是否是某个二叉搜索树的后续序列</span></span><br><span class="line"><span class="string">            如果是，返回True，否则返回False</span></span><br><span class="line"><span class="string">            """</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> postorder:<span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">            root = postorder[<span class="number">-1</span>]</span><br><span class="line">            left,right = <span class="number">0</span>,<span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(len(postorder)):</span><br><span class="line">                <span class="keyword">if</span> postorder[i] &gt; root:</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">            <span class="comment">#跳出for循环的i指向第一个大于root的节点,左子树[0,i-1]</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(i,len(postorder)<span class="number">-1</span>):</span><br><span class="line">                <span class="comment">#如果右子树中有比root小的，返回false</span></span><br><span class="line">                <span class="keyword">if</span> postorder[j] &lt; root:</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">            is_left,is_right = <span class="keyword">False</span>,<span class="keyword">False</span><span class="comment">#判断左后续序列是否能组成二叉搜索树</span></span><br><span class="line">            is_left = isTree(postorder[:i])</span><br><span class="line">            is_right = isTree(postorder[i:<span class="number">-1</span>])</span><br><span class="line">            <span class="keyword">return</span> is_left <span class="keyword">and</span> is_right</span><br><span class="line">        <span class="keyword">return</span> isTree(postorder)</span><br></pre></td></tr></table></figure>
<ul>
<li>时间复杂度：O(n2)</li>
<li>空间复杂度：O(N)0</li>
</ul>
<p><strong>【分析二】</strong></p>
<h1><span id="12-总结">12. 总结</span></h1><ul>
<li>深度优先搜索DFS一般使用栈结构存储，广度优先搜索BFS一般使用队列结构存储</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/05/24/Leetcode之链表/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Echo">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/touxiang.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Echo's blog">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/05/24/Leetcode之链表/" itemprop="url">Leetcode之链表</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-05-24T16:19:04+08:00">
                2020-05-24
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/算法/" itemprop="url" rel="index">
                    <span itemprop="name">算法</span>
                  </a>
                </span>

                
                
              
            </span>
          

          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  2k
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  8
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <p>链表遍历数据时，需要从头遍历。链表只需要给出头指针就可以</p>
          <!--noindex-->
          <div class="post-button text-center">
            <a class="btn" href="/2020/05/24/Leetcode之链表/#more" rel="contents">
              阅读全文 &raquo;
            </a>
          </div>
          <!--/noindex-->
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/03/30/Leetcode之排序/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Echo">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/touxiang.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Echo's blog">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/03/30/Leetcode之排序/" itemprop="url">Leetcode之排序</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-03-30T10:38:24+08:00">
                2020-03-30
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/算法/" itemprop="url" rel="index">
                    <span itemprop="name">算法</span>
                  </a>
                </span>

                
                
              
            </span>
          

          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  13.3k
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  54
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <p>开始刷题了，首先整理并实现经典的排序算法并对其优化，使用Python实现。所有的排序默认从小到大排序</p>
          <!--noindex-->
          <div class="post-button text-center">
            <a class="btn" href="/2020/03/30/Leetcode之排序/#more" rel="contents">
              阅读全文 &raquo;
            </a>
          </div>
          <!--/noindex-->
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/03/29/图神经网络研讨会/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Echo">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/touxiang.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Echo's blog">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/03/29/图神经网络研讨会/" itemprop="url">图神经网络研讨会</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-03-29T13:40:52+08:00">
                2020-03-29
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/Deep-Learning/" itemprop="url" rel="index">
                    <span itemprop="name">Deep Learning</span>
                  </a>
                </span>

                
                
              
            </span>
          

          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  516
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  1
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <p>在线图神经网络研讨会<br></p>
          <!--noindex-->
          <div class="post-button text-center">
            <a class="btn" href="/2020/03/29/图神经网络研讨会/#more" rel="contents">
              阅读全文 &raquo;
            </a>
          </div>
          <!--/noindex-->
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/03/27/Leetcode之二分法/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Echo">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/touxiang.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Echo's blog">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/03/27/Leetcode之二分法/" itemprop="url">Leetcode之二分法</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-03-27T22:34:31+08:00">
                2020-03-27
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/算法/" itemprop="url" rel="index">
                    <span itemprop="name">算法</span>
                  </a>
                </span>

                
                
              
            </span>
          

          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  8.3k
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  36
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <p>列表查找：从列表中查找指定元素</p>
<ul>
<li>输出：列表</li>
<li>输出：元素下标，找不到返回None或-1</li>
</ul>
          <!--noindex-->
          <div class="post-button text-center">
            <a class="btn" href="/2020/03/27/Leetcode之二分法/#more" rel="contents">
              阅读全文 &raquo;
            </a>
          </div>
          <!--/noindex-->
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/7/">7</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/images/touxiang.jpg" alt="Echo">
            
              <p class="site-author-name" itemprop="name">Echo</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">61</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">11</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">48</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="mailto:xiaohuangrenlll@163.com" target="_blank" title="E-Mail">
                      
                        <i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/Echohhhhhh" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; 2019 &mdash; <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Echo</span>

  
</div>









        
<div class="busuanzi-count">
  <!-- <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script> -->
  <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
  

  
    <span class="site-uv">
      <i class="fa fa-user"></i> 访问人数
      <span class="busuanzi-value" id="busuanzi_value_site_uv"></span>
      
    </span>
  

  
    <span class="site-pv">
      <i class="fa fa-eye"></i> 总访问量
      <span class="busuanzi-value" id="busuanzi_value_site_pv"></span>
      次
    </span>
  
</div>








        
        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
          <span id="scrollpercent"><span>0</span>%</span>
        
      </div>
    

    
      <div id="needsharebutton-float">
        <span class="btn">
          <i class="fa fa-share-alt" aria-hidden="true"></i>
        </span>
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  

  
  
  
  <link rel="stylesheet" href="/lib/needsharebutton/needsharebutton.css">

  
  
  <script src="/lib/needsharebutton/needsharebutton.js"></script>

  <script>
    
      pbOptions = {};
      
          pbOptions.iconStyle = "box";
      
          pbOptions.boxForm = "horizontal";
      
          pbOptions.position = "bottomCenter";
      
          pbOptions.networks = "Weibo,Wechat,Douban,QQZone,Twitter,Facebook";
      
      new needShareButton('#needsharebutton-postbottom', pbOptions);
    
    
      flOptions = {};
      
          flOptions.iconStyle = "box";
      
          flOptions.boxForm = "horizontal";
      
          flOptions.position = "topRight";
      
          flOptions.networks = "Weibo,Wechat,Douban,QQZone,Twitter,Facebook";
      
      new needShareButton('#needsharebutton-float', flOptions);
    
  </script>

  

  
  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script type="text/javascript" src="//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML"></script><!-- hexo-inject:begin --><!-- hexo-inject:end -->
  


  

  

  
</body>
</html>
